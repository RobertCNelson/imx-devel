From 99f7d6eff0ef27b587ef1036ef82bd1628a307c5 Mon Sep 17 00:00:00 2001
From: Shawn Guo <shawn.guo@linaro.org>
Date: Thu, 6 Dec 2012 22:54:41 +0800
Subject: [PATCH 6/9] ARM: imx: return zero in case next event gets a large
 increment

The return of v2_set_next_event() will lead to an infinite loop in
tick_handle_oneshot_broadcast() - "goto again;" with imx6q WAIT mode
(to be enabled).  This happens because when global event did not expire
any CPU local events, the broadcast device will be rearmed to a CPU
local next_event, which could be far away from now and result in a
max_delta_tick programming in set_next_event().

Fix the problem by detecting those next events with increments larger
than 0x7fffffff, and simply return zero in that case.

It leaves mx1_2_set_next_event() unchanged since only v2_set_next_event()
will be running with imx6q WAIT mode support.

Thanks Russell King for helping understand the problem.

Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
---
 arch/arm/mach-imx/time.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-imx/time.c b/arch/arm/mach-imx/time.c
index f017302..5d7eb48 100644
--- a/arch/arm/mach-imx/time.c
+++ b/arch/arm/mach-imx/time.c
@@ -152,7 +152,8 @@ static int v2_set_next_event(unsigned long evt,
 
 	__raw_writel(tcmp, timer_base + V2_TCMP);
 
-	return (int)(tcmp - __raw_readl(timer_base + V2_TCN)) < 0 ?
+	return evt < 0x7fffffff &&
+		(int)(tcmp - __raw_readl(timer_base + V2_TCN)) < 0 ?
 				-ETIME : 0;
 }
 
-- 
1.7.10.4

