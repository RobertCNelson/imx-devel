From 3f86e1862fdaca2f69ef10379f0ecf80fdb8e05c Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan <ra5478@freescale.com>
Date: Mon, 1 Apr 2013 16:03:31 -0500
Subject: [PATCH 222/231] ENGR00257847-2 MX6Q/DL-Fix Ethernet performance
 issue when WAIT mode is active

All of the interrupts from the ENET block are not routed to
the GPC block. Hence ENET interrupts are not able to wake
up the SOC when the system is in WAIT mode. And the ENET
interrupt gets serviced only when another interrupt causes
the SOC to exit WAIT mode. This impacts the ENET performance.

To fix the issue two options:
1. Route the ENET interrupt to a GPIO. Need to enable the
CONFIG_MX6_ENET_IRQ_TO_GPIO in the config.
2. If the GPIO mechanism cannot be used and is not enabled
by the above mentioned config, the patch will disable entry
to WAIT mode until ENET clock is active. When the ENET clock
is disabled, WAIT mode will be automatically enetered.

Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
---
 drivers/net/fec.c   |   17 +++++++++++++++++
 include/linux/fec.h |    3 +++
 2 files changed, 20 insertions(+)

diff --git a/drivers/net/fec.c b/drivers/net/fec.c
index 3a4ca0c..7d5c855 100755
--- a/drivers/net/fec.c
+++ b/drivers/net/fec.c
@@ -27,6 +27,7 @@
 #include <linux/string.h>
 #include <linux/ptrace.h>
 #include <linux/errno.h>
+#include <linux/gpio.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -1834,6 +1835,17 @@ fec_probe(struct platform_device *pdev)
 	if (pdata)
 		fep->phy_interface = pdata->phy;
 
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+	gpio_request(pdata->gpio_irq, "gpio_enet_irq");
+	gpio_direction_input(pdata->gpio_irq);
+
+	irq = gpio_to_irq(pdata->gpio_irq);
+	ret = request_irq(irq, fec_enet_interrupt,
+			IRQF_TRIGGER_RISING,
+			 pdev->name, ndev);
+	if (ret)
+		goto failed_irq;
+#else
 	/* This device has up to three irqs on some platforms */
 	for (i = 0; i < 3; i++) {
 		irq = platform_get_irq(pdev, i);
@@ -1848,6 +1860,7 @@ fec_probe(struct platform_device *pdev)
 			goto failed_irq;
 		}
 	}
+#endif
 
 	fep->clk = clk_get(&pdev->dev, "fec_clk");
 	if (IS_ERR(fep->clk)) {
@@ -1896,11 +1909,15 @@ failed_init:
 	clk_disable(fep->clk);
 	clk_put(fep->clk);
 failed_clk:
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+	free_irq(irq, ndev);
+#else
 	for (i = 0; i < 3; i++) {
 		irq = platform_get_irq(pdev, i);
 		if (irq > 0)
 			free_irq(irq, ndev);
 	}
+#endif
 failed_irq:
 	iounmap(fep->hwp);
 failed_ioremap:
diff --git a/include/linux/fec.h b/include/linux/fec.h
index fb9ac26..a14d1a0d 100644
--- a/include/linux/fec.h
+++ b/include/linux/fec.h
@@ -22,6 +22,9 @@ struct fec_platform_data {
 	phy_interface_t phy;
 	unsigned char mac[ETH_ALEN];
         u32 phy_noscan_mask;
+#ifdef CONFIG_MX6_ENET_IRQ_TO_GPIO
+	unsigned int gpio_irq;
+#endif
 };
 
 #endif
-- 
1.7.10.4

