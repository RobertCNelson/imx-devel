From a38c9a40bb8b00b7f5dc3a5ad00bf30e799e08ce Mon Sep 17 00:00:00 2001
From: Zhang Jiejing <jiejing.zhang@freescale.com>
Date: Thu, 20 Dec 2012 16:09:40 +0800
Subject: [PATCH 24/54] ENGR00237868 input: egalax_ts: remove the while loop
 for system performance.

Remove the while loop inside of threaded-irq handler.

Found this system issue on Sabre-AI board, if touch screen keep comming,
the UI is very slow, special on slow SD card.

After remove the loop, the UI is much smoother on SD card,
 and same on eMMC based system.

When add this patch, this was caused by the local timer not enable,
after local timer enable, the threaded
irq is almost real time, so we don't need add this while loop anymore.

Signed-off-by: Zhang Jiejing <jiejing.zhang@freescale.com>
---
 drivers/input/touchscreen/egalax_ts.c |   85 ++++++++++++++++-----------------
 1 file changed, 41 insertions(+), 44 deletions(-)

diff --git a/drivers/input/touchscreen/egalax_ts.c b/drivers/input/touchscreen/egalax_ts.c
index 9a149e4..a4b60b0 100644
--- a/drivers/input/touchscreen/egalax_ts.c
+++ b/drivers/input/touchscreen/egalax_ts.c
@@ -124,51 +124,48 @@ static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)
 	bool down, valid;
 	u8 state;
 
+	memset(buf, 0, MAX_I2C_DATA_LEN);
 	do {
-		memset(buf, 0, MAX_I2C_DATA_LEN);
-		do {
-			ret = i2c_master_recv(client, buf, MAX_I2C_DATA_LEN);
-		} while (ret == -EAGAIN && tries++ < EGALAX_MAX_TRIES);
-
-		if (ret < 0)
-			return IRQ_HANDLED;
-
-		if (buf[0] != REPORT_MODE_MTTOUCH) {
-			/* ignore mouse events and vendor events */
-			return IRQ_HANDLED;
-		}
-
-		state = buf[1];
-		x = (buf[3] << 8) | buf[2];
-		y = (buf[5] << 8) | buf[4];
-		z = (buf[7] << 8) | buf[6];
-
-		valid = state & EVENT_VALID_MASK;
-		id = (state & EVENT_ID_MASK) >> EVENT_ID_OFFSET;
-		down = state & EVENT_DOWN_UP;
-
-		if (!valid || id >= MAX_SUPPORT_POINTS) {
-			dev_dbg(&client->dev, "point invalid\n");
-			return IRQ_HANDLED;
-		}
-
-		if (data->finger_mask & (1U << id))
-			report_input_data(data);
-
-		if (!down) {
-			data->fingers[id].z = -1;
-			data->finger_mask |= 1U << id;
-		} else {
-			data->fingers[id].x = x;
-			data->fingers[id].y = y;
-			data->fingers[id].z = z;
-			data->finger_mask |= 1U << id;
-		}
-
-		dev_dbg(&client->dev, "%s id:%d x:%d y:%d z:%d\n",
-			(down ? "down" : "up"), id, x, y, z);
-
-	} while (gpio_get_value(irq_to_gpio(client->irq)) == 0);
+		ret = i2c_master_recv(client, buf, MAX_I2C_DATA_LEN);
+	} while (ret == -EAGAIN && tries++ < EGALAX_MAX_TRIES);
+
+	if (ret < 0)
+		return IRQ_HANDLED;
+
+	if (buf[0] != REPORT_MODE_MTTOUCH) {
+		/* ignore mouse events and vendor events */
+		return IRQ_HANDLED;
+	}
+
+	state = buf[1];
+	x = (buf[3] << 8) | buf[2];
+	y = (buf[5] << 8) | buf[4];
+	z = (buf[7] << 8) | buf[6];
+
+	valid = state & EVENT_VALID_MASK;
+	id = (state & EVENT_ID_MASK) >> EVENT_ID_OFFSET;
+	down = state & EVENT_DOWN_UP;
+
+	if (!valid || id >= MAX_SUPPORT_POINTS) {
+		dev_dbg(&client->dev, "point invalid\n");
+		return IRQ_HANDLED;
+	}
+
+	if (data->finger_mask & (1U << id))
+		report_input_data(data);
+
+	if (!down) {
+		data->fingers[id].z = -1;
+		data->finger_mask |= 1U << id;
+	} else {
+		data->fingers[id].x = x;
+		data->fingers[id].y = y;
+		data->fingers[id].z = z;
+		data->finger_mask |= 1U << id;
+	}
+
+	dev_dbg(&client->dev, "%s id:%d x:%d y:%d z:%d\n",
+		(down ? "down" : "up"), id, x, y, z);
 
 	if (data->finger_mask)
 		report_input_data(data);
-- 
1.7.10.4

