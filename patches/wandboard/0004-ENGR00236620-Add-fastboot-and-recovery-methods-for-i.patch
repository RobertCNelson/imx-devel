From a0b2354c2a5f7a30773ec05f9a41e1838c7d02a8 Mon Sep 17 00:00:00 2001
From: Nitin Garg <nitin.garg@freescale.com>
Date: Tue, 11 Dec 2012 07:58:59 -0600
Subject: [PATCH 004/223] ENGR00236620: Add fastboot and recovery methods for
 iMX5

Add fastboot and recovery methods with Android reboot
commands.

Signed-off-by: Nitin Garg <nitin.garg@freescale.com>
---
 arch/arm/configs/imx5_android_defconfig |    3 +-
 arch/arm/mach-mx5/system.c              |   69 +++++++++++++++++++++++++++++++
 2 files changed, 71 insertions(+), 1 deletion(-)

diff --git a/arch/arm/configs/imx5_android_defconfig b/arch/arm/configs/imx5_android_defconfig
index a36a224..2974b2b 100644
--- a/arch/arm/configs/imx5_android_defconfig
+++ b/arch/arm/configs/imx5_android_defconfig
@@ -317,7 +317,7 @@ CONFIG_MXC_TZIC=y
 CONFIG_MXC_PWM=y
 # CONFIG_MXC_DEBUG_BOARD is not set
 # CONFIG_MXC_REBOOT_MFGMODE is not set
-# CONFIG_MXC_REBOOT_ANDROID_CMD is not set
+CONFIG_MXC_REBOOT_ANDROID_CMD=y
 CONFIG_ARCH_MXC_IOMUX_V3=y
 CONFIG_ARCH_MXC_AUDMUX_V2=y
 CONFIG_IRAM_ALLOC=y
@@ -1315,6 +1315,7 @@ CONFIG_TOUCHSCREEN_MAX11801=y
 # CONFIG_TOUCHSCREEN_WM97XX is not set
 # CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_MC13783 is not set
+# CONFIG_TOUCHSCREEN_NOVATEK is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
 # CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
diff --git a/arch/arm/mach-mx5/system.c b/arch/arm/mach-mx5/system.c
index 59d46c9..8ecf042 100755
--- a/arch/arm/mach-mx5/system.c
+++ b/arch/arm/mach-mx5/system.c
@@ -26,6 +26,7 @@
 #include <mach/common.h>
 #include <mach/hardware.h>
 #include <mach/clock.h>
+#include <mach/devices-common.h>
 #include <asm/proc-fns.h>
 #include <asm/system.h>
 #include "crm_regs.h"
@@ -57,6 +58,18 @@ extern void __iomem *arm_plat_base;
 extern void (*suspend_in_iram)(void *param1, void *param2, void* param3);
 extern void __iomem *suspend_param1;
 
+#ifdef CONFIG_MXC_REBOOT_ANDROID_CMD
+#ifdef CONFIG_SOC_IMX50
+static resource_size_t srtc_iobase = MX50_SRTC_BASE_ADDR;
+#endif
+#ifdef CONFIG_SOC_IMX51
+static resource_size_t srtc_iobase = MX51_SRTC_BASE_ADDR;
+#endif
+#ifdef CONFIG_SOC_IMX53
+static resource_size_t srtc_iobase = MX53_SRTC_BASE_ADDR;
+#endif
+#endif
+
 static struct clk *gpc_dvfs_clk;
 static struct clk *pll1_sw_clk;
 static struct clk *osc;
@@ -298,3 +311,59 @@ int mxs_reset_block(void __iomem *hwreg, int just_enable)
 	return r;
 }
 
+#ifdef CONFIG_MXC_REBOOT_ANDROID_CMD
+/* This function will set a bits on SRTC_LPGR[27-26] bits to enter
+ * special boot mode.  These bits will not clear by watchdog reset, so
+ * it can be checked by bootloader to choose enter different mode.
+ * Bit 27 = Recovery mode
+ * Bit 26 = Fastboot mode
+ */
+
+#define ANDROID_RECOVERY_BOOT  (1 << 27)
+#define ANDROID_FASTBOOT_BOOT  (1 << 26)
+#define SRTC_LPGR               0x1C
+
+void do_switch_recovery(void)
+{
+	u32 reg;
+	void __iomem *srtc_base;
+	struct clk *srtc_clk;
+
+	srtc_clk = clk_get_sys("mxc_rtc.0", NULL);
+	if (IS_ERR_OR_NULL(srtc_clk))
+		printk(KERN_WARNING "Error getting mxc_rtc clk\n");
+	else
+		clk_enable(srtc_clk);
+
+	srtc_base = ioremap(srtc_iobase, 40);
+	if (srtc_base) {
+		reg = __raw_readl(srtc_base + SRTC_LPGR);
+		reg |= ANDROID_RECOVERY_BOOT;
+		__raw_writel(reg, srtc_base + SRTC_LPGR);
+		iounmap(srtc_base);
+	} else
+		printk(KERN_WARNING "Failed to ioremap srtc iobase\n");
+}
+
+void do_switch_fastboot(void)
+{
+	u32 reg;
+	void __iomem *srtc_base;
+	struct clk *srtc_clk;
+
+	srtc_clk = clk_get_sys("mxc_rtc.0", NULL);
+	if (IS_ERR_OR_NULL(srtc_clk))
+		printk(KERN_WARNING "Error getting mxc_rtc clk\n");
+	else
+		clk_enable(srtc_clk);
+
+	srtc_base = ioremap(srtc_iobase, 40);
+	if (srtc_base) {
+		reg = __raw_readl(srtc_base + SRTC_LPGR);
+		reg |= ANDROID_FASTBOOT_BOOT;
+		__raw_writel(reg, srtc_base + SRTC_LPGR);
+		iounmap(srtc_base);
+	} else
+		printk(KERN_WARNING "Failed to ioremap srtc iobase\n");
+}
+#endif
-- 
1.7.10.4

