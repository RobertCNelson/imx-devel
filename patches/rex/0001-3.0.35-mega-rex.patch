From fe60f1f31efd7de87811118dc5f3d17559ab5480 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Tue, 24 Jun 2014 19:52:58 -0500
Subject: [PATCH] 3.0.35 mega rex

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/Kconfig                                   |   10 +
 arch/arm/configs/imx6_defconfig                    |   16 +-
 arch/arm/configs/imx6_updater_defconfig            |    6 +-
 arch/arm/configs/imx6s_defconfig                   |    6 +
 arch/arm/configs/imx6s_updater_defconfig           |    2 +
 arch/arm/include/asm/dma-mapping.h                 |   13 +
 arch/arm/kernel/process.c                          |    2 +-
 arch/arm/mach-mx6/Kconfig                          |   60 +
 arch/arm/mach-mx6/Makefile                         |    6 +-
 arch/arm/mach-mx6/board-mx6dl_arm2.h               |   10 +-
 arch/arm/mach-mx6/board-mx6dl_hdmidongle.h         |  342 +++
 arch/arm/mach-mx6/board-mx6dl_sabresd.h            |    9 +-
 arch/arm/mach-mx6/board-mx6q_arm2.c                |   90 +-
 arch/arm/mach-mx6/board-mx6q_arm2.h                |    9 +-
 arch/arm/mach-mx6/board-mx6q_hdmidongle.c          |  800 +++++++
 arch/arm/mach-mx6/board-mx6q_hdmidongle.h          |  343 +++
 arch/arm/mach-mx6/board-mx6q_sabreauto.c           |  220 +-
 arch/arm/mach-mx6/board-mx6q_sabreauto.h           |   22 +-
 arch/arm/mach-mx6/board-mx6q_sabrelite.c           |  105 +-
 arch/arm/mach-mx6/board-mx6q_sabresd.c             |  173 +-
 arch/arm/mach-mx6/board-mx6q_sabresd.h             |    9 +-
 arch/arm/mach-mx6/board-mx6sl_arm2.c               |   74 +-
 arch/arm/mach-mx6/board-mx6sl_common.h             |  112 +-
 arch/arm/mach-mx6/board-mx6sl_evk.c                |  155 +-
 arch/arm/mach-mx6/board-mx6solo_sabreauto.h        |   22 +-
 arch/arm/mach-mx6/bus_freq.c                       |   15 +-
 arch/arm/mach-mx6/clock.c                          |  192 +-
 arch/arm/mach-mx6/clock_mx6sl.c                    |  198 +-
 arch/arm/mach-mx6/cpu.c                            |   34 +-
 arch/arm/mach-mx6/cpu_op-mx6.c                     |   34 +-
 arch/arm/mach-mx6/cpu_op-mx6.h                     |    6 +-
 arch/arm/mach-mx6/cpu_regulator-mx6.c              |   42 +-
 arch/arm/mach-mx6/crm_regs.h                       |   29 +-
 arch/arm/mach-mx6/irq.c                            |   17 +-
 arch/arm/mach-mx6/localtimer.c                     |    4 +-
 arch/arm/mach-mx6/mm.c                             |   18 +-
 arch/arm/mach-mx6/msi.c                            |  151 ++
 arch/arm/mach-mx6/msi.h                            |   26 +
 arch/arm/mach-mx6/mx6_anatop_regulator.c           |   27 +-
 arch/arm/mach-mx6/mx6_bt_rfkill.c                  |  167 ++
 arch/arm/mach-mx6/mx6_ddr_freq.S                   |   98 +-
 arch/arm/mach-mx6/mx6_suspend.S                    |   33 +-
 arch/arm/mach-mx6/mx6q_sabreauto_pmic_pfuze100.c   |   78 +-
 arch/arm/mach-mx6/mx6q_sabresd_pmic_pfuze100.c     |   79 +-
 arch/arm/mach-mx6/mx6sl_arm2_pmic_pfuze100.c       |   84 +-
 arch/arm/mach-mx6/mx6sl_ddr.S                      |   70 +-
 arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c        |   83 +-
 arch/arm/mach-mx6/mx6sl_wfi.S                      |   89 +-
 arch/arm/mach-mx6/pcie.c                           |  612 ++++-
 arch/arm/mach-mx6/pm.c                             |   63 +-
 arch/arm/mach-mx6/regs-anadig.h                    |    5 +-
 arch/arm/mach-mx6/system.c                         |  105 +-
 arch/arm/mach-mx6/usb.h                            |   15 +-
 arch/arm/mach-mx6/usb_dr.c                         |  252 +-
 arch/arm/mach-mx6/usb_h1.c                         |   68 +-
 arch/arm/mach-mx6/usb_h2.c                         |    8 +-
 arch/arm/mach-mx6/usb_h3.c                         |    8 +-
 arch/arm/mm/cache-v7.S                             |    3 +
 arch/arm/mm/dma-mapping.c                          |   17 +
 arch/arm/plat-mxc/Makefile                         |    2 +-
 arch/arm/plat-mxc/ahci_sata.c                      |    8 +-
 arch/arm/plat-mxc/cpufreq.c                        |  299 ++-
 arch/arm/plat-mxc/devices/platform-ahci-imx.c      |    5 +-
 arch/arm/plat-mxc/devices/platform-fec.c           |    5 +-
 arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c  |   52 +-
 arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c  |   53 +-
 arch/arm/plat-mxc/devices/platform-imx-caam.c      |   14 +
 arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c   |    5 +-
 .../plat-mxc/devices/platform-imx-hdmi-soc-dai.c   |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c  |    9 +-
 arch/arm/plat-mxc/devices/platform-imx-i2c.c       |    3 +
 arch/arm/plat-mxc/devices/platform-imx-pcie.c      |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-pm.c        |    7 +-
 arch/arm/plat-mxc/devices/platform-imx-pxp.c       |   15 +-
 arch/arm/plat-mxc/devices/platform-imx-uart.c      |    1 +
 arch/arm/plat-mxc/devices/platform-imx_vpu.c       |    7 +-
 arch/arm/plat-mxc/devices/platform-mxc-ehci.c      |   50 +-
 arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c |    5 +-
 arch/arm/plat-mxc/devices/platform-mxc_hdmi.c      |    6 +-
 arch/arm/plat-mxc/devices/platform-mxc_mlb.c       |    7 +-
 arch/arm/plat-mxc/devices/platform-viv_gpu.c       |   35 +-
 arch/arm/plat-mxc/fuse.c                           |  165 ++
 arch/arm/plat-mxc/gpio.c                           |    9 +-
 arch/arm/plat-mxc/include/mach/arc_otg.h           |    3 +-
 arch/arm/plat-mxc/include/mach/devices-common.h    |    8 +-
 arch/arm/plat-mxc/include/mach/dma.h               |    1 +
 arch/arm/plat-mxc/include/mach/epdc.h              |    2 +-
 arch/arm/plat-mxc/include/mach/iomux-mx6dl.h       |  108 +-
 arch/arm/plat-mxc/include/mach/iomux-mx6q.h        |  113 +-
 arch/arm/plat-mxc/include/mach/iomux-v3.h          |    6 +-
 arch/arm/plat-mxc/include/mach/ipu-v3.h            |   13 +-
 arch/arm/plat-mxc/include/mach/irqs.h              |   11 +-
 arch/arm/plat-mxc/include/mach/mx6.h               |   11 +-
 arch/arm/plat-mxc/include/mach/mxc.h               |   24 +-
 arch/arm/plat-mxc/include/mach/mxc_hdmi.h          |    9 +-
 arch/arm/plat-mxc/include/mach/mxc_vpu.h           |    5 +-
 arch/arm/plat-mxc/include/mach/pcie.h              |    3 +-
 arch/arm/plat-mxc/include/mach/system.h            |    3 +
 arch/arm/plat-mxc/iomux-v3.c                       |   46 +
 arch/arm/plat-mxc/pwm.c                            |    8 +-
 arch/arm/plat-mxc/system.c                         |   14 +-
 arch/arm/plat-mxc/usb_common.c                     |   29 +-
 arch/arm/plat-mxc/usb_wakeup.c                     |   20 +-
 arch/arm/tools/mach-types                          |    1 +
 arch/arm/vfp/vfpmodule.c                           |   10 +-
 crypto/tcrypt.c                                    |   14 +-
 drivers/crypto/caam/Kconfig                        |   39 +
 drivers/crypto/caam/Makefile                       |    3 +
 drivers/crypto/caam/caamalg.c                      |   18 +-
 drivers/crypto/caam/caamhash.c                     |   10 +-
 drivers/crypto/caam/ctrl.c                         |  100 +-
 drivers/crypto/caam/desc.h                         |   17 +
 drivers/crypto/caam/intern.h                       |   26 +
 drivers/crypto/caam/jr.c                           |    7 +-
 drivers/crypto/caam/regs.h                         |  138 +-
 drivers/crypto/caam/secvio.c                       |  310 +++
 drivers/crypto/caam/secvio.h                       |   64 +
 drivers/crypto/caam/sg_sw_sec4.h                   |   10 +-
 drivers/crypto/caam/sm.h                           |   86 +
 drivers/crypto/caam/sm_store.c                     |  890 +++++++
 drivers/crypto/caam/sm_test.c                      |  795 +++++++
 drivers/crypto/caam/snvsregs.h                     |  237 ++
 drivers/dma/imx-sdma.c                             |  118 +-
 drivers/dma/pxp/pxp_dma_v2.c                       |    2 +-
 drivers/gpu/drm/Makefile                           |    2 +-
 drivers/gpu/drm/vivante/Makefile                   |    2 +-
 drivers/gpu/drm/vivante/vivante_drv.c              |    2 +-
 drivers/gpu/drm/vivante/vivante_drv.h              |    2 +-
 drivers/i2c/busses/i2c-imx.c                       |   96 +-
 drivers/input/touchscreen/Kconfig                  |   24 +-
 drivers/input/touchscreen/Makefile                 |    1 +
 drivers/input/touchscreen/egalax_ts.c              |    7 +-
 drivers/input/touchscreen/novatek_ts.c             |  407 ++++
 drivers/media/video/Kconfig                        |    1 +
 drivers/media/video/mxc/capture/Kconfig            |    6 -
 drivers/media/video/mxc/capture/adv7180.c          |   60 +-
 .../media/video/mxc/capture/adv7280_mipi_tvin.c    |  293 ++-
 drivers/media/video/mxc/capture/csi_v4l2_capture.c |  557 ++++-
 drivers/media/video/mxc/capture/fsl_csi.c          |   34 +-
 drivers/media/video/mxc/capture/fsl_csi.h          |    2 +
 drivers/media/video/mxc/capture/ipu_csi_enc.c      |    5 +-
 .../media/video/mxc/capture/ipu_fg_overlay_sdc.c   |   43 +-
 drivers/media/video/mxc/capture/ipu_prp_enc.c      |    3 +
 drivers/media/video/mxc/capture/mxc_v4l2_capture.c |   40 +-
 drivers/media/video/mxc/capture/mxc_v4l2_capture.h |    9 +-
 drivers/media/video/mxc/capture/ov5640.c           | 1687 ++++++++-----
 drivers/media/video/mxc/capture/ov5640_mipi.c      |   24 +-
 drivers/media/video/mxc/capture/ov5642.c           |   61 +-
 drivers/media/video/mxc/output/mxc_vout.c          |  428 ++--
 drivers/media/video/videobuf-dma-contig.c          |    3 +-
 drivers/mfd/wm831x-i2c.c                           |   16 +-
 drivers/mmc/core/mmc.c                             |   76 +-
 drivers/mmc/host/sdhci-esdhc-imx.c                 |    2 +
 drivers/mmc/host/sdhci-pltfm.c                     |    8 +-
 drivers/mmc/host/sdhci.c                           |    1 +
 drivers/mtd/chips/cfi_cmdset_0002.c                |  386 ++-
 drivers/mtd/nand/gpmi-nand/gpmi-lib.c              |    4 +-
 drivers/mxc/asrc/mxc_asrc.c                        | 1105 +++++----
 drivers/mxc/gpu-viv/Kbuild                         |    5 +-
 .../hal/kernel/gc_hal_kernel_hardware_command_vg.c |    4 +-
 .../hal/kernel/gc_hal_kernel_hardware_command_vg.h |    5 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.c   |   76 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.h   |    7 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.c   |   42 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.h   |    4 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c  | 1042 +++++++-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h  |   10 +-
 drivers/mxc/gpu-viv/config                         |    3 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     | 1490 +++++++++---
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |  187 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |  392 ++-
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |   34 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c  |  176 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c   |    4 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |  257 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c    |    4 +-
 .../hal/kernel/gc_hal_kernel_interrupt_vg.c        |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c |  562 ++++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c  |    4 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c   |  347 +++
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c  |  139 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h  |    5 +-
 .../hal/kernel/gc_hal_kernel_video_memory.c        |   10 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |  181 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  125 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h   |  597 ++++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |  306 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h  |    9 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h   |    3 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h    |   34 +-
 .../hal/kernel/inc/gc_hal_eglplatform_type.h       |    3 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |  185 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h  |   11 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |   38 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h  |   49 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h    |   16 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |  164 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   |   17 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h |    6 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h |    4 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h |    3 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |   53 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |    6 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h     |   13 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debug.h      |    4 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.c    |    4 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.h    |    4 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  126 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |   15 +-
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |  203 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.c      |   20 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_math.c       |    4 +-
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c | 1037 ++++----
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h |   15 +-
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c                |    6 +-
 drivers/mxc/ipu/ipu_calc_stripes_sizes.c           |   42 +-
 drivers/mxc/ipu3/ipu_calc_stripes_sizes.c          |   42 +-
 drivers/mxc/ipu3/ipu_capture.c                     |   32 +-
 drivers/mxc/ipu3/ipu_common.c                      |  187 +-
 drivers/mxc/ipu3/ipu_device.c                      |  285 ++-
 drivers/mxc/ipu3/ipu_disp.c                        |    8 +-
 drivers/mxc/ipu3/ipu_ic.c                          |    9 +-
 drivers/mxc/ipu3/ipu_param_mem.h                   |   20 +-
 drivers/mxc/mlb/mxc_mlb150.c                       | 2510 +++++++++++---------
 drivers/mxc/thermal/cooling.c                      |   11 +-
 drivers/mxc/thermal/thermal.c                      |   81 +-
 drivers/mxc/vpu/mxc_vpu.c                          |  337 ++-
 drivers/net/can/dev.c                              |   10 +-
 drivers/net/can/flexcan.c                          |   23 +-
 drivers/net/fec.c                                  |  129 +-
 drivers/net/fec_1588.c                             |  716 +++---
 drivers/net/fec_1588.h                             |  119 +-
 drivers/power/sabresd_battery.c                    |   10 +-
 drivers/regulator/pfuze100-regulator.c             |    4 +-
 drivers/tty/serial/imx.c                           |   11 +-
 drivers/usb/core/driver.c                          |    2 +
 drivers/usb/core/hub.c                             |   59 +
 drivers/usb/core/quirks.c                          |    3 -
 drivers/usb/gadget/arcotg_udc.c                    |   62 +-
 drivers/usb/gadget/arcotg_udc.h                    |    1 +
 drivers/usb/host/Kconfig                           |    7 +
 drivers/usb/host/Makefile                          |    1 +
 drivers/usb/host/arc_hset.c                        |  468 ++++
 drivers/usb/host/ehci-arc.c                        |  130 +-
 drivers/usb/host/ehci-fsl.h                        |    3 +-
 drivers/usb/host/ehci-hcd.c                        |   31 +-
 drivers/usb/host/ehci-q.c                          |  181 ++
 drivers/usb/otg/fsl_otg.c                          |   33 +-
 drivers/usb/otg/otg_fsm.c                          |    4 +-
 drivers/video/mxc/epdc_regs.h                      |    1 +
 drivers/video/mxc/ldb.c                            |   51 +-
 drivers/video/mxc/mxc_edid.c                       |   68 +-
 drivers/video/mxc/mxc_elcdif_fb.c                  |   14 +-
 drivers/video/mxc/mxc_epdc_fb.c                    |  146 +-
 drivers/video/mxc/mxc_ipuv3_fb.c                   |  114 +-
 drivers/video/mxc/mxcfb_sii902x_elcdif.c           |   32 +-
 drivers/video/mxc_hdmi.c                           |  518 +++-
 include/linux/can/dev.h                            |    2 +-
 include/linux/clockchips.h                         |    6 +
 include/linux/dmapool.h                            |    2 -
 include/linux/fec.h                                |    3 +-
 include/linux/fsl_devices.h                        |    7 +-
 include/linux/i2c/novatek_ts.h                     |   16 +
 include/linux/ipu.h                                |   11 +-
 include/linux/mtd/map.h                            |    2 +-
 include/linux/mxc_asrc.h                           |   83 +-
 include/linux/mxc_mlb.h                            |    7 +-
 include/linux/mxcfb.h                              |   13 +-
 kernel/power/main.c                                |    1 +
 kernel/time/tick-broadcast.c                       |   85 +-
 mm/compaction.c                                    |    6 +-
 mm/dmapool.c                                       |    4 -
 sound/soc/codecs/cs42888.c                         |   10 +-
 sound/soc/codecs/mxc_spdif.c                       |   39 +-
 sound/soc/codecs/wm8962.c                          |   19 +-
 sound/soc/imx/Kconfig                              |    6 +
 sound/soc/imx/imx-cs42888.c                        |   12 +-
 sound/soc/imx/imx-esai.h                           |    2 -
 sound/soc/imx/imx-hdmi-dai.c                       |    8 +-
 sound/soc/imx/imx-hdmi-dma.c                       |  107 +-
 sound/soc/imx/imx-hdmi.c                           |    8 +-
 sound/soc/imx/imx-pcm-dma-mx2.c                    |   49 +-
 sound/soc/imx/imx-pcm.h                            |    6 +
 sound/soc/imx/imx-si4763.c                         |    4 +-
 sound/soc/imx/imx-ssi.c                            |  111 +-
 sound/soc/imx/imx-ssi.h                            |    3 -
 sound/soc/imx/imx-wm8962.c                         |  429 ++--
 sound/soc/soc-core.c                               |   10 +
 290 files changed, 23347 insertions(+), 7174 deletions(-)
 create mode 100644 arch/arm/mach-mx6/board-mx6dl_hdmidongle.h
 create mode 100644 arch/arm/mach-mx6/board-mx6q_hdmidongle.c
 create mode 100644 arch/arm/mach-mx6/board-mx6q_hdmidongle.h
 create mode 100644 arch/arm/mach-mx6/msi.c
 create mode 100644 arch/arm/mach-mx6/msi.h
 create mode 100644 arch/arm/mach-mx6/mx6_bt_rfkill.c
 create mode 100644 arch/arm/plat-mxc/fuse.c
 create mode 100644 drivers/crypto/caam/secvio.c
 create mode 100644 drivers/crypto/caam/secvio.h
 create mode 100644 drivers/crypto/caam/sm.h
 create mode 100644 drivers/crypto/caam/sm_store.c
 create mode 100644 drivers/crypto/caam/sm_test.c
 create mode 100644 drivers/crypto/caam/snvsregs.h
 create mode 100644 drivers/input/touchscreen/novatek_ts.c
 mode change 100644 => 100755 drivers/mfd/wm831x-i2c.c
 create mode 100644 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
 create mode 100644 drivers/usb/host/arc_hset.c
 create mode 100644 include/linux/i2c/novatek_ts.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 164e772..25f41ef 100755
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1248,6 +1248,16 @@ config ARM_ERRATA_754327
 	  This workaround defines cpu_relax() as smp_mb(), preventing correctly
 	  written polling loops from denying visibility of updates to memory.
 
+config ARM_ERRATA_775420
+       bool "ARM errata: A data cache maintenance operation which aborts, might lead to deadlock"
+       depends on CPU_V7
+       help
+	 This option enables the workaround for the 775420 Cortex-A9 (r2p2,
+	 r2p6,r2p8,r2p10,r3p0) erratum. In case a date cache maintenance
+	 operation aborts with MMU exception, it might cause the processor
+	 to deadlock. This workaround puts DSB before executing ISB if
+	 an abort may occur on cache maintenance.
+
 endmenu
 
 source "arch/arm/common/Kconfig"
diff --git a/arch/arm/configs/imx6_defconfig b/arch/arm/configs/imx6_defconfig
index f62ea0e..b02b875 100644
--- a/arch/arm/configs/imx6_defconfig
+++ b/arch/arm/configs/imx6_defconfig
@@ -310,12 +310,14 @@ CONFIG_MACH_MX6Q_ARM2=y
 CONFIG_MACH_MX6Q_SABRELITE=y
 CONFIG_MACH_MX6Q_SABRESD=y
 CONFIG_MACH_MX6Q_SABREAUTO=y
+CONFIG_MACH_MX6Q_HDMIDONGLE=y
 
 #
 # MX6 Options:
 #
 # CONFIG_IMX_PCIE is not set
 CONFIG_USB_EHCI_ARC_H1=y
+CONFIG_USB_FSL_ARC_OTG=y
 # CONFIG_MX6_INTER_LDO_BYPASS is not set
 # CONFIG_MX6_CLK_FOR_BOOTUI_TRANS is not set
 CONFIG_ISP1504_MXC=y
@@ -379,6 +381,7 @@ CONFIG_ARM_ERRATA_751472=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
 # CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
@@ -389,7 +392,7 @@ CONFIG_ARM_AMBA=y
 # CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 CONFIG_ARM_ERRATA_764369=y
-# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_PL310_ERRATA_769419=y
 
 #
 # Kernel Features
@@ -1068,7 +1071,6 @@ CONFIG_KEYBOARD_GPIO=y
 # CONFIG_KEYBOARD_STOWAWAY is not set
 # CONFIG_KEYBOARD_SUNKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYBOARD_MXC is not set
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
@@ -1640,6 +1642,7 @@ CONFIG_MXC_CAMERA_OV8820_MIPI=m
 CONFIG_MXC_CAMERA_OV5642=m
 CONFIG_MXC_TVIN_ADV7180=m
 CONFIG_MXC_CAMERA_OV5640_MIPI=m
+# CONFIG_MXC_MIPI_CSI2_TVIN_ADV7280 is not set
 CONFIG_MXC_CAMERA_SENSOR_CLK=m
 CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=m
 CONFIG_MXC_IPU_PRP_ENC=m
@@ -1773,7 +1776,6 @@ CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
 # CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL is not set
 # CONFIG_FB_MXC_SEIKO_WVGA_SYNC_PANEL is not set
 # CONFIG_FB_MXC_SII902X is not set
-# CONFIG_FB_MXC_SII902X_ELCDIF is not set
 # CONFIG_FB_MXC_CH7026 is not set
 # CONFIG_FB_MXC_TVOUT_CH7024 is not set
 # CONFIG_FB_MXC_ASYNC_PANEL is not set
@@ -1856,13 +1858,11 @@ CONFIG_SND_SOC_IMX_SPDIF=y
 CONFIG_SND_SOC_IMX_HDMI=y
 CONFIG_SND_SOC_I2C_AND_SPI=y
 # CONFIG_SND_SOC_ALL_CODECS is not set
-# CONFIG_SND_SOC_WM_HUBS is not set
 CONFIG_SND_SOC_MXC_HDMI=y
 CONFIG_SND_SOC_MXC_SPDIF=y
 CONFIG_SND_SOC_SGTL5000=y
 CONFIG_SND_SOC_CS42888=y
 CONFIG_SND_SOC_WM8962=y
-# CONFIG_SND_SOC_WM8994 is not set
 # CONFIG_SOUND_PRIME is not set
 CONFIG_AC97_BUS=y
 CONFIG_HID_SUPPORT=y
@@ -1963,7 +1963,7 @@ CONFIG_USB_EHCI_ARC_OTG=y
 # CONFIG_USB_EHCI_ARC_HSIC is not set
 # CONFIG_USB_STATIC_IRAM is not set
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
-# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
 # CONFIG_USB_EHCI_MXC is not set
 # CONFIG_USB_OXU210HP_HCD is not set
 # CONFIG_USB_ISP116X_HCD is not set
@@ -2698,6 +2698,10 @@ CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API=y
 CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API=y
 # CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE=7
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
 # CONFIG_BINARY_PRINTF is not set
 
 #
diff --git a/arch/arm/configs/imx6_updater_defconfig b/arch/arm/configs/imx6_updater_defconfig
index 06ffbc5..2eea527 100644
--- a/arch/arm/configs/imx6_updater_defconfig
+++ b/arch/arm/configs/imx6_updater_defconfig
@@ -320,11 +320,13 @@ CONFIG_MACH_MX6SL_ARM2=y
 CONFIG_MACH_MX6Q_SABRELITE=y
 CONFIG_MACH_MX6Q_SABRESD=y
 CONFIG_MACH_MX6Q_SABREAUTO=y
+CONFIG_MACH_MX6Q_HDMIDONGLE=y
 
 #
 # MX6 Options:
 #
 # CONFIG_IMX_PCIE is not set
+CONFIG_USB_FSL_ARC_OTG=y
 # CONFIG_MX6_INTER_LDO_BYPASS is not set
 # CONFIG_MX6_CLK_FOR_BOOTUI_TRANS is not set
 CONFIG_ISP1504_MXC=y
@@ -389,6 +391,7 @@ CONFIG_ARM_ERRATA_751472=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
 # CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
@@ -399,7 +402,7 @@ CONFIG_ARM_AMBA=y
 # CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 # CONFIG_ARM_ERRATA_764369 is not set
-# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_PL310_ERRATA_769419=y
 
 #
 # Kernel Features
@@ -727,6 +730,7 @@ CONFIG_MTD_CFI_UTIL=y
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_IMX6X_WEIMNOR=y
 # CONFIG_MTD_PHYSMAP_COMPAT is not set
 # CONFIG_MTD_ARM_INTEGRATOR is not set
 # CONFIG_MTD_PLATRAM is not set
diff --git a/arch/arm/configs/imx6s_defconfig b/arch/arm/configs/imx6s_defconfig
index 41f43e5..14e9ba5 100644
--- a/arch/arm/configs/imx6s_defconfig
+++ b/arch/arm/configs/imx6s_defconfig
@@ -1,3 +1,4 @@
+
 #
 # Automatically generated make config: don't edit
 # Linux/arm 3.0.35 Kernel Configuration
@@ -316,12 +317,14 @@ CONFIG_MACH_MX6SL_EVK=y
 # CONFIG_MACH_MX6Q_SABRELITE is not set
 CONFIG_MACH_MX6Q_SABRESD=y
 # CONFIG_MACH_MX6Q_SABREAUTO is not set
+CONFIG_SDMA_IRAM=y
 
 #
 # MX6 Options:
 #
 # CONFIG_IMX_PCIE is not set
 CONFIG_USB_EHCI_ARC_H1=y
+CONFIG_USB_FSL_ARC_OTG=y
 CONFIG_MX6_INTER_LDO_BYPASS=y
 CONFIG_ISP1504_MXC=y
 # CONFIG_MXC_IRQ_PRIOR is not set
@@ -335,6 +338,7 @@ CONFIG_ARCH_MXC_AUDMUX_V2=y
 CONFIG_IRAM_ALLOC=y
 CONFIG_CLK_DEBUG=y
 CONFIG_DMA_ZONE_SIZE=184
+CONFIG_MACH_IMX_BLUETOOTH_RFKILL=y
 
 #
 # System MMU
@@ -380,6 +384,7 @@ CONFIG_CPU_HAS_PMU=y
 CONFIG_ARM_ERRATA_743622=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
@@ -1816,6 +1821,7 @@ CONFIG_SND_SOC=y
 CONFIG_SND_SOC_AC97_BUS=y
 CONFIG_SND_IMX_SOC=y
 CONFIG_SND_MXC_SOC_MX2=y
+CONFIG_SND_MXC_SOC_IRAM=y
 CONFIG_SND_MXC_SOC_SPDIF_DAI=y
 CONFIG_SND_SOC_IMX_SGTL5000=y
 CONFIG_SND_SOC_IMX_WM8958=y
diff --git a/arch/arm/configs/imx6s_updater_defconfig b/arch/arm/configs/imx6s_updater_defconfig
index bd227b3..3fffe50 100644
--- a/arch/arm/configs/imx6s_updater_defconfig
+++ b/arch/arm/configs/imx6s_updater_defconfig
@@ -326,6 +326,7 @@ CONFIG_MACH_MX6Q_SABREAUTO=y
 # MX6 Options:
 #
 # CONFIG_IMX_PCIE is not set
+CONFIG_USB_FSL_ARC_OTG=y
 CONFIG_MX6_INTER_LDO_BYPASS=y
 CONFIG_ISP1504_MXC=y
 # CONFIG_MXC_IRQ_PRIOR is not set
@@ -384,6 +385,7 @@ CONFIG_CPU_HAS_PMU=y
 CONFIG_ARM_ERRATA_743622=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index 635c940..5eaa7a2 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -173,6 +173,19 @@ static inline void dma_free_noncoherent(struct device *dev, size_t size,
 }
 
 /**
+ * dma_alloc_noncached - allocate consistent memory for DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @size: required memory size
+ * @handle: bus-specific DMA address
+ *
+ * Allocate some uncached, unbuffered memory for a device for
+ * performing DMA.  This function allocates pages, and will
+ * return the CPU-viewed address, and sets @handle to be the
+ * device-viewed address.
+ */
+extern void *dma_alloc_noncached(struct device *, size_t, dma_addr_t *, gfp_t);
+
+/**
  * dma_alloc_coherent - allocate consistent memory for DMA
  * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
  * @size: required memory size
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 63c9205..f818b4e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -195,7 +195,7 @@ void cpu_idle(void)
 #ifdef CONFIG_PL310_ERRATA_769419
 			wmb();
 #endif
-			if (hlt_counter) {
+			if (hlt_counter || tick_check_broadcast_pending()) {
 				local_irq_enable();
 				cpu_relax();
 			} else {
diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 97262dc..64ce4d4 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -5,6 +5,7 @@ config ARCH_MX6Q
 	select USB_ARCH_HAS_EHCI
 	select ARCH_MXC_IOMUX_V3
 	select ARCH_MXC_AUDMUX_V2
+	select ARCH_SUPPORTS_MSI
 	select ARM_GIC
 	select ARCH_HAS_CPUFREQ
 	select OC_ETM
@@ -251,16 +252,62 @@ config MACH_MX6Q_SABREAUTO
 	  Include support for i.MX 6Quad SABRE Auto platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX6Q_HDMIDONGLE
+	bool "Support i.MX 6Quad HDMIDONGLE platform"
+	select ARCH_MX6Q
+	select SOC_IMX6Q
+	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_DMA
+	select IMX_HAVE_PLATFORM_GPMI_NFC
+	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_VIV_GPU
+	select IMX_HAVE_PLATFORM_IMX_VPU
+	select IMX_HAVE_PLATFORM_IMX_DVFS
+	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
+	select IMX_HAVE_PLATFORM_FSL_USB2_UDC
+	select IMX_HAVE_PLATFORM_MXC_EHCI
+	select IMX_HAVE_PLATFORM_FSL_OTG
+	select IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
+	select IMX_HAVE_PLATFORM_AHCI
+	select IMX_HAVE_PLATFORM_IMX_OCOTP
+	select IMX_HAVE_PLATFORM_IMX_VIIM
+	select IMX_HAVE_PLATFORM_IMX2_WDT
+	select IMX_HAVE_PLATFORM_IMX_SNVS_RTC
+	select IMX_HAVE_PLATFORM_IMX_PM
+	select IMX_HAVE_PLATFORM_MXC_HDMI
+	select IMX_HAVE_PLATFORM_IMX_PCIE
+	help
+	  Include support for i.MX 6Quad HDMI Dongle platform. This includes specific
+	  configurations for the board and its peripherals.
+
 comment "MX6 Options:"
 
 config IMX_PCIE
 	bool "PCI Express support"
 	select PCI
 
+config IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+	bool "PCI Express EP mode in the IMX6 RC/EP interconnection system"
+	depends on IMX_PCIE
+
+config IMX_PCIE_RC_MODE_IN_EP_RC_SYS
+	bool "PCI Express RC mode in the IMX6 RC/EP interconnection system"
+	depends on IMX_PCIE
+
 config USB_EHCI_ARC_H1
 	tristate "USB Host 1 support"
 	depends on USB_EHCI_ARC
 
+config USB_FSL_ARC_OTG
+	tristate "FSL USB OTG support"
+
+config USB_ID_WAKEUP_ENABLE
+	bool "Enable USB ID Pin As System Wakeup Source"
+	depends on SOC_IMX6SL
+	default n
+
 config MX6_INTER_LDO_BYPASS
 	bool "Internal LDO in MX6Q/DL bypass"
 	depends on  REGULATOR_PFUZE100 && CPU_FREQ_IMX && ARCH_MX6
@@ -279,4 +326,17 @@ config MX6_CLK_FOR_BOOTUI_TRANS
 	 avoid setting IPU related clocks' parents when initializing clock tree
 	 so that bootloader splashimage can transition to kernel smoothly.
 
+config MACH_IMX_BLUETOOTH_RFKILL
+       tristate "i.MX Bluetooth rfkill interface support"
+       depends on RFKILL
+       ---help---
+	Say Y to get the standard rfkill interface of Bluetooth
+
+config SDMA_IRAM
+	bool "Use Internal RAM for SDMA data structures"
+	depends on IMX_SDMA && SOC_IMX6SL
+	help
+	  SDMA buffer or control structures are stored in the IRAM/OCRAM
+
+
 endif
diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 05dc62d..8c1d754 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Object file lists.
-obj-y   := cpu.o mm.o system.o devices.o dummy_gpio.o irq.o bus_freq.o usb_dr.o usb_h2.o usb_h3.o\
+obj-y   := cpu.o mm.o system.o devices.o dummy_gpio.o irq.o bus_freq.o  usb_h2.o usb_h3.o\
 pm.o cpu_op-mx6.o mx6_wfi.o mx6_fec.o mx6_anatop_regulator.o cpu_regulator-mx6.o \
 mx6_mmdc.o mx6_ddr_freq.o mx6sl_ddr.o mx6sl_wfi.o etm.o
 
@@ -14,7 +14,11 @@ obj-$(CONFIG_MACH_MX6SL_EVK) += board-mx6sl_evk.o mx6sl_evk_pmic_pfuze100.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += board-mx6q_sabrelite.o
 obj-$(CONFIG_MACH_MX6Q_SABRESD) += board-mx6q_sabresd.o mx6q_sabresd_pmic_pfuze100.o
 obj-$(CONFIG_MACH_MX6Q_SABREAUTO) += board-mx6q_sabreauto.o mx6q_sabreauto_pmic_pfuze100.o
+obj-$(CONFIG_MACH_MX6Q_HDMIDONGLE) += board-mx6q_hdmidongle.o
 obj-$(CONFIG_SMP) += plat_hotplug.o platsmp.o headsmp.o
 obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
 obj-$(CONFIG_IMX_PCIE) += pcie.o
+obj-$(CONFIG_USB_FSL_ARC_OTG) += usb_dr.o
 obj-$(CONFIG_USB_EHCI_ARC_H1) += usb_h1.o
+obj-$(CONFIG_MACH_IMX_BLUETOOTH_RFKILL) += mx6_bt_rfkill.o
+obj-$(CONFIG_PCI_MSI) += msi.o
diff --git a/arch/arm/mach-mx6/board-mx6dl_arm2.h b/arch/arm/mach-mx6/board-mx6dl_arm2.h
index 429febb..f4560e4 100644
--- a/arch/arm/mach-mx6/board-mx6dl_arm2.h
+++ b/arch/arm/mach-mx6/board-mx6dl_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -182,13 +182,7 @@ static iomux_v3_cfg_t mx6dl_arm2_pads[] = {
 
 	/* USBOTG ID pin */
 	MX6DL_PAD_GPIO_1__USBOTG_ID,
-
-	/* MLB150 */
-	MX6DL_PAD_GPIO_3__MLB_MLBCLK,
-	MX6DL_PAD_GPIO_6__MLB_MLBSIG,
-	MX6DL_PAD_GPIO_2__MLB_MLBDAT,
-
-};
+ };
 
 static iomux_v3_cfg_t mx6dl_arm2_epdc_pads[] = {
 	MX6DL_PAD_EIM_A17__GPIO_2_21,
diff --git a/arch/arm/mach-mx6/board-mx6dl_hdmidongle.h b/arch/arm/mach-mx6/board-mx6dl_hdmidongle.h
new file mode 100644
index 0000000..b46b6e1
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6dl_hdmidongle.h
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _BOARD_MX6DL_HDMIDONGLE_H
+#define _BOARD_MX6DL_HDMIDONGLE_H
+#include <mach/iomux-mx6dl.h>
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_rev_a_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6DL_PAD_EIM_OE__ECSPI2_MISO,
+	MX6DL_PAD_EIM_RW__ECSPI2_SS0,
+	MX6DL_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6DL_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6DL_PAD_EIM_A16__GPIO_2_22,
+	/*BT_WAKEUP_HOST(Combo module BT wake-up output) */
+	MX6DL_PAD_EIM_A25__GPIO_5_2,
+	/* HOST_WAKEUP_BT(CPU wakeup BT signal)*/
+	MX6DL_PAD_EIM_D16__GPIO_3_16,
+
+	/* I2C3  */
+	MX6DL_PAD_EIM_D17__I2C3_SCL,
+	MX6DL_PAD_EIM_D18__I2C3_SDA,
+
+	/* USB OC pin */
+	MX6DL_PAD_EIM_D21__USBOH3_USBOTG_OC,
+	/* WLAN_WAKEUP_HOST(Combo module WLAN host wake-up output) */
+	MX6DL_PAD_EIM_D22__GPIO_3_22,
+
+	/* BT_UART2  */
+	MX6DL_PAD_EIM_D26__UART2_TXD,
+	MX6DL_PAD_EIM_D27__UART2_RXD,
+	MX6DL_PAD_EIM_D28__UART2_CTS,
+	MX6DL_PAD_EIM_D29__UART2_RTS,
+
+	/*BT_nRST(Combo module BT reset signal)*/
+	MX6DL_PAD_EIM_DA7__GPIO_3_7,
+
+	/*BT_REG_ON(Combo module BT Internal regulators power enable/disable)*/
+	MX6DL_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WL_REG_ON(Combo module WLAN Internal regulators power enable/disable)*/
+	MX6DL_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6DL_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6DL_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6DL_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6DL_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A24__GPIO_5_4,	/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6DL_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+	/* I2C1  */
+	MX6DL_PAD_CSI0_DAT8__I2C1_SDA,
+	MX6DL_PAD_CSI0_DAT9__I2C1_SCL,
+
+	/* UART1 for debug */
+	MX6DL_PAD_CSI0_DAT10__UART1_TXD,
+	MX6DL_PAD_CSI0_DAT11__UART1_RXD,
+
+	/* SD1 (Combo module WLAN SDIO )*/
+	MX6DL_PAD_SD1_CLK__USDHC1_CLK,
+	MX6DL_PAD_SD1_CMD__USDHC1_CMD,
+	MX6DL_PAD_SD1_DAT0__USDHC1_DAT0,
+	MX6DL_PAD_SD1_DAT1__USDHC1_DAT1,
+	MX6DL_PAD_SD1_DAT2__USDHC1_DAT2,
+	MX6DL_PAD_SD1_DAT3__USDHC1_DAT3,
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6DL_PAD_SD2_CLK__USDHC2_CLK,
+	MX6DL_PAD_SD2_CMD__USDHC2_CMD,
+	MX6DL_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6DL_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6DL_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6DL_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6DL_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6DL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6DL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6DL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6DL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6DL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6DL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6DL_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6DL_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6DL_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6DL_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6DL_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6DL_PAD_KEY_COL0__UART4_TXD,
+	MX6DL_PAD_KEY_ROW0__UART4_RXD,
+
+	/*HDMI CEC communication PIN*/
+	MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/* I2C2 */
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/*DCDC5V_PWREN(5V DCDC BOOST control signal)*/
+	MX6DL_PAD_KEY_COL4__GPIO_4_14,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6DL_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6DL_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C3 */
+	MX6DL_PAD_GPIO_5__I2C3_SCL,
+	MX6DL_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6DL_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6DL_PAD_NANDF_CS0__GPIO_6_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6DL_PAD_NANDF_CS1__GPIO_6_14,
+
+	/*PWRKEY_DET(Power key press detection)*/
+	MX6DL_PAD_NANDF_CS3__GPIO_6_16,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6DL_PAD_NANDF_D6__GPIO_2_6,
+
+	/*IR_RC*/
+	MX6DL_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_rev_b_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6DL_PAD_EIM_OE__ECSPI2_MISO,
+	MX6DL_PAD_EIM_RW__ECSPI2_SS0,
+	MX6DL_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6DL_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6DL_PAD_EIM_A16__GPIO_2_22,
+	/*WLAN_CLKREQn*/
+	MX6DL_PAD_EIM_A25__GPIO_5_2,
+
+	/* WLAN_ACT */
+	MX6DL_PAD_EIM_D17__GPIO_3_17,
+
+	/*BT_PERI*/
+	MX6DL_PAD_EIM_D18__GPIO_3_18,
+
+	/* USB OC pin */
+	MX6DL_PAD_EIM_D21__USBOH3_USBOTG_OC,
+
+	/* WLAN_WAKEn (PM event, OD, used to reactivate the PCIe main PWR and REF CLK) */
+	MX6DL_PAD_EIM_D22__GPIO_3_22,
+
+
+	/*WLAN_PERSTn (PCIe rst signal, avtive LOW)*/
+	MX6DL_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WLAN_PDn (Externally shutdown RTL8192)*/
+	MX6DL_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6DL_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6DL_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6DL_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6DL_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A24__GPIO_5_4,		/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6DL_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6DL_PAD_SD2_CLK__USDHC2_CLK,
+	MX6DL_PAD_SD2_CMD__USDHC2_CMD,
+	MX6DL_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6DL_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6DL_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6DL_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6DL_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6DL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6DL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6DL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6DL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6DL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6DL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6DL_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6DL_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6DL_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6DL_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6DL_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6DL_PAD_KEY_COL0__UART4_TXD,
+	MX6DL_PAD_KEY_ROW0__UART4_RXD,
+
+	/*SD2_VSELECT (SD2 SDXC power exchange control signal)*/
+	MX6DL_PAD_KEY_ROW1__GPIO_4_9,
+
+	/*HDMI CEC communication PIN*/
+	MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/*PWRKEY_DET (Pwr button detection interrupt)*/
+	MX6DL_PAD_ENET_RXD0__GPIO_1_27,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6DL_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6DL_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C2 */
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/* I2C3 */
+	MX6DL_PAD_GPIO_5__I2C3_SCL,
+	MX6DL_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6DL_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6DL_PAD_SD4_DAT3__GPIO_2_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6DL_PAD_SD4_DAT1__GPIO_2_9,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6DL_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+/* The GPMI is conflicted with SD3, so init this in the driver. */
+static iomux_v3_cfg_t mx6dl_gpmi_nand[] __initdata = {
+	MX6DL_PAD_NANDF_CLE__RAWNAND_CLE,
+	MX6DL_PAD_NANDF_ALE__RAWNAND_ALE,
+	MX6DL_PAD_NANDF_CS0__RAWNAND_CE0N,
+	MX6DL_PAD_NANDF_CS1__RAWNAND_CE1N,
+	MX6DL_PAD_NANDF_CS2__RAWNAND_CE2N,
+	MX6DL_PAD_NANDF_CS3__RAWNAND_CE3N,
+	MX6DL_PAD_NANDF_RB0__RAWNAND_READY0,
+	MX6DL_PAD_SD4_DAT0__RAWNAND_DQS,
+	MX6DL_PAD_NANDF_D0__RAWNAND_D0,
+	MX6DL_PAD_NANDF_D1__RAWNAND_D1,
+	MX6DL_PAD_NANDF_D2__RAWNAND_D2,
+	MX6DL_PAD_NANDF_D3__RAWNAND_D3,
+	MX6DL_PAD_NANDF_D4__RAWNAND_D4,
+	MX6DL_PAD_NANDF_D5__RAWNAND_D5,
+	MX6DL_PAD_NANDF_D6__RAWNAND_D6,
+	MX6DL_PAD_NANDF_D7__RAWNAND_D7,
+	MX6DL_PAD_SD4_CMD__RAWNAND_RDN,
+	MX6DL_PAD_SD4_CLK__RAWNAND_WRN,
+	MX6DL_PAD_NANDF_WP_B__RAWNAND_RESETN,
+};
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_hdmi_ddc_pads[] = {
+	MX6DL_PAD_KEY_COL3__HDMI_TX_DDC_SCL, /* HDMI DDC SCL */
+	MX6DL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA, /* HDMI DDC SDA */
+};
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_i2c2_pads[] = {
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,	/* I2C2 SCL */
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,	/* I2C2 SDA */
+};
+
+#endif
diff --git a/arch/arm/mach-mx6/board-mx6dl_sabresd.h b/arch/arm/mach-mx6/board-mx6dl_sabresd.h
index 7e6a261..7cb6924 100644
--- a/arch/arm/mach-mx6/board-mx6dl_sabresd.h
+++ b/arch/arm/mach-mx6/board-mx6dl_sabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -66,7 +66,6 @@ static iomux_v3_cfg_t mx6dl_sabresd_pads[] = {
 
 	/* I2C3 */
 	MX6DL_PAD_GPIO_3__I2C3_SCL,
-	MX6DL_PAD_GPIO_6__I2C3_SDA,
 
 	/* DISPLAY */
 	MX6DL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
@@ -167,7 +166,7 @@ static iomux_v3_cfg_t mx6dl_sabresd_pads[] = {
 	MX6DL_PAD_SD4_DAT7__USDHC4_DAT7_50MHZ,
 
 	/* HDMI_CEC_IN*/
-	MX6DL_PAD_KEY_ROW2__GPIO_4_11,
+	MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
 
 	/* CCM - Audio, Camera clock  */
 	MX6DL_PAD_GPIO_0__CCM_CLKO,
@@ -263,8 +262,8 @@ static iomux_v3_cfg_t mx6dl_sabresd_pads[] = {
 	/* ACCL_INT_INT */
 	MX6DL_PAD_SD1_CMD__GPIO_1_18,
 
-	/* USR_DEF_GRN_LED */
-	MX6DL_PAD_GPIO_1__GPIO_1_1,
+	/*WDOG_B to reset pmic*/
+	MX6DL_PAD_GPIO_1__WDOG2_WDOG_B,
 	/* USR_DEF_RED_LED */
 	MX6DL_PAD_GPIO_2__GPIO_1_2,
 };
diff --git a/arch/arm/mach-mx6/board-mx6q_arm2.c b/arch/arm/mach-mx6/board-mx6q_arm2.c
index 50f26dd..8280805 100644
--- a/arch/arm/mach-mx6/board-mx6q_arm2.c
+++ b/arch/arm/mach-mx6/board-mx6q_arm2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -155,6 +155,10 @@
 
 #define MX6_ARM2_CAN2_STBY		MX6_ARM2_IO_EXP_GPIO2(1)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
 
 #define BMCR_PDOWN			0x0800 /* PHY Powerdown */
 
@@ -173,7 +177,7 @@ extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
 extern int epdc_enabled;
-extern void mx6_cpu_regulator_init(void);
+extern bool enet_to_gpio_6;
 static int max17135_regulator_init(struct max17135 *max17135);
 
 enum sd_pad_mode {
@@ -337,6 +341,16 @@ static int mx6_arm2_fec_phy_init(struct phy_device *phydev)
 {
 	unsigned short val;
 
+	/* Ar8031 phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, 0xd, 0x3);
+	phy_write(phydev, 0xe, 0x805d);
+	phy_write(phydev, 0xd, 0x4003);
+	val = phy_read(phydev, 0xe);
+	val &= ~(0x1 << 8);
+	phy_write(phydev, 0xe, val);
+
 	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
 	phy_write(phydev, 0xd, 0x7);
 	phy_write(phydev, 0xe, 0x8016);
@@ -378,6 +392,7 @@ static struct fec_platform_data fec_data __initdata = {
 	.init			= mx6_arm2_fec_phy_init,
 	.power_hibernate	= mx6_arm2_fec_power_hibernate,
 	.phy			= PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq = MX6_ENET_IRQ,
 };
 
 static int mx6_arm2_spi_cs[] = {
@@ -864,11 +879,7 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 	},
 };
 
-static struct imxi2c_platform_data mx6_arm2_i2c0_data = {
-	.bitrate = 100000,
-};
-
-static struct imxi2c_platform_data mx6_arm2_i2c1_data = {
+static struct imxi2c_platform_data mx6_arm2_i2c_data = {
 	.bitrate = 100000,
 };
 
@@ -1244,7 +1255,7 @@ static void __init mx6_arm2_init_usb(void)
 	mxc_iomux_set_gpr_register(1, 13, 1, 1);
 
 	mx6_set_otghost_vbus_func(imx6_arm2_usbotg_vbus);
-	mx6_usb_dr_init();
+
 #ifdef CONFIG_USB_EHCI_ARC_HSIC
 	mx6_usb_h2_init();
 	mx6_usb_h3_init();
@@ -1308,11 +1319,22 @@ static int mx6_arm2_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -1323,6 +1345,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6_arm2_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -1338,6 +1361,7 @@ static struct ahci_platform_data mx6_arm2_sata_data = {
 	.init	= mx6_arm2_sata_init,
 	.exit	= mx6_arm2_sata_exit,
 };
+#endif
 
 static struct imx_asrc_platform_data imx_asrc_data = {
 	.channel_bits	= 4,
@@ -2029,6 +2053,18 @@ static void __init mx6_arm2_init(void)
 		spdif_pads_cnt =  ARRAY_SIZE(mx6q_arm2_spdif_pads);
 		flexcan_pads_cnt = ARRAY_SIZE(mx6q_arm2_can_pads);
 		i2c3_pads_cnt = ARRAY_SIZE(mx6q_arm2_i2c3_pads);
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6Q_PAD_GPIO_3__MLB_MLBCLK,
+				MX6Q_PAD_GPIO_6__MLB_MLBSIG,
+				MX6Q_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	} else if (cpu_is_mx6dl()) {
 		common_pads = mx6dl_arm2_pads;
 		esai_rec_pads = mx6dl_arm2_esai_record_pads;
@@ -2043,6 +2079,18 @@ static void __init mx6_arm2_init(void)
 		flexcan_pads_cnt = ARRAY_SIZE(mx6dl_arm2_can_pads);
 		i2c3_pads_cnt = ARRAY_SIZE(mx6dl_arm2_i2c3_pads);
 		epdc_pads_cnt = ARRAY_SIZE(mx6dl_arm2_epdc_pads);
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6DL_PAD_GPIO_3__MLB_MLBCLK,
+				MX6DL_PAD_GPIO_6__MLB_MLBSIG,
+				MX6DL_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	}
 
 	BUG_ON(!common_pads);
@@ -2129,8 +2177,8 @@ static void __init mx6_arm2_init(void)
 
 	imx6q_add_imx_caam();
 
-	imx6q_add_imx_i2c(0, &mx6_arm2_i2c0_data);
-	imx6q_add_imx_i2c(1, &mx6_arm2_i2c1_data);
+	imx6q_add_imx_i2c(0, &mx6_arm2_i2c_data);
+	imx6q_add_imx_i2c(1, &mx6_arm2_i2c_data);
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 			ARRAY_SIZE(mxc_i2c0_board_info));
 	i2c_register_board_info(1, mxc_i2c1_board_info,
@@ -2142,6 +2190,8 @@ static void __init mx6_arm2_init(void)
 		i2c_register_board_info(2, mxc_i2c2_board_info,
 				ARRAY_SIZE(mxc_i2c2_board_info));
 	}
+	if (cpu_is_mx6dl())
+		imx6q_add_imx_i2c(3, &mx6_arm2_i2c_data);
 
 	/* SPI */
 	imx6q_add_ecspi(0, &mx6_arm2_spi_data);
@@ -2151,20 +2201,34 @@ static void __init mx6_arm2_init(void)
 
 	imx6q_add_anatop_thermal_imx(1, &mx6_arm2_anatop_thermal_data);
 
-	if (!esai_record)
+	if (!esai_record) {
+		if (enet_to_gpio_6)
+			/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+			mxc_iomux_set_specialbits_register(
+				IOMUX_OBSRV_MUX1_OFFSET,
+				OBSRV_MUX1_ENET_IRQ,
+				OBSRV_MUX1_MASK);
+		else
+			fec_data.gpio_irq = -1;
 		imx6_init_fec(fec_data);
+	}
 
 	imx6q_add_pm_imx(0, &mx6_arm2_pm_data);
 	imx6q_add_sdhci_usdhc_imx(3, &mx6_arm2_sd4_data);
 	imx6q_add_sdhci_usdhc_imx(2, &mx6_arm2_sd3_data);
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6_gpu_pdata);
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 		imx6q_add_ahci(0, &mx6_arm2_sata_data);
+#else
+		mx6_arm2_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	mx6_arm2_init_usb();
 	mx6_arm2_init_audio();
 	platform_device_register(&arm2_vmmc_reg_devices);
-	mx6_cpu_regulator_init();
 
 	imx_asrc_data.asrc_core_clk = clk_get(NULL, "asrc_clk");
 	imx_asrc_data.asrc_audio_clk = clk_get(NULL, "asrc_serial_clk");
diff --git a/arch/arm/mach-mx6/board-mx6q_arm2.h b/arch/arm/mach-mx6/board-mx6q_arm2.h
index eb06ef8..24a894f 100644
--- a/arch/arm/mach-mx6/board-mx6q_arm2.h
+++ b/arch/arm/mach-mx6/board-mx6q_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012, 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -182,12 +182,7 @@ static iomux_v3_cfg_t mx6q_arm2_pads[] = {
 
 	/* USBOTG ID pin */
 	MX6Q_PAD_GPIO_1__USBOTG_ID,
-
-	/* MLB150 */
-	MX6Q_PAD_GPIO_3__MLB_MLBCLK,
-	MX6Q_PAD_GPIO_6__MLB_MLBSIG,
-	MX6Q_PAD_GPIO_2__MLB_MLBDAT,
-};
+ };
 
 static iomux_v3_cfg_t mx6q_arm2_i2c3_pads[] = {
 	MX6Q_PAD_GPIO_5__I2C3_SCL,
diff --git a/arch/arm/mach-mx6/board-mx6q_hdmidongle.c b/arch/arm/mach-mx6/board-mx6q_hdmidongle.c
new file mode 100644
index 0000000..ffd8d9a
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6q_hdmidongle.c
@@ -0,0 +1,800 @@
+/*
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c.h>
+#include <linux/i2c/pca953x.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
+#include <linux/fec.h>
+#include <linux/memblock.h>
+#include <linux/gpio.h>
+#include <linux/etherdevice.h>
+#include <linux/regulator/anatop-regulator.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/mfd/mxc-hdmi-core.h>
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/memory.h>
+#include <mach/iomux-mx6q.h>
+#include <mach/imx-uart.h>
+#include <mach/viv_gpu.h>
+#include <mach/ipu-v3.h>
+#include <mach/mxc_hdmi.h>
+
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#ifdef CONFIG_MFD_WM831X
+#include <linux/mfd/wm831x/core.h>
+#include <linux/mfd/wm831x/pdata.h>
+#include <linux/mfd/wm831x/regulator.h>
+#include <linux/mfd/wm831x/gpio.h>
+#endif
+
+#include "usb.h"
+#include "devices-imx6q.h"
+#include "crm_regs.h"
+#include "cpu_op-mx6.h"
+#include "board-mx6q_hdmidongle.h"
+#include "board-mx6dl_hdmidongle.h"
+
+#define HDMIDONGLE_USB_OTG_PWR	IMX_GPIO_NR(4, 15)
+#define HDMIDONGLE_USB_H1_PWR	IMX_GPIO_NR(4, 14)
+#define HDMIDONGLE_ECSPI2_CS0  IMX_GPIO_NR(2, 26)
+#define HDMIDONGLE_HDMI_CEC_IN	IMX_GPIO_NR(4, 11)
+
+
+#define HDMIDONGLE_BT_RST	IMX_GPIO_NR(3, 7)
+#define HDMIDONGLE_BT_EN	IMX_GPIO_NR(3, 9)
+#define HDMIDONGLE_WL_EN        IMX_GPIO_NR(3, 10)
+
+#define HDMIDONGLE_SD2_CD		IMX_GPIO_NR(1, 4)
+#define HDMIDONGLE_REVA_POWER_KEY	IMX_GPIO_NR(6, 16)
+#define HDMIDONGLE_REVB_POWER_KEY	IMX_GPIO_NR(1, 27)
+
+#ifdef CONFIG_IMX_PCIE
+#define HDMIDONGLE_PCIE_PWR_EN	IMX_GPIO_NR(3, 7) /*fake pcie power enable */
+#define HDMIDONGLE_PCIE_RST     IMX_GPIO_NR(3, 9)
+#define HDMIDONGLE_PCIE_WAKE	IMX_GPIO_NR(3, 22)
+#define HDMIDONGLE_PCIE_DIS		IMX_GPIO_NR(3, 10)
+#endif
+
+extern char *gp_reg_id;
+extern char *soc_reg_id;
+extern char *pu_reg_id;
+
+static const struct esdhc_platform_data mx6q_hdmidongle_sd1_data __initconst = {
+	.always_present = 1,
+};
+
+static const struct esdhc_platform_data mx6q_hdmidongle_sd2_data __initconst = {
+	.cd_gpio = HDMIDONGLE_SD2_CD,
+	.keep_power_at_suspend = 1,
+	.support_8bit = 0,
+	.delay_line = 0,
+	.cd_type = ESDHC_CD_CONTROLLER,
+};
+
+static const struct esdhc_platform_data mx6q_hdmidongle_sd3_data __initconst = {
+	.always_present = 1,
+	.keep_power_at_suspend = 1,
+	.support_8bit = 1,
+	.delay_line = 0,
+	.cd_type = ESDHC_CD_PERMANENT,
+};
+
+static const struct esdhc_platform_data mx6q_hdmidongle_revc_sd3_data __initconst = {
+	.always_present = 1,
+	.keep_power_at_suspend = 1,
+	.support_8bit = 0,
+	.delay_line = 0,
+	.cd_type = ESDHC_CD_PERMANENT,
+};
+
+
+static int __init gpmi_nand_platform_init(void)
+{
+	iomux_v3_cfg_t *nand_pads = NULL;
+	u32 nand_pads_cnt;
+
+	if (cpu_is_mx6q()) {
+		nand_pads = mx6q_gpmi_nand;
+		nand_pads_cnt = ARRAY_SIZE(mx6q_gpmi_nand);
+	} else if (cpu_is_mx6dl()) {
+		nand_pads = mx6dl_gpmi_nand;
+		nand_pads_cnt = ARRAY_SIZE(mx6dl_gpmi_nand);
+
+	}
+	BUG_ON(!nand_pads);
+	return mxc_iomux_v3_setup_multiple_pads(nand_pads, nand_pads_cnt);
+}
+
+static struct gpmi_nand_platform_data
+mx6_gpmi_nand_platform_data __initdata = {
+	.platform_init           = gpmi_nand_platform_init,
+	.min_prop_delay_in_ns    = 5,
+	.max_prop_delay_in_ns    = 9,
+	.max_chip_count          = 1,
+	.enable_bbt              = 1,
+	.enable_ddr              = 0,
+};
+
+static int __init board_support_onfi_nand(char *p)
+{
+	mx6_gpmi_nand_platform_data.enable_ddr = 1;
+	return 0;
+}
+
+early_param("onfi_support", board_support_onfi_nand);
+
+
+static const struct anatop_thermal_platform_data
+	mx6q_hdmidongle_anatop_thermal_data __initconst = {
+		.name = "anatop_thermal",
+};
+
+static inline void mx6q_hdmidongle_init_uart(void)
+{
+	if (board_is_mx6_reva())
+		imx6q_add_imx_uart(1, NULL);
+	imx6q_add_imx_uart(0, NULL);
+	imx6q_add_imx_uart(3, NULL);
+}
+
+static int mx6q_hdmidongle_spi_cs[] = {
+	HDMIDONGLE_ECSPI2_CS0,
+};
+
+static const struct spi_imx_master mx6q_hdmidongle_spi_data __initconst = {
+	.chipselect     = mx6q_hdmidongle_spi_cs,
+	.num_chipselect = ARRAY_SIZE(mx6q_hdmidongle_spi_cs),
+};
+
+
+
+#ifdef CONFIG_MFD_WM831X
+#if 0
+/* 1.4125, 1.4125. 1.5 */
+#define WM831X_DC1_ON_CONFIG_VAL            (0x48<<WM831X_DC1_ON_VSEL_SHIFT)
+#define WM831X_DC2_ON_CONFIG_VAL            (0x48<<WM831X_DC2_ON_VSEL_SHIFT)
+#define WM831X_DC3_ON_CONFIG_VAL            (0x1A<<WM831X_DC3_ON_VSEL_SHIFT)
+#else
+/* 1.375, 1.375. 1.5 */
+
+#define WM831X_DC1_ON_CONFIG_VAL            (0x44<<WM831X_DC1_ON_VSEL_SHIFT)
+#define WM831X_DC2_ON_CONFIG_VAL            (0x44<<WM831X_DC2_ON_VSEL_SHIFT)
+#define WM831X_DC3_ON_CONFIG_VAL            (0x1A<<WM831X_DC3_ON_VSEL_SHIFT)
+
+#endif
+
+#define WM831X_DC1_DVS_MODE_VAL             (0x02<<WM831X_DC1_DVS_SRC_SHIFT)
+#define WM831X_DC2_DVS_MODE_VAL             (0x02<<WM831X_DC2_DVS_SRC_SHIFT)
+
+#define WM831X_DC1_DVS_CONTROL_VAL           (0x20<<WM831X_DC1_DVS_VSEL_SHIFT)
+#define WM831X_DC2_DVS_CONTROL_VAL           (0x20<<WM831X_DC2_DVS_VSEL_SHIFT)
+
+#define WM831X_DC1_DVS_MASK                  (WM831X_DC1_DVS_SRC_MASK|WM831X_DC1_DVS_VSEL_MASK)
+#define WM831X_DC2_DVS_MASK                  (WM831X_DC2_DVS_SRC_MASK|WM831X_DC1_DVS_VSEL_MASK)
+
+#define WM831X_DC1_DVS_VAL                   (WM831X_DC1_DVS_MODE_VAL|WM831X_DC1_DVS_CONTROL_VAL)
+#define WM831X_DC2_DVS_VAL                   (WM831X_DC2_DVS_MODE_VAL|WM831X_DC2_DVS_CONTROL_VAL)
+
+#define WM831X_GPN_FN_VAL_HW_EN              (0x0A<<WM831X_GPN_FN_SHIFT)
+#define WM831X_GPN_FN_VAL_HW_CTL             (0x0C<<WM831X_GPN_FN_SHIFT)
+#define WM831X_GPN_FN_VAL_DVS1               (0x08<<WM831X_GPN_FN_SHIFT)
+
+#define WM831X_GPN_DIR_VAL                   (0x1<<WM831X_GPN_DIR_SHIFT)
+#define WM831X_GPN_PULL_VAL                  (0x3<<WM831X_GPN_PULL_SHIFT)
+#define WM831X_GPN_INT_MODE_VAL              (0x1<<WM831X_GPN_INT_MODE_SHIFT)
+#define WM831X_GPN_POL_VAL                   (0x1<<WM831X_GPN_POL_SHIFT)
+#define WM831X_GPN_ENA_VAL                   (0x1<<WM831X_GPN_ENA_SHIFT)
+
+#define WM831X_GPIO7_8_9_MASK               (WM831X_GPN_DIR_MASK|WM831X_GPN_INT_MODE_MASK|WM831X_GPN_PULL_MASK|WM831X_GPN_POL_MASK|WM831X_GPN_FN_MASK)
+
+
+#define WM831X_GPIO7_VAL                     (WM831X_GPN_DIR_VAL|WM831X_GPN_PULL_VAL|WM831X_GPN_INT_MODE_VAL|WM831X_GPN_POL_VAL|WM831X_GPN_ENA_VAL|WM831X_GPN_FN_VAL_HW_EN)
+#define WM831X_GPIO8_VAL                     (WM831X_GPN_DIR_VAL|WM831X_GPN_PULL_VAL|WM831X_GPN_INT_MODE_VAL|WM831X_GPN_POL_VAL|WM831X_GPN_ENA_VAL|WM831X_GPN_FN_VAL_HW_CTL)
+#define WM831X_GPIO9_VAL                     (WM831X_GPN_DIR_VAL|WM831X_GPN_PULL_VAL|WM831X_GPN_INT_MODE_VAL|WM831X_GPN_POL_VAL|WM831X_GPN_ENA_VAL|WM831X_GPN_FN_VAL_DVS1)
+
+#define WM831X_STATUS_LED_MASK                0xC000
+#define WM831X_STATUS_LED_ON                  (0x1 << 14)
+#define WM831X_STATUS_LED_OFF                 (0x0 << 14)
+
+static int wm8326_post_init(struct wm831x *wm831x)
+{
+	wm831x_set_bits(wm831x, WM831X_DC1_ON_CONFIG, WM831X_DC1_ON_VSEL_MASK, WM831X_DC1_ON_CONFIG_VAL);
+	wm831x_set_bits(wm831x, WM831X_DC2_ON_CONFIG, WM831X_DC2_ON_VSEL_MASK, WM831X_DC2_ON_CONFIG_VAL);
+	wm831x_set_bits(wm831x, WM831X_DC3_ON_CONFIG, WM831X_DC3_ON_VSEL_MASK, WM831X_DC3_ON_CONFIG_VAL);
+
+	wm831x_set_bits(wm831x, WM831X_DC1_DVS_CONTROL, WM831X_DC1_DVS_MASK, WM831X_DC1_DVS_VAL);
+	wm831x_set_bits(wm831x, WM831X_DC2_DVS_CONTROL, WM831X_DC2_DVS_MASK, WM831X_DC2_DVS_VAL);
+
+	wm831x_set_bits(wm831x, WM831X_GPIO7_CONTROL, WM831X_GPIO7_8_9_MASK, WM831X_GPIO7_VAL);
+	wm831x_set_bits(wm831x, WM831X_GPIO8_CONTROL, WM831X_GPIO7_8_9_MASK, WM831X_GPIO8_VAL);
+	wm831x_set_bits(wm831x, WM831X_GPIO9_CONTROL, WM831X_GPIO7_8_9_MASK, WM831X_GPIO9_VAL);
+
+    wm831x_set_bits(wm831x, WM831X_STATUS_LED_1 , WM831X_STATUS_LED_MASK, WM831X_STATUS_LED_OFF);
+    wm831x_set_bits(wm831x, WM831X_STATUS_LED_2 , WM831X_STATUS_LED_MASK, WM831X_STATUS_LED_ON);
+	return 0;
+}
+
+static struct wm831x_pdata hdmidongle_wm8326_pdata = {
+	.post_init = wm8326_post_init,
+};
+#endif
+
+static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
+	{
+#ifdef CONFIG_MFD_WM831X
+	I2C_BOARD_INFO("wm8326", 0x34),
+	.platform_data = &hdmidongle_wm8326_pdata,
+#endif
+	},
+};
+
+static struct spi_board_info wm8326_spi1_board_info[] __initdata = {
+#if defined(CONFIG_MFD_WM831X_SPI)
+	{
+	/* The modalias must be the same as spi device driver name */
+	.modalias	= "wm8326",
+	.max_speed_hz	= 20000000,
+	.bus_num	= 1,
+	.chip_select	= 0,
+	},
+#endif
+};
+
+static void spi_device_init(void)
+{
+	spi_register_board_info(wm8326_spi1_board_info,
+				ARRAY_SIZE(wm8326_spi1_board_info));
+}
+
+static struct imxi2c_platform_data mx6q_hdmidongle_i2c_data = {
+	.bitrate = 100000,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("mxc_hdmi_i2c", 0x50),
+	},
+};
+
+
+static void imx6q_hdmidongle_usbotg_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(HDMIDONGLE_USB_OTG_PWR, 1);
+	else
+		gpio_set_value(HDMIDONGLE_USB_OTG_PWR, 0);
+}
+
+static void __init imx6q_hdmidongle_init_usb(void)
+{
+	int ret = 0;
+
+	imx_otg_base = MX6_IO_ADDRESS(MX6Q_USB_OTG_BASE_ADDR);
+	/* disable external charger detect,
+	 * or it will affect signal quality at dp .
+	 */
+	ret = gpio_request(HDMIDONGLE_USB_OTG_PWR, "usb-pwr");
+	if (ret) {
+		pr_err("failed to get GPIO HDMIDONGLE_USB_OTG_PWR: %d\n",
+			ret);
+		return;
+	}
+	gpio_direction_output(HDMIDONGLE_USB_OTG_PWR, 0);
+	/* keep USB host1 VBUS always on */
+	if (board_is_mx6_reva()) {
+		ret = gpio_request(HDMIDONGLE_USB_H1_PWR, "usb-h1-pwr");
+		if (ret) {
+			pr_err("failed to get GPIO HDMIDONGLE_USB_H1_PWR: %d\n",
+				ret);
+			return;
+		}
+		gpio_direction_output(HDMIDONGLE_USB_H1_PWR, 1);
+	}
+	mxc_iomux_set_gpr_register(1, 13, 1, 1);
+
+	mx6_set_otghost_vbus_func(imx6q_hdmidongle_usbotg_vbus);
+}
+
+
+static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
+	.reserved_mem_size = SZ_128M + SZ_64M,
+};
+
+
+static struct ipuv3_fb_platform_data hdmidongle_fb_data[] = {
+	{/*fb0*/
+	.disp_dev = "hdmi",
+	.interface_pix_fmt = IPU_PIX_FMT_RGB24,
+	.mode_str = "1920x1080M@60",
+	.default_bpp = 32,
+	.int_clk = false,
+	},
+};
+
+static void hdmi_init(int ipu_id, int disp_id)
+{
+	int hdmi_mux_setting;
+
+	if ((ipu_id > 1) || (ipu_id < 0)) {
+		pr_err("Invalid IPU select for HDMI: %d. Set to 0\n", ipu_id);
+		ipu_id = 0;
+	}
+
+	if ((disp_id > 1) || (disp_id < 0)) {
+		pr_err("Invalid DI select for HDMI: %d. Set to 0\n", disp_id);
+		disp_id = 0;
+	}
+
+	/* Configure the connection between IPU1/2 and HDMI */
+	hdmi_mux_setting = 2*ipu_id + disp_id;
+
+	/* GPR3, bits 2-3 = HDMI_MUX_CTL */
+	mxc_iomux_set_gpr_register(3, 2, 2, hdmi_mux_setting);
+	/* Set HDMI event as SDMA event2 while Chip version later than TO1.2 */
+	if (hdmi_SDMA_check())
+		mxc_iomux_set_gpr_register(0, 0, 1, 1);
+}
+
+/* On mx6x sabresd board i2c2 iomux with hdmi ddc,
+ * the pins default work at i2c2 function,
+ when hdcp enable, the pins should work at ddc function */
+
+static void hdmi_enable_ddc_pin(void)
+{
+	if (cpu_is_mx6dl())
+		mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_hdmi_ddc_pads,
+			ARRAY_SIZE(mx6dl_hdmidongle_hdmi_ddc_pads));
+	else
+		mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_hdmi_ddc_pads,
+			ARRAY_SIZE(mx6q_hdmidongle_hdmi_ddc_pads));
+}
+
+static void hdmi_disable_ddc_pin(void)
+{
+	if (cpu_is_mx6dl())
+		mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_i2c2_pads,
+			ARRAY_SIZE(mx6dl_hdmidongle_i2c2_pads));
+	else
+		mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_i2c2_pads,
+			ARRAY_SIZE(mx6q_hdmidongle_i2c2_pads));
+}
+
+
+static struct fsl_mxc_hdmi_platform_data hdmi_data = {
+	.init = hdmi_init,
+	.enable_pins = hdmi_enable_ddc_pin,
+	.disable_pins = hdmi_disable_ddc_pin,
+	.phy_reg_vlev = 0x0294,
+	.phy_reg_cksymtx = 0x800d,
+};
+
+static struct fsl_mxc_hdmi_core_platform_data hdmi_core_data = {
+	.ipu_id = 0,
+	.disp_id = 0,
+};
+
+static struct imx_ipuv3_platform_data ipu_data[] = {
+	{
+	.rev = 4,
+	.csi_clk[0] = "clko_clk",
+	}, {
+	.rev = 4,
+	.csi_clk[0] = "clko_clk",
+	},
+};
+
+static void hdmidongle_suspend_enter(void)
+{
+	/* suspend preparation */
+}
+
+static void hdmidongle_suspend_exit(void)
+{
+	/* resume restore */
+}
+static const struct pm_platform_data mx6q_hdmidongle_pm_data __initconst = {
+	.name = "imx_pm",
+	.suspend_enter = hdmidongle_suspend_enter,
+	.suspend_exit = hdmidongle_suspend_exit,
+};
+
+static struct regulator_consumer_supply hdmidongle_vmmc_consumers[] = {
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.1"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.2"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.3"),
+};
+
+static struct regulator_init_data hdmidongle_vmmc_init = {
+	.num_consumer_supplies = ARRAY_SIZE(hdmidongle_vmmc_consumers),
+	.consumer_supplies = hdmidongle_vmmc_consumers,
+};
+
+static struct fixed_voltage_config hdmidongle_vmmc_reg_config = {
+	.supply_name		= "vmmc",
+	.microvolts		= 3300000,
+	.gpio			= -1,
+	.init_data		= &hdmidongle_vmmc_init,
+};
+
+static struct platform_device hdmidongle_vmmc_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id	= 3,
+	.dev	= {
+		.platform_data = &hdmidongle_vmmc_reg_config,
+	},
+};
+
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+#define GPIO_BUTTON(gpio_num, ev_code, act_low, descr, wake, debounce)	\
+{								\
+	.gpio		= gpio_num,				\
+	.type		= EV_KEY,				\
+	.code		= ev_code,				\
+	.active_low	= act_low,				\
+	.desc		= "btn " descr,				\
+	.wakeup		= wake,					\
+	.debounce_interval = debounce,				\
+}
+
+static struct gpio_keys_button hdmidongle_reva_buttons[] = {
+	GPIO_BUTTON(HDMIDONGLE_REVA_POWER_KEY, KEY_POWER, 1, "power", 1, 1),
+};
+
+static struct gpio_keys_platform_data hdmidongle_reva_button_data = {
+	.buttons	= hdmidongle_reva_buttons,
+	.nbuttons	= ARRAY_SIZE(hdmidongle_reva_buttons),
+};
+
+static struct platform_device hdmidongle_reva_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data = &hdmidongle_reva_button_data,
+	}
+};
+
+static struct gpio_keys_button hdmidongle_revb_buttons[] = {
+	GPIO_BUTTON(HDMIDONGLE_REVB_POWER_KEY, KEY_POWER, 1, "power", 1, 1),
+};
+
+static struct gpio_keys_platform_data hdmidongle_revb_button_data = {
+	.buttons	= hdmidongle_revb_buttons,
+	.nbuttons	= ARRAY_SIZE(hdmidongle_revb_buttons),
+};
+
+static struct platform_device hdmidongle_revb_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data = &hdmidongle_revb_button_data,
+	}
+};
+
+
+static void __init imx6q_add_device_buttons(void)
+{
+	if (board_is_mx6_reva())
+		platform_device_register(&hdmidongle_reva_button_device);
+	else
+		platform_device_register(&hdmidongle_revb_button_device);
+}
+#else
+static void __init imx6q_add_device_buttons(void) {}
+#endif
+
+static struct mxc_dvfs_platform_data hdmidongle_dvfscore_data = {
+	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	.reg_id = "VDDCORE",
+	#else
+	.reg_id = "cpu_vddgp",
+	.soc_id = "cpu_vddsoc",
+	.pu_id = "cpu_vddvpu",
+	#endif
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_offset = MXC_GPC_CNTR_OFFSET,
+	.ccm_cdcr_offset = MXC_CCM_CDCR_OFFSET,
+	.ccm_cacrr_offset = MXC_CCM_CACRR_OFFSET,
+	.ccm_cdhipr_offset = MXC_CCM_CDHIPR_OFFSET,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 80,
+};
+
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	char *str;
+	struct tag *t;
+	int i = 0;
+	struct ipuv3_fb_platform_data *pdata_fb = hdmidongle_fb_data;
+
+	for_each_tag(t, tags) {
+		if (t->hdr.tag == ATAG_CMDLINE) {
+			str = t->u.cmdline.cmdline;
+			str = strstr(str, "fbmem=");
+			if (str != NULL) {
+				str += 6;
+				pdata_fb[i++].res_size[0] = memparse(str, &str);
+				while (*str == ',' &&
+					i < ARRAY_SIZE(hdmidongle_fb_data)) {
+					str++;
+					pdata_fb[i++].res_size[0] = memparse(str, &str);
+				}
+			}
+			break;
+		}
+	}
+}
+
+#define SNVS_LPCR 0x38
+static void mx6_snvs_poweroff(void)
+{
+
+	void __iomem *mx6_snvs_base =  MX6_IO_ADDRESS(MX6Q_SNVS_BASE_ADDR);
+	u32 value;
+	value = readl(mx6_snvs_base + SNVS_LPCR);
+	/*set TOP and DP_EN bit*/
+	writel(value | 0x60, mx6_snvs_base + SNVS_LPCR);
+}
+
+#ifdef CONFIG_IMX_PCIE
+static const struct imx_pcie_platform_data mx6_hdmidongle_pcie_data __initconst = {
+	.pcie_pwr_en	= HDMIDONGLE_PCIE_PWR_EN,
+	.pcie_rst	= HDMIDONGLE_PCIE_RST,
+	.pcie_wake_up	= HDMIDONGLE_PCIE_WAKE,
+	.pcie_dis	= HDMIDONGLE_PCIE_DIS,
+};
+#endif
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mx6_hdmidongle_board_init(void)
+{
+	int i;
+
+	if (cpu_is_mx6q()) {
+		if (board_is_mx6_revb() || board_is_mx6_revc())
+			mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_rev_b_pads,
+				ARRAY_SIZE(mx6q_hdmidongle_rev_b_pads));
+		else
+			mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_rev_a_pads,
+				ARRAY_SIZE(mx6q_hdmidongle_rev_a_pads));
+	} else if (cpu_is_mx6dl()) {
+		if (board_is_mx6_revb() || board_is_mx6_revc())
+			mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_rev_b_pads,
+				ARRAY_SIZE(mx6dl_hdmidongle_rev_b_pads));
+		else
+			mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_rev_a_pads,
+				ARRAY_SIZE(mx6dl_hdmidongle_rev_a_pads));
+	}
+
+	gp_reg_id = hdmidongle_dvfscore_data.reg_id;
+	soc_reg_id = hdmidongle_dvfscore_data.soc_id;
+	pu_reg_id = hdmidongle_dvfscore_data.pu_id;
+	mx6q_hdmidongle_init_uart();
+
+	/*
+	 * MX6DL/Solo only supports single IPU
+	 * The following codes are used to change ipu id
+	 * and display id information for MX6DL/Solo. Then
+	 * register 1 IPU device and up to 2 displays for
+	 * MX6DL/Solo
+	 */
+	if (cpu_is_mx6dl())
+		hdmi_core_data.disp_id = 0;
+
+	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
+
+	imx6q_add_ipuv3(0, &ipu_data[0]);
+	if (cpu_is_mx6q())
+		imx6q_add_ipuv3(1, &ipu_data[1]);
+	for (i = 0; i < ARRAY_SIZE(hdmidongle_fb_data); i++)
+		imx6q_add_ipuv3fb(i, &hdmidongle_fb_data[i]);
+
+	imx6q_add_vdoa();
+
+	imx6q_add_v4l2_output(0);
+
+	imx6q_add_imx_snvs_rtc();
+
+	imx6q_add_imx_i2c(1, &mx6q_hdmidongle_i2c_data);
+    imx6q_add_imx_i2c(2, &mx6q_hdmidongle_i2c_data);
+
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+			ARRAY_SIZE(mxc_i2c1_board_info));
+
+
+	i2c_register_board_info(2, mxc_i2c2_board_info,
+			ARRAY_SIZE(mxc_i2c2_board_info));
+
+
+	/* SPI */
+	imx6q_add_ecspi(1, &mx6q_hdmidongle_spi_data);
+	spi_device_init();
+
+	imx6q_add_mxc_hdmi(&hdmi_data);
+
+	imx6q_add_anatop_thermal_imx(1, &mx6q_hdmidongle_anatop_thermal_data);
+	imx6q_add_pm_imx(0, &mx6q_hdmidongle_pm_data);
+	/* Move sd3 to first because sd3 connect to emmc.
+	   Mfgtools want emmc is mmcblk0 and other sd card is mmcblk1.
+	*/
+	if (board_is_mx6_revc())
+		imx6q_add_sdhci_usdhc_imx(2, &mx6q_hdmidongle_revc_sd3_data);
+	else
+		imx6q_add_sdhci_usdhc_imx(2, &mx6q_hdmidongle_sd3_data);
+	imx6q_add_sdhci_usdhc_imx(1, &mx6q_hdmidongle_sd2_data);
+	if (board_is_mx6_reva())
+		imx6q_add_sdhci_usdhc_imx(0, &mx6q_hdmidongle_sd1_data);
+	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
+	imx6q_hdmidongle_init_usb();
+
+	imx6q_add_vpu();
+
+	platform_device_register(&hdmidongle_vmmc_reg_devices);
+
+	imx6q_add_otp();
+	imx6q_add_viim();
+	imx6q_add_imx2_wdt(0, NULL);
+	imx6q_add_dma();
+	if (board_is_mx6_revb() || board_is_mx6_revc())
+		imx6q_add_gpmi(&mx6_gpmi_nand_platform_data);
+
+	imx6q_add_dvfs_core(&hdmidongle_dvfscore_data);
+	#ifndef CONFIG_MX6_INTER_LDO_BYPASS
+	mx6_cpu_regulator_init();
+	#endif
+
+	imx6q_add_device_buttons();
+
+	imx6q_add_hdmi_soc();
+	imx6q_add_hdmi_soc_dai();
+
+	if (board_is_mx6_reva()) {
+		gpio_request(HDMIDONGLE_BT_RST, "bt_reset");
+		gpio_direction_output(HDMIDONGLE_BT_RST, 1);
+		gpio_set_value(HDMIDONGLE_BT_RST, 1);
+		msleep(1000);
+		gpio_request(HDMIDONGLE_BT_EN, "bt_en");
+		gpio_direction_output(HDMIDONGLE_BT_EN, 1);
+		gpio_set_value(HDMIDONGLE_BT_EN, 1);
+
+		msleep(1000);
+		gpio_request(HDMIDONGLE_WL_EN, "wl_en");
+		gpio_direction_output(HDMIDONGLE_WL_EN, 1);
+		gpio_set_value(HDMIDONGLE_WL_EN, 1);
+		msleep(1000);
+	} else if (board_is_mx6_revb() || board_is_mx6_revc()) {
+		/* Add PCIe RC interface support */
+#ifdef CONFIG_IMX_PCIE
+		imx6q_add_pcie(&mx6_hdmidongle_pcie_data);
+#endif
+	}
+	pm_power_off = mx6_snvs_poweroff;
+	imx6q_add_busfreq();
+}
+
+extern void __iomem *twd_base;
+static void __init mx6_hdmidongle_timer_init(void)
+{
+	struct clk *uart_clk;
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = ioremap(LOCAL_TWD_ADDR, SZ_256);
+	BUG_ON(!twd_base);
+#endif
+	mx6_clocks_init(32768, 24000000, 0, 0);
+
+	uart_clk = clk_get_sys("imx-uart.0", NULL);
+	early_console_setup(UART4_BASE_ADDR, uart_clk);
+}
+
+static struct sys_timer mx6_hdmidongle_timer = {
+	.init   = mx6_hdmidongle_timer_init,
+};
+
+static void __init mx6q_hdmidongle_reserve(void)
+{
+	phys_addr_t phys;
+	int i;
+
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
+	if (imx6q_gpu_pdata.reserved_mem_size) {
+		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
+					   SZ_4K, SZ_1G);
+		memblock_remove(phys, imx6q_gpu_pdata.reserved_mem_size);
+		imx6q_gpu_pdata.reserved_mem_base = phys;
+	}
+#endif
+#if defined(CONFIG_ION)
+	if (imx_ion_data.heaps[0].size) {
+		phys = memblock_alloc(imx_ion_data.heaps[0].size, SZ_4K);
+		memblock_remove(phys, imx_ion_data.heaps[0].size);
+		imx_ion_data.heaps[0].base = phys;
+	}
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(hdmidongle_fb_data); i++)
+		if (hdmidongle_fb_data[i].res_size[0]) {
+			/* reserve for background buffer */
+			phys = memblock_alloc(hdmidongle_fb_data[i].res_size[0],
+						SZ_4K);
+			memblock_remove(phys, hdmidongle_fb_data[i].res_size[0]);
+			hdmidongle_fb_data[i].res_base[0] = phys;
+		}
+}
+
+/*
+ * initialize __mach_desc_MX6Q_HDMIDONGLE data structure.
+ */
+MACHINE_START(MX6Q_HDMIDONGLE, "Freescale i.MX 6Quad/DualLite HDMI Dongle Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.boot_params = MX6_PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mx6_map_io,
+	.init_irq = mx6_init_irq,
+	.init_machine = mx6_hdmidongle_board_init,
+	.timer = &mx6_hdmidongle_timer,
+	.reserve = mx6q_hdmidongle_reserve,
+MACHINE_END
diff --git a/arch/arm/mach-mx6/board-mx6q_hdmidongle.h b/arch/arm/mach-mx6/board-mx6q_hdmidongle.h
new file mode 100644
index 0000000..9338c3e
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6q_hdmidongle.h
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _BOARD_MX6Q_HDMIDONGLE_H
+#define _BOARD_MX6Q_HDMIDONGLE_H
+#include <mach/iomux-mx6q.h>
+
+static iomux_v3_cfg_t mx6q_hdmidongle_rev_a_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6Q_PAD_EIM_OE__ECSPI2_MISO,
+	MX6Q_PAD_EIM_RW__ECSPI2_SS0,
+	MX6Q_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6Q_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6Q_PAD_EIM_A16__GPIO_2_22,
+	/*BT_WAKEUP_HOST(Combo module BT wake-up output) */
+	MX6Q_PAD_EIM_A25__GPIO_5_2,
+	/* HOST_WAKEUP_BT(CPU wakeup BT signal)*/
+	MX6Q_PAD_EIM_D16__GPIO_3_16,
+
+	/* I2C3  */
+	MX6Q_PAD_EIM_D17__I2C3_SCL,
+	MX6Q_PAD_EIM_D18__I2C3_SDA,
+
+	/* USB OC pin */
+	MX6Q_PAD_EIM_D21__USBOH3_USBOTG_OC,
+	/* WLAN_WAKEUP_HOST(Combo module WLAN host wake-up output) */
+	MX6Q_PAD_EIM_D22__GPIO_3_22,
+
+	/* BT_UART2  */
+	MX6Q_PAD_EIM_D26__UART2_TXD,
+	MX6Q_PAD_EIM_D27__UART2_RXD,
+	MX6Q_PAD_EIM_D28__UART2_CTS,
+	MX6Q_PAD_EIM_D29__UART2_RTS,
+
+	/*BT_nRST(Combo module BT reset signal)*/
+	MX6Q_PAD_EIM_DA7__GPIO_3_7,
+
+	/*BT_REG_ON(Combo module BT Internal regulators power enable/disable)*/
+	MX6Q_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WL_REG_ON(Combo module WLAN Internal regulators power enable/disable)*/
+	MX6Q_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6Q_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6Q_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6Q_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6Q_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A24__GPIO_5_4,	/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6Q_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+	/* I2C1  */
+	MX6Q_PAD_CSI0_DAT8__I2C1_SDA,
+	MX6Q_PAD_CSI0_DAT9__I2C1_SCL,
+
+	/* UART1 for debug */
+	MX6Q_PAD_CSI0_DAT10__UART1_TXD,
+	MX6Q_PAD_CSI0_DAT11__UART1_RXD,
+
+	/* SD1 (Combo module WLAN SDIO )*/
+	MX6Q_PAD_SD1_CLK__USDHC1_CLK,
+	MX6Q_PAD_SD1_CMD__USDHC1_CMD,
+	MX6Q_PAD_SD1_DAT0__USDHC1_DAT0,
+	MX6Q_PAD_SD1_DAT1__USDHC1_DAT1,
+	MX6Q_PAD_SD1_DAT2__USDHC1_DAT2,
+	MX6Q_PAD_SD1_DAT3__USDHC1_DAT3,
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6Q_PAD_SD2_CLK__USDHC2_CLK,
+	MX6Q_PAD_SD2_CMD__USDHC2_CMD,
+	MX6Q_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6Q_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6Q_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6Q_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6Q_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6Q_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6Q_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6Q_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6Q_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6Q_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6Q_PAD_KEY_COL0__UART4_TXD,
+	MX6Q_PAD_KEY_ROW0__UART4_RXD,
+
+	/*HDMI CEC communication PIN*/
+	MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/* I2C2 */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/*DCDC5V_PWREN(5V DCDC BOOST control signal)*/
+	MX6Q_PAD_KEY_COL4__GPIO_4_14,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6Q_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6Q_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C3 */
+	MX6Q_PAD_GPIO_5__I2C3_SCL,
+	MX6Q_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6Q_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6Q_PAD_NANDF_CS0__GPIO_6_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6Q_PAD_NANDF_CS1__GPIO_6_14,
+
+	/*PWRKEY_DET(Power key press detection)*/
+	MX6Q_PAD_NANDF_CS3__GPIO_6_16,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6Q_PAD_NANDF_D6__GPIO_2_6,
+
+	/*IR_RC*/
+	MX6Q_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6q_hdmidongle_rev_b_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6Q_PAD_EIM_OE__ECSPI2_MISO,
+	MX6Q_PAD_EIM_RW__ECSPI2_SS0,
+	MX6Q_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6Q_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6Q_PAD_EIM_A16__GPIO_2_22,
+	/*WLAN_CLKREQn*/
+	MX6Q_PAD_EIM_A25__GPIO_5_2,
+
+	/* WLAN_ACT */
+	MX6Q_PAD_EIM_D17__GPIO_3_17,
+
+	/*BT_PERI*/
+	MX6Q_PAD_EIM_D18__GPIO_3_18,
+
+	/* USB OC pin */
+	MX6Q_PAD_EIM_D21__USBOH3_USBOTG_OC,
+
+	/* WLAN_WAKEn (PM event, OD, used to reactivate the PCIe main PWR and REF CLK) */
+	MX6Q_PAD_EIM_D22__GPIO_3_22,
+
+
+	/*WLAN_PERSTn (PCIe rst signal, avtive LOW)*/
+	MX6Q_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WLAN_PDn (Externally shutdown RTL8192)*/
+	MX6Q_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6Q_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6Q_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6Q_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6Q_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A24__GPIO_5_4,		/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6Q_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6Q_PAD_SD2_CLK__USDHC2_CLK,
+	MX6Q_PAD_SD2_CMD__USDHC2_CMD,
+	MX6Q_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6Q_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6Q_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6Q_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6Q_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6Q_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6Q_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6Q_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6Q_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6Q_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6Q_PAD_KEY_COL0__UART4_TXD,
+	MX6Q_PAD_KEY_ROW0__UART4_RXD,
+
+	/*SD2_VSELECT (SD2 SDXC power exchange control signal)*/
+	MX6Q_PAD_KEY_ROW1__GPIO_4_9,
+
+	/*HDMI CEC communication PIN*/
+	MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/*PWRKEY_DET (Pwr button detection interrupt)*/
+	MX6Q_PAD_ENET_RXD0__GPIO_1_27,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6Q_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6Q_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C2 */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/* I2C3 */
+	MX6Q_PAD_GPIO_5__I2C3_SCL,
+	MX6Q_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6Q_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6Q_PAD_SD4_DAT3__GPIO_2_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6Q_PAD_SD4_DAT1__GPIO_2_9,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6Q_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+/* The GPMI is conflicted with SD3, so init this in the driver. */
+static iomux_v3_cfg_t mx6q_gpmi_nand[] __initdata = {
+	MX6Q_PAD_NANDF_CLE__RAWNAND_CLE,
+	MX6Q_PAD_NANDF_ALE__RAWNAND_ALE,
+	MX6Q_PAD_NANDF_CS0__RAWNAND_CE0N,
+	MX6Q_PAD_NANDF_CS1__RAWNAND_CE1N,
+	MX6Q_PAD_NANDF_CS2__RAWNAND_CE2N,
+	MX6Q_PAD_NANDF_CS3__RAWNAND_CE3N,
+	MX6Q_PAD_NANDF_RB0__RAWNAND_READY0,
+	MX6Q_PAD_SD4_DAT0__RAWNAND_DQS,
+	MX6Q_PAD_NANDF_D0__RAWNAND_D0,
+	MX6Q_PAD_NANDF_D1__RAWNAND_D1,
+	MX6Q_PAD_NANDF_D2__RAWNAND_D2,
+	MX6Q_PAD_NANDF_D3__RAWNAND_D3,
+	MX6Q_PAD_NANDF_D4__RAWNAND_D4,
+	MX6Q_PAD_NANDF_D5__RAWNAND_D5,
+	MX6Q_PAD_NANDF_D6__RAWNAND_D6,
+	MX6Q_PAD_NANDF_D7__RAWNAND_D7,
+	MX6Q_PAD_SD4_CMD__RAWNAND_RDN,
+	MX6Q_PAD_SD4_CLK__RAWNAND_WRN,
+	MX6Q_PAD_NANDF_WP_B__RAWNAND_RESETN,
+};
+
+static iomux_v3_cfg_t mx6q_hdmidongle_hdmi_ddc_pads[] = {
+	MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL, /* HDMI DDC SCL */
+	MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA, /* HDMI DDC SDA */
+};
+
+static iomux_v3_cfg_t mx6q_hdmidongle_i2c2_pads[] = {
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* I2C2 SCL */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* I2C2 SDA */
+};
+
+#endif
diff --git a/arch/arm/mach-mx6/board-mx6q_sabreauto.c b/arch/arm/mach-mx6/board-mx6q_sabreauto.c
index c956577..7c1fada 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabreauto.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabreauto.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -114,6 +114,11 @@
 #define SABREAUTO_MAX7310_2_BASE_ADDR	IMX_GPIO_NR(8, 8)
 #define SABREAUTO_MAX7310_3_BASE_ADDR	IMX_GPIO_NR(8, 16)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
+
 #define SABREAUTO_IO_EXP_GPIO1(x)	(SABREAUTO_MAX7310_1_BASE_ADDR + (x))
 #define SABREAUTO_IO_EXP_GPIO2(x)	(SABREAUTO_MAX7310_2_BASE_ADDR + (x))
 #define SABREAUTO_IO_EXP_GPIO3(x)	(SABREAUTO_MAX7310_3_BASE_ADDR + (x))
@@ -135,6 +140,7 @@
 extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
+extern bool enet_to_gpio_6;
 
 static int mma8451_position = 3;
 static int mag3110_position = 2;
@@ -328,10 +334,16 @@ mx6q_sabreauto_anatop_thermal_data __initconst = {
 	.name = "anatop_thermal",
 };
 
+static const struct imxuart_platform_data mx6_bt_uart_data __initconst = {
+	.flags = IMXUART_HAVE_RTSCTS | IMXUART_SDMA,
+	.dma_req_rx = MX6Q_DMA_REQ_UART3_RX,
+	.dma_req_tx = MX6Q_DMA_REQ_UART3_TX,
+};
+
 static inline void mx6q_sabreauto_init_uart(void)
 {
 	imx6q_add_imx_uart(1, NULL);
-	imx6q_add_imx_uart(2, NULL);
+	imx6q_add_imx_uart(2, &mx6_bt_uart_data);
 	imx6q_add_imx_uart(3, NULL);
 }
 
@@ -340,6 +352,17 @@ static int mx6q_sabreauto_fec_phy_init(struct phy_device *phydev)
 	unsigned short val;
 
 	if (!board_is_mx6_reva()) {
+		/* Ar8031 phy SmartEEE feature cause link status generates
+		 * glitch, which cause ethernet link down/up issue, so
+		 * disable SmartEEE
+		 */
+		phy_write(phydev, 0xd, 0x3);
+		phy_write(phydev, 0xe, 0x805d);
+		phy_write(phydev, 0xd, 0x4003);
+		val = phy_read(phydev, 0xe);
+		val &= ~(0x1 << 8);
+		phy_write(phydev, 0xe, val);
+
 		/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
 		phy_write(phydev, 0xd, 0x7);
 		phy_write(phydev, 0xe, 0x8016);
@@ -387,6 +410,7 @@ static struct fec_platform_data fec_data __initdata = {
 	.init			= mx6q_sabreauto_fec_phy_init,
 	.power_hibernate	= mx6q_sabreauto_fec_power_hibernate,
 	.phy			= PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq		= MX6_ENET_IRQ,
 };
 
 static int mx6q_sabreauto_spi_cs[] = {
@@ -482,20 +506,78 @@ static struct platform_device physmap_flash_device = {
 	.num_resources	= 1,
 };
 
+/* These registers settings are just valid for Numonyx M29W256GL7AN6E. */
 static void mx6q_setup_weimcs(void)
 {
-	unsigned int reg;
 	void __iomem *nor_reg = MX6_IO_ADDRESS(WEIM_BASE_ADDR);
 	void __iomem *ccm_reg = MX6_IO_ADDRESS(CCM_BASE_ADDR);
+	unsigned int reg;
+	struct clk *clk;
+	u32 rate;
 
-	/*CCM_BASE_ADDR + CLKCTL_CCGR6*/
+	/* CLKCTL_CCGR6: Set emi_slow_clock to be on in all modes */
 	reg = readl(ccm_reg + 0x80);
 	reg |= 0x00000C00;
 	writel(reg, ccm_reg + 0x80);
 
-	__raw_writel(0x00620081, nor_reg);
-	__raw_writel(0x1C022000, nor_reg + 0x00000008);
-	__raw_writel(0x0804a240, nor_reg + 0x00000010);
+	/* Timing settings below based upon datasheet for M29W256GL7AN6E
+	   These setting assume that the EIM_SLOW_CLOCK is set to 132 MHz */
+	clk = clk_get(NULL, "emi_slow_clk");
+	if (IS_ERR(clk))
+		printk(KERN_ERR "emi_slow_clk not found\n");
+
+	rate = clk_get_rate(clk);
+	if (rate != 132000000)
+		printk(KERN_ERR "Warning: emi_slow_clk not set to 132 MHz!"
+		       " WEIM NOR timing may be incorrect!\n");
+
+	/*
+	 * For EIM General Configuration registers.
+	 *
+	 * CS0GCR1:
+	 *	GBC = 0; CSREC = 6; DSZ = 2; BL = 0;
+	 *	CREP = 1; CSEN = 1;
+	 *
+	 *	EIM Operation Mode: MUM = SRD = SWR = 0.
+	 *		(Async write/Async page read, none multiplexed)
+	 *
+	 * CS0GCR2:
+	 *	ADH = 1
+	 */
+	writel(0x00620081, nor_reg);
+	writel(0x00000001, nor_reg + 0x00000004);
+
+	/*
+	 * For EIM Read Configuration registers.
+	 *
+	 * CS0RCR1:
+	 *	RWSC = 1C;
+	 *	RADVA = 0; RADVN = 2;
+	 *	OEA = 2; OEN = 0;
+	 *	RCSA = 0; RCSN = 0
+	 *
+	 * CS0RCR2:
+	 *	APR = 1 (Async Page Read);
+	 *	PAT = 4 (6 EIM clock sycles)
+	 */
+	writel(0x1C022000, nor_reg + 0x00000008);
+	writel(0x0000C000, nor_reg + 0x0000000C);
+
+	/*
+	 * For EIM Write Configuration registers.
+	 *
+	 * CS0WCR1:
+	 *	WWSC = 20;
+	 *	WADVA = 0; WADVN = 1;
+	 *	WBEA = 1; WBEN = 2;
+	 *	WEA = 1; WEN = 6;
+	 *	WCSA = 1; WCSN = 2;
+	 *
+	 * CS0WCR2:
+	 *	WBCDD = 0
+	 */
+	writel(0x1404a38e, nor_reg + 0x00000010);
+	writel(0x00000000, nor_reg + 0x00000014);
 }
 
 static int max7310_1_setup(struct i2c_client *client,
@@ -555,6 +637,9 @@ static int max7310_u39_setup(struct i2c_client *client,
 
 	int n;
 
+	if (uart3_en)
+		max7310_gpio_value[4] = 1;
+
 	 for (n = 0; n < ARRAY_SIZE(max7310_gpio_value); ++n) {
 		gpio_request(gpio_base + n, "MAX7310 U39 GPIO Expander");
 		if (max7310_gpio_value[n] < 0)
@@ -612,16 +697,10 @@ static struct pca953x_platform_data max7310_u43_platdata = {
 
 static void adv7180_pwdn(int pwdn)
 {
-	int status = -1;
-
-	status = gpio_request(SABREAUTO_VIDEOIN_PWR, "tvin-pwr");
-
 	if (pwdn)
-		gpio_direction_output(SABREAUTO_VIDEOIN_PWR, 0);
+		gpio_set_value_cansleep(SABREAUTO_VIDEOIN_PWR, 0);
 	else
-		gpio_direction_output(SABREAUTO_VIDEOIN_PWR, 1);
-
-	gpio_free(SABREAUTO_VIDEOIN_PWR);
+		gpio_set_value_cansleep(SABREAUTO_VIDEOIN_PWR, 1);
 }
 
 static void mx6q_csi0_io_init(void)
@@ -643,6 +722,12 @@ static struct fsl_mxc_tvin_platform_data adv7180_data = {
 	.io_init	= mx6q_csi0_io_init,
 };
 
+static void mx6q_mipi_csi1_io_init(void)
+{
+	if (cpu_is_mx6dl())
+		mxc_iomux_set_gpr_register(13, 3, 3, 1);
+}
+
 static struct fsl_mxc_tvin_platform_data adv7280_data = {
 	.dvddio_reg	= NULL,
 	.dvdd_reg	= NULL,
@@ -650,13 +735,16 @@ static struct fsl_mxc_tvin_platform_data adv7280_data = {
 	.pvdd_reg	= NULL,
 	.pwdn		= NULL,
 	.cvbs		= true,
+	.io_init    = mx6q_mipi_csi1_io_init,
+	/* csi slave reg address */
+	.csi_tx_addr = 0x52,
 };
 
 static struct imxi2c_platform_data mx6q_sabreauto_i2c2_data = {
 	.bitrate	= 400000,
 };
 
-static struct imxi2c_platform_data mx6q_sabreauto_i2c1_data = {
+static struct imxi2c_platform_data mx6q_sabreauto_i2c_data = {
 	.bitrate	= 100000,
 };
 
@@ -774,7 +862,6 @@ static void __init imx6q_sabreauto_init_usb(void)
 
 	mxc_iomux_set_gpr_register(1, 13, 1, 0);
 	mx6_set_otghost_vbus_func(imx6q_sabreauto_usbotg_vbus);
-	mx6_usb_dr_init();
 	mx6_set_host1_vbus_func(imx6q_sabreauto_usbhost1_vbus);
 #ifdef CONFIG_USB_EHCI_ARC_HSIC
 	mx6_usb_h2_init();
@@ -835,11 +922,22 @@ static int mx6q_sabreauto_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -847,6 +945,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6q_sabreauto_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -858,6 +957,7 @@ static struct ahci_platform_data mx6q_sabreauto_sata_data = {
 	.init = mx6q_sabreauto_sata_init,
 	.exit = mx6q_sabreauto_sata_exit,
 };
+#endif
 
 static struct imx_asrc_platform_data imx_asrc_data = {
 	.channel_bits	= 4,
@@ -988,10 +1088,10 @@ static struct fsl_mxc_ldb_platform_data ldb_data = {
 static struct imx_ipuv3_platform_data ipu_data[] = {
 	{
 		.rev		= 4,
-		.csi_clk[0]	= "ccm_clk0",
+		.csi_clk[0]	= "clko_clk",
 	}, {
 		.rev		= 4,
-		.csi_clk[0]	= "ccm_clk0",
+		.csi_clk[0]	= "clko_clk",
 	},
 };
 
@@ -1016,6 +1116,15 @@ static int flexcan1_en;
 static void mx6q_flexcan_switch(void)
 {
   if (flexcan0_en || flexcan1_en) {
+	/*
+	 * The transceiver TJA1041A on sabreauto RevE baseboard will
+	 * fail to transit to Normal state if EN/STBY is high by default
+	 * after board power up. So we set the EN/STBY initial state to low
+	 * first then to high to guarantee the state transition successfully.
+	 */
+	gpio_set_value_cansleep(SABREAUTO_CAN_EN, 0);
+	gpio_set_value_cansleep(SABREAUTO_CAN_STBY, 0);
+
 	gpio_set_value_cansleep(SABREAUTO_CAN_EN, 1);
 	gpio_set_value_cansleep(SABREAUTO_CAN_STBY, 1);
 	/* Enable STEER pin if CAN1 interface is required.
@@ -1064,9 +1173,9 @@ static const struct flexcan_platform_data
 
 static struct mipi_csi2_platform_data mipi_csi2_pdata = {
 	.ipu_id		= 0,
-	.csi_id		= 0,
-	.v_channel	= 0,
-	.lanes		= 2,
+	.csi_id		= 1,
+	.v_channel	= 1,
+	.lanes		= 1,
 	.dphy_clk	= "mipi_pllref_clk",
 	.pixel_clk	= "emi_clk",
 };
@@ -1273,9 +1382,8 @@ static struct mxc_mlb_platform_data mx6_sabreauto_mlb150_data = {
 };
 
 static struct mxc_dvfs_platform_data sabreauto_dvfscore_data = {
-	.reg_id			= "cpu_vddgp",
-	.soc_id			= "cpu_vddsoc",
-	.pu_id			= "cpu_vddvpu",
+	.reg_id			= "VDDCORE",
+	.soc_id			= "VDDSOC",
 	.clk1_id		= "cpu_clk",
 	.clk2_id 		= "gpc_dvfs_clk",
 	.gpc_cntr_offset 	= MXC_GPC_CNTR_OFFSET,
@@ -1359,6 +1467,7 @@ static void __init mx6_board_init(void)
 	iomux_v3_cfg_t *tuner_pads = NULL;
 	iomux_v3_cfg_t *spinor_pads = NULL;
 	iomux_v3_cfg_t *weimnor_pads = NULL;
+	iomux_v3_cfg_t *bluetooth_pads = NULL;
 	iomux_v3_cfg_t *extra_pads = NULL;
 
 	int common_pads_cnt;
@@ -1369,6 +1478,7 @@ static void __init mx6_board_init(void)
 	int tuner_pads_cnt;
 	int spinor_pads_cnt;
 	int weimnor_pads_cnt;
+	int bluetooth_pads_cnt;
 	int extra_pads_cnt;
 
 	if (cpu_is_mx6q()) {
@@ -1379,6 +1489,7 @@ static void __init mx6_board_init(void)
 		tuner_pads = mx6q_tuner_pads;
 		spinor_pads = mx6q_spinor_pads;
 		weimnor_pads = mx6q_weimnor_pads;
+		bluetooth_pads = mx6q_bluetooth_pads;
 
 		common_pads_cnt = ARRAY_SIZE(mx6q_sabreauto_pads);
 		can0_pads_cnt = ARRAY_SIZE(mx6q_sabreauto_can0_pads);
@@ -1387,6 +1498,7 @@ static void __init mx6_board_init(void)
 		tuner_pads_cnt = ARRAY_SIZE(mx6q_tuner_pads);
 		spinor_pads_cnt = ARRAY_SIZE(mx6q_spinor_pads);
 		weimnor_pads_cnt = ARRAY_SIZE(mx6q_weimnor_pads);
+		bluetooth_pads_cnt = ARRAY_SIZE(mx6q_bluetooth_pads);
 		if (board_is_mx6_reva()) {
 			i2c3_pads = mx6q_i2c3_pads_rev_a;
 			i2c3_pads_cnt = ARRAY_SIZE(mx6q_i2c3_pads_rev_a);
@@ -1400,6 +1512,18 @@ static void __init mx6_board_init(void)
 			mxc_iomux_v3_setup_multiple_pads(extra_pads,
 					extra_pads_cnt);
 		}
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6Q_PAD_ENET_TXD1__MLB_MLBCLK,
+				MX6Q_PAD_GPIO_6__MLB_MLBSIG,
+				MX6Q_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	} else if (cpu_is_mx6dl()) {
 		common_pads = mx6dl_sabreauto_pads;
 		can0_pads = mx6dl_sabreauto_can0_pads;
@@ -1408,6 +1532,7 @@ static void __init mx6_board_init(void)
 		tuner_pads = mx6dl_tuner_pads;
 		spinor_pads = mx6dl_spinor_pads;
 		weimnor_pads = mx6dl_weimnor_pads;
+		bluetooth_pads = mx6dl_bluetooth_pads;
 
 		common_pads_cnt = ARRAY_SIZE(mx6dl_sabreauto_pads);
 		can0_pads_cnt = ARRAY_SIZE(mx6dl_sabreauto_can0_pads);
@@ -1416,6 +1541,7 @@ static void __init mx6_board_init(void)
 		tuner_pads_cnt = ARRAY_SIZE(mx6dl_tuner_pads);
 		spinor_pads_cnt = ARRAY_SIZE(mx6dl_spinor_pads);
 		weimnor_pads_cnt = ARRAY_SIZE(mx6dl_weimnor_pads);
+		bluetooth_pads_cnt = ARRAY_SIZE(mx6dl_bluetooth_pads);
 
 		if (board_is_mx6_reva()) {
 			i2c3_pads = mx6dl_i2c3_pads_rev_a;
@@ -1430,6 +1556,18 @@ static void __init mx6_board_init(void)
 			mxc_iomux_v3_setup_multiple_pads(extra_pads,
 					extra_pads_cnt);
 		}
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6DL_PAD_ENET_TXD1__MLB_MLBCLK,
+				MX6DL_PAD_GPIO_6__MLB_MLBSIG,
+				MX6DL_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	}
 
 	BUG_ON(!common_pads);
@@ -1450,6 +1588,11 @@ static void __init mx6_board_init(void)
 			mxc_iomux_v3_setup_multiple_pads(i2c3_pads,
 					i2c3_pads_cnt);
 		}
+		if (uart3_en) {
+			BUG_ON(!bluetooth_pads);
+			mxc_iomux_v3_setup_multiple_pads(bluetooth_pads,
+					bluetooth_pads_cnt);
+		}
 	}
 
 	if (can0_enable) {
@@ -1502,7 +1645,6 @@ static void __init mx6_board_init(void)
 
 	gp_reg_id = sabreauto_dvfscore_data.reg_id;
 	soc_reg_id = sabreauto_dvfscore_data.soc_id;
-	pu_reg_id = sabreauto_dvfscore_data.pu_id;
 	mx6q_sabreauto_init_uart();
 	imx6q_add_mipi_csi2(&mipi_csi2_pdata);
 	if (cpu_is_mx6dl()) {
@@ -1538,12 +1680,15 @@ static void __init mx6_board_init(void)
 
 	imx6q_add_imx_caam();
 
-	imx6q_add_imx_i2c(1, &mx6q_sabreauto_i2c1_data);
+	imx6q_add_imx_i2c(1, &mx6q_sabreauto_i2c_data);
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 			ARRAY_SIZE(mxc_i2c1_board_info));
 	imx6q_add_imx_i2c(2, &mx6q_sabreauto_i2c2_data);
 	i2c_register_board_info(2, mxc_i2c2_board_info,
 			ARRAY_SIZE(mxc_i2c2_board_info));
+	if (cpu_is_mx6dl())
+		imx6q_add_imx_i2c(3, &mx6q_sabreauto_i2c_data);
+
 
 	ret = gpio_request(SABREAUTO_PMIC_INT, "pFUZE-int");
 	if (ret) {
@@ -1565,9 +1710,17 @@ static void __init mx6_board_init(void)
 
 	imx6q_add_anatop_thermal_imx(1, &mx6q_sabreauto_anatop_thermal_data);
 
-	if (!can0_enable)
+	if (!can0_enable) {
+		if (enet_to_gpio_6)
+			/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+			mxc_iomux_set_specialbits_register(
+				IOMUX_OBSRV_MUX1_OFFSET,
+				OBSRV_MUX1_ENET_IRQ,
+				OBSRV_MUX1_MASK);
+		else
+			fec_data.gpio_irq = -1;
 		imx6_init_fec(fec_data);
-
+	}
 	imx6q_add_pm_imx(0, &mx6q_sabreauto_pm_data);
 
 	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabreauto_sd3_data);
@@ -1575,12 +1728,17 @@ static void __init mx6_board_init(void)
 
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
 	imx6q_sabreauto_init_usb();
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 		imx6q_add_ahci(0, &mx6q_sabreauto_sata_data);
+#else
+		mx6q_sabreauto_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	imx6q_init_audio();
 	platform_device_register(&sabreauto_vmmc_reg_devices);
-	mx6_cpu_regulator_init();
 	imx_asrc_data.asrc_core_clk = clk_get(NULL, "asrc_clk");
 	imx_asrc_data.asrc_audio_clk = clk_get(NULL, "asrc_serial_clk");
 	imx6q_add_asrc(&imx_asrc_data);
diff --git a/arch/arm/mach-mx6/board-mx6q_sabreauto.h b/arch/arm/mach-mx6/board-mx6q_sabreauto.h
index fee469a..436a11d 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabreauto.h
+++ b/arch/arm/mach-mx6/board-mx6q_sabreauto.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -191,9 +191,7 @@ static iomux_v3_cfg_t mx6q_sabreauto_pads[] = {
 	MX6Q_PAD_GPIO_8__UART2_RXD,
 	MX6Q_PAD_SD4_DAT6__UART2_CTS,
 	MX6Q_PAD_SD4_DAT5__UART2_RTS,
-	/* UART 3 */
-	MX6Q_PAD_SD4_CLK__UART3_TXD,
-	MX6Q_PAD_SD4_CMD__UART3_RXD,
+
 	/*USBs OC pin */
 	MX6Q_PAD_EIM_WAIT__GPIO_5_0,  /*HOST1_OC*/
 	MX6Q_PAD_SD4_DAT0__GPIO_2_8,  /*OTG_OC*/
@@ -209,12 +207,7 @@ static iomux_v3_cfg_t mx6q_sabreauto_pads[] = {
 
 	/* HDMI */
 	MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE,
-
-	/* MLB150 */
-	MX6Q_PAD_ENET_TXD1__MLB_MLBCLK,
-	MX6Q_PAD_GPIO_6__MLB_MLBSIG,
-	MX6Q_PAD_GPIO_2__MLB_MLBDAT,
-};
+ };
 
 static iomux_v3_cfg_t mx6q_sabreauto_can0_pads[] = {
 	/* CAN1 */
@@ -299,6 +292,15 @@ static iomux_v3_cfg_t mx6q_spinor_pads[] __initdata = {
 	MX6Q_PAD_EIM_D19__GPIO_3_19,
 };
 
+/*Bluetooth is conflicted with GMPI and NOR chips*/
+static iomux_v3_cfg_t mx6q_bluetooth_pads[] __initdata = {
+	/* UART 3 */
+	MX6Q_PAD_SD4_CLK__UART3_RXD,
+	MX6Q_PAD_SD4_CMD__UART3_TXD,
+	MX6Q_PAD_EIM_D30__UART3_CTS,
+	MX6Q_PAD_EIM_EB3__UART3_RTS,
+};
+
 static iomux_v3_cfg_t mx6q_weimnor_pads[] __initdata = {
 	/* Parallel NOR */
 	MX6Q_PAD_EIM_OE__WEIM_WEIM_OE,
diff --git a/arch/arm/mach-mx6/board-mx6q_sabrelite.c b/arch/arm/mach-mx6/board-mx6q_sabrelite.c
index eff81ac..1fe0f7b 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabrelite.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -93,6 +93,11 @@
 #define MX6Q_SABRELITE_CSI0_RST		IMX_GPIO_NR(1, 8)
 #define MX6Q_SABRELITE_CSI0_PWN		IMX_GPIO_NR(1, 6)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
+
 #define MX6Q_SABRELITE_SD3_WP_PADCFG	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
@@ -103,10 +108,11 @@ static struct clk *sata_clk;
 extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
+extern bool enet_to_gpio_6;
+static int caam_enabled;
 
 extern struct regulator *(*get_cpu_regulator)(void);
 extern void (*put_cpu_regulator)(void);
-extern void mx6_cpu_regulator_init(void);
 
 static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	/* AUDMUX */
@@ -209,8 +215,8 @@ static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	MX6Q_PAD_EIM_D28__I2C1_SDA,	/* GPIO3[28] */
 
 	/* I2C2 Camera, MIPI */
-	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
-	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,    /* GPIO4[12] */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,    /* GPIO4[13] */
 
 	/* I2C3 */
 	MX6Q_PAD_GPIO_5__I2C3_SCL,	/* GPIO1[5] - J7 - Display card */
@@ -321,7 +327,6 @@ static iomux_v3_cfg_t mx6q_sabrelite_csi0_sensor_pads[] = {
 	MX6Q_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
 	MX6Q_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
 	MX6Q_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
-	MX6Q_PAD_GPIO_6__GPIO_1_6,		/* J5 - Camera GP */
 	MX6Q_PAD_GPIO_8__GPIO_1_8,		/* J5 - Camera Reset */
 	MX6Q_PAD_SD1_DAT0__GPIO_1_16,		/* J5 - Camera GP */
 	MX6Q_PAD_NANDF_D5__GPIO_2_5,		/* J16 - MIPI GP */
@@ -467,6 +472,7 @@ static int mx6q_sabrelite_fec_phy_init(struct phy_device *phydev)
 static struct fec_platform_data fec_data __initdata = {
 	.init = mx6q_sabrelite_fec_phy_init,
 	.phy = PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq = MX6_ENET_IRQ,
 };
 
 static int mx6q_sabrelite_spi_cs[] = {
@@ -632,7 +638,7 @@ static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 		I2C_BOARD_INFO("mxc_hdmi_i2c", 0x50),
 	},
 	{
-		I2C_BOARD_INFO("ov5642", 0x3c),
+		I2C_BOARD_INFO("ov564x", 0x3c),
 		.platform_data = (void *)&camera_data,
 	},
 };
@@ -670,7 +676,6 @@ static void __init imx6q_sabrelite_init_usb(void)
 	mxc_iomux_set_gpr_register(1, 13, 1, 1);
 
 	mx6_set_otghost_vbus_func(imx6q_sabrelite_usbotg_vbus);
-	mx6_usb_dr_init();
 }
 
 /* HW Initialization, if return 0, initialization is successful. */
@@ -722,11 +727,22 @@ static int mx6q_sabrelite_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -734,6 +750,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6q_sabrelite_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -744,6 +761,7 @@ static struct ahci_platform_data mx6q_sabrelite_sata_data = {
 	.init = mx6q_sabrelite_sata_init,
 	.exit = mx6q_sabrelite_sata_exit,
 };
+#endif
 
 static struct gpio mx6q_sabrelite_flexcan_gpios[] = {
 	{ MX6Q_SABRELITE_CAN1_EN, GPIOF_OUT_INIT_LOW, "flexcan1-en" },
@@ -895,6 +913,16 @@ static struct fsl_mxc_capture_platform_data capture_data[] = {
 };
 
 
+struct imx_vout_mem {
+	resource_size_t res_mbase;
+	resource_size_t res_msize;
+};
+
+static struct imx_vout_mem vout_mem __initdata = {
+	.res_msize = SZ_128M,
+};
+
+
 static void sabrelite_suspend_enter(void)
 {
 	/* suspend preparation */
@@ -1115,6 +1143,13 @@ static struct mipi_csi2_platform_data mipi_csi2_pdata = {
 	.pixel_clk = "emi_clk",
 };
 
+static int __init caam_setup(char *__unused)
+{
+	caam_enabled = 1;
+	return 1;
+}
+early_param("caam", caam_setup);
+
 /*!
  * Board specific initialization.
  */
@@ -1125,10 +1160,22 @@ static void __init mx6_sabrelite_board_init(void)
 	struct clk *clko2;
 	struct clk *new_parent;
 	int rate;
+	struct platform_device *voutdev;
 
 	mxc_iomux_v3_setup_multiple_pads(mx6q_sabrelite_pads,
 					ARRAY_SIZE(mx6q_sabrelite_pads));
 
+	if (enet_to_gpio_6) {
+		iomux_v3_cfg_t enet_gpio_pad =
+			MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+		mxc_iomux_v3_setup_pad(enet_gpio_pad);
+	} else {
+		/* J5 - Camera GP */
+		iomux_v3_cfg_t camera_gpio_pad =
+			MX6Q_PAD_GPIO_6__GPIO_1_6;
+		mxc_iomux_v3_setup_pad(camera_gpio_pad);
+	}
+
 #ifdef CONFIG_FEC_1588
 	/* Set GPIO_16 input for IEEE-1588 ts_clk and RMII reference clock
 	 * For MX6 GPR1 bit21 meaning:
@@ -1153,13 +1200,24 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_vdoa();
 	imx6q_add_lcdif(&lcdif_data);
 	imx6q_add_ldb(&ldb_data);
-	imx6q_add_v4l2_output(0);
+	voutdev = imx6q_add_v4l2_output(0);
+	if (vout_mem.res_msize && voutdev) {
+		dma_declare_coherent_memory(&voutdev->dev,
+					    vout_mem.res_mbase,
+					    vout_mem.res_mbase,
+					    vout_mem.res_msize,
+					    (DMA_MEMORY_MAP |
+					     DMA_MEMORY_EXCLUSIVE));
+	}
+
+
 	imx6q_add_v4l2_capture(0, &capture_data[0]);
 	imx6q_add_v4l2_capture(1, &capture_data[1]);
 	imx6q_add_mipi_csi2(&mipi_csi2_pdata);
 	imx6q_add_imx_snvs_rtc();
 
-	imx6q_add_imx_caam();
+	if (1 == caam_enabled)
+		imx6q_add_imx_caam();
 
 	imx6q_add_imx_i2c(0, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabrelite_i2c_data);
@@ -1178,13 +1236,30 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_mxc_hdmi(&hdmi_data);
 
 	imx6q_add_anatop_thermal_imx(1, &mx6q_sabrelite_anatop_thermal_data);
+	if (enet_to_gpio_6)
+		/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+		mxc_iomux_set_specialbits_register(
+			IOMUX_OBSRV_MUX1_OFFSET,
+			OBSRV_MUX1_ENET_IRQ,
+			OBSRV_MUX1_MASK);
+	else
+		fec_data.gpio_irq = -1;
+
 	imx6_init_fec(fec_data);
 	imx6q_add_pm_imx(0, &mx6q_sabrelite_pm_data);
 	imx6q_add_sdhci_usdhc_imx(3, &mx6q_sabrelite_sd4_data);
 	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabrelite_sd3_data);
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
 	imx6q_sabrelite_init_usb();
-	imx6q_add_ahci(0, &mx6q_sabrelite_sata_data);
+
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
+		imx6q_add_ahci(0, &mx6q_sabrelite_sata_data);
+#else
+		mx6q_sabrelite_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	imx6q_init_audio();
 	platform_device_register(&sabrelite_vmmc_reg_devices);
@@ -1207,7 +1282,6 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_dma();
 
 	imx6q_add_dvfs_core(&sabrelite_dvfscore_data);
-	mx6_cpu_regulator_init();
 
 	sabrelite_add_device_buttons();
 
@@ -1260,8 +1334,8 @@ static struct sys_timer mx6_sabrelite_timer = {
 
 static void __init mx6q_sabrelite_reserve(void)
 {
-#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 	phys_addr_t phys;
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 
 	if (imx6q_gpu_pdata.reserved_mem_size) {
 		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
@@ -1270,6 +1344,13 @@ static void __init mx6q_sabrelite_reserve(void)
 		imx6q_gpu_pdata.reserved_mem_base = phys;
 	}
 #endif
+	if (vout_mem.res_msize) {
+		phys = memblock_alloc_base(vout_mem.res_msize,
+					   SZ_4K, SZ_1G);
+		memblock_remove(phys, vout_mem.res_msize);
+		vout_mem.res_mbase = phys;
+	}
+
 }
 
 /*
diff --git a/arch/arm/mach-mx6/board-mx6q_sabresd.c b/arch/arm/mach-mx6/board-mx6q_sabresd.c
index ab24bb4..3f9a845 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabresd.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabresd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -198,18 +198,23 @@
 #define SABRESD_ELAN_RST	IMX_GPIO_NR(3, 8)
 #define SABRESD_ELAN_INT	IMX_GPIO_NR(3, 28)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
+
 static struct clk *sata_clk;
 static struct clk *clko;
 static int mma8451_position = 1;
 static int mag3110_position = 2;
 static int max11801_mode = 1;
-static int enable_lcd_ldb;
-
+static int caam_enabled;
 
 extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
 extern int epdc_enabled;
+extern bool enet_to_gpio_6;
 
 static int max17135_regulator_init(struct max17135 *max17135);
 
@@ -254,6 +259,16 @@ static int mx6q_sabresd_fec_phy_init(struct phy_device *phydev)
 {
 	unsigned short val;
 
+	/* Ar8031 phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, 0xd, 0x3);
+	phy_write(phydev, 0xe, 0x805d);
+	phy_write(phydev, 0xd, 0x4003);
+	val = phy_read(phydev, 0xe);
+	val &= ~(0x1 << 8);
+	phy_write(phydev, 0xe, val);
+
 	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
 	phy_write(phydev, 0xd, 0x7);
 	phy_write(phydev, 0xe, 0x8016);
@@ -282,6 +297,7 @@ static int mx6q_sabresd_fec_phy_init(struct phy_device *phydev)
 static struct fec_platform_data fec_data __initdata = {
 	.init = mx6q_sabresd_fec_phy_init,
 	.phy = PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq = MX6_ENET_IRQ,
 };
 
 static int mx6q_sabresd_spi_cs[] = {
@@ -782,7 +798,7 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 		I2C_BOARD_INFO("wm89**", 0x1a),
 	},
 	{
-		I2C_BOARD_INFO("ov5642", 0x3c),
+		I2C_BOARD_INFO("ov564x", 0x3c),
 		.platform_data = (void *)&camera_data,
 	},
 	{
@@ -1084,6 +1100,14 @@ static void imx6q_sabresd_usbotg_vbus(bool on)
 		gpio_set_value(SABRESD_USB_OTG_PWR, 0);
 }
 
+static void imx6q_sabresd_host1_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(SABRESD_USB_H1_PWR, 1);
+	else
+		gpio_set_value(SABRESD_USB_H1_PWR, 0);
+}
+
 static void __init imx6q_sabresd_init_usb(void)
 {
 	int ret = 0;
@@ -1106,14 +1130,15 @@ static void __init imx6q_sabresd_init_usb(void)
 			ret);
 		return;
 	}
-	gpio_direction_output(SABRESD_USB_H1_PWR, 1);
+	gpio_direction_output(SABRESD_USB_H1_PWR, 0);
 	if (board_is_mx6_reva())
 		mxc_iomux_set_gpr_register(1, 13, 1, 1);
 	else
 		mxc_iomux_set_gpr_register(1, 13, 1, 0);
 
 	mx6_set_otghost_vbus_func(imx6q_sabresd_usbotg_vbus);
-	mx6_usb_dr_init();
+	mx6_set_host1_vbus_func(imx6q_sabresd_host1_vbus);
+
 }
 
 /* HW Initialization, if return 0, initialization is successful. */
@@ -1165,11 +1190,22 @@ static int mx6q_sabresd_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -1177,6 +1213,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6q_sabresd_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -1187,6 +1224,7 @@ static struct ahci_platform_data mx6q_sabresd_sata_data = {
 	.init = mx6q_sabresd_sata_init,
 	.exit = mx6q_sabresd_sata_exit,
 };
+#endif
 
 static void mx6q_sabresd_flexcan0_switch(int enable)
 {
@@ -1317,6 +1355,8 @@ static struct fsl_mxc_hdmi_platform_data hdmi_data = {
 	.init = hdmi_init,
 	.enable_pins = hdmi_enable_ddc_pin,
 	.disable_pins = hdmi_disable_ddc_pin,
+	.phy_reg_vlev = 0x0294,
+	.phy_reg_cksymtx = 0x800d,
 };
 
 static struct fsl_mxc_hdmi_core_platform_data hdmi_core_data = {
@@ -1332,11 +1372,11 @@ static struct fsl_mxc_lcd_platform_data lcdif_data = {
 
 static struct fsl_mxc_ldb_platform_data ldb_data = {
 	.ipu_id = 1,
-	.disp_id = 0,
+	.disp_id = 1,
 	.ext_ref = 1,
-	.mode = LDB_SEP0,
+	.mode = LDB_SEP1,
 	.sec_ipu_id = 1,
-	.sec_disp_id = 1,
+	.sec_disp_id = 0,
 };
 
 static struct max8903_pdata charger1_data = {
@@ -1384,6 +1424,15 @@ static struct fsl_mxc_capture_platform_data capture_data[] = {
 };
 
 
+struct imx_vout_mem {
+	resource_size_t res_mbase;
+	resource_size_t res_msize;
+};
+
+static struct imx_vout_mem vout_mem __initdata = {
+	.res_msize = SZ_128M,
+};
+
 static void sabresd_suspend_enter(void)
 {
 	/* suspend preparation */
@@ -1586,14 +1635,8 @@ static struct platform_pwm_backlight_data mx6_sabresd_pwm_backlight_data = {
 };
 
 static struct mxc_dvfs_platform_data sabresd_dvfscore_data = {
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.reg_id = "VDDCORE",
 	.soc_id	= "VDDSOC",
-#else
-	.reg_id = "cpu_vddgp",
-	.soc_id = "cpu_vddsoc",
-	.pu_id = "cpu_vddvpu",
-#endif
 	.clk1_id = "cpu_clk",
 	.clk2_id = "gpc_dvfs_clk",
 	.gpc_cntr_offset = MXC_GPC_CNTR_OFFSET,
@@ -1629,6 +1672,13 @@ static struct mipi_csi2_platform_data mipi_csi2_pdata = {
 	.pixel_clk = "emi_clk",
 };
 
+static int __init caam_setup(char *__unused)
+{
+	caam_enabled = 1;
+	return 1;
+}
+early_param("caam", caam_setup);
+
 #define SNVS_LPCR 0x38
 static void mx6_snvs_poweroff(void)
 {
@@ -1645,15 +1695,13 @@ static const struct imx_pcie_platform_data mx6_sabresd_pcie_data __initconst = {
 	.pcie_rst	= SABRESD_PCIE_RST_B_REVB,
 	.pcie_wake_up	= SABRESD_PCIE_WAKE_B,
 	.pcie_dis	= SABRESD_PCIE_DIS_B,
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+	.type_ep	= 1,
+#else
+	.type_ep	= 0,
+#endif
 };
 
-static int __init early_enable_lcd_ldb(char *p)
-{
-	enable_lcd_ldb = 1;
-	return 0;
-}
-early_param("enable_lcd_ldb", early_enable_lcd_ldb);
-
 /*!
  * Board specific initialization.
  */
@@ -1664,15 +1712,36 @@ static void __init mx6_sabresd_board_init(void)
 	struct clk *clko, *clko2;
 	struct clk *new_parent;
 	int rate;
+	struct platform_device *voutdev;
 
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
 		mxc_iomux_v3_setup_multiple_pads(mx6q_sabresd_pads,
 			ARRAY_SIZE(mx6q_sabresd_pads));
-	else if (cpu_is_mx6dl()) {
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t i2c3_pad =
+				MX6Q_PAD_GPIO_6__I2C3_SDA;
+			mxc_iomux_v3_setup_pad(i2c3_pad);
+		}
+	} else if (cpu_is_mx6dl()) {
 		mxc_iomux_v3_setup_multiple_pads(mx6dl_sabresd_pads,
 			ARRAY_SIZE(mx6dl_sabresd_pads));
+
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t i2c3_pad =
+				MX6DL_PAD_GPIO_6__I2C3_SDA;
+			mxc_iomux_v3_setup_pad(i2c3_pad);
+		}
 	}
 
+
 #ifdef CONFIG_FEC_1588
 	/* Set GPIO_16 input for IEEE-1588 ts_clk and RMII reference clock
 	 * For MX6 GPR1 bit21 meaning:
@@ -1684,7 +1753,6 @@ static void __init mx6_sabresd_board_init(void)
 
 	gp_reg_id = sabresd_dvfscore_data.reg_id;
 	soc_reg_id = sabresd_dvfscore_data.soc_id;
-	pu_reg_id = sabresd_dvfscore_data.pu_id;
 	mx6q_sabresd_init_uart();
 
 	/*
@@ -1696,16 +1764,7 @@ static void __init mx6_sabresd_board_init(void)
 	 */
 	if (cpu_is_mx6dl()) {
 		ldb_data.ipu_id = 0;
-		ldb_data.disp_id = 0;
 		ldb_data.sec_ipu_id = 0;
-		ldb_data.sec_disp_id = 1;
-		hdmi_core_data.disp_id = 1;
-		mipi_dsi_pdata.ipu_id = 0;
-		mipi_dsi_pdata.disp_id = 1;
-		if (enable_lcd_ldb) {
-			ldb_data.disp_id = 1;
-			ldb_data.mode = LDB_SIN1;
-		}
 	}
 	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
 
@@ -1722,13 +1781,23 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_mipi_dsi(&mipi_dsi_pdata);
 	imx6q_add_lcdif(&lcdif_data);
 	imx6q_add_ldb(&ldb_data);
-	imx6q_add_v4l2_output(0);
+	voutdev = imx6q_add_v4l2_output(0);
+	if (vout_mem.res_msize && voutdev) {
+		dma_declare_coherent_memory(&voutdev->dev,
+					    vout_mem.res_mbase,
+					    vout_mem.res_mbase,
+					    vout_mem.res_msize,
+					    (DMA_MEMORY_MAP |
+					     DMA_MEMORY_EXCLUSIVE));
+	}
+
 	imx6q_add_v4l2_capture(0, &capture_data[0]);
 	imx6q_add_v4l2_capture(1, &capture_data[1]);
 	imx6q_add_mipi_csi2(&mipi_csi2_pdata);
 	imx6q_add_imx_snvs_rtc();
 
-	imx6q_add_imx_caam();
+	if (1 == caam_enabled)
+		imx6q_add_imx_caam();
 
 	if (board_is_mx6_reva()) {
 		strcpy(mxc_i2c0_board_info[0].type, "wm8958");
@@ -1742,6 +1811,8 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_imx_i2c(0, &mx6q_sabresd_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabresd_i2c_data);
 	imx6q_add_imx_i2c(2, &mx6q_sabresd_i2c_data);
+	if (cpu_is_mx6dl())
+		imx6q_add_imx_i2c(3, &mx6q_sabresd_i2c_data);
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 			ARRAY_SIZE(mxc_i2c0_board_info));
 	i2c_register_board_info(1, mxc_i2c1_board_info,
@@ -1763,7 +1834,17 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_mxc_hdmi(&hdmi_data);
 
 	imx6q_add_anatop_thermal_imx(1, &mx6q_sabresd_anatop_thermal_data);
+
+	if (enet_to_gpio_6)
+		/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+		mxc_iomux_set_specialbits_register(
+			IOMUX_OBSRV_MUX1_OFFSET,
+			OBSRV_MUX1_ENET_IRQ,
+			OBSRV_MUX1_MASK);
+	else
+		fec_data.gpio_irq = -1;
 	imx6_init_fec(fec_data);
+
 	imx6q_add_pm_imx(0, &mx6q_sabresd_pm_data);
 
 	/* Move sd4 to first because sd4 connect to emmc.
@@ -1775,8 +1856,14 @@ static void __init mx6_sabresd_board_init(void)
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
 	imx6q_sabresd_init_usb();
 	/* SATA is not supported by MX6DL/Solo */
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 		imx6q_add_ahci(0, &mx6q_sabresd_sata_data);
+#else
+		mx6q_sabresd_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	imx6q_init_audio();
 	platform_device_register(&sabresd_vmmc_reg_devices);
@@ -1807,9 +1894,6 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_dma();
 
 	imx6q_add_dvfs_core(&sabresd_dvfscore_data);
-#ifndef CONFIG_MX6_INTER_LDO_BYPASS
-	mx6_cpu_regulator_init();
-#endif
 	imx6q_add_device_buttons();
 
 	/* enable sensor 3v3 and 1v8 */
@@ -1927,8 +2011,8 @@ static struct sys_timer mx6_sabresd_timer = {
 
 static void __init mx6q_sabresd_reserve(void)
 {
-#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 	phys_addr_t phys;
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 
 	if (imx6q_gpu_pdata.reserved_mem_size) {
 		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
@@ -1937,6 +2021,13 @@ static void __init mx6q_sabresd_reserve(void)
 		imx6q_gpu_pdata.reserved_mem_base = phys;
 	}
 #endif
+
+	if (vout_mem.res_msize) {
+		phys = memblock_alloc_base(vout_mem.res_msize,
+					   SZ_4K, SZ_1G);
+		memblock_remove(phys, vout_mem.res_msize);
+		vout_mem.res_mbase = phys;
+	}
 }
 
 /*
diff --git a/arch/arm/mach-mx6/board-mx6q_sabresd.h b/arch/arm/mach-mx6/board-mx6q_sabresd.h
index da26cd9..adb2e3e 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabresd.h
+++ b/arch/arm/mach-mx6/board-mx6q_sabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -30,7 +30,7 @@ static iomux_v3_cfg_t mx6q_sabresd_pads[] = {
 	/* CAN1  */
 	MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
 	/* MX6Q_PAD_KEY_COL2__CAN1_TXCAN, */
-	MX6Q_PAD_GPIO_1__GPIO_1_1,		/* user defiend green led */
+	MX6Q_PAD_GPIO_1__WDOG2_WDOG_B,		/*WDOG_B to reset pmic*/
 	MX6Q_PAD_GPIO_2__GPIO_1_2,		/* user defined red led */
 	MX6Q_PAD_GPIO_7__GPIO_1_7,		/* NERR */
 
@@ -132,9 +132,8 @@ static iomux_v3_cfg_t mx6q_sabresd_pads[] = {
 	MX6Q_PAD_KEY_COL3__I2C2_SCL,
 	MX6Q_PAD_KEY_ROW3__I2C2_SDA,
 
-	/* I2C3 */
-	MX6Q_PAD_GPIO_3__I2C3_SCL,	/* GPIO1[3] */
-	MX6Q_PAD_GPIO_6__I2C3_SDA,
+	/*I2C3 */
+	MX6Q_PAD_GPIO_3__I2C3_SCL,
 
 	/* DISPLAY */
 	MX6Q_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
diff --git a/arch/arm/mach-mx6/board-mx6sl_arm2.c b/arch/arm/mach-mx6/board-mx6sl_arm2.c
index 477ea8c..63fd579 100755
--- a/arch/arm/mach-mx6/board-mx6sl_arm2.c
+++ b/arch/arm/mach-mx6/board-mx6sl_arm2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -75,6 +75,8 @@
 static int spdc_sel;
 static int max17135_regulator_init(struct max17135 *max17135);
 static struct clk *extern_audio_root;
+static void mx6sl_suspend_enter(void);
+static void mx6sl_suspend_exit(void);
 
 extern char *gp_reg_id;
 extern char *soc_reg_id;
@@ -313,13 +315,13 @@ static struct platform_device max17135_sensor_device = {
 
 static struct max17135_platform_data max17135_pdata __initdata = {
 	.vneg_pwrup = 1,
-	.gvee_pwrup = 1,
-	.vpos_pwrup = 2,
-	.gvdd_pwrup = 1,
+	.gvee_pwrup = 2,
+	.vpos_pwrup = 10,
+	.gvdd_pwrup = 12,
 	.gvdd_pwrdn = 1,
 	.vpos_pwrdn = 2,
-	.gvee_pwrdn = 1,
-	.vneg_pwrdn = 1,
+	.gvee_pwrdn = 8,
+	.vneg_pwrdn = 10,
 	.gpio_pmic_pwrgood = MX6SL_BRD_EPDC_PWRSTAT,
 	.gpio_pmic_vcom_ctrl = MX6SL_BRD_EPDC_VCOM,
 	.gpio_pmic_wakeup = MX6SL_BRD_EPDC_PMIC_WAKE,
@@ -482,8 +484,8 @@ static int mxc_wm8962_init(void)
 
 	clk_set_parent(extern_audio_root, pll4);
 
-	rate = clk_round_rate(extern_audio_root, 26000000);
-	clk_set_rate(extern_audio_root, rate);
+	rate = 24000000;
+	clk_set_rate(extern_audio_root, 24000000);
 
 	wm8962_data.sysclk = rate;
 
@@ -580,14 +582,8 @@ static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
 };
 
 static struct mxc_dvfs_platform_data mx6sl_arm2_dvfscore_data = {
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.reg_id			= "VDDCORE",
 	.soc_id			= "VDDSOC",
-#else
-	.reg_id			= "cpu_vddgp",
-	.soc_id			= "cpu_vddsoc",
-	.pu_id			= "cpu_vddvpu",
-#endif
 	.clk1_id		= "cpu_clk",
 	.clk2_id		= "gpc_dvfs_clk",
 	.gpc_cntr_offset	= MXC_GPC_CNTR_OFFSET,
@@ -623,7 +619,6 @@ static inline void mx6_arm2_init_uart(void)
 static int mx6sl_arm2_fec_phy_init(struct phy_device *phydev)
 {
 	int val;
-
 	/* power on FEC phy and reset phy */
 	gpio_request(MX6_BRD_FEC_PWR_EN, "fec-pwr");
 	gpio_direction_output(MX6_BRD_FEC_PWR_EN, 0);
@@ -636,7 +631,6 @@ static int mx6sl_arm2_fec_phy_init(struct phy_device *phydev)
 	if (val & BMCR_PDOWN) {
 		phy_write(phydev, 0x0, (val & ~BMCR_PDOWN));
 	}
-
 	return 0;
 }
 
@@ -728,8 +722,6 @@ static void epdc_enable_pins(void)
 
 static void epdc_disable_pins(void)
 {
-	/* Configure MUX settings for EPDC pins to
-	 * GPIO and drive to 0. */
 	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_epdc_disable_pads, \
 				ARRAY_SIZE(mx6sl_brd_epdc_disable_pads));
 
@@ -970,7 +962,7 @@ static void spdc_enable_pins(void)
 
 static void spdc_disable_pins(void)
 {
-	/* Configure MUX settings for SPDC pins to
+	/* Configure MUX settings for EPDC pins to
 	 * GPIO and drive to 0. */
 	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_spdc_disable_pads, \
 				ARRAY_SIZE(mx6sl_brd_spdc_disable_pads));
@@ -1081,7 +1073,6 @@ static void __init mx6_arm2_init_usb(void)
 	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 1);
 
 	mx6_set_otghost_vbus_func(imx6_arm2_usbotg_vbus);
-	mx6_usb_dr_init();
 #ifdef CONFIG_USB_EHCI_ARC_HSIC
 	mxc_iomux_set_specialbits_register(MX6SL_PAD_HSIC_DAT,
 		PAD_CTL_DDR_SEL_DDR3, PAD_CTL_DDR_SEL_MASK);
@@ -1101,7 +1092,7 @@ static struct platform_pwm_backlight_data mx6_arm2_pwm_backlight_data = {
 static struct fb_videomode video_modes[] = {
 	{
 	 /* 800x480 @ 57 Hz , pixel clk @ 32MHz */
-	 "SEIKO-WVGA", 60, 800, 480, 29850, 99, 164, 33, 10, 10, 10,
+	 "SEIKO-WVGA", 60, 800, 480, 29850, 89, 164, 23, 10, 10, 10,
 	 FB_SYNC_CLK_LAT_FALL,
 	 FB_VMODE_NONINTERLACED,
 	 0,},
@@ -1120,6 +1111,12 @@ static struct platform_device lcd_wvga_device = {
 	.name = "lcd_seiko",
 };
 
+static const struct pm_platform_data mx6sl_arm2_pm_data __initconst = {
+	.name		= "imx_pm",
+	.suspend_enter = mx6sl_suspend_enter,
+	.suspend_exit = mx6sl_suspend_exit,
+};
+
 static int mx6sl_arm2_keymap[] = {
 	KEY(0, 0, KEY_SELECT),
 	KEY(0, 1, KEY_BACK),
@@ -1178,6 +1175,33 @@ static void mx6_snvs_poweroff(void)
 	writel(value | 0x60, mx6_snvs_base + SNVS_LPCR);
 }
 
+static void mx6sl_suspend_enter()
+{
+	iomux_v3_cfg_t *p = suspend_enter_pads;
+	int i;
+
+	/* Set PADCTRL to 0 for all IOMUX. */
+	for (i = 0; i < ARRAY_SIZE(suspend_enter_pads); i++) {
+		suspend_exit_pads[i] = *p;
+		*p &= ~MUX_PAD_CTRL_MASK;
+		/* Enable the Pull down and the keeper
+		  * Set the drive strength to 0.
+		  */
+		*p |= ((u64)0x3000 << MUX_PAD_CTRL_SHIFT);
+		p++;
+	}
+	mxc_iomux_v3_get_multiple_pads(suspend_exit_pads,
+			ARRAY_SIZE(suspend_exit_pads));
+	mxc_iomux_v3_setup_multiple_pads(suspend_enter_pads,
+			ARRAY_SIZE(suspend_enter_pads));
+}
+
+static void mx6sl_suspend_exit()
+{
+	mxc_iomux_v3_setup_multiple_pads(suspend_exit_pads,
+			ARRAY_SIZE(suspend_exit_pads));
+}
+
 /*!
  * Board specific initialization.
  */
@@ -1188,15 +1212,8 @@ static void __init mx6_arm2_init(void)
 
 	elan_ts_init();
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	gp_reg_id = mx6sl_arm2_dvfscore_data.reg_id;
-	soc_reg_id = mx6sl_arm2_dvfscore_data.soc_id;
-#else
 	gp_reg_id = mx6sl_arm2_dvfscore_data.reg_id;
 	soc_reg_id = mx6sl_arm2_dvfscore_data.soc_id;
-	pu_reg_id = mx6sl_arm2_dvfscore_data.pu_id;
-	mx6_cpu_regulator_init();
-#endif
 
 	imx6q_add_imx_snvs_rtc();
 
@@ -1267,6 +1284,7 @@ static void __init mx6_arm2_init(void)
 	imx6q_add_perfmon(0);
 	imx6q_add_perfmon(1);
 	imx6q_add_perfmon(2);
+	imx6q_add_pm_imx(0, &mx6sl_arm2_pm_data);
 
 	pm_power_off = mx6_snvs_poweroff;
 }
diff --git a/arch/arm/mach-mx6/board-mx6sl_common.h b/arch/arm/mach-mx6/board-mx6sl_common.h
index c432e0a..897099f 100644
--- a/arch/arm/mach-mx6/board-mx6sl_common.h
+++ b/arch/arm/mach-mx6/board-mx6sl_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -85,6 +85,8 @@
 /* CSI */
 #define MX6SL_BRD_CSI_PWDN		IMX_GPIO_NR(1, 25)
 #define MX6SL_BRD_CSI_RST		IMX_GPIO_NR(1, 26)
+/* bt */
+#define MX6SL_BRD_BT_RESET		IMX_GPIO_NR(5, 11)
 
 static iomux_v3_cfg_t mx6sl_brd_pads[] = {
 
@@ -395,6 +397,114 @@ static iomux_v3_cfg_t mx6sl_brd_elan_pads[] = {
 	MX6SL_PAD_KEY_COL6__GPIO_4_4,		/* RST */
 };
 
+static iomux_v3_cfg_t suspend_enter_pads[] = {
+	/* Audio pads. */
+	MX6SL_PAD_AUD_MCLK__GPIO_1_6,
+	MX6SL_PAD_AUD_RXC__GPIO_1_1,
+	MX6SL_PAD_AUD_RXD__GPIO_1_2,
+	MX6SL_PAD_AUD_RXFS__GPIO_1_0,
+	MX6SL_PAD_AUD_TXC__GPIO_1_3,
+	MX6SL_PAD_AUD_TXD__GPIO_1_5,
+	MX6SL_PAD_AUD_TXFS__GPIO_1_4,
+	/* ECSPI pads. */
+	MX6SL_PAD_ECSPI1_MISO__GPIO_4_10,
+	MX6SL_PAD_ECSPI1_MOSI__GPIO_4_9,
+	MX6SL_PAD_ECSPI1_SCLK__GPIO_4_8,
+	MX6SL_PAD_ECSPI1_SS0__GPIO_4_11,
+	MX6SL_PAD_ECSPI2_SCLK__GPIO_4_12,
+	/* FEC pad*/
+	MX6SL_PAD_FEC_CRS_DV__GPIO_4_25,
+	MX6SL_PAD_FEC_MDC__GPIO_4_23,
+	MX6SL_PAD_FEC_MDIO__GPIO_4_20,
+	MX6SL_PAD_FEC_REF_CLK__GPIO_4_26,
+	MX6SL_PAD_FEC_RXD0__GPIO_4_17,
+	MX6SL_PAD_FEC_RXD1__GPIO_4_18,
+	MX6SL_PAD_FEC_TXD0__GPIO_4_24,
+	MX6SL_PAD_FEC_TXD1__GPIO_4_16,
+	MX6SL_PAD_FEC_TX_CLK__GPIO_4_21,
+	MX6SL_PAD_FEC_TX_EN__GPIO_4_22,
+	/* I2C pads */
+	MX6SL_PAD_I2C1_SCL__GPIO_3_12,
+	MX6SL_PAD_I2C1_SDA__GPIO_3_13,
+	MX6SL_PAD_I2C2_SCL__GPIO_3_14,
+	MX6SL_PAD_I2C2_SDA__GPIO_3_15,
+	/* LCD pads*/
+	MX6SL_PAD_LCD_CLK__GPIO_2_15,
+	MX6SL_PAD_LCD_DAT0__GPIO_2_20,
+	MX6SL_PAD_LCD_DAT1__GPIO_2_21,
+	MX6SL_PAD_LCD_DAT2__GPIO_2_22,
+	MX6SL_PAD_LCD_DAT3__GPIO_2_23,
+	MX6SL_PAD_LCD_DAT4__GPIO_2_24,
+	MX6SL_PAD_LCD_DAT5__GPIO_2_25,
+	MX6SL_PAD_LCD_DAT10__GPIO_2_30,
+	MX6SL_PAD_LCD_DAT11__GPIO_2_31,
+	MX6SL_PAD_LCD_DAT12__GPIO_3_0,
+	MX6SL_PAD_LCD_DAT13__GPIO_3_1,
+	MX6SL_PAD_LCD_DAT14__GPIO_3_2,
+	MX6SL_PAD_LCD_DAT15__GPIO_3_3,
+	MX6SL_PAD_LCD_DAT16__GPIO_3_4,
+	MX6SL_PAD_LCD_DAT17__GPIO_3_5,
+	MX6SL_PAD_LCD_DAT18__GPIO_3_6,
+	MX6SL_PAD_LCD_DAT19__GPIO_3_7,
+	MX6SL_PAD_LCD_DAT20__GPIO_3_8,
+	MX6SL_PAD_LCD_DAT21__GPIO_3_9,
+	MX6SL_PAD_LCD_DAT22__GPIO_3_10,
+	MX6SL_PAD_LCD_DAT23__GPIO_3_11,
+	/* PWM pads */
+	MX6SL_PAD_PWM1__GPIO_3_23,
+	/* SD pads. */
+	MX6SL_PAD_SD1_CLK__GPIO_5_15,
+	MX6SL_PAD_SD1_CMD__GPIO_5_14,
+	MX6SL_PAD_SD1_DAT0__GPIO_5_11,
+	MX6SL_PAD_SD1_DAT1__GPIO_5_8,
+	MX6SL_PAD_SD1_DAT2__GPIO_5_13,
+	MX6SL_PAD_SD1_DAT3__GPIO_5_6,
+	MX6SL_PAD_SD1_DAT4__GPIO_5_12,
+	MX6SL_PAD_SD1_DAT5__GPIO_5_9,
+	MX6SL_PAD_SD1_DAT6__GPIO_5_7,
+	MX6SL_PAD_SD1_DAT7__GPIO_5_10,
+
+	MX6SL_PAD_SD2_CLK__GPIO_5_5,
+	MX6SL_PAD_SD2_CMD__GPIO_5_4,
+	MX6SL_PAD_SD2_DAT0__GPIO_5_1,
+	MX6SL_PAD_SD2_DAT1__GPIO_4_30,
+	MX6SL_PAD_SD2_DAT2__GPIO_5_3,
+	MX6SL_PAD_SD2_DAT3__GPIO_4_28,
+	MX6SL_PAD_SD2_DAT4__GPIO_5_2,
+	MX6SL_PAD_SD2_DAT5__GPIO_4_31,
+
+	MX6SL_PAD_SD3_CLK__GPIO_5_18,
+	MX6SL_PAD_SD3_CMD__GPIO_5_21,
+	MX6SL_PAD_SD3_DAT0__GPIO_5_19,
+	MX6SL_PAD_SD3_DAT1__GPIO_5_20,
+	MX6SL_PAD_SD3_DAT2__GPIO_5_16,
+	MX6SL_PAD_SD3_DAT3__GPIO_5_17,
+
+	/* USBOTG ID pin */
+#ifndef CONFIG_USB_ID_WAKEUP_ENABLE
+	MX6SL_PAD_EPDC_PWRCOM__GPIO_2_11,
+#endif
+	MX6SL_PAD_HSIC_STROBE__GPIO_3_20,
+	MX6SL_PAD_HSIC_DAT__GPIO_3_19,
+
+	/* Key row/column */
+	MX6SL_PAD_KEY_COL0__GPIO_3_24,
+	MX6SL_PAD_KEY_COL1__GPIO_3_26,
+	MX6SL_PAD_KEY_COL2__GPIO_3_28,
+	MX6SL_PAD_KEY_COL3__GPIO_3_30,
+	MX6SL_PAD_KEY_COL6__GPIO_4_4,
+	MX6SL_PAD_KEY_COL7__GPIO_4_6,
+	MX6SL_PAD_KEY_ROW0__GPIO_3_25,
+	MX6SL_PAD_KEY_ROW1__GPIO_3_27,
+	MX6SL_PAD_KEY_ROW2__GPIO_3_29,
+	MX6SL_PAD_KEY_ROW3__GPIO_3_31,
+	MX6SL_PAD_KEY_ROW4__GPIO_4_1,
+	MX6SL_PAD_KEY_ROW5__GPIO_4_3,
+	MX6SL_PAD_KEY_ROW6__GPIO_4_5,
+};
+
+static iomux_v3_cfg_t suspend_exit_pads[ARRAY_SIZE(suspend_enter_pads)];
+
 #define MX6SL_USDHC_8BIT_PAD_SETTING(id, speed)	\
 mx6sl_sd##id##_##speed##mhz[] = {		\
 	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
diff --git a/arch/arm/mach-mx6/board-mx6sl_evk.c b/arch/arm/mach-mx6/board-mx6sl_evk.c
index 4c9c4d3..082845b 100644
--- a/arch/arm/mach-mx6/board-mx6sl_evk.c
+++ b/arch/arm/mach-mx6/board-mx6sl_evk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -61,6 +61,7 @@
 #include <mach/iomux-mx6sl.h>
 #include <mach/imx-uart.h>
 #include <mach/viv_gpu.h>
+#include <mach/imx_rfkill.h>
 
 #include <asm/irq.h>
 #include <asm/setup.h>
@@ -77,6 +78,9 @@
 
 static int spdc_sel;
 static int max17135_regulator_init(struct max17135 *max17135);
+static void mx6sl_evk_suspend_enter(void);
+static void mx6sl_evk_suspend_exit(void);
+
 struct clk *extern_audio_root;
 
 extern char *gp_reg_id;
@@ -86,6 +90,8 @@ extern int __init mx6sl_evk_init_pfuze100(u32 int_gpio);
 
 static int csi_enabled;
 
+#define SXSDMAN_BLUETOOTH_ENABLE
+
 static iomux_v3_cfg_t mx6sl_brd_csi_enable_pads[] = {
 	MX6SL_PAD_EPDC_GDRL__CSI_MCLK,
 	MX6SL_PAD_EPDC_SDCE3__I2C3_SDA,
@@ -108,6 +114,16 @@ static iomux_v3_cfg_t mx6sl_brd_csi_enable_pads[] = {
 	MX6SL_PAD_EPDC_SDOE__GPIO_1_25,		/* CMOS_PWDN GPIO */
 };
 
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+static iomux_v3_cfg_t mx6sl_uart4_pads[] = {
+	MX6SL_PAD_SD1_DAT4__UART4_RXD,
+	MX6SL_PAD_SD1_DAT5__UART4_TXD,
+	MX6SL_PAD_SD1_DAT6__UART4_RTS,
+	MX6SL_PAD_SD1_DAT7__UART4_CTS,
+	/* gpio for reset */
+	MX6SL_PAD_SD1_DAT0__GPIO_5_11,
+};
+#else
 /* uart2 pins */
 static iomux_v3_cfg_t mx6sl_uart2_pads[] = {
 	MX6SL_PAD_SD2_DAT5__UART2_TXD,
@@ -115,6 +131,7 @@ static iomux_v3_cfg_t mx6sl_uart2_pads[] = {
 	MX6SL_PAD_SD2_DAT6__UART2_RTS,
 	MX6SL_PAD_SD2_DAT7__UART2_CTS,
 };
+#endif
 
 enum sd_pad_mode {
 	SD_PAD_MODE_LOW_SPEED,
@@ -122,6 +139,12 @@ enum sd_pad_mode {
 	SD_PAD_MODE_HIGH_SPEED,
 };
 
+static const struct pm_platform_data mx6sl_evk_pm_data __initconst = {
+	.name		= "imx_pm",
+	.suspend_enter = mx6sl_evk_suspend_enter,
+	.suspend_exit = mx6sl_evk_suspend_exit,
+};
+
 static int __init csi_setup(char *__unused)
 {
 	csi_enabled = 1;
@@ -355,13 +378,13 @@ static struct platform_device max17135_sensor_device = {
 
 static struct max17135_platform_data max17135_pdata __initdata = {
 	.vneg_pwrup = 1,
-	.gvee_pwrup = 1,
-	.vpos_pwrup = 2,
-	.gvdd_pwrup = 1,
+	.gvee_pwrup = 2,
+	.vpos_pwrup = 10,
+	.gvdd_pwrup = 12,
 	.gvdd_pwrdn = 1,
 	.vpos_pwrdn = 2,
-	.gvee_pwrdn = 1,
-	.vneg_pwrdn = 1,
+	.gvee_pwrdn = 8,
+	.vneg_pwrdn = 10,
 	.gpio_pmic_pwrgood = MX6SL_BRD_EPDC_PWRSTAT,
 	.gpio_pmic_vcom_ctrl = MX6SL_BRD_EPDC_VCOM,
 	.gpio_pmic_wakeup = MX6SL_BRD_EPDC_PMIC_WAKE,
@@ -524,8 +547,8 @@ static int mxc_wm8962_init(void)
 
 	clk_set_parent(extern_audio_root, pll4);
 
-	rate = clk_round_rate(extern_audio_root, 26000000);
-	clk_set_rate(extern_audio_root, rate);
+	rate = 24000000;
+	clk_set_rate(extern_audio_root, 24000000);
 
 	wm8962_data.sysclk = rate;
 	/* set AUDMUX pads to 1.8v */
@@ -749,14 +772,8 @@ static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
 };
 
 static struct mxc_dvfs_platform_data mx6sl_evk_dvfscore_data = {
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.reg_id			= "VDDCORE",
 	.soc_id			= "VDDSOC",
-#else
-	.reg_id			= "cpu_vddgp",
-	.soc_id			= "cpu_vddsoc",
-	.pu_id			= "cpu_vddvpu",
-#endif
 	.clk1_id		= "cpu_clk",
 	.clk2_id		= "gpc_dvfs_clk",
 	.gpc_cntr_offset	= MXC_GPC_CNTR_OFFSET,
@@ -784,11 +801,19 @@ static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
 
 void __init early_console_setup(unsigned long base, struct clk *clk);
 
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+static const struct imxuart_platform_data mx6sl_evk_uart4_data __initconst = {
+	.flags      = IMXUART_HAVE_RTSCTS,
+	.dma_req_rx = MX6Q_DMA_REQ_UART4_RX,
+	.dma_req_tx = MX6Q_DMA_REQ_UART4_TX,
+};
+#else
 static const struct imxuart_platform_data mx6sl_evk_uart1_data __initconst = {
 	.flags      = IMXUART_HAVE_RTSCTS | IMXUART_SDMA,
 	.dma_req_rx = MX6Q_DMA_REQ_UART2_RX,
 	.dma_req_tx = MX6Q_DMA_REQ_UART2_TX,
 };
+#endif
 
 static inline void mx6_evk_init_uart(void)
 {
@@ -1230,6 +1255,14 @@ static void imx6_evk_usbotg_vbus(bool on)
 		gpio_set_value(MX6_BRD_USBOTG1_PWR, 0);
 }
 
+static void imx6_evk_usbh1_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(MX6_BRD_USBOTG2_PWR, 1);
+	else
+		gpio_set_value(MX6_BRD_USBOTG2_PWR, 0);
+}
+
 static void __init mx6_evk_init_usb(void)
 {
 	int ret = 0;
@@ -1252,10 +1285,11 @@ static void __init mx6_evk_init_usb(void)
 		pr_err("failed to get GPIO MX6_BRD_USBOTG2_PWR:%d\n", ret);
 		return;
 	}
-	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 1);
+	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 0);
 
 	mx6_set_otghost_vbus_func(imx6_evk_usbotg_vbus);
-	mx6_usb_dr_init();
+	mx6_set_host1_vbus_func(imx6_evk_usbh1_vbus);
+
 #ifdef CONFIG_USB_EHCI_ARC_HSIC
 	mx6_usb_h2_init();
 #endif
@@ -1270,7 +1304,7 @@ static struct platform_pwm_backlight_data mx6_evk_pwm_backlight_data = {
 static struct fb_videomode wvga_video_modes[] = {
 	{
 	 /* 800x480 @ 57 Hz , pixel clk @ 32MHz */
-	 "SEIKO-WVGA", 60, 800, 480, 29850, 99, 164, 33, 10, 10, 10,
+	 "SEIKO-WVGA", 60, 800, 480, 29850, 89, 164, 23, 10, 10, 10,
 	 FB_SYNC_CLK_LAT_FALL,
 	 FB_VMODE_NONINTERLACED,
 	 0,},
@@ -1397,6 +1431,22 @@ static void mx6_snvs_poweroff(void)
 	writel(value | 0x60, mx6_snvs_base + SNVS_LPCR);
 }
 
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+static int uart4_enabled;
+static int __init uart4_setup(char * __unused)
+{
+	uart4_enabled = 1;
+	return 1;
+}
+__setup("bluetooth", uart4_setup);
+
+static void __init uart4_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_uart4_pads,
+					ARRAY_SIZE(mx6sl_uart4_pads));
+	imx6sl_add_imx_uart(3, &mx6sl_evk_uart4_data);
+}
+#else
 static int uart2_enabled;
 static int __init uart2_setup(char * __unused)
 {
@@ -1411,6 +1461,62 @@ static void __init uart2_init(void)
 					ARRAY_SIZE(mx6sl_uart2_pads));
 	imx6sl_add_imx_uart(1, &mx6sl_evk_uart1_data);
 }
+#endif
+
+static void mx6sl_evk_bt_reset(void)
+{
+	gpio_request(MX6SL_BRD_BT_RESET, "bt-reset");
+	gpio_direction_output(MX6SL_BRD_BT_RESET, 0);
+	/* pull down reset pin at least >5ms */
+	mdelay(6);
+	/* pull up after power supply BT */
+	gpio_set_value(MX6SL_BRD_BT_RESET, 1);
+	gpio_free(MX6SL_BRD_BT_RESET);
+}
+
+static int mx6sl_evk_bt_power_change(int status)
+{
+	if (status)
+		mx6sl_evk_bt_reset();
+	return 0;
+}
+
+static struct platform_device mxc_bt_rfkill = {
+	.name = "mxc_bt_rfkill",
+};
+
+static struct imx_bt_rfkill_platform_data mxc_bt_rfkill_data = {
+	.power_change = mx6sl_evk_bt_power_change,
+};
+
+static void mx6sl_evk_suspend_enter()
+{
+	iomux_v3_cfg_t *p = suspend_enter_pads;
+	int i;
+
+	/* Set PADCTRL to 0 for all IOMUX. */
+	for (i = 0; i < ARRAY_SIZE(suspend_enter_pads); i++) {
+		suspend_exit_pads[i] = *p;
+		*p &= ~MUX_PAD_CTRL_MASK;
+		/* Enable the Pull down and the keeper
+		  * Set the drive strength to 0.
+		  */
+		*p |= ((u64)0x3000 << MUX_PAD_CTRL_SHIFT);
+		p++;
+	}
+	mxc_iomux_v3_get_multiple_pads(suspend_exit_pads,
+			ARRAY_SIZE(suspend_exit_pads));
+	mxc_iomux_v3_setup_multiple_pads(suspend_enter_pads,
+			ARRAY_SIZE(suspend_enter_pads));
+
+}
+
+static void mx6sl_evk_suspend_exit()
+{
+	mxc_iomux_v3_setup_multiple_pads(suspend_exit_pads,
+			ARRAY_SIZE(suspend_exit_pads));
+}
+
 /*!
  * Board specific initialization.
  */
@@ -1423,15 +1529,8 @@ static void __init mx6_evk_init(void)
 
 	elan_ts_init();
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	gp_reg_id = mx6sl_evk_dvfscore_data.reg_id;
 	soc_reg_id = mx6sl_evk_dvfscore_data.soc_id;
-#else
-	gp_reg_id = mx6sl_evk_dvfscore_data.reg_id;
-	soc_reg_id = mx6sl_evk_dvfscore_data.soc_id;
-	pu_reg_id = mx6sl_evk_dvfscore_data.pu_id;
-	mx6_cpu_regulator_init();
-#endif
 
 	imx6q_add_imx_snvs_rtc();
 
@@ -1514,8 +1613,15 @@ static void __init mx6_evk_init(void)
 	imx6q_init_audio();
 
 	/* uart2 for bluetooth */
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+	if (uart4_enabled)
+		uart4_init();
+#else
 	if (uart2_enabled)
 		uart2_init();
+#endif
+
+	mxc_register_device(&mxc_bt_rfkill, &mxc_bt_rfkill_data);
 
 	imx6q_add_viim();
 	imx6q_add_imx2_wdt(0, NULL);
@@ -1539,6 +1645,7 @@ static void __init mx6_evk_init(void)
 	/* Register charger chips */
 	platform_device_register(&evk_max8903_charger_1);
 	pm_power_off = mx6_snvs_poweroff;
+	imx6q_add_pm_imx(0, &mx6sl_evk_pm_data);
 }
 
 extern void __iomem *twd_base;
diff --git a/arch/arm/mach-mx6/board-mx6solo_sabreauto.h b/arch/arm/mach-mx6/board-mx6solo_sabreauto.h
index 18f5d90..e4047d5 100644
--- a/arch/arm/mach-mx6/board-mx6solo_sabreauto.h
+++ b/arch/arm/mach-mx6/board-mx6solo_sabreauto.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -188,9 +188,7 @@ static iomux_v3_cfg_t mx6dl_sabreauto_pads[] = {
 	MX6DL_PAD_GPIO_8__UART2_RXD,
 	MX6DL_PAD_SD4_DAT6__UART2_CTS,
 	MX6DL_PAD_SD4_DAT5__UART2_RTS,
-	/* UART 3 */
-	MX6DL_PAD_SD4_CLK__UART3_TXD,
-	MX6DL_PAD_SD4_CMD__UART3_RXD,
+
 	/*USBs OC pin */
 	MX6DL_PAD_EIM_WAIT__GPIO_5_0,  /*HOST1_OC*/
 	MX6DL_PAD_SD4_DAT0__GPIO_2_8,  /*OTG_OC*/
@@ -206,12 +204,7 @@ static iomux_v3_cfg_t mx6dl_sabreauto_pads[] = {
 
 	/* HDMI */
 	MX6DL_PAD_EIM_A25__HDMI_TX_CEC_LINE,
-
-	/* MLB150 */
-	MX6DL_PAD_ENET_TXD1__MLB_MLBCLK,
-	MX6DL_PAD_GPIO_6__MLB_MLBSIG,
-	MX6DL_PAD_GPIO_2__MLB_MLBDAT,
-};
+ };
 
 static iomux_v3_cfg_t mx6dl_sabreauto_can0_pads[] = {
 	/* CAN1 */
@@ -297,6 +290,15 @@ static iomux_v3_cfg_t mx6dl_spinor_pads[] __initdata = {
 	MX6DL_PAD_EIM_D19__GPIO_3_19,
 };
 
+/*Bluetooth is conflicted with GMPI and NOR chips*/
+static iomux_v3_cfg_t mx6dl_bluetooth_pads[] __initdata = {
+	/* UART 3 */
+	MX6DL_PAD_SD4_CLK__UART3_RXD,
+	MX6DL_PAD_SD4_CMD__UART3_TXD,
+	MX6DL_PAD_EIM_D30__UART3_CTS,
+	MX6DL_PAD_EIM_EB3__UART3_RTS,
+};
+
 static iomux_v3_cfg_t mx6dl_weimnor_pads[] __initdata = {
 	/* Parallel NOR */
 	MX6DL_PAD_EIM_OE__WEIM_WEIM_OE,
diff --git a/arch/arm/mach-mx6/bus_freq.c b/arch/arm/mach-mx6/bus_freq.c
index 6422052..ba26367 100644
--- a/arch/arm/mach-mx6/bus_freq.c
+++ b/arch/arm/mach-mx6/bus_freq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -47,7 +47,7 @@
 #include <linux/suspend.h>
 
 #define LPAPM_CLK		24000000
-#define DDR_AUDIO_CLK	50000000
+#define DDR_AUDIO_CLK	100000000
 #define DDR_MED_CLK		400000000
 #define DDR3_NORMAL_CLK		528000000
 #define GPC_PGC_GPU_PGCR_OFFSET	0x260
@@ -78,7 +78,8 @@ unsigned int ddr_normal_rate;
 int low_freq_bus_used(void);
 void set_ddr_freq(int ddr_freq);
 void *mx6sl_wfi_iram_base;
-void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr) = NULL;
+void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr,\
+		int audio_mode) = NULL;
 extern void mx6sl_wait (int arm_podf, unsigned long wfi_iram_addr);
 
 void *mx6sl_ddr_freq_base;
@@ -169,6 +170,10 @@ void reduce_bus_freq(void)
 			/* PLL2 is on in this mode, as DDR is at 50MHz. */
 			/* Now change DDR freq while running from IRAM. */
 
+			/* Set AHB to 24MHz. */
+			clk_set_rate(ahb_clk,
+				clk_round_rate(ahb_clk, LPAPM_CLK / 3));
+
 			spin_lock_irqsave(&freq_lock, flags);
 			mx6sl_ddr_freq_change_iram(DDR_AUDIO_CLK,
 							low_bus_freq_mode);
@@ -269,7 +274,7 @@ int set_low_bus_freq(void)
 	if (!bus_freq_scaling_initialized || !bus_freq_scaling_is_active)
 		return 0;
 
-	/* Check to see if we need to got from
+	/* Check to see if we need to get from
 	  * low bus freq mode to audio bus freq mode.
 	  * If so, the change needs to be done immediately.
 	  */
@@ -300,6 +305,8 @@ int set_high_bus_freq(int high_bus_freq)
 	if (!bus_freq_scaling_initialized || !bus_freq_scaling_is_active)
 		return 0;
 
+	if (cpu_is_mx6sl())
+		high_bus_freq = 1;
 
 	if (high_bus_freq_mode && high_bus_freq)
 		return 0;
diff --git a/arch/arm/mach-mx6/clock.c b/arch/arm/mach-mx6/clock.c
index 67c3d1f..f8abae4 100644
--- a/arch/arm/mach-mx6/clock.c
+++ b/arch/arm/mach-mx6/clock.c
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -50,6 +50,8 @@ extern int lp_med_freq;
 extern int wait_mode_arm_podf;
 extern int lp_audio_freq;
 extern int cur_arm_podf;
+extern bool enet_is_active;
+extern bool enet_to_gpio_6;
 
 void __iomem *apll_base;
 
@@ -1023,7 +1025,8 @@ static int _clk_audio_video_set_rate(struct clk *clk, unsigned long rate)
 	__raw_writel(mfn, pllbase + PLL_NUM_DIV_OFFSET);
 	__raw_writel(mfd, pllbase + PLL_DENOM_DIV_OFFSET);
 
-	if (rev >= IMX_CHIP_REVISION_1_1) {
+	if ((rev >= IMX_CHIP_REVISION_1_1) &&
+		(pllbase == PLL5_VIDEO_BASE_ADDR)) {
 		reg = __raw_readl(ANA_MISC2_BASE_ADDR)
 			& ~ANADIG_ANA_MISC2_CONTROL3_MASK;
 		reg |= control3 << ANADIG_ANA_MISC2_CONTROL3_OFFSET;
@@ -1152,7 +1155,11 @@ static int _clk_pll_mlb_main_enable(struct clk *clk)
 	reg = __raw_readl(pllbase);
 	reg &= ~ANADIG_PLL_BYPASS;
 
-	reg = 0x0da20800;
+	reg = (0x3 << ANADIG_PLL_MLB_FLT_RES_CFG_OFFSET) |
+		(0x3 << ANADIG_PLL_MLB_RX_CLK_DELAY_CFG_OFFSET) |
+		(0x2 << ANADIG_PLL_MLB_VDDD_DELAY_CFG_OFFSET) |
+		(0x1 << ANADIG_PLL_MLB_VDDA_DELAY_CFG_OFFSET) |
+		(ANADIG_PLL_HOLD_RING_OFF);
 	__raw_writel(reg, pllbase);
 
 	return 0;
@@ -1859,6 +1866,8 @@ static int _clk_ipg_perclk_set_rate(struct clk *clk, unsigned long rate)
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	reg &= ~MXC_CCM_CSCMR1_PERCLK_PODF_MASK;
 	reg |= (div - 1) << MXC_CCM_CSCMR1_PERCLK_PODF_OFFSET;
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2390,6 +2399,9 @@ static int _clk_usdhc1_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC1_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2447,6 +2459,9 @@ static int _clk_usdhc2_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC2_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2504,6 +2519,9 @@ static int _clk_usdhc3_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC3_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2562,6 +2580,9 @@ static int _clk_usdhc4_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC4_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2677,6 +2698,8 @@ static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &pll3_pfd_508M, &pll3_pfd_454M,
 			&pll4_audio_main_clk, NULL, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -2751,6 +2774,8 @@ static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &pll3_pfd_508M, &pll3_pfd_454M,
 			&pll4_audio_main_clk, NULL, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -2824,6 +2849,8 @@ static int _clk_ssi3_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &pll3_pfd_508M, &pll3_pfd_454M,
 				&pll4_audio_main_clk, NULL, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_SSI3_CLK_SEL_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -3723,6 +3750,23 @@ static unsigned long _clk_enet_get_rate(struct clk *clk)
 	return 500000000 / div;
 }
 
+static int _clk_enet_enable(struct clk *clk)
+{
+	if (!enet_to_gpio_6)
+		enet_is_active = true;
+
+	_clk_enable(clk);
+	return 0;
+}
+
+static void _clk_enet_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+
+	if (!enet_to_gpio_6)
+		enet_is_active = false;
+}
+
 static struct clk enet_clk[] = {
 	{
 	__INIT_CLK_DEBUG(enet_clk)
@@ -3730,8 +3774,8 @@ static struct clk enet_clk[] = {
 	 .parent = &pll8_enet_main_clk,
 	 .enable_reg = MXC_CCM_CCGR1,
 	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
-	 .enable = _clk_enable,
-	 .disable = _clk_disable,
+	 .enable = _clk_enet_enable,
+	 .disable = _clk_enet_disable,
 	 .set_rate = _clk_enet_set_rate,
 	 .get_rate = _clk_enet_get_rate,
 	.secondary = &enet_clk[1],
@@ -3743,6 +3787,17 @@ static struct clk enet_clk[] = {
 	},
 };
 
+static unsigned long _clk_enet_mdc_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent);
+}
+
+static struct clk enet_mdc_clk = {
+	__INIT_CLK_DEBUG(enet_mdc_clk)
+	.parent = &ipg_clk,
+	.get_rate = _clk_enet_mdc_get_rate,
+};
+
 static struct clk ecspi_clk[] = {
 	{
 	__INIT_CLK_DEBUG(ecspi0_clk)
@@ -3825,6 +3880,8 @@ static int _clk_emi_slow_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &axi_clk, &pll3_usb_otg_main_clk,
 				&pll2_pfd_400M, &pll2_pfd_352M, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_ACLK_EMI_SLOW_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -3855,6 +3912,8 @@ static int _clk_emi_slow_set_rate(struct clk *clk, unsigned long rate)
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	reg &= ~MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_MASK;
 	reg |= (div - 1) << MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_OFFSET;
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -3899,9 +3958,11 @@ static int _clk_emi_set_parent(struct clk *clk, struct clk *parent)
 	int mux;
 	u32 reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_ACLK_EMI_MASK;
 
-	mux = _get_mux6(parent, &axi_clk, &pll3_usb_otg_main_clk,
-			&pll2_pfd_400M, &pll2_pfd_352M, NULL, NULL);
+	mux = _get_mux6(parent, &pll2_pfd_400M, &pll3_usb_otg_main_clk,
+			&axi_clk, &pll2_pfd_352M, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_ACLK_EMI_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -3911,6 +3972,7 @@ static unsigned long _clk_emi_get_rate(struct clk *clk)
 {
 	u32 reg, div;
 
+	/* ACLK_EMI_PODF read value matches with real divider value */
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	div = ((reg & MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK) >>
 			MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET) + 1;
@@ -3929,9 +3991,26 @@ static int _clk_emi_set_rate(struct clk *clk, unsigned long rate)
 	if (((parent_rate / div) != rate) || (div > 8))
 		return -EINVAL;
 
+	/*
+	 * This is a software workaround for ACLK_EMI_PODF SoC
+	 * implementation bug. The write/read/divider values
+	 * have the relationship described by the following table:
+	 *
+	 * write value       read value        description
+	 * 3b'000            3b'110            divided by 7
+	 * 3b'001            3b'111            divided by 8
+	 * 3b'010            3b'100            divided by 5
+	 * 3b'011            3b'101            divided by 6
+	 * 3b'100            3b'010            divided by 3
+	 * 3b'101            3b'011            divided by 4
+	 * 3b'110            3b'000            divided by 1
+	 * 3b'111            3b'001            divided by 2(default)
+	 *
+	 * That's why we do the xor operation below.
+	 */
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	reg &= ~MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK;
-	reg |= (div - 1) << MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET;
+	reg |= ((div - 1)^0x6) << MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -4244,7 +4323,7 @@ static struct clk caam_clk[] = {
 	 __INIT_CLK_DEBUG(caam_ipg_clk)
 	.id = 2,
 	.enable_reg = MXC_CCM_CCGR0,
-	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
 	.enable = _clk_enable,
 	.disable = _clk_disable,
 	.parent = &mmdc_ch0_axi_clk[0],
@@ -4770,6 +4849,7 @@ static int _clk_pcie_enable(struct clk *clk)
 {
 	unsigned int reg;
 
+#ifndef CONFIG_IMX_PCIE_RC_MODE_IN_EP_RC_SYS
 	/* Activate LVDS CLK1 (the MiniPCIe slot clock input) */
 	reg = __raw_readl(ANADIG_MISC1_REG);
 	reg &= ~ANATOP_LVDS_CLK1_IBEN_MASK;
@@ -4782,6 +4862,7 @@ static int _clk_pcie_enable(struct clk *clk)
 	reg = __raw_readl(ANADIG_MISC1_REG);
 	reg |= ANATOP_LVDS_CLK1_OBEN_MASK;
 	__raw_writel(reg, ANADIG_MISC1_REG);
+#endif
 
 	/* Enable PCIE ref clock */
 	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
@@ -4799,9 +4880,10 @@ static void _clk_pcie_disable(struct clk *clk)
 
 	_clk_disable(clk);
 
+#ifndef CONFIG_IMX_PCIE_RC_MODE_IN_EP_RC_SYS
 	/* De-activate LVDS CLK1 (the MiniPCIe slot clock input) */
 	reg = __raw_readl(ANADIG_MISC1_REG);
-	reg &= ~ANATOP_LVDS_CLK1_IBEN_MASK;
+	reg |= ANATOP_LVDS_CLK1_IBEN_MASK;
 	__raw_writel(reg, ANADIG_MISC1_REG);
 
 	reg = __raw_readl(ANADIG_MISC1_REG);
@@ -4811,6 +4893,7 @@ static void _clk_pcie_disable(struct clk *clk)
 	reg = __raw_readl(ANADIG_MISC1_REG);
 	reg &= ~ANATOP_LVDS_CLK1_OBEN_MASK;
 	__raw_writel(reg, ANADIG_MISC1_REG);
+#endif
 
 	/* Disable PCIE ref clock */
 	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
@@ -4844,6 +4927,53 @@ static struct clk pcie_clk[] = {
 	},
 };
 
+static int _clk_pcie_ep_enable(struct clk *clk)
+{
+	unsigned int reg;
+
+	/* Enable PCIE ref clock */
+	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
+	reg |= ANADIG_PLL_ENET_EN_PCIE;
+	__raw_writel(reg, PLL8_ENET_BASE_ADDR);
+
+	_clk_enable(clk);
+
+	return 0;
+}
+
+static void _clk_pcie_ep_disable(struct clk *clk)
+{
+	unsigned int reg;
+
+	_clk_disable(clk);
+
+	/* Disable PCIE ref clock */
+	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
+	reg &= ~ANADIG_PLL_ENET_EN_PCIE;
+	__raw_writel(reg, PLL8_ENET_BASE_ADDR);
+}
+
+static struct clk pcie_ep_clk[] = {
+	{
+	__INIT_CLK_DEBUG(pcie_ep_clk)
+	.parent = &pcie_axi_clk,
+	.enable = _clk_pcie_ep_enable,
+	.disable = _clk_pcie_ep_disable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.secondary = &pcie_ep_clk[1],
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	.parent = &pll8_enet_main_clk,
+	.secondary = &pcie_ep_clk[2],
+	},
+	{
+	.parent = &mmdc_ch0_axi_clk[0],
+	.secondary = &mx6fast1_clk,
+	},
+};
+
 static struct clk usboh3_clk[] = {
 	{
 	__INIT_CLK_DEBUG(usboh3_clk)
@@ -4888,6 +5018,7 @@ static int _clk_mlb_set_parent(struct clk *clk, struct clk *parent)
 static struct clk mlb150_clk = {
 	__INIT_CLK_DEBUG(mlb150_clk)
 	.id = 0,
+	.secondary = &ocram_clk,
 	.set_parent = _clk_mlb_set_parent,
 	.enable_reg = MXC_CCM_CCGR3,
 	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
@@ -5250,7 +5381,6 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("imx6q-ecspi.1", NULL, ecspi_clk[1]),
 	_REGISTER_CLOCK("imx6q-ecspi.2", NULL, ecspi_clk[2]),
 	_REGISTER_CLOCK("imx6q-ecspi.3", NULL, ecspi_clk[3]),
-	_REGISTER_CLOCK("imx6q-ecspi.4", NULL, ecspi_clk[4]),
 	_REGISTER_CLOCK(NULL, "emi_slow_clk", emi_slow_clk),
 	_REGISTER_CLOCK(NULL, "emi_clk", emi_clk),
 	_REGISTER_CLOCK(NULL, "enfc_clk", enfc_clk),
@@ -5258,6 +5388,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("imx-uart.1", NULL, uart_clk[0]),
 	_REGISTER_CLOCK("imx-uart.2", NULL, uart_clk[0]),
 	_REGISTER_CLOCK("imx-uart.3", NULL, uart_clk[0]),
+	_REGISTER_CLOCK("imx-uart.4", NULL, uart_clk[0]),
 	_REGISTER_CLOCK(NULL, "hsi_tx", hsi_tx_clk[0]),
 	_REGISTER_CLOCK(NULL, "caam_clk", caam_clk[0]),
 	_REGISTER_CLOCK(NULL, "asrc_clk", asrc_clk[0]),
@@ -5278,7 +5409,9 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm_clk[2]),
 	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm_clk[3]),
 	_REGISTER_CLOCK(NULL, "pcie_clk", pcie_clk[0]),
-	_REGISTER_CLOCK("enet.0", NULL, enet_clk[0]),
+	_REGISTER_CLOCK(NULL, "pcie_ep_clk", pcie_ep_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_clk", enet_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_mdc_clk", enet_mdc_clk),
 	_REGISTER_CLOCK(NULL, "imx_sata_clk", sata_clk[0]),
 	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
 	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy1_clk),
@@ -5306,6 +5439,11 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "apb_pclk", dummy_clk),
 };
 
+static struct
+clk_lookup imx6dl_i2c4 = _REGISTER_CLOCK("imx-i2c.3", NULL, ecspi_clk[4]);
+static struct
+clk_lookup imx6q_ecspi5 = _REGISTER_CLOCK("imx6q-ecspi.4", NULL, ecspi_clk[4]);
+
 static void clk_tree_init(void)
 
 {
@@ -5343,8 +5481,18 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 		clk_debug_register(lookups[i].clk);
 	}
 
-	/* Lower the ipg_perclk frequency to 6MHz. */
-	clk_set_rate(&ipg_perclk, 6000000);
+	/*
+	 * imx6q have 5 ecspi and 3 i2c
+	 * imx6dl have 4 ecspi and 4 i2c
+	 * imx6dl i2c4 use the imx6q ecspi5 clock source
+	 */
+	if (cpu_is_mx6dl()) {
+		clkdev_add(&imx6dl_i2c4);
+		clk_debug_register(imx6dl_i2c4.clk);
+	} else {
+		clkdev_add(&imx6q_ecspi5);
+		clk_debug_register(imx6q_ecspi5.clk);
+	}
 
 	/* Timer needs to be initialized first as the
 	  * the WAIT routines use GPT counter as
@@ -5363,6 +5511,15 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 
 	clk_tree_init();
 
+	/*
+	 * Lower the ipg_perclk frequency to 22MHz.
+	 * I2C needs a minimum of 12.8MHz as its source
+	 * to acheive 400KHz speed. IPG_PERCLK sources
+	 * I2C. 22MHz when divided by the I2C divider gives the
+	 * freq closest to 400KHz.
+	 */
+	clk_set_rate(&ipg_perclk, 22000000);
+
 #ifdef CONFIG_MX6_VPU_352M
 	if (cpu_is_mx6q()) {
 		clk_set_rate(&pll2_pfd_400M, 352000000);
@@ -5405,8 +5562,11 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 	clk_set_parent(&ipu2_di_clk[1], &pll5_video_main_clk);
 
 	clk_set_parent(&emi_clk, &pll2_pfd_400M);
-	clk_set_rate(&emi_clk, 200000000);
-
+#ifdef CONFIG_MX6_VPU_352M
+	clk_set_rate(&emi_clk, 176000000);
+#else
+	clk_set_rate(&emi_clk, 198000000);
+#endif
 	/*
 	* on mx6dl, 2d core clock sources from 3d shader core clock,
 	* but 3d shader clock multiplexer of mx6dl is different from
diff --git a/arch/arm/mach-mx6/clock_mx6sl.c b/arch/arm/mach-mx6/clock_mx6sl.c
index 544b995..f375b4a 100755
--- a/arch/arm/mach-mx6/clock_mx6sl.c
+++ b/arch/arm/mach-mx6/clock_mx6sl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -73,6 +73,7 @@ static struct cpu_op *cpu_op_tbl;
 static int cpu_op_nr;
 static bool pll1_enabled;
 static bool arm_needs_pll2_400;
+static bool audio_pll_bypass;
 
 DEFINE_SPINLOCK(mx6sl_clk_lock);
 #define SPIN_DELAY	1200000 /* in nanoseconds */
@@ -429,7 +430,8 @@ static int _clk_pll_enable(struct clk *clk)
 	pllbase = _get_pll_base(clk);
 
 	reg = __raw_readl(pllbase);
-	reg &= ~ANADIG_PLL_POWER_DOWN;
+	if (clk != &pll4_audio_main_clk || !audio_pll_bypass)
+		reg &= ~ANADIG_PLL_POWER_DOWN;
 
 	/* The 480MHz PLLs have the opposite definition for power bit. */
 	if (clk == &pll3_usb_otg_main_clk || clk == &pll7_usb_host_main_clk)
@@ -442,14 +444,20 @@ static int _clk_pll_enable(struct clk *clk)
 		__raw_writel(BM_ANADIG_ANA_MISC2_CONTROL0, apll_base + HW_ANADIG_ANA_MISC2_CLR);
 
 	/* Wait for PLL to lock */
-	if (!WAIT((__raw_readl(pllbase) & ANADIG_PLL_LOCK),
-				SPIN_DELAY))
-		panic("pll enable failed\n");
-
+	if (clk != &pll4_audio_main_clk || !audio_pll_bypass) {
+		if (!WAIT((__raw_readl(pllbase) & ANADIG_PLL_LOCK),
+					SPIN_DELAY))
+			panic("pll enable failed\n");
+	}
 	/* Enable the PLL output now*/
 	reg = __raw_readl(pllbase);
-	reg &= ~ANADIG_PLL_BYPASS;
+
+	/* If audio PLL is set to 24MHz, leave it in bypass mode. */
+	if (clk != &pll4_audio_main_clk || !audio_pll_bypass)
+		reg &= ~ANADIG_PLL_BYPASS;
+
 	reg |= ANADIG_PLL_ENABLE;
+
 	__raw_writel(reg, pllbase);
 
 	return 0;
@@ -874,6 +882,9 @@ static unsigned long _clk_audio_video_get_rate(struct clk *clk)
 
 	pllbase = _get_pll_base(clk);
 
+	if (__raw_readl(pllbase) & ANADIG_PLL_BYPASS)
+		return 24000000;
+
 	test_div_sel = (__raw_readl(pllbase)
 		& ANADIG_PLL_AV_TEST_DIV_SEL_MASK)
 		>> ANADIG_PLL_AV_TEST_DIV_SEL_OFFSET;
@@ -917,6 +928,16 @@ static int _clk_audio_video_set_rate(struct clk *clk, unsigned long rate)
 	u32 test_div_sel = 2;
 	u32 control3 = 0;
 
+	pllbase = _get_pll_base(clk);
+
+	if (clk == &pll4_audio_main_clk && audio_pll_bypass) {
+		reg = __raw_readl(pllbase)
+				& ~ANADIG_PLL_SYS_DIV_SELECT_MASK
+				& ~ANADIG_PLL_AV_TEST_DIV_SEL_MASK;
+		__raw_writel(reg, pllbase);
+		return 0;
+	}
+
 	if (clk == &pll4_audio_main_clk)
 		min_clk_rate = AUDIO_VIDEO_MIN_CLK_FREQ / 4;
 	else
@@ -925,8 +946,6 @@ static int _clk_audio_video_set_rate(struct clk *clk, unsigned long rate)
 	if ((rate < min_clk_rate) || (rate > AUDIO_VIDEO_MAX_CLK_FREQ))
 		return -EINVAL;
 
-	pllbase = _get_pll_base(clk);
-
 	pre_div_rate = rate;
 	while (pre_div_rate < AUDIO_VIDEO_MIN_CLK_FREQ) {
 		pre_div_rate *= 2;
@@ -986,6 +1005,9 @@ static unsigned long _clk_audio_video_round_rate(struct clk *clk,
 	u32 control3 = 0;
 	unsigned long final_rate;
 
+	if (clk == &pll4_audio_main_clk && audio_pll_bypass)
+		return 24000000;
+
 	if (clk == &pll4_audio_main_clk)
 		min_clk_rate = AUDIO_VIDEO_MIN_CLK_FREQ / 4;
 	else
@@ -1681,6 +1703,7 @@ static struct clk mmdc_ch1_axi_clk[] = {
 	.secondary = &tzasc2_clk,
 	},
 };
+
 #if defined(CONFIG_SDMA_IRAM) || defined(CONFIG_SND_MXC_SOC_IRAM)
 static struct clk ocram_clk = {
 	__INIT_CLK_DEBUG(ocram_clk)
@@ -1692,6 +1715,7 @@ static struct clk ocram_clk = {
 	.disable = _clk_disable_inwait,
 };
 #endif
+
 static unsigned long _clk_ipg_perclk_get_rate(struct clk *clk)
 {
 	u32 reg, div;
@@ -2376,14 +2400,23 @@ static int _clk_extern_audio_set_rate(struct clk *clk, unsigned long rate)
 	u32 reg, div, pre, post;
 	u32 parent_rate = clk_get_rate(clk->parent);
 
-	div = parent_rate / rate;
-	if (div == 0)
-		div++;
-	if (((parent_rate / div) != rate) || div > 64)
-		return -EINVAL;
+	if (rate == 24000000 && clk->parent == &pll4_audio_main_clk) {
+		/* If the requested rate is 24MHz,
+		  * set the PLL4 to bypass mode.
+		  */
+		audio_pll_bypass = 1;
+		pre = post = 1;
+	} else {
+		div = parent_rate / rate;
+		if (div == 0)
+			div++;
+		if (((parent_rate / div) != rate) || div > 64)
+			return -EINVAL;
 
-	__calc_pre_post_dividers(1 << 3, div, &pre, &post);
+		audio_pll_bypass = 0;
 
+		__calc_pre_post_dividers(1 << 3, div, &pre, &post);
+	}
 	reg = __raw_readl(MXC_CCM_CS1CDR);
 	reg &= ~(MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK|
 		 MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK);
@@ -2427,23 +2460,25 @@ static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk ssi1_clk = {
-	__INIT_CLK_DEBUG(ssi1_clk)
-	.parent = &pll3_pfd2_508M,
-	.enable_reg = MXC_CCM_CCGR5,
-	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
-	.enable = _clk_enable,
-	.disable = _clk_disable,
-	.set_parent = _clk_ssi1_set_parent,
-	.set_rate = _clk_ssi1_set_rate,
-	.round_rate = _clk_ssi_round_rate,
-	.get_rate = _clk_ssi1_get_rate,
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &ocram_clk,
-#else
+static struct clk ssi1_clk[] = {
+	{
+	 __INIT_CLK_DEBUG(ssi1_clk)
+	 .parent = &pll3_pfd2_508M,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .set_rate = _clk_ssi1_set_rate,
+	 .round_rate = _clk_ssi_round_rate,
+	 .get_rate = _clk_ssi1_get_rate,
+	 .flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#ifndef CONFIG_SND_MXC_SOC_IRAM
 	 .secondary = &mmdc_ch1_axi_clk[0],
+#else
+	 .secondary = &ocram_clk,
 #endif
-	.flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
 };
 
 static unsigned long _clk_ssi2_get_rate(struct clk *clk)
@@ -2501,23 +2536,25 @@ static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk ssi2_clk = {
-	__INIT_CLK_DEBUG(ssi2_clk)
-	.parent = &pll3_pfd2_508M,
-	.enable_reg = MXC_CCM_CCGR5,
-	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
-	.enable = _clk_enable,
-	.disable = _clk_disable,
-	.set_parent = _clk_ssi2_set_parent,
-	.set_rate = _clk_ssi2_set_rate,
-	.round_rate = _clk_ssi_round_rate,
-	.get_rate = _clk_ssi2_get_rate,
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &ocram_clk,
-#else
+static struct clk ssi2_clk[] = {
+	{
+	 __INIT_CLK_DEBUG(ssi2_clk)
+	 .parent = &pll3_pfd2_508M,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .set_rate = _clk_ssi2_set_rate,
+	 .round_rate = _clk_ssi_round_rate,
+	 .get_rate = _clk_ssi2_get_rate,
+	 .flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#ifndef CONFIG_SND_MXC_SOC_IRAM
 	 .secondary = &mmdc_ch1_axi_clk[0],
+#else
+	 .secondary = &ocram_clk,
 #endif
-	.flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
 };
 
 static unsigned long _clk_ssi3_get_rate(struct clk *clk)
@@ -2574,23 +2611,25 @@ static int _clk_ssi3_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk ssi3_clk = {
-	__INIT_CLK_DEBUG(ssi3_clk)
-	.parent = &pll3_pfd2_508M,
-	.enable_reg = MXC_CCM_CCGR5,
-	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
-	.enable = _clk_enable,
-	.disable = _clk_disable,
-	.set_parent = _clk_ssi3_set_parent,
-	.set_rate = _clk_ssi3_set_rate,
-	.round_rate = _clk_ssi_round_rate,
-	.get_rate = _clk_ssi3_get_rate,
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &ocram_clk,
-#else
+static struct clk ssi3_clk[] = {
+	{
+	 __INIT_CLK_DEBUG(ssi3_clk)
+	 .parent = &pll3_pfd2_508M,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .set_parent = _clk_ssi3_set_parent,
+	 .set_rate = _clk_ssi3_set_rate,
+	 .round_rate = _clk_ssi_round_rate,
+	 .get_rate = _clk_ssi3_get_rate,
+	 .flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#ifndef CONFIG_SND_MXC_SOC_IRAM
 	 .secondary = &mmdc_ch1_axi_clk[0],
+#else
+	 .secondary = &ocram_clk,
 #endif
-	.flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
 };
 
 static unsigned long _clk_epdc_lcdif_pix_round_rate(struct clk *clk,
@@ -3156,6 +3195,17 @@ static struct clk fec_clk[] = {
 	},
 };
 
+static unsigned long _clk_fec_mdc_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent);
+}
+
+static struct clk fec_mdc_clk = {
+	__INIT_CLK_DEBUG(fec_mdc_clk)
+	.parent = &ipg_clk,
+	.get_rate = _clk_fec_mdc_get_rate,
+};
+
 static struct clk ecspi_clk[] = {
 	{
 	__INIT_CLK_DEBUG(ecspi0_clk)
@@ -3755,11 +3805,11 @@ static int _clk_clko2_set_parent(struct clk *clk, struct clk *parent)
 		sel = 14;
 	else if (parent == &usdhc2_clk)
 		sel = 17;
-	else if (parent == &ssi1_clk)
+	else if (parent == &ssi1_clk[0])
 		sel = 18;
-	else if (parent == &ssi2_clk)
+	else if (parent == &ssi2_clk[0])
 		sel = 19;
-	else if (parent == &ssi3_clk)
+	else if (parent == &ssi3_clk[0])
 		sel = 20;
 	else if (parent == &uart_clk[0])
 		sel = 28;
@@ -3912,9 +3962,9 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("sdhci-esdhc-imx.1", NULL, usdhc2_clk),
 	_REGISTER_CLOCK("sdhci-esdhc-imx.2", NULL, usdhc3_clk),
 	_REGISTER_CLOCK("sdhci-esdhc-imx.3", NULL, usdhc4_clk),
-	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk),
-	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk),
-	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk),
+	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk[0]),
+	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk[0]),
+	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk[0]),
 	_REGISTER_CLOCK(NULL, "pxp_axi", pxp_axi_clk),
 	_REGISTER_CLOCK(NULL, "epdc_axi", epdc_axi_clk),
 	_REGISTER_CLOCK(NULL, "epdc_pix", epdc_pix_clk),
@@ -3935,7 +3985,8 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm_clk[1]),
 	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm_clk[2]),
 	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm_clk[3]),
-	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_clk", fec_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_mdc_clk", fec_mdc_clk),
 	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
 	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy1_clk),
 	_REGISTER_CLOCK(NULL, "usb_phy3_clk", usb_phy3_clk),
@@ -4003,11 +4054,14 @@ int __init mx6sl_clocks_init(unsigned long ckil, unsigned long osc,
 	 * should be from OSC24M */
 	clk_set_parent(&ipg_perclk, &osc_clk);
 
-	/* Need to set IPG_PERCLK to 3MHz, so that we can
-	  * satisfy the 2.5:1 AHB:IPG_PERCLK ratio. Since AHB
-	  * can be dropped to as low as 8MHz in low power mode.
+
+	/*IPG_PERCLK sources I2C.
+	  * I2C needs a minimum of 12.8MHz as its source
+	  * to acheive 400KHz speed.
+	  * Hence set ipg_perclk to 24MHz.
 	  */
-	clk_set_rate(&ipg_perclk, 3000000);
+
+	clk_set_rate(&ipg_perclk, 24000000);
 
 	gpt_clk[0].parent = &ipg_perclk;
 	gpt_clk[0].get_rate = NULL;
@@ -4094,6 +4148,8 @@ int __init mx6sl_clocks_init(unsigned long ckil, unsigned long osc,
 	/* lcdif pix - PLL5 as parent */
 	clk_set_parent(&lcdif_pix_clk, &pll5_video_main_clk);
 
+	clk_set_parent(&ssi2_clk[0], &pll4_audio_main_clk);
+
 	lp_high_freq = 0;
 	lp_med_freq = 0;
 
diff --git a/arch/arm/mach-mx6/cpu.c b/arch/arm/mach-mx6/cpu.c
index fbb3827..a65ad81 100644
--- a/arch/arm/mach-mx6/cpu.c
+++ b/arch/arm/mach-mx6/cpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,6 +25,7 @@
 #include <linux/delay.h>
 
 #include <mach/hardware.h>
+#include <mach/system.h>
 #include <asm/io.h>
 #include <asm/mach/map.h>
 
@@ -33,8 +34,10 @@
 
 struct cpu_op *(*get_cpu_op)(int *op);
 bool enable_wait_mode = true;
-u32 arm_max_freq = CPU_AT_1GHz;
+u32 enable_ldo_mode = LDO_MODE_DEFAULT;
+u32 arm_max_freq = CPU_AT_1_2GHz;
 bool mem_clk_on_in_wait;
+bool enet_to_gpio_6;
 int chip_rev;
 
 void __iomem *gpc_base;
@@ -211,6 +214,13 @@ static int __init post_cpu_init(void)
 	else
 		chip_rev = mx6sl_revision();
 
+	/* mx6sl doesn't have pcie. save power, disable PCIe PHY */
+	if (!cpu_is_mx6sl()) {
+		reg = __raw_readl(IOMUXC_GPR1);
+		reg = reg & (~IOMUXC_GPR1_PCIE_REF_CLK_EN);
+		reg |= IOMUXC_GPR1_TEST_POWERDOWN;
+		__raw_writel(reg, IOMUXC_GPR1);
+	}
 	return 0;
 }
 postcore_initcall(post_cpu_init);
@@ -245,6 +255,19 @@ static int __init arm_core_max(char *p)
 
 early_param("arm_freq", arm_core_max);
 
+static int __init enable_ldo(char *p)
+{
+	if (memcmp(p, "on", 2) == 0) {
+		enable_ldo_mode = LDO_MODE_ENABLED;
+		p += 2;
+	} else if (memcmp(p, "off", 3) == 0) {
+		enable_ldo_mode = LDO_MODE_BYPASSED;
+		p += 3;
+	}
+	return 0;
+}
+early_param("ldo_active", enable_ldo);
+
 static int __init enable_mem_clk_in_wait(char *p)
 {
 	mem_clk_on_in_wait = true;
@@ -254,5 +277,10 @@ static int __init enable_mem_clk_in_wait(char *p)
 
 early_param("mem_clk_on", enable_mem_clk_in_wait);
 
+static int __init set_enet_irq_to_gpio(char *p)
+{
+	enet_to_gpio_6 = true;
+	return 0;
+}
 
-
+early_param("enet_gpio_6", set_enet_irq_to_gpio);
diff --git a/arch/arm/mach-mx6/cpu_op-mx6.c b/arch/arm/mach-mx6/cpu_op-mx6.c
index 028e876..210fdd5 100644
--- a/arch/arm/mach-mx6/cpu_op-mx6.c
+++ b/arch/arm/mach-mx6/cpu_op-mx6.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -13,10 +13,12 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <asm/io.h>
 #include <mach/hardware.h>
 #include <mach/mxc_dvfs.h>
 #include "cpu_op-mx6.h"
 
+#define OCOTP_SPEED_BIT_OFFSET (16)
 extern struct cpu_op *(*get_cpu_op)(int *op);
 extern struct dvfs_op *(*get_dvfs_core_op)(int *wp);
 extern void (*set_num_cpu_op)(int num);
@@ -33,6 +35,13 @@ static struct cpu_op mx6q_cpu_op_1_2G[] = {
 	 .soc_voltage = 1275000,
 	 .cpu_voltage = 1275000,},
 	{
+	 .pll_rate = 996000000,
+	 .cpu_rate = 996000000,
+	 .cpu_podf = 0,
+	 .pu_voltage = 1250000,
+	 .soc_voltage = 1250000,
+	 .cpu_voltage = 1250000,},
+	{
 	 .pll_rate = 792000000,
 	 .cpu_rate = 792000000,
 	 .cpu_podf = 0,
@@ -331,6 +340,29 @@ void mx6_set_num_cpu_op(int num)
 
 void mx6_cpu_op_init(void)
 {
+	unsigned int reg;
+	void __iomem *base;
+	if (!cpu_is_mx6sl()) {
+		/*read fuse bit to know the max cpu freq : offset 0x440
+		* bit[17:16]:SPEED_GRADING[1:0],for mx6dq/dl*/
+		base = IO_ADDRESS(OCOTP_BASE_ADDR);
+		reg = __raw_readl(base + 0x440);
+		reg &= (0x3 << OCOTP_SPEED_BIT_OFFSET);
+		reg >>= OCOTP_SPEED_BIT_OFFSET;
+		/*choose the little value to run lower max cpufreq*/
+		arm_max_freq = (reg > arm_max_freq) ? arm_max_freq : reg;
+	} else {
+		/*
+		 * There is no SPEED_GRADING fuse bit on mx6sl,then do:
+		 * If arm_max_freq set by default on CPU_AT_1_2GHz which mean
+		 * there is no 'arm_freq' setting in cmdline from bootloader,
+		 * force arm_max_freq to 1G. Else use 'arm_freq' setting.
+		 */
+		if (arm_max_freq == CPU_AT_1_2GHz)
+			arm_max_freq = CPU_AT_1GHz;/*mx6sl max freq is 1Ghz*/
+	}
+	printk(KERN_INFO "arm_max_freq=%s\n", (arm_max_freq == CPU_AT_1_2GHz) ?
+		"1.2GHz" : ((arm_max_freq == CPU_AT_1GHz) ? "1GHz" : "800MHz"));
 	get_cpu_op = mx6_get_cpu_op;
 	set_num_cpu_op = mx6_set_num_cpu_op;
 
diff --git a/arch/arm/mach-mx6/cpu_op-mx6.h b/arch/arm/mach-mx6/cpu_op-mx6.h
index b5ca58e..310cbb3 100644
--- a/arch/arm/mach-mx6/cpu_op-mx6.h
+++ b/arch/arm/mach-mx6/cpu_op-mx6.h
@@ -10,9 +10,9 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
-
+/*The below value aligned with SPEED_GRADING bits in 0x440 fuse offset */
 #define CPU_AT_800MHz		0
-#define CPU_AT_1GHz			1
-#define CPU_AT_1_2GHz		2
+#define CPU_AT_1GHz		2
+#define CPU_AT_1_2GHz		3
 
 void mx6_cpu_op_init(void);
diff --git a/arch/arm/mach-mx6/cpu_regulator-mx6.c b/arch/arm/mach-mx6/cpu_regulator-mx6.c
index 30af30a..0e91c8c 100644
--- a/arch/arm/mach-mx6/cpu_regulator-mx6.c
+++ b/arch/arm/mach-mx6/cpu_regulator-mx6.c
@@ -20,11 +20,14 @@
 #if defined(CONFIG_CPU_FREQ)
 #include <linux/cpufreq.h>
 #endif
+#include <linux/io.h>
 #include <asm/cpu.h>
 
 #include <mach/clock.h>
 #include <mach/hardware.h>
-
+#include <mach/system.h>
+#include "regs-anadig.h"
+#include "crm_regs.h"
 struct regulator *cpu_regulator;
 struct regulator *soc_regulator;
 struct regulator *pu_regulator;
@@ -37,6 +40,7 @@ static struct cpu_op *cpu_op_tbl;
 extern struct cpu_op *(*get_cpu_op)(int *op);
 
 extern unsigned long loops_per_jiffy;
+extern u32 enable_ldo_mode;
 int external_pureg;
 
 static inline unsigned long mx6_cpu_jiffies(unsigned long old, u_int div,
@@ -57,15 +61,32 @@ static inline unsigned long mx6_cpu_jiffies(unsigned long old, u_int div,
 #endif
 }
 
-
 void mx6_cpu_regulator_init(void)
 {
 	int cpu;
 	u32 curr_cpu = 0;
+	unsigned int reg;
 #ifndef CONFIG_SMP
 	unsigned long old_loops_per_jiffy;
 #endif
+	void __iomem *gpc_base = IO_ADDRESS(GPC_BASE_ADDR);
 	external_pureg = 0;
+	/*If internal ldo actived, use internal cpu_* regulator to replace the
+	*regulator ids from board file. If internal ldo bypassed, use the
+	*regulator ids which defined in board file and source from extern pmic
+	*power rails.
+	*If you want to use ldo bypass,you should do:
+	*1.set enable_ldo_mode=LDO_MODE_BYPASSED in your board file by default
+	*   or set in commandline from u-boot
+	*2.set your extern pmic regulator name in your board file.
+	*/
+	if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		gp_reg_id = "cpu_vddgp";
+		soc_reg_id = "cpu_vddsoc";
+		pu_reg_id = "cpu_vddgpu";
+	}
+	printk(KERN_INFO "cpu regulator mode:%s\n", (enable_ldo_mode ==
+		LDO_MODE_BYPASSED) ? "ldo_bypass" : "ldo_enable");
 	cpu_regulator = regulator_get(NULL, gp_reg_id);
 	if (IS_ERR(cpu_regulator))
 		printk(KERN_ERR "%s: failed to get cpu regulator\n", __func__);
@@ -101,6 +122,21 @@ void mx6_cpu_regulator_init(void)
 			regulator_set_voltage(cpu_regulator,
 					      cpu_op_tbl[0].cpu_voltage,
 					      cpu_op_tbl[0].cpu_voltage);
+			if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+				/* digital bypass VDDPU/VDDSOC/VDDARM */
+				reg = __raw_readl(ANADIG_REG_CORE);
+				reg &= ~BM_ANADIG_REG_CORE_REG0_TRG;
+				reg |= BF_ANADIG_REG_CORE_REG0_TRG(0x1f);
+				reg &= ~BM_ANADIG_REG_CORE_REG1_TRG;
+				reg |= BF_ANADIG_REG_CORE_REG1_TRG(0x1f);
+				reg &= ~BM_ANADIG_REG_CORE_REG2_TRG;
+				reg |= BF_ANADIG_REG_CORE_REG2_TRG(0x1f);
+				__raw_writel(reg, ANADIG_REG_CORE);
+				/* mask the ANATOP brown out irq in the GPC. */
+				reg = __raw_readl(gpc_base + 0x14);
+				reg |= 0x80000000;
+				__raw_writel(reg, gpc_base + 0x14);
+			}
 
 			clk_set_rate(cpu_clk, cpu_op_tbl[0].cpu_rate);
 
@@ -144,7 +180,7 @@ void mx6_cpu_regulator_init(void)
 	 * VDDPU can be turned off by internal anatop anatop power gate.
 	 *
 	 */
-	if (!IS_ERR(pu_regulator) && strcmp(pu_reg_id, "cpu_vddvpu"))
+	if (!IS_ERR(pu_regulator) && strcmp(pu_reg_id, "cpu_vddgpu"))
 		external_pureg = 1;
 }
 
diff --git a/arch/arm/mach-mx6/crm_regs.h b/arch/arm/mach-mx6/crm_regs.h
index 43fcb4d..0ae8e41 100644
--- a/arch/arm/mach-mx6/crm_regs.h
+++ b/arch/arm/mach-mx6/crm_regs.h
@@ -28,6 +28,29 @@
 #define IOMUXC_GPR12			(MXC_IOMUXC_BASE + 0x30)
 #define IOMUXC_GPR13			(MXC_IOMUXC_BASE + 0x34)
 
+/* GPR1: IOMUXC_GPR1_PCIE_REF_CLK_EN(IOMUXC_GPR1[16]) */
+#define IOMUXC_GPR1_PCIE_REF_CLK_EN		(1 << 16)
+/* GPR1: IOMUXC_GPR1_TEST_POWERDOWN(IOMUXC_GPR1[18]) */
+#define IOMUXC_GPR1_TEST_POWERDOWN		(1 << 18)
+
+/* GPR8: IOMUXC_GPR8_TX_DEEMPH_GEN1(IOMUXC_GPR8[5:0]) */
+#define IOMUXC_GPR8_TX_DEEMPH_GEN1		(0x3F << 0)
+/* GPR8: IOMUXC_GPR8_TX_DEEMPH_GEN2_3P5DB(IOMUXC_GPR8[11:6]) */
+#define IOMUXC_GPR8_TX_DEEMPH_GEN2_3P5DB	(0x3F << 6)
+/* GPR8: IOMUXC_GPR8_TX_DEEMPH_GEN2_6DB(IOMUXC_GPR8[17:12]) */
+#define IOMUXC_GPR8_TX_DEEMPH_GEN2_6DB		(0x3F << 12)
+/* GPR8: IOMUXC_GPR8_TX_SWING_FULL(IOMUXC_GPR8[24:18]) */
+#define IOMUXC_GPR8_TX_SWING_FULL		(0x7F << 18)
+/* GPR8: IOMUXC_GPR8_TX_SWING_LOW(IOMUXC_GPR8[31:25]) */
+#define IOMUXC_GPR8_TX_SWING_LOW		(0x7F << 25)
+
+/* GPR12: IOMUXC_GPR12_LOS_LEVEL(IOMUXC_GPR12[8:4]) */
+#define IOMUXC_GPR12_LOS_LEVEL			(0x1F << 4)
+/* GPR12: IOMUXC_GPR12_APP_LTSSM_ENABLE(IOMUXC_GPR12[10]) */
+#define IOMUXC_GPR12_APP_LTSSM_ENABLE		(1 << 10)
+/* GPR12: IOMUXC_GPR12_DEVICE_TYPE(IOMUXC_GPR12[15:12]) */
+#define IOMUXC_GPR12_DEVICE_TYPE		(0xF << 12)
+
 #define IOMUXC_GPR3_OCRAM_CTL_EN	(0xf << 21)
 #define IOMUXC_GPR4_VDOA_CACHE_EN	(0xf << 28)
 #define IOMUXC_GPR4_VPU_CACHE_EN	(0xcc)
@@ -155,9 +178,9 @@
 #define ANADIG_ANA_MISC2_REG1_BO_EN			(1 << 13)
 #define ANADIG_ANA_MISC2_CONTROL3_MASK		0xC0000000
 #define ANADIG_ANA_MISC2_CONTROL3_OFFSET	30
-#define ANADIG_ANA_MISC2_REG0_STEP_TIME_MASK		0x30000000
-#define ANADIG_ANA_MISC2_REG1_STEP_TIME_MASK		0xC000000
-#define ANADIG_ANA_MISC2_REG2_STEP_TIME_MASK		0x3000000
+#define ANADIG_ANA_MISC2_REG0_STEP_TIME_MASK		0x03000000
+#define ANADIG_ANA_MISC2_REG1_STEP_TIME_MASK		0x0C000000
+#define ANADIG_ANA_MISC2_REG2_STEP_TIME_MASK		0x30000000
 
 #define MXC_CCM_BASE		MX6_IO_ADDRESS(CCM_BASE_ADDR)
 /* CCM Register Offsets. */
diff --git a/arch/arm/mach-mx6/irq.c b/arch/arm/mach-mx6/irq.c
index e865b45..d0bde95 100644
--- a/arch/arm/mach-mx6/irq.c
+++ b/arch/arm/mach-mx6/irq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,6 +26,9 @@
 #ifdef CONFIG_CPU_FREQ_GOV_INTERACTIVE
 #include <linux/cpufreq.h>
 #endif
+#ifdef CONFIG_PCI_MSI
+#include "msi.h"
+#endif
 
 int mx6q_register_gpios(void);
 unsigned int gpc_wake_irq[4];
@@ -103,9 +106,6 @@ void mx6_init_irq(void)
 	void __iomem *gpc_base = IO_ADDRESS(GPC_BASE_ADDR);
 	struct irq_desc *desc;
 	unsigned int i;
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	u32 reg;
-#endif
 
 	/* start offset if private timer irq id, which is 29.
 	 * ID table:
@@ -124,12 +124,6 @@ void mx6_init_irq(void)
 		__raw_writel(0x20000000, gpc_base + 0x10);
 	}
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	/* Mask the ANATOP brown out interrupt in the GPC. */
-	reg = __raw_readl(gpc_base + 0x14);
-	reg |= 0x80000000;
-	__raw_writel(reg, gpc_base + 0x14);
-#endif
 
 	for (i = MXC_INT_START; i <= MXC_INT_END; i++) {
 		desc = irq_to_desc(i);
@@ -140,4 +134,7 @@ void mx6_init_irq(void)
 	for (i = 0; i < ARRAY_SIZE(mxc_irq_tuner); i++)
 		cpufreq_gov_irq_tuner_register(mxc_irq_tuner[i]);
 #endif
+#ifdef CONFIG_PCI_MSI
+	imx_msi_init();
+#endif
 }
diff --git a/arch/arm/mach-mx6/localtimer.c b/arch/arm/mach-mx6/localtimer.c
index 402368b..2fac9fb 100644
--- a/arch/arm/mach-mx6/localtimer.c
+++ b/arch/arm/mach-mx6/localtimer.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,8 +24,6 @@
 #include <mach/irqs.h>
 #include <mach/hardware.h>
 
-
-extern bool enable_wait_mode;
 /*
  * Setup the local clock events for a CPU.
  */
diff --git a/arch/arm/mach-mx6/mm.c b/arch/arm/mach-mx6/mm.c
index 3cf6b22..8d2c715 100644
--- a/arch/arm/mach-mx6/mm.c
+++ b/arch/arm/mach-mx6/mm.c
@@ -111,9 +111,21 @@ int mxc_init_l2x0(void)
 	writel(0x132, IO_ADDRESS(L2_BASE_ADDR + L2X0_TAG_LATENCY_CTRL));
 	writel(0x132, IO_ADDRESS(L2_BASE_ADDR + L2X0_DATA_LATENCY_CTRL));
 
-	val = readl(IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
-	val |= 0x40800000;
-	writel(val, IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
+	/*
+	 * The L2 cache controller(PL310) version on the i.MX6D/Q is r3p1-50rel0
+	 * The L2 cache controller(PL310) version on the i.MX6DL/SOLO/SL is r3p2
+	 * But according to ARM PL310 errata: 752271
+	 * ID: 752271: Double linefill feature can cause data corruption
+	 * Fault Status: Present in: r3p0, r3p1, r3p1-50rel0. Fixed in r3p2
+	 * Workaround: The only workaround to this erratum is to disable the
+	 * double linefill feature. This is the default behavior.
+	 */
+	if (!cpu_is_mx6q()) {
+		val = readl(IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
+		val |= 0x40800000;
+		writel(val, IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
+	}
+
 	val = readl(IO_ADDRESS(L2_BASE_ADDR + L2X0_POWER_CTRL));
 	val |= L2X0_DYNAMIC_CLK_GATING_EN;
 	val |= L2X0_STNDBY_MODE_EN;
diff --git a/arch/arm/mach-mx6/msi.c b/arch/arm/mach-mx6/msi.c
new file mode 100644
index 0000000..096d1c2
--- /dev/null
+++ b/arch/arm/mach-mx6/msi.c
@@ -0,0 +1,151 @@
+/*
+ * arch/arm/mach-mx6/msi.c
+ *
+ * PCI MSI support for the imx processor
+ *
+ * Copyright (c) 2013 Boundary Devices.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <asm/bitops.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+#include "msi.h"
+
+
+#define IMX_NUM_MSI_IRQS 128
+static DECLARE_BITMAP(msi_irq_in_use, IMX_NUM_MSI_IRQS);
+
+static void imx_msi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	int i, j;
+	unsigned int status;
+	struct irq_chip *chip = irq_get_chip(irq);
+	unsigned int base_irq = IRQ_IMX_MSI_0;
+
+	chained_irq_enter(chip, desc);
+	for (i = 0; i < 8; i++) {
+		status = imx_pcie_msi_pending(i);
+		while (status) {
+			j = __fls(status);
+			generic_handle_irq(base_irq + j);
+			status &= ~(1 << j);
+		}
+		base_irq += 32;
+	}
+	chained_irq_exit(chip, desc);
+}
+
+/*
+* Dynamic irq allocate and deallocation
+*/
+int create_irq(void)
+{
+	int irq, pos;
+
+	do {
+		pos = find_first_zero_bit(msi_irq_in_use, IMX_NUM_MSI_IRQS);
+		if ((unsigned int)pos >= IMX_NUM_MSI_IRQS)
+			return -ENOSPC;
+		/* test_and_set_bit operates on 32-bits at a time */
+	} while (test_and_set_bit(pos, msi_irq_in_use));
+
+	irq = IRQ_IMX_MSI_0 + pos;
+	dynamic_irq_init(irq);
+	return irq;
+}
+
+void destroy_irq(unsigned int irq)
+{
+	int pos = irq - IRQ_IMX_MSI_0;
+
+	dynamic_irq_cleanup(irq);
+	clear_bit(pos, msi_irq_in_use);
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+static void imx_msi_irq_ack(struct irq_data *d)
+{
+	return;
+}
+
+static void imx_msi_irq_enable(struct irq_data *d)
+{
+	imx_pcie_enable_irq(d->irq - IRQ_IMX_MSI_0, 1);
+	return unmask_msi_irq(d);
+}
+
+static void imx_msi_irq_disable(struct irq_data *d)
+{
+	imx_pcie_enable_irq(d->irq - IRQ_IMX_MSI_0, 0);
+	return mask_msi_irq(d);
+}
+
+static void imx_msi_irq_mask(struct irq_data *d)
+{
+	imx_pcie_mask_irq(d->irq - IRQ_IMX_MSI_0, 1);
+	return mask_msi_irq(d);
+}
+
+static void imx_msi_irq_unmask(struct irq_data *d)
+{
+	imx_pcie_mask_irq(d->irq - IRQ_IMX_MSI_0, 0);
+	return unmask_msi_irq(d);
+}
+
+static struct irq_chip imx_msi_chip = {
+	.name = "PCIe-MSI",
+	.irq_ack = imx_msi_irq_ack,
+	.irq_enable = imx_msi_irq_enable,
+	.irq_disable = imx_msi_irq_disable,
+	.irq_mask = imx_msi_irq_mask,
+	.irq_unmask = imx_msi_irq_unmask,
+};
+
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int irq = create_irq();
+	struct msi_msg msg;
+
+	if (irq < 0)
+		return irq;
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_hi = 0x0;
+	msg.address_lo = MSI_MATCH_ADDR;
+	/* 16bits msg.data: set cpu type to the upper 8bits*/
+	msg.data = (mxc_cpu_type << 8) | ((irq - IRQ_IMX_MSI_0) & 0xFF);
+
+	write_msi_msg(irq, &msg);
+	irq_set_chip_and_handler(irq, &imx_msi_chip, handle_simple_irq);
+	set_irq_flags(irq, IRQF_VALID);
+	pr_info("IMX-PCIe: MSI 0x%04x @%#x:%#x, irq = %d\n",
+			msg.data, msg.address_hi,
+			msg.address_lo, irq);
+	return 0;
+}
+
+void imx_msi_init(void)
+{
+	irq_set_chained_handler(MXC_INT_PCIE_0, imx_msi_handler);
+}
diff --git a/arch/arm/mach-mx6/msi.h b/arch/arm/mach-mx6/msi.h
new file mode 100644
index 0000000..ce0e467
--- /dev/null
+++ b/arch/arm/mach-mx6/msi.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2013 Boundary Devices, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+extern void imx_pcie_enable_irq(unsigned pos, int set);
+void imx_pcie_mask_irq(unsigned pos, int set);
+unsigned imx_pcie_msi_pending(unsigned index);
+
+#define MSI_MATCH_ADDR  0x01FF8000
+
+void imx_msi_init(void);
diff --git a/arch/arm/mach-mx6/mx6_anatop_regulator.c b/arch/arm/mach-mx6/mx6_anatop_regulator.c
index b9413fd..83bd363 100644
--- a/arch/arm/mach-mx6/mx6_anatop_regulator.c
+++ b/arch/arm/mach-mx6/mx6_anatop_regulator.c
@@ -34,6 +34,7 @@
 #include <linux/clk.h>
 
 #include <mach/clock.h>
+#include <mach/system.h>
 
 #include "crm_regs.h"
 #include "regs-anadig.h"
@@ -58,6 +59,7 @@ static struct clk *gpu3d_clk, *gpu3d_shade_clk, *gpu2d_clk, *gpu2d_axi_clk;
 static struct clk *openvg_axi_clk, *vpu_clk;
 extern int external_pureg;
 extern struct regulator *pu_regulator;
+extern u32 enable_ldo_mode;
 
 
 static int get_voltage(struct anatop_regulator *sreg)
@@ -237,13 +239,12 @@ static int pu_enable(struct anatop_regulator *sreg)
 	reg = __raw_readl(ANA_MISC2_BASE_ADDR);
 	reg |= ANADIG_ANA_MISC2_REG1_BO_EN;
 	__raw_writel(reg, ANA_MISC2_BASE_ADDR);
-
-#ifndef CONFIG_MX6_INTER_LDO_BYPASS
-	/* Unmask the ANATOP brown out interrupt in the GPC. */
-	reg = __raw_readl(gpc_base + 0x14);
-	reg &= ~0x80000000;
-	__raw_writel(reg, gpc_base + 0x14);
-#endif
+	if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		/* Unmask the ANATOP brown out interrupt in the GPC. */
+		reg = __raw_readl(gpc_base + 0x14);
+		reg &= ~0x80000000;
+		__raw_writel(reg, gpc_base + 0x14);
+	}
 	pu_is_enabled = 1;
 	if (get_clk) {
 		if (!cpu_is_mx6sl()) {
@@ -281,12 +282,12 @@ static int pu_disable(struct anatop_regulator *sreg)
 	/* Wait for power down to complete. */
 	while (__raw_readl(gpc_base + GPC_CNTR_OFFSET) & 0x1)
 			;
-#ifndef CONFIG_MX6_INTER_LDO_BYPASS
-	/* Mask the ANATOP brown out interrupt in the GPC. */
-	reg = __raw_readl(gpc_base + 0x14);
-	reg |= 0x80000000;
-	__raw_writel(reg, gpc_base + 0x14);
-#endif
+	if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		/* Mask the ANATOP brown out interrupt in the GPC. */
+		reg = __raw_readl(gpc_base + 0x14);
+		reg |= 0x80000000;
+		__raw_writel(reg, gpc_base + 0x14);
+	}
 
 	if (external_pureg) {
 		/*disable extern PU regulator*/
diff --git a/arch/arm/mach-mx6/mx6_bt_rfkill.c b/arch/arm/mach-mx6/mx6_bt_rfkill.c
new file mode 100644
index 0000000..3b256e9
--- /dev/null
+++ b/arch/arm/mach-mx6/mx6_bt_rfkill.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file mx6_bt_rfkill.c
+ *
+ * @brief This driver is implement a rfkill control interface of bluetooth
+ * chip on i.MX serial boards. Register the power regulator function and
+ * reset function in platform data.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+#include <linux/init.h>
+#include <linux/rfkill.h>
+#include <mach/hardware.h>
+#include <mach/imx_rfkill.h>
+
+static int system_in_suspend;
+
+static int mxc_bt_set_block(void *rfkdata, bool blocked)
+{
+	struct imx_bt_rfkill_platform_data *data = rfkdata;
+	int ret;
+
+	/* Bluetooth stack will reset the bluetooth chip during
+	 * resume, since we keep bluetooth's power during suspend,
+	 * don't let rfkill to actually reset the chip. */
+	if (system_in_suspend)
+		return 0;
+	pr_info("rfkill: BT RF going to : %s\n", blocked ? "off" : "on");
+	if (!blocked)
+		ret = data->power_change(1);
+	else
+		ret = data->power_change(0);
+
+	return ret;
+}
+
+static const struct rfkill_ops mxc_bt_rfkill_ops = {
+	.set_block = mxc_bt_set_block,
+};
+
+static int mxc_bt_power_event(struct notifier_block *this,
+			      unsigned long event, void *dummy)
+{
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+		system_in_suspend = 1;
+		/* going to suspend, don't reset chip */
+		break;
+	case PM_POST_SUSPEND:
+		system_in_suspend = 0;
+		/* System is resume, can reset chip */
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block mxc_bt_power_notifier = {
+	.notifier_call = mxc_bt_power_event,
+};
+
+static int mxc_bt_rfkill_probe(struct platform_device *dev)
+{
+	int rc;
+	struct rfkill *rfk;
+
+	struct imx_bt_rfkill_platform_data *data = dev->dev.platform_data;
+
+	if (data->power_change == NULL) {
+		rc = -EINVAL;
+		dev_err(&dev->dev, "no power_change function\n");
+		goto error_check_func;
+	}
+
+	rc = register_pm_notifier(&mxc_bt_power_notifier);
+	if (rc)
+		goto error_check_func;
+
+	rfk = rfkill_alloc("mxc-bt", &dev->dev, RFKILL_TYPE_BLUETOOTH,
+			   &mxc_bt_rfkill_ops, data);
+
+	if (!rfk) {
+		rc = -ENOMEM;
+		goto error_rfk_alloc;
+	}
+
+	rc = rfkill_register(rfk);
+	if (rc)
+		goto error_rfkill;
+
+	platform_set_drvdata(dev, rfk);
+	printk(KERN_INFO "mxc_bt_rfkill driver success loaded\n");
+	return 0;
+
+error_rfkill:
+	rfkill_destroy(rfk);
+error_rfk_alloc:
+error_check_func:
+	return rc;
+}
+
+static int __devexit mxc_bt_rfkill_remove(struct platform_device *dev)
+{
+	struct imx_bt_rfkill_platform_data *data = dev->dev.platform_data;
+	struct rfkill *rfk = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	if (rfk) {
+		rfkill_unregister(rfk);
+		rfkill_destroy(rfk);
+	}
+
+	data->power_change(0);
+
+	return 0;
+}
+
+static struct platform_driver mxc_bt_rfkill_driver = {
+	.driver = {
+		.name = "mxc_bt_rfkill",
+	},
+	.probe	= mxc_bt_rfkill_probe,
+	.remove = __devexit_p(mxc_bt_rfkill_remove),
+};
+
+static int __init mxc_bt_rfkill_init(void)
+{
+	return platform_driver_register(&mxc_bt_rfkill_driver);
+}
+
+module_init(mxc_bt_rfkill_init);
+
+static void __exit mxc_bt_rfkill_exit(void)
+{
+	platform_driver_unregister(&mxc_bt_rfkill_driver);
+}
+
+module_exit(mxc_bt_rfkill_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("RFKill control interface of BT on MX6 Platform");
diff --git a/arch/arm/mach-mx6/mx6_ddr_freq.S b/arch/arm/mach-mx6/mx6_ddr_freq.S
index 19fb491..de20f0c 100644
--- a/arch/arm/mach-mx6/mx6_ddr_freq.S
+++ b/arch/arm/mach-mx6/mx6_ddr_freq.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -103,11 +103,24 @@ periph_clk_switch4:
 	cmp     r0, #0
 	bne     periph_clk_switch4
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround1
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround1
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0xA
 	str     r0, [r6, #0x1C]
+skip_gpt_workaround1:
 	.endm
 
 	.macro   switch_to_400MHz
@@ -193,12 +206,24 @@ wait_div_update400_2:
 	cmp     r0, #0
 	bne     wait_div_update400_2
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround2
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround2
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0xA
 	str     r0, [r6, #0x1C]
-
+skip_gpt_workaround2:
 	.endm
 
 	.macro   switch_to_50MHz
@@ -265,11 +290,24 @@ periph_clk_switch2:
 	cmp    r0, #0
 	bne     periph_clk_switch2
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround3
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround3
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0x1
 	str     r0, [r6, #0x1C]
+skip_gpt_workaround3:
 
 	.endm
 
@@ -311,11 +349,24 @@ wait_div_update:
 	cmp    r0, #0
 	bne     wait_div_update
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround4
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround4
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0x1
 	str     r0, [r6, #0x1C]
+skip_gpt_workaround4:
 
 	.endm
 
@@ -350,20 +401,6 @@ ddr_freq_change:
 
 	adr   r10, ddr_freq_change               @Address in this function.
 
-
-	mcr   p15, 0, r10, c8, c7, 1      @//@ Make sure freq code address
-	                                       @//  @ is not already in TLB.
-	mcr   p15, 0, r6, c8, c7, 1      @//@ Make sure CCM address
-	                                         @//@ is not already in TLB.
-	mcr   p15, 0, r5, c8, c7, 1      @//@ make sure MMDC address
-	                                         @//@ is not already in TLB.
-	mcr   p15, 0, r7, c8, c7, 1      @//@ make sure IOMUX address
-	                                         @//@ is not already in TLB.
-
-	mrc   p15, 0, r0, c10, c0, 0    @//@ Read the TLB lockdown register
-	orr    r0, r0, #1                    @//@ Set the Preserve bit.
-	mcr   p15, 0, r0, c10, c0, 0    @//@ Write to the lockdown register
-
 	ldr    r2, [r6]                        @ TLB will miss,
 	                                         @CCM address will be loaded
 	ldr    r2, [r5]                        @ TLB will miss,
@@ -372,18 +409,33 @@ ddr_freq_change:
 	                                         @IOMUX will be loaded
 
 	ldr    r2, [r8]                        @ Get the DDR settings.
-
 	ldr    r2, [r10]                        @ TLB will miss
-
 	ldr    r2, [r11]				@Get the IOMUX settings
 
-	mrc  p15, 0, r0, c10, c0, 0      @//@ Read the lockdown register
-	                                             @//@ (victim will be incremented)
-	bic   r0, r0, #1                     @//@ Clear the preserve bit
-	mcr   p15, 0, r0, c10, c0, 0     @//@ Write to the lockdown register
+	/* Make sure all the L1 & L2 buffers are drained, as
+	  * we don't want any writes to the DDR when it is
+	  * in self-refresh.
+	  */
+	/* Make sure the L1 buffers are drained. */
+	dsb
 
-	/* Disable automatic power saving. */
+#ifdef CONFIG_CACHE_L2X0
+	/* Make sure the L2 buffers are drained.
+	  * Sync operation on L2 drains the buffers.
+	  */
+	ldr      r0, =L2_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	mov    r1, #0x0
+	str      r1, [r0, #0x730]
+#endif
+
+     /* The second dsb might be needed to keep cache sync (device write)
+       * ordering with the memory accesses before it.
+       */
+	dsb
+	isb
 
+	/* Disable automatic power saving. */
 	ldr    r0, [r5, #0x404]
 	orr    r0, r0, #0x01
 	str    r0, [r5, #0x404]
diff --git a/arch/arm/mach-mx6/mx6_suspend.S b/arch/arm/mach-mx6/mx6_suspend.S
index f712700..e8642f8 100644
--- a/arch/arm/mach-mx6/mx6_suspend.S
+++ b/arch/arm/mach-mx6/mx6_suspend.S
@@ -1105,11 +1105,9 @@ set ddr iomux to low power mode
 	ldr	r1, =CCM_BASE_ADDR
 	add	r1, r1, #PERIPBASE_VIRT
 	ldr	r0, [r1]
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	ldr	r1, =ANATOP_BASE_ADDR
 	add	r1, r1, #PERIPBASE_VIRT
 	ldr	r0, [r1]
-#endif
 
 	/* Do a DSB to drain the buffers. */
 	dsb
@@ -1239,14 +1237,21 @@ rbc_loop:
 	cmp	r4, #0x0
 	bne	rbc_loop
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	/*if internal ldo(VDDARM) bypassed,analog bypass it for DSM(0x1e) and
+	*restore it when resume(0x1f).
+	*/
 	ldr	r1, =ANATOP_BASE_ADDR
 	add	r1, r1, #PERIPBASE_VIRT
 	ldr	r4, [r1, #0x140]
+	and	r4, r4, #0x1f
+	cmp	r4, #0x1f
+	bne	ldo_check_done1
+ldo_analog_bypass:
+	ldr	r4, [r1, #0x140]
 	bic	r4, r4, #0x1f
 	orr	r4, r4, #0x1e
 	str	r4, [r1, #0x140]
-#endif
+ldo_check_done1:
 /****************************************************************
 execute a wfi instruction to let SOC go into stop mode.
 ****************************************************************/
@@ -1261,14 +1266,18 @@ execute a wfi instruction to let SOC go into stop mode.
 if go here, means there is a wakeup irq pending, we should resume
 system immediately.
 ****************************************************************/
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	/*restore it with 0x1f if use ldo bypass mode.*/
 	ldr	r1, =ANATOP_BASE_ADDR
 	add	r1, r1, #PERIPBASE_VIRT
 	ldr	r3, [r1, #0x140]
+	and	r3, r3, #0x1f
+	cmp	r3, #0x1e
+	bne	ldo_check_done2
+ldo_bypass_restore:
+	ldr	r3, [r1, #0x140]
 	orr	r3, r3, #0x1f
 	str	r3, [r1, #0x140]
-#endif
-
+ldo_check_done2:
 	mov	r0, r2 		/* get suspend_iram_base */
 	add	r0, r0, #IRAM_SUSPEND_SIZE	/* 8K */
 
@@ -1387,19 +1396,23 @@ poll_dvfs_clear_1:
 	mcr	p15, 0, r1, c1, c0, 0
 
 	b 	out	/* exit standby */
+	.ltorg
 
 /****************************************************************
 when SOC exit stop mode, arm core restart from here, currently
 are running with MMU off.
 ****************************************************************/
 resume:
-
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	/*restore it with 0x1f if use ldo bypass mode.*/
 	ldr	r1, =ANATOP_BASE_ADDR
 	ldr	r3, [r1, #0x140]
+	and	r3, r3, #0x1f
+	cmp	r3, #0x1e
+	bne	ldo_check_done3
+	ldr	r3, [r1, #0x140]
 	orr	r3, r3, #0x1f
 	str	r3, [r1, #0x140]
-#endif
+ldo_check_done3:
 	/* Invalidate L1 I-cache first */
 	mov	r1,	#0x0
 	mcr	p15, 0, r1, c7, c5, 0	@ Invalidate I-Cache
diff --git a/arch/arm/mach-mx6/mx6q_sabreauto_pmic_pfuze100.c b/arch/arm/mach-mx6/mx6q_sabreauto_pmic_pfuze100.c
index 3987777..671233f 100644
--- a/arch/arm/mach-mx6/mx6q_sabreauto_pmic_pfuze100.c
+++ b/arch/arm/mach-mx6/mx6q_sabreauto_pmic_pfuze100.c
@@ -26,6 +26,7 @@
 #include <linux/mfd/pfuze.h>
 #include <linux/io.h>
 #include <mach/irqs.h>
+#include <mach/system.h>
 #include "crm_regs.h"
 #include "regs-anadig.h"
 #include "cpu_op-mx6.h"
@@ -57,16 +58,17 @@
 #define PFUZE100_SW1CCON_SPEED_M	(0x3<<6)
 
 extern u32 arm_max_freq;
+extern u32 enable_ldo_mode;
 
 static struct regulator_consumer_supply sw1a_consumers[] = {
 	{
-	 .supply = "P1V325_VDDARM_SW1AB",
+	 .supply = "VDDCORE",
 	 }
 };
 
 static struct regulator_consumer_supply sw1c_consumers[] = {
 	{
-	 .supply = "P1V325_VDDSOC_SW1C",
+	 .supply = "VDDSOC",
 	 }
 };
 
@@ -397,8 +399,12 @@ static struct regulator_init_data vgen6_init = {
 static int pfuze100_init(struct mc_pfuze *pfuze)
 {
 	int ret, i;
-	unsigned int reg;
 	unsigned char value;
+
+	/*use default mode(ldo bypass) if no param from cmdline*/
+	if (enable_ldo_mode == LDO_MODE_DEFAULT)
+		enable_ldo_mode = LDO_MODE_ENABLED;
+
 	/*read Device ID*/
 	ret = pfuze_reg_read(pfuze, PFUZE100_DEVICEID, &value);
 	if (ret)
@@ -441,39 +447,59 @@ static int pfuze100_init(struct mc_pfuze *pfuze)
 		}
 
 	}
+	/*use ldo active mode if use 1.2GHz,otherwise use ldo bypass mode*/
 	if (arm_max_freq == CPU_AT_1_2GHz) {
-		/*VDDARM_IN 1.475V*/
+			/*VDDARM_IN 1.425*/
 		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
 					PFUZE100_SW1AVOL_VSEL_M,
-					0x2f);
+					0x2d);
 		if (ret)
 			goto err;
-		/*VDDSOC_IN 1.475V*/
+		/*VDDSOC_IN 1.425V*/
 		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
 					PFUZE100_SW1CVOL_VSEL_M,
-					0x2f);
+					0x2d);
+		if (ret)
+			goto err;
+		enable_ldo_mode = LDO_MODE_ENABLED;
+	} else if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+		/*decrease VDDARM_IN/VDDSOC_IN,since we will use ldo bypass mode*/
+		/*VDDARM_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*VDDSOC_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*set SW1AB/1C DVSPEED as 25mV step each 4us,quick than 16us before.*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
+				    PFUZE100_SW1ACON_SPEED_M,
+				    PFUZE100_SW1ACON_SPEED_VAL);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
+				    PFUZE100_SW1CCON_SPEED_M,
+				    PFUZE100_SW1CCON_SPEED_VAL);
+		if (ret)
+			goto err;
+	} else if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		/*Increase VDDARM_IN/VDDSOC_IN to 1.375V in ldo active mode*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x2b);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x2b);
 		if (ret)
 			goto err;
-		/*set VDDSOC&VDDPU to 1.25V*/
-		reg = __raw_readl(ANADIG_REG_CORE);
-		reg &= ~BM_ANADIG_REG_CORE_REG2_TRG;
-		reg |= BF_ANADIG_REG_CORE_REG2_TRG(0x16);
-		reg &= ~BM_ANADIG_REG_CORE_REG1_TRG;
-		reg |= BF_ANADIG_REG_CORE_REG1_TRG(0x16);
-		__raw_writel(reg, ANADIG_REG_CORE);
-
 	}
-	/*set SW1AB/1C DVSPEED as 25mV step each 4us,quick than 16us before.*/
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
-			    PFUZE100_SW1ACON_SPEED_M,
-			    PFUZE100_SW1ACON_SPEED_VAL);
-	if (ret)
-		goto err;
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
-			    PFUZE100_SW1CCON_SPEED_M,
-			    PFUZE100_SW1CCON_SPEED_VAL);
-	if (ret)
-		goto err;
 	return 0;
 err:
 	printk(KERN_ERR "pfuze100 init error!\n");
diff --git a/arch/arm/mach-mx6/mx6q_sabresd_pmic_pfuze100.c b/arch/arm/mach-mx6/mx6q_sabresd_pmic_pfuze100.c
index 6b38bd0..c18a014 100644
--- a/arch/arm/mach-mx6/mx6q_sabresd_pmic_pfuze100.c
+++ b/arch/arm/mach-mx6/mx6q_sabresd_pmic_pfuze100.c
@@ -26,6 +26,7 @@
 #include <linux/mfd/pfuze.h>
 #include <linux/io.h>
 #include <mach/irqs.h>
+#include <mach/system.h>
 #include "crm_regs.h"
 #include "regs-anadig.h"
 #include "cpu_op-mx6.h"
@@ -57,8 +58,8 @@
 #define PFUZE100_SW1CCON_SPEED_M	(0x3<<6)
 
 extern u32 arm_max_freq;
+extern u32 enable_ldo_mode;
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 static struct regulator_consumer_supply sw1_consumers[] = {
 	{
 		.supply	   = "VDDCORE",
@@ -69,7 +70,6 @@ static struct regulator_consumer_supply sw1c_consumers[] = {
 		.supply	   = "VDDSOC",
 	},
 };
-#endif
 
 static struct regulator_consumer_supply sw2_consumers[] = {
 	{
@@ -152,10 +152,8 @@ static struct regulator_init_data sw1a_init = {
 			},
 	},
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
 	.consumer_supplies = sw1_consumers,
-#endif
 };
 
 static struct regulator_init_data sw1b_init = {
@@ -186,10 +184,8 @@ static struct regulator_init_data sw1c_init = {
 				.enabled = 1,
 			},
 	},
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.num_consumer_supplies = ARRAY_SIZE(sw1c_consumers),
 	.consumer_supplies = sw1c_consumers,
-#endif
 };
 
 static struct regulator_init_data sw2_init = {
@@ -390,8 +386,10 @@ static struct regulator_init_data vgen6_init = {
 static int pfuze100_init(struct mc_pfuze *pfuze)
 {
 	int ret, i;
-	unsigned int reg;
 	unsigned char value;
+	/*use default mode(ldo bypass) if no param from cmdline*/
+	if (enable_ldo_mode == LDO_MODE_DEFAULT)
+		enable_ldo_mode = LDO_MODE_BYPASSED;
 	/*read Device ID*/
 	ret = pfuze_reg_read(pfuze, PFUZE100_DEVICEID, &value);
 	if (ret)
@@ -434,40 +432,59 @@ static int pfuze100_init(struct mc_pfuze *pfuze)
 		}
 
 	}
-
+	/*use ldo active mode if use 1.2GHz,otherwise use ldo bypass mode*/
 	if (arm_max_freq == CPU_AT_1_2GHz) {
-		/*VDDARM_IN 1.475V*/
+			/*VDDARM_IN 1.425*/
 		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
 					PFUZE100_SW1AVOL_VSEL_M,
-					0x2f);
+					0x2d);
 		if (ret)
 			goto err;
-		/*VDDSOC_IN 1.475V*/
+		/*VDDSOC_IN 1.425V*/
 		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
 					PFUZE100_SW1CVOL_VSEL_M,
-					0x2f);
+					0x2d);
+		if (ret)
+			goto err;
+		enable_ldo_mode = LDO_MODE_ENABLED;
+	} else if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+		/*decrease VDDARM_IN/VDDSOC_IN,since we will use ldo bypass mode*/
+		/*VDDARM_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*VDDSOC_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*set SW1AB/1C DVSPEED as 25mV step each 4us,quick than 16us before.*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
+				    PFUZE100_SW1ACON_SPEED_M,
+				    PFUZE100_SW1ACON_SPEED_VAL);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
+				    PFUZE100_SW1CCON_SPEED_M,
+				    PFUZE100_SW1CCON_SPEED_VAL);
+		if (ret)
+			goto err;
+	} else if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		/*Increase VDDARM_IN/VDDSOC_IN to 1.375V in ldo active mode*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x2b);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x2b);
 		if (ret)
 			goto err;
-		/*set VDDSOC&VDDPU to 1.25V*/
-		reg = __raw_readl(ANADIG_REG_CORE);
-		reg &= ~BM_ANADIG_REG_CORE_REG2_TRG;
-		reg |= BF_ANADIG_REG_CORE_REG2_TRG(0x16);
-		reg &= ~BM_ANADIG_REG_CORE_REG1_TRG;
-		reg |= BF_ANADIG_REG_CORE_REG1_TRG(0x16);
-		__raw_writel(reg, ANADIG_REG_CORE);
-
 	}
-	/*set SW1AB/1C DVSPEED as 25mV step each 4us,quick than 16us before.*/
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
-			    PFUZE100_SW1ACON_SPEED_M,
-			    PFUZE100_SW1ACON_SPEED_VAL);
-	if (ret)
-		goto err;
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
-			    PFUZE100_SW1CCON_SPEED_M,
-			    PFUZE100_SW1CCON_SPEED_VAL);
-	if (ret)
-		goto err;
 	return 0;
 err:
 	printk(KERN_ERR "pfuze100 init error!\n");
diff --git a/arch/arm/mach-mx6/mx6sl_arm2_pmic_pfuze100.c b/arch/arm/mach-mx6/mx6sl_arm2_pmic_pfuze100.c
index 55a802b7..7cebb8f 100644
--- a/arch/arm/mach-mx6/mx6sl_arm2_pmic_pfuze100.c
+++ b/arch/arm/mach-mx6/mx6sl_arm2_pmic_pfuze100.c
@@ -25,6 +25,8 @@
 #include <linux/regulator/machine.h>
 #include <linux/mfd/pfuze.h>
 #include <mach/irqs.h>
+#include <mach/system.h>
+#include "cpu_op-mx6.h"
 
 /*
  * Convenience conversion.
@@ -47,9 +49,14 @@
 #define PFUZE100_SW1CCON		49
 #define PFUZE100_SW1CCON_SPEED_VAL	(0x1<<6)	/*default */
 #define PFUZE100_SW1CCON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW1AVOL       32
+#define PFUZE100_SW1AVOL_VSEL_M        (0x3f<<0)
+#define PFUZE100_SW1CVOL       46
+#define PFUZE100_SW1CVOL_VSEL_M        (0x3f<<0)
+extern u32 enable_ldo_mode;
+extern u32 arm_max_freq;
 
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 static struct regulator_consumer_supply sw1_consumers[] = {
 	{
 		.supply	   = "VDDCORE",
@@ -60,7 +67,6 @@ static struct regulator_consumer_supply sw1c_consumers[] = {
 		.supply	   = "VDDSOC",
 	},
 };
-#endif
 
 static struct regulator_consumer_supply sw2_consumers[] = {
 	{
@@ -143,10 +149,8 @@ static struct regulator_init_data sw1a_init = {
 				.enabled = 1,
 			},
 	},
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
 	.consumer_supplies = sw1_consumers,
-#endif
 };
 
 static struct regulator_init_data sw1b_init = {
@@ -177,10 +181,8 @@ static struct regulator_init_data sw1c_init = {
 				.enabled = 1,
 			},
 	},
-	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.num_consumer_supplies = ARRAY_SIZE(sw1c_consumers),
 	.consumer_supplies = sw1c_consumers,
-	#endif
 };
 
 static struct regulator_init_data sw2_init = {
@@ -383,8 +385,11 @@ static struct regulator_init_data vgen6_init = {
 static int pfuze100_init(struct mc_pfuze *pfuze)
 {
 	int ret, i;
-	unsigned int reg;
 	unsigned char value;
+
+	/*use default mode(ldo bypass) if no param from cmdline*/
+	if (enable_ldo_mode == LDO_MODE_DEFAULT)
+		enable_ldo_mode = LDO_MODE_BYPASSED;
 	/*read Device ID*/
 	ret = pfuze_reg_read(pfuze, PFUZE100_DEVICEID, &value);
 	if (ret)
@@ -427,17 +432,60 @@ static int pfuze100_init(struct mc_pfuze *pfuze)
 		}
 
 	}
-	/*set SW1AB/SW1C DVSPEED as 25mV step each 4us,quick than 16us before.*/
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
-			    PFUZE100_SW1ACON_SPEED_M,
-			    PFUZE100_SW1ACON_SPEED_VAL);
-	if (ret)
-		goto err;
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
-			    PFUZE100_SW1CCON_SPEED_M,
-			    PFUZE100_SW1CCON_SPEED_VAL);
-	if (ret)
-		goto err;
+	/*use ldo active mode if use 1.2GHz,otherwise use ldo bypass mode*/
+	if (arm_max_freq == CPU_AT_1_2GHz) {
+			/*VDDARM_IN 1.47*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x2f);
+		if (ret)
+			goto err;
+		/*VDDSOC_IN 1.475V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x2f);
+		if (ret)
+			goto err;
+		enable_ldo_mode = LDO_MODE_ENABLED;
+	} else if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+		/*decrease VDDARM_IN/VDDSOC_IN,since we will use dynamic ldo bypass
+		*mode or ldo bypass mode here.*/
+		/*VDDARM_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*VDDSOC_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*set SW1AB/SW1C DVSPEED as 25mV step each 4us,quick than 16us before.*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
+				    PFUZE100_SW1ACON_SPEED_M,
+				    PFUZE100_SW1ACON_SPEED_VAL);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
+				    PFUZE100_SW1CCON_SPEED_M,
+				    PFUZE100_SW1CCON_SPEED_VAL);
+		if (ret)
+			goto err;
+	} else if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		/*Increase VDDARM_IN/VDDSOC_IN to 1.375V in ldo active mode*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x2b);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x2b);
+		if (ret)
+			goto err;
+	}
 	return 0;
 err:
 	printk(KERN_ERR "pfuze100 init error!\n");
diff --git a/arch/arm/mach-mx6/mx6sl_ddr.S b/arch/arm/mach-mx6/mx6sl_ddr.S
index 3059f3a..9e83985 100644
--- a/arch/arm/mach-mx6/mx6sl_ddr.S
+++ b/arch/arm/mach-mx6/mx6sl_ddr.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -116,13 +116,6 @@ mmdc_podf0:
 
 	  .macro	ddr_switch_400MHz
 
-     /* Check if we are switching between
-       * 400Mhz <-> 50MHz. If so, we only need to
-       * update MMDC divider.
-       */
-      cmp    r1, #0
-      beq     change_divider_only
-
     /* Set MMDC divider first, in case PLL3 is at 480MHz. */
       ldr     r6, [r3, #0x10]
       and    r6, r6, #0x10000
@@ -141,6 +134,13 @@ mmdc_podf:
 
 pll3_in_bypass:
 
+     /* Check if we are switching between
+       * 400Mhz <-> 100MHz.If so, we should
+       * try to source MMDC from PLL2_200M.
+       */
+      cmp    r1, #0
+      beq     not_low_bus_freq
+
      /* Ensure that MMDC is sourced from PLL2 mux first. */
      ldr     r6, [r2, #0x14]
      bic     r6, r6, #0x4000000
@@ -151,6 +151,7 @@ periph2_clk_switch4:
      cmp     r6, #0
      bne     periph2_clk_switch4
 
+not_low_bus_freq:
      /* Now ensure periph2_clk2_sel mux is set to PLL3 */
      ldr     r6, [r2, #0x18]
      bic     r6, r6, #0x100000
@@ -166,6 +167,12 @@ periph2_clk_switch5:
      cmp     r6, #0
      bne     periph2_clk_switch5
 
+     /* Check if PLL2 is already unlocked.
+       * If so do nothing with PLL2.
+       */
+     cmp    r1, #0
+     beq	pll2_already_on
+
      /* Now power up PLL2 and unbypass it. */
      ldr    r6, [r3, #0x30]
      bic    r6, r6, #0x1000
@@ -192,27 +199,43 @@ wait_for_pll_lock:
      bic    r6, r6, #0x800000
      str     r6, [r3, #0x100]
 
+pll2_already_on:
     /* Now switch MMDC clk back to pll2_mux option. */
     /* Ensure pre_periph2_clk2 is set to pll2_pfd_400M */
+    /* If switching to audio DDR freq, set the
+     * pre_periph2_clk2 to PLL2_PFD_200M
+     */
+    ldr     r6, =400000000
+    cmp   r6, r0
+    bne    use_pll2_pfd_200M
+
      ldr     r6, [r2, #0x18]
      bic     r6, r6, #0x600000
      orr     r6, r6, #0x200000
      str     r6, [r2, #0x18]
+     ldr     r6, =400000000
+     b       cont2
 
-     ldr     r6, [r2, #0x14]
-     bic     r6, r6, #0x4000000
-     str     r6, [r2, #0x14]
+use_pll2_pfd_200M:
+     ldr     r6, [r2, #0x18]
+     orr     r6, r6, #0x600000
+     str     r6, [r2, #0x18]
+     ldr     r6, =200000000
+
+cont2:
+     ldr     r4, [r2, #0x14]
+     bic     r4, r4, #0x4000000
+     str     r4, [r2, #0x14]
 
 periph2_clk_switch6:
-     ldr     r6, [r2, #0x48]
-     cmp     r6, #0
+     ldr     r4, [r2, #0x48]
+     cmp     r4, #0
      bne     periph2_clk_switch6
 
 change_divider_only:
     /* Calculate the MMDC divider
      * based on the requested freq.
      */
-    ldr    r6, =400000000
     ldr    r4, =0
 Loop2:
     sub    r6, r6, r0
@@ -306,7 +329,7 @@ force_measure1:
  */
 ENTRY(mx6sl_ddr_iram)
 
-    push {r4, r5, r6, r7, r8, r9, r10 }
+    push {r4-r10}
 
 mx6sl_ddr_freq_change:
     ldr     r3, =ANATOP_BASE_ADDR
@@ -326,6 +349,21 @@ mx6sl_ddr_freq_change:
     ldr     r6, [r3]
     ldr     r6, [r2]
 
+     /* Drain all the L1 buffers. */
+     dsb
+
+#ifdef CONFIG_CACHE_L2X0
+    /* Need to make sure the buffers in L2 are drained.
+      * Performing a sync operation does this. */
+     ldr     r7, =L2_BASE_ADDR
+     add   r7, r7, #PERIPBASE_VIRT
+     mov  r6, #0x0
+     str    r6, [r7, #0x730]
+#endif
+
+     /* The second dsb might be needed to keep cache sync (device write)
+       * ordering with the memory accesses before it.
+       */
      dsb
      isb
 
@@ -421,7 +459,7 @@ skip_power_down:
      bic     r6, r6, #0x100
      str     r6, [r8, #0x410]
 
-    pop {r4,r5, r6, r7, r8, r9, r10}
+    pop {r4-r10}
 
     /* Restore registers */
     mov     pc, lr
diff --git a/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c b/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c
index bfd5faf..14bd33f 100644
--- a/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c
+++ b/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c
@@ -25,6 +25,8 @@
 #include <linux/regulator/machine.h>
 #include <linux/mfd/pfuze.h>
 #include <mach/irqs.h>
+#include <mach/system.h>
+#include "cpu_op-mx6.h"
 
 /*
  * Convenience conversion.
@@ -47,8 +49,13 @@
 #define PFUZE100_SW1CCON		49
 #define PFUZE100_SW1CCON_SPEED_VAL	(0x1<<6)	/*default */
 #define PFUZE100_SW1CCON_SPEED_M	(0x3<<6)
+#define PFUZE100_SW1AVOL       32
+#define PFUZE100_SW1AVOL_VSEL_M        (0x3f<<0)
+#define PFUZE100_SW1CVOL       46
+#define PFUZE100_SW1CVOL_VSEL_M        (0x3f<<0)
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+extern u32 enable_ldo_mode;
+extern u32 arm_max_freq;
 static struct regulator_consumer_supply sw1_consumers[] = {
 	{
 		.supply	   = "VDDCORE",
@@ -59,7 +66,6 @@ static struct regulator_consumer_supply sw1c_consumers[] = {
 		.supply	   = "VDDSOC",
 	},
 };
-#endif
 
 static struct regulator_consumer_supply sw2_consumers[] = {
 	{
@@ -146,10 +152,8 @@ static struct regulator_init_data sw1a_init = {
 				.enabled = 1,
 			},
 	},
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
 	.consumer_supplies = sw1_consumers,
-#endif
 };
 
 static struct regulator_init_data sw1b_init = {
@@ -180,10 +184,8 @@ static struct regulator_init_data sw1c_init = {
 				.enabled = 1,
 			},
 	},
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.num_consumer_supplies = ARRAY_SIZE(sw1c_consumers),
 	.consumer_supplies = sw1c_consumers,
-#endif
 };
 
 static struct regulator_init_data sw2_init = {
@@ -388,8 +390,10 @@ static struct regulator_init_data vgen6_init = {
 static int pfuze100_init(struct mc_pfuze *pfuze)
 {
 	int ret, i;
-	unsigned int reg;
 	unsigned char value;
+	/*use default mode(ldo bypass) if no param from cmdline*/
+	if (enable_ldo_mode == LDO_MODE_DEFAULT)
+		enable_ldo_mode = LDO_MODE_BYPASSED;
 	/*read Device ID*/
 	ret = pfuze_reg_read(pfuze, PFUZE100_DEVICEID, &value);
 	if (ret)
@@ -432,18 +436,61 @@ static int pfuze100_init(struct mc_pfuze *pfuze)
 		}
 
 	}
+	/*use ldo active mode if use 1.2GHz,otherwise use ldo bypass mode*/
+	if (arm_max_freq == CPU_AT_1_2GHz) {
+			/*VDDARM_IN 1.47*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x2f);
+		if (ret)
+			goto err;
+		/*VDDSOC_IN 1.475V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x2f);
+		if (ret)
+			goto err;
+		enable_ldo_mode = LDO_MODE_ENABLED;
+	} else if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+		/*decrease VDDARM_IN/VDDSOC_IN,since we will use dynamic ldo bypass
+		*mode or ldo bypass mode here.*/
+		/*VDDARM_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
+		/*VDDSOC_IN 1.3V*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x28);
+		if (ret)
+			goto err;
 
-	/*set SW1AB/SW1CDVSPEED as 25mV step each 4us,quick than 16us before.*/
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
-			    PFUZE100_SW1ACON_SPEED_M,
-			    PFUZE100_SW1ACON_SPEED_VAL);
-	if (ret)
-		goto err;
-	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
-			    PFUZE100_SW1CCON_SPEED_M,
-			    PFUZE100_SW1CCON_SPEED_VAL);
-	if (ret)
-		goto err;
+		/*set SW1AB/SW1CDVSPEED as 25mV step each 4us,quick than 16us before.*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
+				    PFUZE100_SW1ACON_SPEED_M,
+				    PFUZE100_SW1ACON_SPEED_VAL);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CCON,
+				    PFUZE100_SW1CCON_SPEED_M,
+				    PFUZE100_SW1CCON_SPEED_VAL);
+		if (ret)
+			goto err;
+	} else if (enable_ldo_mode != LDO_MODE_BYPASSED) {
+		/*Increase VDDARM_IN/VDDSOC_IN to 1.375V in ldo active mode*/
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1AVOL,
+					PFUZE100_SW1AVOL_VSEL_M,
+					0x2b);
+		if (ret)
+			goto err;
+		ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CVOL,
+					PFUZE100_SW1CVOL_VSEL_M,
+					0x2b);
+		if (ret)
+			goto err;
+	}
 	return 0;
 err:
 	printk(KERN_ERR "pfuze100 init error!\n");
diff --git a/arch/arm/mach-mx6/mx6sl_wfi.S b/arch/arm/mach-mx6/mx6sl_wfi.S
index 4ec97e4..bd5a00c 100644
--- a/arch/arm/mach-mx6/mx6sl_wfi.S
+++ b/arch/arm/mach-mx6/mx6sl_wfi.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -158,9 +158,11 @@ fifo_reset2_wait:
  */
 ENTRY(mx6sl_wait)
 
-    push {r4, r5, r6, r7, r8, r9, r10}
+    push {r4-r11}
 
 mx6sl_lpm_wfi:
+    mov    r11, r2
+
     /* Get the IRAM data storage address. */
     mov    r10, r1
     mov	r9, r1 		/* get suspend_iram_base */
@@ -192,7 +194,23 @@ mx6sl_lpm_wfi:
     ldr     r6, [r2]
     ldr     r6, [r1]
 
+     /* Drain all the L1 buffers. */
+     dsb
+
+#ifdef CONFIG_CACHE_L2X0
+    /* Need to make sure the buffers in L2 are drained.
+      * Performing a sync operation does this. */
+     ldr     r7, =L2_BASE_ADDR
+     add   r7, r7, #PERIPBASE_VIRT
+     mov  r6, #0x0
+     str    r6, [r7, #0x730]
+#endif
+
+     /* The second dsb might be needed to keep cache sync (device write)
+       * ordering with the memory accesses before it.
+       */
      dsb
+     isb
 
      /* Disable Automatic power savings. */
      ldr    r6, [r8, #0x404]
@@ -215,6 +233,9 @@ poll_dvfs_set_1:
      orr     r6, r6, #0x100
      str     r6, [r8, #0x410]
 
+     cmp      r11, #1
+     beq      audio_mode
+
      /* Now set DDR rate to 1MHz. */
      /* DDR is from bypassed PLL2 on periph2_clk2 path.
        * Set the periph2_clk2_podf to divide by 8.
@@ -228,6 +249,15 @@ poll_dvfs_set_1:
      bic    r6, r6, #0x38
      orr    r6, r6, #0x10
      str     r6, [r2, #0x14]
+     b       mmdc_podf
+
+audio_mode:
+     /* MMDC is from PLL2_200M.
+       * Set the mmdc_podf to div by 8.
+       */
+     ldr    r6, [r2, #0x14]
+     orr    r6, r6, #0x38
+     str     r6, [r2, #0x14]
 
     /* Loop till podf is accepted. */
 mmdc_podf:
@@ -238,6 +268,9 @@ mmdc_podf:
       /* Set the DDR IO in LPM state. */
      sl_ddr_io_set_lpm
 
+     cmp      r11, #1
+     beq      do_audio_arm_clk
+
      /* Check if none of the PLLs are
       * locked, except PLL1 which will get
       * bypassed below.
@@ -378,6 +411,30 @@ podf_loop:
      orr     r6, r6, #0x1
      str     r6, [r3, #0x150]
 
+     b      do_wfi
+
+do_audio_arm_clk:
+    /* ARM is from PLL2_PFD2_400M here.
+      * Switch ARM to bypassed PLL1.
+      */
+     ldr    r6, [r2, #0xC]
+     bic   r6, r6, #0x4
+     str   r6, [r2, #0xC]
+
+     /* Set the ARM_PODF to divide by 2
+      * as IPG is at 4MHz, we cannot run
+      * ARM_CLK above 9.6MHz when
+      * system enters WAIT mode.
+      */
+    ldr    r6, =0x2
+    str    r6, [r2, #0x10]
+
+    /* Loop till podf is accepted. */
+podf_loop_audio:
+     ldr     r6, [r2, #0x48]
+     cmp   r6, #0x0
+     bne   podf_loop_audio
+
 do_wfi:
      /* Now do WFI. */
      wfi
@@ -391,6 +448,9 @@ podf_loop1:
      cmp   r6, #0x0
      bne   podf_loop1
 
+     cmp    r11, #1
+     beq    audio_arm_clk_restore
+
       /* Check if powered down
         * analog components.
         */
@@ -473,12 +533,24 @@ ahb_podf1:
      cmp   r6, #0x0
      bne   podf_loop1
 
-    mov	r9, r10 		/* get suspend_iram_base */
+     b     wfi_restore
+
+audio_arm_clk_restore:
+     /* Move ARM back to PLL2_PFD2_400M */
+     ldr    r6, [r2, #0xC]
+     orr   r6, r6, #0x4
+     str   r6, [r2, #0xC]
+
+wfi_restore:
+     mov	r9, r10 		/* get suspend_iram_base */
      add	r9, r9, #IRAM_WAIT_SIZE	/* 4K */
 
     /* Restore the DDR IO before exiting self-refresh. */
      sl_ddr_io_restore
 
+     cmp     r11, #1
+     beq     mmdc_audio_restore
+
     /* Set MMDC back to 24MHz. */
     /* Set periph2_clk2_podf to divide by 1. */
      /* Now set MMDC PODF to divide by 1. */
@@ -486,6 +558,15 @@ ahb_podf1:
      bic   r6, r6, #0x3f
      str    r6, [r2, #0x14]
 
+     b     mmdc_podf1
+
+mmdc_audio_restore:
+     /* Set MMDC back to 100MHz. */
+     ldr    r6, [r2, #0x14]
+     bic   r6, r6, #0x38
+     orr   r6, r6, #0x8
+     str    r6, [r2, $0x14]
+
 mmdc_podf1:
      ldr     r6, [r2, #0x48]
      cmp   r6, #0x0
@@ -549,7 +630,7 @@ poll_dvfs_clear_1:
      str     r6, [r8, #0x410]
 
 
-    pop {r4,r5, r6, r7, r8, r9, r10}
+    pop {r4-r11}
 
     /* Restore registers */
     mov     pc, lr
diff --git a/arch/arm/mach-mx6/pcie.c b/arch/arm/mach-mx6/pcie.c
index f39dd3d..fa37e07 100644
--- a/arch/arm/mach-mx6/pcie.c
+++ b/arch/arm/mach-mx6/pcie.c
@@ -3,7 +3,7 @@
  *
  * PCIe host controller driver for IMX6 SOCs
  *
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Bits taken from arch/arm/mach-dove/pcie.c
  *
@@ -29,13 +29,19 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
+#include <linux/slab.h>
 #include <linux/platform_device.h>
+#include <linux/time.h>
 
 #include <mach/pcie.h>
 
 #include <asm/sizes.h>
+#include <asm/signal.h>
 
 #include "crm_regs.h"
+#ifdef CONFIG_PCI_MSI
+#include "msi.h"
+#endif
 
 /* Register Definitions */
 #define PRT_LOG_R_BaseAddress 0x700
@@ -66,29 +72,6 @@
 #define ATU_REGION_LOW_TRGT_ADDR_R (ATU_R_BaseAddress + 0x18)
 #define ATU_REGION_UP_TRGT_ADDR_R (ATU_R_BaseAddress + 0x1C)
 
-/* GPR1: iomuxc_gpr1_pcie_ref_clk_en(iomuxc_gpr1[16]) */
-#define iomuxc_gpr1_pcie_ref_clk_en		(1 << 16)
-/* GPR1: iomuxc_gpr1_test_powerdown(iomuxc_gpr1_18) */
-#define iomuxc_gpr1_test_powerdown		(1 << 18)
-
-/* GPR12: iomuxc_gpr12_los_level(iomuxc_gpr12[8:4]) */
-#define iomuxc_gpr12_los_level			(0x1F << 4)
-/* GPR12: iomuxc_gpr12_app_ltssm_enable(iomuxc_gpr12[10]) */
-#define iomuxc_gpr12_app_ltssm_enable		(1 << 10)
-/* GPR12: iomuxc_gpr12_device_type(iomuxc_gpr12[15:12]) */
-#define iomuxc_gpr12_device_type		(0xF << 12)
-
-/* GPR8: iomuxc_gpr8_tx_deemph_gen1(iomuxc_gpr8[5:0]) */
-#define iomuxc_gpr8_tx_deemph_gen1		(0x3F << 0)
-/* GPR8: iomuxc_gpr8_tx_deemph_gen2_3p5db(iomuxc_gpr8[11:6]) */
-#define iomuxc_gpr8_tx_deemph_gen2_3p5db	(0x3F << 6)
-/* GPR8: iomuxc_gpr8_tx_deemph_gen2_6db(iomuxc_gpr8[17:12]) */
-#define iomuxc_gpr8_tx_deemph_gen2_6db		(0x3F << 12)
-/* GPR8: iomuxc_gpr8_tx_swing_full(iomuxc_gpr8[24:18]) */
-#define iomuxc_gpr8_tx_swing_full		(0x7F << 18)
-/* GPR8: iomuxc_gpr8_tx_swing_low(iomuxc_gpr8[31:25]) */
-#define iomuxc_gpr8_tx_swing_low		(0x7F << 25)
-
 /* Registers of PHY */
 /* Register PHY_STS_R */
 /* PHY Status Register */
@@ -158,6 +141,18 @@
 #define LNK_CAP_RegisterResetValue 0x011cc12
 #define LNK_CAP_RegisterResetMask 0xffffffff
 
+#ifdef CONFIG_PCI_MSI
+#define PCIE_RC_MSI_CAP   0x50
+
+#define PCIE_PL_MSICA    0x820
+#define PCIE_PL_MSICUA    0x824
+#define PCIE_PL_MSIC_INT  0x828
+
+#define MSIC_INT_EN  0x0
+#define MSIC_INT_MASK  0x4
+#define MSIC_INT_STATUS  0x8
+#endif
+
 /* End of Register Definitions */
 
 #define PCIE_DBI_BASE_ADDR	(PCIE_ARB_END_ADDR - SZ_16K + 1)
@@ -167,6 +162,21 @@
 #define  PCIE_CONF_FUNC(f)		(((f) & 0x7) << 8)
 #define  PCIE_CONF_REG(r)		((r) & ~0x3)
 
+/*
+ * The default values of the RC's reserved ddr memory
+ * used to verify EP mode.
+ * BTW, here is the layout of the 1G ddr on SD boards
+ * 0x1000_0000 ~ 0x4FFF_FFFF
+ */
+static u32 rc_ddr_test_region = 0x40000000;
+static u32 rc_ddr_test_region_size = (SZ_16M - SZ_16K);
+
+#ifdef EP_SELF_IO_TEST
+static void *rc_ddr_test_reg1, *rc_ddr_test_reg2;
+static void __iomem *pcie_arb_base_addr;
+static struct timeval tv1, tv2, tv3;
+static u32 tv_count1, tv_count2;
+#endif
 static void __iomem *base;
 static void __iomem *dbi_base;
 
@@ -235,7 +245,7 @@ static int __init imx_pcie_setup(int nr, struct pci_sys_data *sys)
 	pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
 	pp->res[0].name = pp->io_space_name;
 	if (pp->index == 0) {
-		pp->res[0].start = PCIE_ARB_BASE_ADDR;
+		pp->res[0].start = PCIE_ARB_BASE_ADDR + SZ_16M - SZ_2M;
 		pp->res[0].end = pp->res[0].start + SZ_1M - 1;
 	}
 	pp->res[0].flags = IORESOURCE_IO;
@@ -251,7 +261,7 @@ static int __init imx_pcie_setup(int nr, struct pci_sys_data *sys)
 	pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
 	pp->res[1].name = pp->mem_space_name;
 	if (pp->index == 0) {
-		pp->res[1].start = PCIE_ARB_BASE_ADDR + SZ_1M;
+		pp->res[1].start = PCIE_ARB_BASE_ADDR;
 		pp->res[1].end = pp->res[1].start + SZ_16M - SZ_2M - 1;
 	}
 	pp->res[1].flags = IORESOURCE_MEM;
@@ -299,7 +309,7 @@ static int imx_pcie_link_up(void __iomem *dbi_base)
 					0x0000);
 		}
 
-		if ((iterations < 0))
+		if (iterations == 0)
 			pr_info("link up failed, DB_R0:0x%08x, DB_R1:0x%08x!\n"
 					, readl(dbi_base + DB_R0)
 					, readl(dbi_base + DB_R1));
@@ -310,8 +320,14 @@ static int imx_pcie_link_up(void __iomem *dbi_base)
 	return 1;
 }
 
-static void imx_pcie_regions_setup(void __iomem *dbi_base)
+static void imx_pcie_regions_setup(struct device *dev, void __iomem *dbi_base)
 {
+	struct imx_pcie_platform_data *pdata = dev->platform_data;
+#ifdef CONFIG_PCI_MSI
+	unsigned int i;
+	void __iomem *p = dbi_base + PCIE_PL_MSIC_INT;
+#endif
+
 	/*
 	 * i.MX6 defines 16MB in the AXI address map for PCIe.
 	 *
@@ -319,9 +335,13 @@ static void imx_pcie_regions_setup(void __iomem *dbi_base)
 	 * split and defined into different regions by iATU,
 	 * with sizes and offsets as follows:
 	 *
-	 * 0x0100_0000 --- 0x010F_FFFF 1MB IORESOURCE_IO
-	 * 0x0110_0000 --- 0x01EF_FFFF 14MB IORESOURCE_MEM
-	 * 0x01F0_0000 --- 0x01FF_FFFF 1MB Cfg + Registers
+	 * RC:
+	 * 0x0100_0000 --- 0x01DF_FFFF 14MB IORESOURCE_MEM
+	 * 0x01E0_0000 --- 0x01EF_FFFF 1MB IORESOURCE_IO
+	 * 0x01F0_0000 --- 0x01FF_FFFF 1MB Cfg + MSI + Registers
+	 *
+	 * EP (default value):
+	 * 0x0100_0000 --- 0x01FF_C000 16MB - 16KB IORESOURCE_MEM
 	 */
 
 	/* CMD reg:I/O space, MEM space, and Bus Master Enable */
@@ -331,43 +351,187 @@ static void imx_pcie_regions_setup(void __iomem *dbi_base)
 			| PCI_COMMAND_MASTER,
 			dbi_base + PCI_COMMAND);
 
-	/* Set the CLASS_REV of RC CFG header to PCI_CLASS_BRIDGE_PCI */
-	writel(readl(dbi_base + PCI_CLASS_REVISION)
-			| (PCI_CLASS_BRIDGE_PCI << 16),
-			dbi_base + PCI_CLASS_REVISION);
+	if (pdata->type_ep) {
+		/*
+		 * configure the class_rev(emaluate one memory ram ep device),
+		 * bar0 and bar1 of ep
+		 */
+		writel(0xdeadbeaf, dbi_base + PCI_VENDOR_ID);
+		writel(readl(dbi_base + PCI_CLASS_REVISION)
+				| (PCI_CLASS_MEMORY_RAM	<< 16),
+				dbi_base + PCI_CLASS_REVISION);
+		writel(0xdeadbeaf, dbi_base + PCI_SUBSYSTEM_VENDOR_ID);
+
+		/* 32bit none-prefetchable 8M bytes memory on bar0 */
+		writel(0x0, dbi_base + PCI_BASE_ADDRESS_0);
+		writel(SZ_8M - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_0);
+
+		/* None used bar1 */
+		writel(0x0, dbi_base + PCI_BASE_ADDRESS_1);
+		writel(0, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_1);
+
+		/* 4K bytes IO on bar2 */
+		writel(0x1, dbi_base + PCI_BASE_ADDRESS_2);
+		writel(SZ_4K - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_2);
+
+		/*
+		 * 32bit prefetchable 1M bytes memory on bar3
+		 * FIXME BAR MASK3 is not changable, the size
+		 * is fixed to 256 bytes.
+		 */
+		writel(0x8, dbi_base + PCI_BASE_ADDRESS_3);
+		writel(SZ_1M - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_3);
 
-	/*
-	 * region0 outbound used to access target cfg
-	 */
-	writel(0, dbi_base + ATU_VIEWPORT_R);
-	writel(PCIE_ARB_END_ADDR - SZ_1M + 1, dbi_base + ATU_REGION_LOWBASE_R);
-	writel(PCIE_ARB_END_ADDR, dbi_base + ATU_REGION_LIMIT_ADDR_R);
-	writel(0, dbi_base + ATU_REGION_UPBASE_R);
-
-	writel(0, dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
-	writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
-	writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
-	writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+		/*
+		 * 64bit prefetchable 1M bytes memory on bar4-5.
+		 * FIXME BAR4,5 are not enabled yet
+		 */
+		writel(0xc, dbi_base + PCI_BASE_ADDRESS_4);
+		writel(SZ_1M - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_4);
+		writel(0, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_5);
+
+		/*
+		 * region0 outbound used to access RC's reserved ddr memory
+		 */
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(PCIE_ARB_BASE_ADDR, dbi_base + ATU_REGION_LOWBASE_R);
+		writel(0, dbi_base + ATU_REGION_UPBASE_R);
+		writel(PCIE_ARB_BASE_ADDR + rc_ddr_test_region_size,
+				dbi_base + ATU_REGION_LIMIT_ADDR_R);
+
+		writel(rc_ddr_test_region,
+				dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
+		writel(MemRdWr, dbi_base + ATU_REGION_CTRL1_R);
+		writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+	} else {
+		/* Set the CLASS_REV of RC CFG header to PCI_CLASS_BRIDGE_PCI */
+		writel(readl(dbi_base + PCI_CLASS_REVISION)
+				| (PCI_CLASS_BRIDGE_PCI << 16),
+				dbi_base + PCI_CLASS_REVISION);
+
+		/*
+		 * region0 outbound used to access target cfg
+		 */
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(PCIE_ARB_END_ADDR - SZ_1M + 1,
+				dbi_base + ATU_REGION_LOWBASE_R);
+		writel(PCIE_ARB_END_ADDR - SZ_64K,
+				dbi_base + ATU_REGION_LIMIT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UPBASE_R);
+
+		writel(0, dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
+		writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
+		writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+	}
+
+#ifdef CONFIG_PCI_MSI
+	writel(MSI_MATCH_ADDR, dbi_base + PCIE_PL_MSICA);
+	writel(0, dbi_base + PCIE_PL_MSICUA);
+	for (i = 0; i < 8 ; i++) {
+		writel(0, p + MSIC_INT_EN);
+		writel(0xFFFFFFFF, p + MSIC_INT_MASK);
+		writel(0xFFFFFFFF, p + MSIC_INT_STATUS);
+		p += 12;
+	}
+#endif
 }
 
+#ifdef CONFIG_PCI_MSI
+void imx_pcie_mask_irq(unsigned int pos, int set)
+{
+	unsigned int mask = 1 << (pos & 0x1F);
+	unsigned int val, newval;
+	void __iomem *p;
+
+	p = dbi_base + PCIE_PL_MSIC_INT + MSIC_INT_MASK + ((pos >> 5) * 12);
+
+	if (pos >= (8 * 32))
+		return;
+	val = readl(p);
+	if (set)
+		newval = val | mask;
+	else
+		newval = val & ~mask;
+	if (val != newval)
+		writel(newval, p);
+}
+
+void imx_pcie_enable_irq(unsigned int pos, int set)
+{
+	unsigned int mask = 1 << (pos & 0x1F);
+	unsigned int val, newval;
+	void __iomem *p;
+
+	p = dbi_base + PCIE_PL_MSIC_INT + MSIC_INT_EN + ((pos >> 5) * 12);
+
+	/* RC: MSI CAP enable */
+	if (set) {
+		val = readl(dbi_base + PCIE_RC_MSI_CAP);
+		val |= (PCI_MSI_FLAGS_ENABLE << 16);
+		writel(val, dbi_base + PCIE_RC_MSI_CAP);
+	}
+
+	if (pos >= (8 * 32))
+		return;
+	val = readl(p);
+	if (set)
+		newval = val | mask;
+	else
+		newval = val & ~mask;
+	if (val != newval)
+		writel(newval, p);
+	if (set && (val != newval))
+		imx_pcie_mask_irq(pos, 0);  /* unmask when enabled */
+	}
+
+unsigned int imx_pcie_msi_pending(unsigned int index)
+{
+	unsigned int val, mask;
+	void __iomem *p = dbi_base + PCIE_PL_MSIC_INT + (index * 12);
+
+	if (index >= 8)
+		return 0;
+	val = readl(p + MSIC_INT_STATUS);
+	mask = readl(p + MSIC_INT_MASK);
+	val &= ~mask;
+	writel(val, p + MSIC_INT_STATUS);
+	return val;
+}
+#endif
+
 static int imx_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
 			int size, u32 *val)
 {
 	struct imx_pcie_port *pp = bus_to_port(bus->number);
 	u32 va_address;
 
+	/*  Added to change transaction TYPE  */
+	if (bus->number < 2) {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr1, dbi_base + ATU_REGION_CTRL1_R);
+	}
+
 	if (pp) {
 		if (devfn != 0) {
-			*val = 0xffffffff;
+			*val = 0xFFFFFFFF;
 			return PCIBIOS_DEVICE_NOT_FOUND;
 		}
 
 		va_address = (u32)dbi_base + (where & ~0x3);
-	} else
-		va_address = (u32)base + (PCIE_CONF_BUS(bus->number - 1) +
-					  PCIE_CONF_DEV(PCI_SLOT(devfn)) +
-					  PCIE_CONF_FUNC(PCI_FUNC(devfn)) +
-					  PCIE_CONF_REG(where));
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+
+		writel((((PCIE_CONF_BUS(bus->number)
+				+ PCIE_CONF_DEV(PCI_SLOT(devfn))
+				+ PCIE_CONF_FUNC(PCI_FUNC(devfn)))) << 8),
+				dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		va_address = (u32)base + PCIE_CONF_REG(where);
+	}
 
 	*val = readl(va_address);
 
@@ -386,16 +550,29 @@ static int imx_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
 	u32 va_address = 0, mask = 0, tmp = 0;
 	int ret = PCIBIOS_SUCCESSFUL;
 
+	/*  Added to change transaction TYPE  */
+	if (bus->number < 2) {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr1, dbi_base + ATU_REGION_CTRL1_R);
+	}
+
 	if (pp) {
 		if (devfn != 0)
 			return PCIBIOS_DEVICE_NOT_FOUND;
 
 		va_address = (u32)dbi_base + (where & ~0x3);
-	} else
-		va_address = (u32)base + (PCIE_CONF_BUS(bus->number - 1) +
-					  PCIE_CONF_DEV(PCI_SLOT(devfn)) +
-					  PCIE_CONF_FUNC(PCI_FUNC(devfn)) +
-					  PCIE_CONF_REG(where));
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+
+		writel((((PCIE_CONF_BUS(bus->number)
+				+ PCIE_CONF_DEV(PCI_SLOT(devfn))
+				+ PCIE_CONF_FUNC(PCI_FUNC(devfn)))) << 8),
+				dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		va_address = (u32)base + PCIE_CONF_REG(where);
+	}
 
 	if (size == 4) {
 		writel(val, va_address);
@@ -413,7 +590,6 @@ static int imx_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
 	tmp |= val << ((where & 0x3) * 8);
 	writel(tmp, va_address);
 exit:
-
 	return ret;
 }
 
@@ -439,7 +615,13 @@ imx_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 
 static int __init imx_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
-	return MXC_INT_PCIE_3;
+       switch (pin) {
+       case 1: return MXC_INT_PCIE_3;
+       case 2: return MXC_INT_PCIE_2;
+       case 3: return MXC_INT_PCIE_1;
+       case 4: return MXC_INT_PCIE_0;
+       default: return -1;
+       }
 }
 
 static struct hw_pci imx_pci __initdata = {
@@ -512,7 +694,7 @@ static int pcie_phy_cr_read(int addr , int *data)
 
 	/* after got ack return data */
 	temp_rd_data = readl(dbi_base + PHY_STS_R);
-	*data = (temp_rd_data & (0xffff << PCIE_CR_STAT_DATA_LOC)) ;
+	*data = (temp_rd_data & (0xFFFF << PCIE_CR_STAT_DATA_LOC)) ;
 
 	/* deassert rd signal */
 	temp_wr_data = 0x0;
@@ -595,18 +777,30 @@ static void imx_pcie_enable_controller(struct device *dev)
 	/* activate PCIE_PWR_EN */
 	gpio_direction_output(pdata->pcie_pwr_en, 1);
 
-	imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 0 << 18, IOMUXC_GPR1);
+	imx_pcie_clrset(IOMUXC_GPR1_TEST_POWERDOWN, 0 << 18, IOMUXC_GPR1);
+
 
 	/* enable the clks */
-	pcie_clk = clk_get(NULL, "pcie_clk");
-	if (IS_ERR(pcie_clk))
-		pr_err("no pcie clock.\n");
+	if (pdata->type_ep) {
+		pcie_clk = clk_get(NULL, "pcie_ep_clk");
+		if (IS_ERR(pcie_clk))
+			pr_err("no pcie_ep clock.\n");
 
-	if (clk_enable(pcie_clk)) {
-		pr_err("can't enable pcie clock.\n");
-		clk_put(pcie_clk);
+		if (clk_enable(pcie_clk)) {
+			pr_err("can't enable pcie_ep clock.\n");
+			clk_put(pcie_clk);
+		}
+	} else {
+		pcie_clk = clk_get(NULL, "pcie_clk");
+		if (IS_ERR(pcie_clk))
+			pr_err("no pcie clock.\n");
+
+		if (clk_enable(pcie_clk)) {
+			pr_err("can't enable pcie clock.\n");
+			clk_put(pcie_clk);
+		}
 	}
-	imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 1 << 16, IOMUXC_GPR1);
+	imx_pcie_clrset(IOMUXC_GPR1_PCIE_REF_CLK_EN, 1 << 16, IOMUXC_GPR1);
 }
 
 static void card_reset(struct device *dev)
@@ -644,8 +838,8 @@ static void __init add_pcie_port(void __iomem *base, void __iomem *dbi_base,
 		memset(pp->res, 0, sizeof(pp->res));
 	} else {
 		pr_info("IMX PCIe port: link down!\n");
-		/* Release the clocks, and disable the power */
 
+		/* Release the clocks, and disable the power */
 		pcie_clk = clk_get(NULL, "pcie_clk");
 		if (IS_ERR(pcie_clk))
 			pr_err("no pcie clock.\n");
@@ -653,7 +847,7 @@ static void __init add_pcie_port(void __iomem *base, void __iomem *dbi_base,
 		clk_disable(pcie_clk);
 		clk_put(pcie_clk);
 
-		imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 0 << 16,
+		imx_pcie_clrset(IOMUXC_GPR1_PCIE_REF_CLK_EN, 0 << 16,
 				IOMUXC_GPR1);
 
 		/* Disable PCIE power */
@@ -662,103 +856,278 @@ static void __init add_pcie_port(void __iomem *base, void __iomem *dbi_base,
 		/* activate PCIE_PWR_EN */
 		gpio_direction_output(pdata->pcie_pwr_en, 0);
 
-		imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 1 << 18,
+		imx_pcie_clrset(IOMUXC_GPR1_TEST_POWERDOWN, 1 << 18,
 				IOMUXC_GPR1);
 	}
 }
 
+/*  Added for PCI abort handling */
+static int imx6q_pcie_abort_handler(unsigned long addr,
+		unsigned int fsr, struct pt_regs *regs)
+{
+	/*
+	 * If it was an imprecise abort, then we need to correct the
+	 * return address to be _after_ the instruction.
+	 */
+	if (fsr & (1 << 10))
+		regs->ARM_pc += 4;
+	return 0;
+}
+
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+static ssize_t imx_pcie_rc_memw_info(struct device *dev,
+		struct device_attribute *devattr, char *buf)
+{
+	return sprintf(buf, "imx-pcie-rc-memw-info start 0x%08x, size 0x%08x\n",
+			rc_ddr_test_region, rc_ddr_test_region_size);
+}
+
+static ssize_t
+imx_pcie_rc_memw_start(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 memw_start;
+
+	sscanf(buf, "%x\n", &memw_start);
+
+	if (memw_start < 0x10000000) {
+		dev_err(dev, "Invalid memory start address.\n");
+		dev_info(dev, "For example: echo 0x41000000 > /sys/...");
+		return -1;
+	}
+
+	if (rc_ddr_test_region != memw_start) {
+		rc_ddr_test_region = memw_start;
+		/* Re-setup the iATU */
+		imx_pcie_regions_setup(dev, dbi_base);
+	}
+
+	return count;
+}
+
+static ssize_t
+imx_pcie_rc_memw_size(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 memw_size;
+
+	sscanf(buf, "%x\n", &memw_size);
+
+	if ((memw_size > (SZ_16M - SZ_16K)) || (memw_size < SZ_64K)) {
+		dev_err(dev, "Invalid, should be [SZ_64K,SZ_16M - SZ_16KB].\n");
+		dev_info(dev, "For example: echo 0x800000 > /sys/...");
+		return -1;
+	}
+
+	if (rc_ddr_test_region_size != memw_size) {
+		rc_ddr_test_region_size = memw_size;
+		/* Re-setup the iATU */
+		imx_pcie_regions_setup(dev, dbi_base);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(rc_memw_info, S_IRUGO, imx_pcie_rc_memw_info, NULL);
+static DEVICE_ATTR(rc_memw_start_set, S_IWUGO, NULL, imx_pcie_rc_memw_start);
+static DEVICE_ATTR(rc_memw_size_set, S_IWUGO, NULL, imx_pcie_rc_memw_size);
+
+static struct attribute *imx_pcie_attrs[] = {
+	/*
+	 * The start address, and the limitation (64KB ~ (16MB - 16KB))
+	 * of the ddr mem window reserved by RC, and used for EP to access.
+	 * BTW, these attrs are only configured at EP side.
+	 */
+	&dev_attr_rc_memw_info.attr,
+	&dev_attr_rc_memw_start_set.attr,
+	&dev_attr_rc_memw_size_set.attr,
+	NULL
+};
+
+static struct attribute_group imx_pcie_attrgroup = {
+	.attrs	= imx_pcie_attrs,
+};
+#endif
+
 static int __devinit imx_pcie_pltfm_probe(struct platform_device *pdev)
 {
+#ifdef EP_SELF_IO_TEST
+	int i;
+#endif
+	int ret = 0;
 	struct resource *mem;
 	struct device *dev = &pdev->dev;
 	struct imx_pcie_platform_data *pdata = dev->platform_data;
 
+	pr_info("iMX6 PCIe %s mode %s entering.\n",
+			pdata->type_ep ? "PCIe EP" : "PCIe RC", __func__);
+
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem) {
 		dev_err(dev, "no mmio space\n");
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+	/* add attributes for device */
+	ret = sysfs_create_group(&pdev->dev.kobj, &imx_pcie_attrgroup);
+	if (ret)
+		return -EINVAL;
+#endif
+
+	/*  Added for PCI abort handling */
+	hook_fault_code(16 + 6, imx6q_pcie_abort_handler, SIGBUS, 0,
+			"imprecise external abort");
+
 	base = ioremap_nocache(PCIE_ARB_END_ADDR - SZ_1M + 1, SZ_1M - SZ_16K);
 	if (!base) {
 		pr_err("error with ioremap in function %s\n", __func__);
-		return -EIO;
+		ret = PTR_ERR(base);
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+		sysfs_remove_group(&pdev->dev.kobj, &imx_pcie_attrgroup);
+#endif
+		return ret;
 	}
 
 	dbi_base = devm_ioremap(dev, mem->start, resource_size(mem));
 	if (!dbi_base) {
 		dev_err(dev, "can't map %pR\n", mem);
-		return -ENOMEM;
+		ret = PTR_ERR(dbi_base);
+		goto err_base;
 	}
 
 	/* FIXME the field name should be aligned to RM */
-	imx_pcie_clrset(iomuxc_gpr12_app_ltssm_enable, 0 << 10, IOMUXC_GPR12);
+	imx_pcie_clrset(IOMUXC_GPR12_APP_LTSSM_ENABLE, 0 << 10, IOMUXC_GPR12);
 
 	/* configure constant input signal to the pcie ctrl and phy */
-	imx_pcie_clrset(iomuxc_gpr12_device_type, PCI_EXP_TYPE_ROOT_PORT << 12,
-			IOMUXC_GPR12);
-	imx_pcie_clrset(iomuxc_gpr12_los_level, 9 << 4, IOMUXC_GPR12);
+	if (pdata->type_ep & 1)
+		/* EP */
+		imx_pcie_clrset(IOMUXC_GPR12_DEVICE_TYPE,
+				PCI_EXP_TYPE_ENDPOINT	<< 12, IOMUXC_GPR12);
+	else
+		/* RC */
+		imx_pcie_clrset(IOMUXC_GPR12_DEVICE_TYPE,
+				PCI_EXP_TYPE_ROOT_PORT << 12, IOMUXC_GPR12);
+	imx_pcie_clrset(IOMUXC_GPR12_LOS_LEVEL, 9 << 4, IOMUXC_GPR12);
 
-	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen1, 0 << 0, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen2_3p5db, 0 << 6, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen2_6db, 20 << 12, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_swing_full, 127 << 18, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_swing_low, 127 << 25, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_DEEMPH_GEN1, 0 << 0, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_DEEMPH_GEN2_3P5DB, 0 << 6, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_DEEMPH_GEN2_6DB, 20 << 12, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_SWING_FULL, 127 << 18, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_SWING_LOW, 127 << 25, IOMUXC_GPR8);
 
 	/* Enable the pwr, clks and so on */
 	imx_pcie_enable_controller(dev);
+	if (!(pdata->type_ep)) {
+		/*Only RC: togle the external card's reset */
+		card_reset(dev) ;
 
-	/* togle the external card's reset */
-	card_reset(dev) ;
-
-	usleep_range(3000, 4000);
-	imx_pcie_regions_setup(dbi_base);
-	usleep_range(3000, 4000);
+		imx_pcie_regions_setup(dev, dbi_base);
+	}
 
+	pr_info("PCIE: %s start link up.\n", __func__);
 	/* start link up */
-	imx_pcie_clrset(iomuxc_gpr12_app_ltssm_enable, 1 << 10, IOMUXC_GPR12);
-
-	/* add the pcie port */
-	add_pcie_port(base, dbi_base, pdata);
-
+	imx_pcie_clrset(IOMUXC_GPR12_APP_LTSSM_ENABLE, 1 << 10, IOMUXC_GPR12);
+
+	if (pdata->type_ep) {
+#ifdef EP_SELF_IO_TEST
+		/* Prepare the test regions and data */
+		rc_ddr_test_reg1 = kzalloc(rc_ddr_test_region_size, GFP_KERNEL);
+		if (!rc_ddr_test_reg1)
+			pr_err("PCIe EP: can't alloc the test region1.\n");
+
+		rc_ddr_test_reg2 = kzalloc(rc_ddr_test_region_size, GFP_KERNEL);
+		if (!rc_ddr_test_reg2) {
+			kfree(rc_ddr_test_reg1);
+			pr_err("PCIe EP: can't alloc the test region2.\n");
+		}
 
-	pci_common_init(&imx_pci);
-	return 0;
-}
+		pcie_arb_base_addr = ioremap_cached(PCIE_ARB_BASE_ADDR,
+				rc_ddr_test_region_size);
 
-static int __devexit imx_pcie_pltfm_remove(struct platform_device *pdev)
-{
-	struct clk *pcie_clk;
-	struct device *dev = &pdev->dev;
-	struct imx_pcie_platform_data *pdata = dev->platform_data;
-	struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!pcie_arb_base_addr) {
+			pr_err("error with ioremap in function %s\n", __func__);
+			ret = PTR_ERR(pcie_arb_base_addr);
+			kfree(rc_ddr_test_reg2);
+			kfree(rc_ddr_test_reg1);
+			goto err_base;
+		}
 
-	/* Release clocks, and disable power  */
-	pcie_clk = clk_get(NULL, "pcie_clk");
-	if (IS_ERR(pcie_clk))
-		pr_err("no pcie clock.\n");
+		for (i = 0; i < rc_ddr_test_region_size; i = i + 4) {
+			writel(0xE6600D00 + i, rc_ddr_test_reg1 + i);
+			writel(0xDEADBEAF, rc_ddr_test_reg2 + i);
+		}
+#endif
 
-	if (pcie_clk) {
-		clk_disable(pcie_clk);
-		clk_put(pcie_clk);
-	}
+		pr_info("PCIe EP: waiting for link up...\n");
+		/* link is debug bit 36 debug 1 start in bit 32 */
+		do {
+			usleep_range(10, 20);
+		} while ((readl(dbi_base + DB_R1) & 0x10) == 0);
+		/* Make sure that the PCIe link is up */
+		if (imx_pcie_link_up(dbi_base)) {
+			pr_info("PCIe EP: link up.\n");
+		} else {
+			pr_info("PCIe EP: ERROR link is down, exit!\n");
+#ifdef EP_SELF_IO_TEST
+			kfree(rc_ddr_test_reg2);
+			kfree(rc_ddr_test_reg1);
+			iounmap(pcie_arb_base_addr);
+#endif
+			goto err_link_down;
+		}
 
-	imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 0 << 16, IOMUXC_GPR1);
+		imx_pcie_regions_setup(dev, dbi_base);
+#ifdef EP_SELF_IO_TEST
+		/* PCIe EP start the data transfer after link up */
+		pr_info("PCIe EP: Starting data transfer...\n");
+		do_gettimeofday(&tv1);
+
+		memcpy((unsigned long *)pcie_arb_base_addr,
+				(unsigned long *)rc_ddr_test_reg1, 0xFFC000);
+
+		do_gettimeofday(&tv2);
+
+		memcpy((unsigned long *)rc_ddr_test_reg2,
+				(unsigned long *)pcie_arb_base_addr, 0xFFC000);
+
+		do_gettimeofday(&tv3);
+
+		if (memcmp(rc_ddr_test_reg2, rc_ddr_test_reg1, 0xFFC000) != 0) {
+			pr_info("PCIe EP: Data transfer is failed.\n");
+		} else {
+			tv_count1 = (tv2.tv_sec - tv1.tv_sec) * USEC_PER_SEC
+				+ tv2.tv_usec - tv1.tv_usec;
+			tv_count2 = (tv3.tv_sec - tv2.tv_sec) * USEC_PER_SEC
+				+ tv3.tv_usec - tv2.tv_usec;
+
+			pr_info("PCIe EP: Data transfer is successful."
+					"tv_count1 %dus, tv_count2 %dus.\n",
+					tv_count1, tv_count2);
+			pr_info("PCIe EP: Data write speed is %ldMB/s.\n",
+					((((0xFFC000/1024) * MSEC_PER_SEC)))
+					/(tv_count1));
+			pr_info("PCIe EP: Data read speed is %ldMB/s.\n",
+					((((0xFFC000/1024) * MSEC_PER_SEC)))
+					/(tv_count2));
+		}
+#endif
 
-	/* Disable PCIE power */
-	gpio_request(pdata->pcie_pwr_en, "PCIE POWER_EN");
+	} else {
+		/* add the pcie port */
+		add_pcie_port(base, dbi_base, pdata);
 
-	/* activate PCIE_PWR_EN */
-	gpio_direction_output(pdata->pcie_pwr_en, 0);
+		pci_common_init(&imx_pci);
+	}
+	return 0;
 
-	imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 1 << 18, IOMUXC_GPR1);
+err_link_down:
+	iounmap(dbi_base);
 
+err_base:
 	iounmap(base);
-	iounmap(dbi_base);
-	release_mem_region(iomem->start, resource_size(iomem));
-	platform_set_drvdata(pdev, NULL);
 
-	return 0;
+	return ret;
 }
 
 static struct platform_driver imx_pcie_pltfm_driver = {
@@ -767,7 +1136,6 @@ static struct platform_driver imx_pcie_pltfm_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= imx_pcie_pltfm_probe,
-	.remove		= __devexit_p(imx_pcie_pltfm_remove),
 };
 
 /*****************************************************************************\
diff --git a/arch/arm/mach-mx6/pm.c b/arch/arm/mach-mx6/pm.c
index 18b8de8..d9c04e1 100644
--- a/arch/arm/mach-mx6/pm.c
+++ b/arch/arm/mach-mx6/pm.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -79,10 +79,6 @@ static struct regulator *vdd3p0_regulator;
 static struct pm_platform_data *pm_data;
 
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-void mxc_cpufreq_suspend(void);
-void mxc_cpufreq_resume(void);
-#endif
 #if defined(CONFIG_CPU_FREQ)
 extern int set_cpu_freq(int wp);
 #endif
@@ -180,9 +176,8 @@ static void usb_power_up_handler(void)
 
 static void disp_power_down(void)
 {
-#if !defined(CONFIG_FB_MXC_ELCDIF_FB) && \
-    !defined(CONFIG_FB_MXC_ELCDIF_FB_MODULE)
-	if (cpu_is_mx6sl()) {
+	if (cpu_is_mx6sl() && (mx6sl_revision() >= IMX_CHIP_REVISION_1_2)) {
+
 		__raw_writel(0xFFFFFFFF, gpc_base + GPC_PGC_DISP_PUPSCR_OFFSET);
 		__raw_writel(0xFFFFFFFF, gpc_base + GPC_PGC_DISP_PDNSCR_OFFSET);
 
@@ -198,14 +193,11 @@ static void disp_power_down(void)
 			~MXC_CCM_CCGRx_CG1_MASK, MXC_CCM_CCGR3);
 
 	}
-#endif
 }
 
 static void disp_power_up(void)
 {
-#if !defined(CONFIG_FB_MXC_ELCDIF_FB) && \
-    !defined(CONFIG_FB_MXC_ELCDIF_FB_MODULE)
-	if (cpu_is_mx6sl()) {
+	if (cpu_is_mx6sl() && (mx6sl_revision() >= IMX_CHIP_REVISION_1_2)) {
 		/*
 		 * Need to enable EPDC/LCDIF pix clock, and
 		 * EPDC/LCDIF/PXP axi clock before power up.
@@ -221,7 +213,6 @@ static void disp_power_up(void)
 		__raw_writel(0x20, gpc_base + GPC_CNTR_OFFSET);
 		__raw_writel(0x1, gpc_base + GPC_PGC_DISP_SR_OFFSET);
 	}
-#endif
 }
 
 static void mx6_suspend_store(void)
@@ -316,9 +307,13 @@ static int mx6_suspend_enter(suspend_state_t state)
 	}
 	mx6_suspend_store();
 
-	/* i.MX6dl TO1.0 TKT094231: can't support ARM_POWER_OFF mode */
+	/*
+	 * i.MX6dl TO1.0/i.MX6dq TO1.1/1.0 TKT094231: can't support
+	 * ARM_POWER_OFF mode.
+	 */
 	if (state == PM_SUSPEND_MEM &&
-		(mx6dl_revision() == IMX_CHIP_REVISION_1_0)) {
+		((mx6dl_revision() == IMX_CHIP_REVISION_1_0) ||
+		(cpu_is_mx6q() && mx6q_revision() <= IMX_CHIP_REVISION_1_1))) {
 		state = PM_SUSPEND_STANDBY;
 	}
 
@@ -342,9 +337,15 @@ static int mx6_suspend_enter(suspend_state_t state)
 		return -EINVAL;
 	}
 
+	/*
+	 * L2 can exit by 'reset' or Inband beacon (from remote EP)
+	 * toggling phy_powerdown has same effect as 'inband beacon'
+	 * So, toggle bit18 of GPR1, to fix errata
+	 * "PCIe PCIe does not support L2 Power Down"
+	 */
+	__raw_writel(__raw_readl(IOMUXC_GPR1) | (1 << 18), IOMUXC_GPR1);
+
 	if (state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY) {
-		if (pm_data && pm_data->suspend_enter)
-			pm_data->suspend_enter();
 
 		local_flush_tlb_all();
 		flush_cache_all();
@@ -355,9 +356,15 @@ static int mx6_suspend_enter(suspend_state_t state)
 			save_gic_cpu_state(0, &gcs);
 		}
 
+		if (pm_data && pm_data->suspend_enter)
+			pm_data->suspend_enter();
+
 		suspend_in_iram(state, (unsigned long)iram_paddr,
 			(unsigned long)suspend_iram_base, cpu_type);
 
+		if (pm_data && pm_data->suspend_exit)
+			pm_data->suspend_exit();
+
 		/* Reset the RBC counter. */
 		/* All interrupts should be masked before the
 		  * RBC counter is reset.
@@ -397,12 +404,18 @@ static int mx6_suspend_enter(suspend_state_t state)
 		__raw_writel(BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG,
 			anatop_base + HW_ANADIG_ANA_MISC0_CLR);
 
-		if (pm_data && pm_data->suspend_exit)
-			pm_data->suspend_exit();
 	} else {
 			cpu_do_idle();
 	}
 
+	/*
+	 * L2 can exit by 'reset' or Inband beacon (from remote EP)
+	 * toggling phy_powerdown has same effect as 'inband beacon'
+	 * So, toggle bit18 of GPR1, to fix errata
+	 * "PCIe PCIe does not support L2 Power Down"
+	 */
+	__raw_writel(__raw_readl(IOMUXC_GPR1) & (~(1 << 18)), IOMUXC_GPR1);
+
 	return 0;
 }
 
@@ -434,23 +447,14 @@ static void mx6_suspend_finish(void)
 	}
 }
 
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 static int mx6_suspend_begin(suspend_state_t state)
 {
-	mxc_cpufreq_suspend();
 	return 0;
 }
-#endif
 
 /*
  * Called after devices are re-setup, but before processes are thawed.
  */
-static void mx6_suspend_end(void)
-{
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	mxc_cpufreq_resume();
-#endif
-}
 
 static int mx6_pm_valid(suspend_state_t state)
 {
@@ -459,13 +463,10 @@ static int mx6_pm_valid(suspend_state_t state)
 
 struct platform_suspend_ops mx6_suspend_ops = {
 	.valid = mx6_pm_valid,
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	.begin = mx6_suspend_begin,
-#endif
 	.prepare = mx6_suspend_prepare,
 	.enter = mx6_suspend_enter,
 	.finish = mx6_suspend_finish,
-	.end = mx6_suspend_end,
 };
 
 static int __devinit mx6_pm_probe(struct platform_device *pdev)
diff --git a/arch/arm/mach-mx6/regs-anadig.h b/arch/arm/mach-mx6/regs-anadig.h
index 773a43d..b1d1645 100644
--- a/arch/arm/mach-mx6/regs-anadig.h
+++ b/arch/arm/mach-mx6/regs-anadig.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -622,7 +622,8 @@
 #define BF_ANADIG_ANA_MISC0_OSC_I(v)  \
 	(((v) << 14) & BM_ANADIG_ANA_MISC0_OSC_I)
 #define BM_ANADIG_ANA_MISC0_RTC_RINGOSC_EN 0x00002000
-#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG 0x00001000
+#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG \
+	(cpu_is_mx6sl() ? 0x00000800 : 0x00001000)
 #define BP_ANADIG_ANA_MISC0_RSVD0      10
 #define BM_ANADIG_ANA_MISC0_RSVD0 0x00000C00
 #define BF_ANADIG_ANA_MISC0_RSVD0(v)  \
diff --git a/arch/arm/mach-mx6/system.c b/arch/arm/mach-mx6/system.c
index 6d24f22..ff1feda 100644
--- a/arch/arm/mach-mx6/system.c
+++ b/arch/arm/mach-mx6/system.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,10 +57,12 @@ volatile unsigned int num_cpu_idle;
 volatile unsigned int num_cpu_idle_lock = 0x0;
 int wait_mode_arm_podf;
 int cur_arm_podf;
+bool enet_is_active;
 void arch_idle_with_workaround(int cpu);
 
 extern void *mx6sl_wfi_iram_base;
-extern void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr);
+extern void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr, \
+			int audio_mode);
 extern void mx6_wait(void *num_cpu_idle_lock, void *num_cpu_idle, \
 				int wait_arm_podf, int cur_arm_podf);
 extern bool enable_wait_mode;
@@ -80,6 +82,22 @@ void gpc_set_wakeup(unsigned int irq[4])
 	return;
 }
 
+void gpc_mask_single_irq(int irq, bool enable)
+{
+	void __iomem *reg;
+	u32 val;
+
+	reg = gpc_base + 0x8 + (irq / 32 - 1) * 4;
+	val = __raw_readl(reg);
+	if (enable)
+		val |= 1 << (irq % 32);
+	else
+		val &= ~(1 << (irq % 32));
+	__raw_writel(val, reg);
+
+	return;
+}
+
 /* set cpu low power mode before WFI instruction */
 void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 {
@@ -89,6 +107,18 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	u32 ccm_clpcr, anatop_val;
 
 	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	/*
+	 * CCM state machine has restriction that, everytime enable
+	 * LPM mode, we need to make sure last wakeup from LPM mode
+	 * is a dsm_wakeup_signal, which means the wakeup source
+	 * must be seen by GPC, then CCM will clean its state machine
+	 * and re-sample necessary signal to decide whether it can
+	 * enter LPM mode. Here we use the forever pending irq #125,
+	 * unmask it before we enable LPM mode and mask it after LPM
+	 * is enabled, this flow will make sure CCM state machine in
+	 * reliable state before we enter LPM mode.
+	 */
+	gpc_mask_single_irq(MXC_INT_CHEETAH_PARITY, false);
 
 	switch (mode) {
 	case WAIT_CLOCKED:
@@ -147,6 +177,7 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		break;
 	default:
 		printk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);
+		gpc_mask_single_irq(MXC_INT_CHEETAH_PARITY, true);
 		return;
 	}
 
@@ -232,7 +263,7 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 			  */
 			reg = __raw_readl(MXC_CCM_CGPR);
 			reg |= MXC_CCM_CGPR_MEM_IPG_STOP_MASK;
-			if (!cpu_is_mx6sl()) {
+			if (!cpu_is_mx6sl() && stop_mode >= 2) {
 				/*
 				  * For MX6QTO1.2 or later and MX6DLTO1.1 or later,
 				  * ensure that the CCM_CGPR bit 17 is cleared before
@@ -244,6 +275,7 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		}
 	}
 	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	gpc_mask_single_irq(MXC_INT_CHEETAH_PARITY, true);
 }
 
 extern int tick_broadcast_oneshot_active(void);
@@ -275,8 +307,8 @@ void arch_idle_single_core(void)
 			if ((mmdc_ch0_axi != NULL))
 				ddr_usecount = clk_get_usecount(mmdc_ch0_axi);
 
-			if (cpu_is_mx6sl() && low_bus_freq_mode
-				&& ddr_usecount == 1) {
+			if (cpu_is_mx6sl() && (ddr_usecount == 1)  &&
+				(low_bus_freq_mode || audio_bus_freq_mode)) {
 				/* In this mode PLL2 i already in bypass,
 				  * ARM is sourced from PLL1. The code in IRAM
 				  * will set ARM to be sourced from STEP_CLK
@@ -289,7 +321,8 @@ void arch_idle_single_core(void)
 				  * we can lower DDR freq.
 				  */
 				mx6sl_wfi_iram(org_arm_podf,
-					(unsigned long)mx6sl_wfi_iram_base);
+					(unsigned long)mx6sl_wfi_iram_base,
+					audio_bus_freq_mode);
 			} else {
 				/* Need to set ARM to run at 24MHz since IPG
 				  * is at 12MHz. This is valid for audio mode on
@@ -350,7 +383,7 @@ void arch_idle_single_core(void)
 	}
 }
 
-void arch_idle_with_workaround(cpu)
+void arch_idle_with_workaround(int cpu)
 {
 	u32 podf = wait_mode_arm_podf;
 
@@ -369,18 +402,10 @@ void arch_idle_with_workaround(cpu)
 
 }
 
-void arch_idle_multi_core(void)
+void arch_idle_multi_core(int cpu)
 {
 	u32 reg;
-	int cpu = smp_processor_id();
-
-#ifdef CONFIG_LOCAL_TIMERS
-	if (!tick_broadcast_oneshot_active()
-		|| !tick_oneshot_mode_active())
-		return;
 
-	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
-#endif
 	/* iMX6Q and iMX6DL */
 	if ((cpu_is_mx6q() && chip_rev >= IMX_CHIP_REVISION_1_2) ||
 		(cpu_is_mx6dl() && chip_rev >= IMX_CHIP_REVISION_1_1)) {
@@ -398,24 +423,37 @@ void arch_idle_multi_core(void)
 		ca9_do_idle();
 	} else
 		arch_idle_with_workaround(cpu);
-#ifdef CONFIG_LOCAL_TIMERS
-	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);
-#endif
-
 }
 
 void arch_idle(void)
 {
+	int cpu = smp_processor_id();
+
 	if (enable_wait_mode) {
-		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+#ifdef CONFIG_LOCAL_TIMERS
+		if (!tick_broadcast_oneshot_active()
+			|| !tick_oneshot_mode_active())
+			return;
+
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
+#endif
+		if (enet_is_active)
+			/* Don't allow the chip to enter WAIT mode if enet is active
+			  * and the GPIO workaround for ENET interrupts is not used,
+			  * since all ENET interrupts donot wake up the SOC.
+			  */
+			mxc_cpu_lp_set(WAIT_CLOCKED);
+		else
+			mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
 		if (mem_clk_on_in_wait) {
 			u32 reg;
 			/*
 			  * MX6SL, MX6Q (TO1.2 or later) and
-			  * MX6DL (TO1.1 or later) have a bit in CCM_CGPR that
-			  * when cleared keeps the clocks to memories ON
-			  * when ARM is in WFI. This mode can be used when
-			  * IPG clock is very low (12MHz) and the ARM:IPG ratio
+			  * MX6DL (TO1.1 or later) have a bit in
+			  * CCM_CGPR that when cleared keeps the
+			  * clocks to memories ON when ARM is in WFI.
+			  * This mode can be used when IPG clock is
+			  * very low (12MHz) and the ARM:IPG ratio
 			  * perhaps cannot be maintained.
 			  */
 			reg = __raw_readl(MXC_CCM_CGPR);
@@ -427,8 +465,11 @@ void arch_idle(void)
 			/* iMX6SL or iMX6DLS */
 			arch_idle_single_core();
 		else
-			arch_idle_multi_core();
-	} else {
+			arch_idle_multi_core(cpu);
+#ifdef CONFIG_LOCAL_TIMERS
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);
+#endif
+	}  else {
 		mxc_cpu_lp_set(WAIT_CLOCKED);
 		ca9_do_idle();
 	}
@@ -563,7 +604,7 @@ void mxc_clear_mfgmode(void)
 #endif
 
 #ifdef CONFIG_MXC_REBOOT_ANDROID_CMD
-/* This function will set a bit on SRC_GPR10[7-8] bits to enter
+/* This function will set a bit on SNVS_LPGPR[7-8] bits to enter
  * special boot mode.  These bits will not clear by watchdog reset, so
  * it can be checked by bootloader to choose enter different mode.*/
 
@@ -574,18 +615,18 @@ void do_switch_recovery(void)
 {
 	u32 reg;
 
-	reg = __raw_readl(SRC_BASE_ADDR + SRC_GPR10);
+	reg = __raw_readl(MX6Q_SNVS_BASE_ADDR + SNVS_LPGPR);
 	reg |= ANDROID_RECOVERY_BOOT;
-	__raw_writel(reg, SRC_BASE_ADDR + SRC_GPR10);
+	__raw_writel(reg, MX6Q_SNVS_BASE_ADDR + SNVS_LPGPR);
 }
 
 void do_switch_fastboot(void)
 {
 	u32 reg;
 
-	reg = __raw_readl(SRC_BASE_ADDR + SRC_GPR10);
+	reg = __raw_readl(MX6Q_SNVS_BASE_ADDR + SNVS_LPGPR);
 	reg |= ANDROID_FASTBOOT_BOOT;
-	__raw_writel(reg, SRC_BASE_ADDR + SRC_GPR10);
+	__raw_writel(reg, MX6Q_SNVS_BASE_ADDR + SNVS_LPGPR);
 }
 #endif
 
diff --git a/arch/arm/mach-mx6/usb.h b/arch/arm/mach-mx6/usb.h
index f796e7d..b57104b 100644
--- a/arch/arm/mach-mx6/usb.h
+++ b/arch/arm/mach-mx6/usb.h
@@ -27,8 +27,6 @@ extern int fsl_usb_host_init(struct platform_device *pdev);
 extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
 extern int gpio_usbotg_utmi_active(void);
 extern void gpio_usbotg_utmi_inactive(void);
-
-extern void __init mx6_usb_dr_init(void);
 extern bool usb_icbug_swfix_need(void);
 extern void __init mx6_usb_h2_init(void);
 extern void __init mx6_usb_h3_init(void);
@@ -38,7 +36,8 @@ extern void mx6_set_host3_vbus_func(driver_vbus_func);
 extern void mx6_set_host2_vbus_func(driver_vbus_func);
 extern void mx6_set_host1_vbus_func(driver_vbus_func);
 extern void mx6_set_otghost_vbus_func(driver_vbus_func);
-extern void mx6_set_usb_host1_vbus_func(driver_vbus_func *driver_vbus);
+extern void mx6_get_otghost_vbus_func(driver_vbus_func *driver_vbus);
+extern void mx6_get_host1_vbus_func(driver_vbus_func *driver_vbus);
 extern struct platform_device anatop_thermal_device;
 extern struct platform_device mxc_usbdr_otg_device;
 extern struct platform_device mxc_usbdr_udc_device;
@@ -73,3 +72,13 @@ extern void __iomem *imx_otg_base;
 		.iobase = soc ## _USB_ ## hs ## _BASE_ADDR, 	\
 		.irq = soc ## _INT_USB_ ## hs,				\
       }
+#define imx_fsl_usb2_otg_data_entry_single(soc)				\
+		  {					\
+			  .iobase = soc ## _USB_OTG_BASE_ADDR,  \
+			  .irq = soc ## _INT_USB_OTG,			  \
+		  }
+#define imx_fsl_usb2_udc_data_entry_single(soc) \
+		  {				\
+			  .iobase = soc ## _USB_OTG_BASE_ADDR, \
+			  .irq = soc ## _INT_USB_OTG,			  \
+		  }
diff --git a/arch/arm/mach-mx6/usb_dr.c b/arch/arm/mach-mx6/usb_dr.c
index 7b79d98..40bb978 100644
--- a/arch/arm/mach-mx6/usb_dr.c
+++ b/arch/arm/mach-mx6/usb_dr.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -35,6 +35,10 @@ static void usbotg_uninit_ext(struct platform_device *pdev);
 static void usbotg_clock_gate(bool on);
 static void _dr_discharge_line(bool enable);
 extern bool usb_icbug_swfix_need(void);
+static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, \
+								bool enable);
+static u32 wakeup_irq_enable_src; /* only useful at otg mode */
+static u32 low_power_enable_src; /* only useful at otg mode */
 
 /* The usb_phy1_clk do not have enable/disable function at clock.c
  * and PLL output for usb1's phy should be always enabled.
@@ -63,6 +67,7 @@ static struct fsl_usb2_platform_data dr_utmi_config = {
 	.transceiver       = "utmi",
 	.phy_regs = USB_PHY0_BASE_ADDR,
 	.dr_discharge_line = _dr_discharge_line,
+	.lowpower	   = true, /* Default driver low power is true */
 };
 
 /* Platform data for wakeup operation */
@@ -72,51 +77,6 @@ static struct fsl_usb2_wakeup_platform_data dr_wakeup_config = {
 	.usb_wakeup_exhandle = usbotg_wakeup_event_clear,
 };
 
-static void fsl_platform_otg_set_usb_phy_dis(
-		struct fsl_usb2_platform_data *pdata, bool enable)
-{
-	u32 usb_phy_ctrl_dcdt = 0;
-	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
-	usb_phy_ctrl_dcdt = __raw_readl(
-			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
-			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
-	if (enable) {
-		if (usb_phy_ctrl_dcdt == 0) {
-			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
-					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_CLR);
-
-			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
-					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_SET);
-
-			udelay(300);
-
-			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
-				MX6_IO_ADDRESS(pdata->phy_regs)
-				+ HW_USBPHY_CTRL_SET);
-
-			UOG_USBSTS |= (1 << 7);
-
-			while ((UOG_USBSTS & (1 << 7)) == 0)
-				;
-
-			udelay(2);
-
-			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
-					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_CLR);
-
-			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
-					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
-
-		}
-	} else {
-		if (usb_phy_ctrl_dcdt
-				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
-			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
-				MX6_IO_ADDRESS(pdata->phy_regs)
-				+ HW_USBPHY_CTRL_CLR);
-	}
-}
-
 static void usbotg_internal_phy_clock_gate(bool on)
 {
 	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
@@ -141,6 +101,16 @@ static int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
 	UOG_USBCMD |= UCMD_RESET;
 	while ((UOG_USBCMD) & (UCMD_RESET))
 		;
+
+	/*
+	 * If the controller reset does not put the PHY be out of
+	 * low power mode, do it manually.
+	 */
+	if (UOG_PORTSC1 & PORTSC_PHCD) {
+		UOG_PORTSC1 &= ~PORTSC_PHCD;
+		mdelay(1);
+	}
+
 	/* Reset USBPHY module */
 	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
 	tmp = __raw_readl(phy_ctrl);
@@ -186,12 +156,18 @@ static int usbotg_init_ext(struct platform_device *pdev)
 
 	ret = usbotg_init(pdev);
 	if (ret) {
+		clk_disable(usb_oh3_clk);
+		clk_put(usb_oh3_clk);
+		clk_disable(usb_phy1_clk);
+		clk_put(usb_phy1_clk);
 		printk(KERN_ERR "otg init fails......\n");
 		return ret;
 	}
 	if (!otg_used) {
-		usbotg_internal_phy_clock_gate(true);
+		wakeup_irq_enable_src = 0;
+		low_power_enable_src = 0;
 		usb_phy_enable(pdev->dev.platform_data);
+		enter_phy_lowpower_suspend(pdev->dev.platform_data, false);
 		/*after the phy reset,can not read the readingvalue for id/vbus at
 		* the register of otgsc ,cannot  read at once ,need delay 3 ms
 		*/
@@ -204,16 +180,11 @@ static int usbotg_init_ext(struct platform_device *pdev)
 
 static void usbotg_uninit_ext(struct platform_device *pdev)
 {
-	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-
-	clk_disable(usb_phy1_clk);
-	clk_put(usb_phy1_clk);
-
-	clk_disable(usb_oh3_clk);
-	clk_put(usb_oh3_clk);
-
-	usbotg_uninit(pdata);
 	otg_used--;
+	if (!otg_used) {
+		clk_put(usb_phy1_clk);
+		clk_put(usb_oh3_clk);
+	}
 }
 
 static void usbotg_clock_gate(bool on)
@@ -236,10 +207,6 @@ static void dr_platform_phy_power_on(void)
 				anatop_base_addr + HW_ANADIG_ANA_MISC0_SET);
 }
 
-void mx6_set_otghost_vbus_func(driver_vbus_func driver_vbus)
-{
-	dr_utmi_config.platform_driver_vbus = driver_vbus;
-}
 
 static void _dr_discharge_line(bool enable)
 {
@@ -262,7 +229,6 @@ static void _dr_discharge_line(bool enable)
 /* Below two macros are used at otg mode to indicate usb mode*/
 #define ENABLED_BY_HOST   (0x1 << 0)
 #define ENABLED_BY_DEVICE (0x1 << 1)
-static u32 low_power_enable_src; /* only useful at otg mode */
 static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
 {
 	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
@@ -282,10 +248,12 @@ static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, boo
 		usbotg_internal_phy_clock_gate(false);
 
 	} else {
-		if (UOG_PORTSC1 & PORTSC_PHCD) {
+		if (UOG_PORTSC1 & PORTSC_PHCD)
 			UOG_PORTSC1 &= ~PORTSC_PHCD;
-			mdelay(1);
-		}
+
+		/* Wait PHY clock stable */
+		mdelay(1);
+
 		usbotg_internal_phy_clock_gate(true);
 		tmp = (BM_USBPHY_PWD_TXPWDFS
 			| BM_USBPHY_PWD_TXPWDIBIAS
@@ -295,6 +263,19 @@ static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, boo
 			| BM_USBPHY_PWD_RXPWDDIFF
 			| BM_USBPHY_PWD_RXPWDRX);
 		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+		/*
+		 * The PHY works at 32Khz clock when it is at low power mode,
+		 * it needs 10 clocks from 32Khz to normal work state, so
+		 * 500us is the safe value for PHY enters stable status
+		 * according to IC engineer.
+		 *
+		 * Besides, the digital value needs 1ms debounce time to
+		 * wait the value to be stable. We have expected the
+		 * value from OTGSC is correct after calling this API.
+		 *
+		 * So delay 2ms is a save value.
+		 */
+		mdelay(2);
 
 	}
 	pr_debug("DR: %s ends, enable is %d\n", __func__, enable);
@@ -333,6 +314,12 @@ static void otg_wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable
 				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_SET);
 		USB_OTG_CTRL |= UCTRL_OWIE;
 	} else {
+		__raw_writel(BM_USBPHY_CTRL_ENDPDMCHG_WKUP
+				| BM_USBPHY_CTRL_ENAUTOSET_USBCLKS
+				| BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD
+				| BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE
+				| BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE
+				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_CLR);
 		USB_OTG_CTRL &= ~UCTRL_OWIE;
 		/* The interrupt must be disabled for at least 3 clock
 		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
@@ -340,7 +327,6 @@ static void otg_wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable
 	}
 }
 
-static u32 wakeup_irq_enable_src; /* only useful at otg mode */
 static void __wakeup_irq_enable(struct fsl_usb2_platform_data *pdata, bool on, int source)
  {
 	/* otg host and device share the OWIE bit, only when host and device
@@ -388,6 +374,51 @@ static void usbotg_wakeup_event_clear(void)
 
 #ifdef CONFIG_USB_EHCI_ARC_OTG
 /* Beginning of host related operation for DR port */
+static void fsl_platform_otg_set_usb_phy_dis(
+		struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	u32 usb_phy_ctrl_dcdt = 0;
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	usb_phy_ctrl_dcdt = __raw_readl(
+			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
+			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	if (enable) {
+		if (usb_phy_ctrl_dcdt == 0) {
+			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_CLR);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_SET);
+
+			udelay(300);
+
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_SET);
+
+			UOG_USBSTS |= (1 << 7);
+
+			while ((UOG_USBSTS & (1 << 7)) == 0)
+				;
+
+			udelay(2);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_CLR);
+
+			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+
+		}
+	} else {
+		if (usb_phy_ctrl_dcdt
+				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_CLR);
+	}
+}
+
 static void _host_platform_rh_suspend_swfix(struct fsl_usb2_platform_data *pdata)
 {
 	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
@@ -488,8 +519,9 @@ static void _host_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, boo
 
 static void _host_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enable)
 {
-	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	void __iomem *phy_reg __maybe_unused = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
 	__wakeup_irq_enable(pdata, enable, ENABLED_BY_HOST);
+#ifdef CONFIG_USB_OTG
 	if (enable) {
 		pr_debug("host wakeup enable\n");
 		USB_OTG_CTRL |= UCTRL_WKUP_ID_EN;
@@ -503,6 +535,7 @@ static void _host_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enabl
 		udelay(100);
 	}
 	pr_debug("the otgsc is 0x%x, usbsts is 0x%x, portsc is 0x%x, otgctrl: 0x%x\n", UOG_OTGSC, UOG_USBSTS, UOG_PORTSC1, USB_OTG_CTRL);
+#endif
 }
 
 static enum usb_wakeup_event _is_host_wakeup(struct fsl_usb2_platform_data *pdata)
@@ -514,10 +547,8 @@ static enum usb_wakeup_event _is_host_wakeup(struct fsl_usb2_platform_data *pdat
 		pr_debug("the otgsc is 0x%x, usbsts is 0x%x, portsc is 0x%x, wakeup_irq is 0x%x\n", UOG_OTGSC, UOG_USBSTS, UOG_PORTSC1, wakeup_req);
 	}
 	/* if ID change sts, it is a host wakeup event */
-	if (wakeup_req && (otgsc & OTGSC_IS_USB_ID)) {
+	if (otgsc & OTGSC_IS_USB_ID) {
 		pr_debug("otg host ID wakeup\n");
-		/* if host ID wakeup, we must clear the b session change sts */
-		otgsc &= (~OTGSC_IS_USB_ID);
 		return WAKEUP_EVENT_ID;
 	}
 	if (wakeup_req  && (!(otgsc & OTGSC_STS_USB_ID))) {
@@ -604,18 +635,45 @@ static void device_wakeup_handler(struct fsl_usb2_platform_data *pdata)
 /* end of device related operation for DR port */
 #endif /* CONFIG_USB_GADGET_ARC */
 
-void __init mx6_usb_dr_init(void)
+static struct platform_device *pdev[3], *pdev_wakeup;
+static driver_vbus_func  mx6_set_usb_otg_vbus;
+static int devnum;
+static int  __init mx6_usb_dr_init(void)
 {
-	struct platform_device *pdev, *pdev_wakeup;
+	int i = 0;
 	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	struct imx_fsl_usb2_wakeup_data imx6q_fsl_otg_wakeup_data =
+		imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 0, OTG);
+	struct imx_mxc_ehci_data __maybe_unused imx6q_mxc_ehci_otg_data =
+		imx_mxc_ehci_data_entry_single(MX6Q, 0, OTG);
+	struct imx_fsl_usb2_udc_data __maybe_unused imx6q_fsl_usb2_udc_data =
+		imx_fsl_usb2_udc_data_entry_single(MX6Q);
+	struct imx_fsl_usb2_otg_data __maybe_unused imx6q_fsl_usb2_otg_data  =
+		imx_fsl_usb2_otg_data_entry_single(MX6Q);
+
+	/* Some phy and power's special controls for otg
+	 * 1. The external charger detector needs to be disabled
+	 * or the signal at DP will be poor
+	 * 2. The EN_USB_CLKS is always enabled.
+	 * The PLL's power is controlled by usb and others who
+	 * use pll3 too.
+	 */
+	__raw_writel(BM_ANADIG_USB1_CHRG_DETECT_EN_B  \
+			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,  \
+			anatop_base_addr + HW_ANADIG_USB1_CHRG_DETECT);
+	__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+			anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+	mx6_get_otghost_vbus_func(&mx6_set_usb_otg_vbus);
+	dr_utmi_config.platform_driver_vbus = mx6_set_usb_otg_vbus;
 
 #ifdef CONFIG_USB_OTG
 	/* wake_up_enable is useless, just for usb_register_remote_wakeup execution*/
 	dr_utmi_config.wake_up_enable = _device_wakeup_enable;
 	dr_utmi_config.operating_mode = FSL_USB2_DR_OTG;
 	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
-	pdev = imx6q_add_fsl_usb2_otg(&dr_utmi_config);
-	dr_wakeup_config.usb_pdata[0] = pdev->dev.platform_data;
+	pdev[i] = imx6q_add_fsl_usb2_otg(&dr_utmi_config);
+	dr_wakeup_config.usb_pdata[i] = pdev[i]->dev.platform_data;
+	i++;
 #endif
 #ifdef CONFIG_USB_EHCI_ARC_OTG
 	dr_utmi_config.operating_mode = DR_HOST_MODE;
@@ -633,8 +691,9 @@ void __init mx6_usb_dr_init(void)
 	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
 	dr_utmi_config.wakeup_handler = host_wakeup_handler;
 	dr_utmi_config.platform_phy_power_on = dr_platform_phy_power_on;
-	pdev = imx6q_add_fsl_ehci_otg(&dr_utmi_config);
-	dr_wakeup_config.usb_pdata[1] = pdev->dev.platform_data;
+	pdev[i] = imx6q_add_fsl_ehci_otg(&dr_utmi_config);
+	dr_wakeup_config.usb_pdata[i] = pdev[i]->dev.platform_data;
+	i++;
 #endif
 #ifdef CONFIG_USB_GADGET_ARC
 	dr_utmi_config.operating_mode = DR_UDC_MODE;
@@ -648,25 +707,38 @@ void __init mx6_usb_dr_init(void)
 	dr_utmi_config.wakeup_handler = device_wakeup_handler;
 	dr_utmi_config.charger_base_addr = anatop_base_addr;
 	dr_utmi_config.platform_phy_power_on = dr_platform_phy_power_on;
-	pdev = imx6q_add_fsl_usb2_udc(&dr_utmi_config);
-	dr_wakeup_config.usb_pdata[2] = pdev->dev.platform_data;
+	pdev[i] = imx6q_add_fsl_usb2_udc(&dr_utmi_config);
+	dr_wakeup_config.usb_pdata[i] = pdev[i]->dev.platform_data;
+	i++;
 #endif
+	devnum = i;
 	/* register wakeup device */
 	pdev_wakeup = imx6q_add_fsl_usb2_otg_wakeup(&dr_wakeup_config);
-	if (pdev != NULL)
-		((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
+	for (i = 0; i < devnum; i++) {
+		platform_device_add(pdev[i]);
+		((struct fsl_usb2_platform_data *)(pdev[i]->dev.platform_data))->wakeup_pdata =
 			(struct fsl_usb2_wakeup_platform_data *)(pdev_wakeup->dev.platform_data);
+	}
+
+	return 0;
+}
+module_init(mx6_usb_dr_init);
+
+static void __exit mx6_usb_dr_exit(void)
+{
+	int i;
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+
+	for (i = 0; i < devnum; i++)
+		platform_device_del(pdev[devnum-i-1]);
+	platform_device_unregister(pdev_wakeup);
+	otg_used = 0;
 
-	/* Some phy and power's special controls for otg
-	 * 1. The external charger detector needs to be disabled
-	 * or the signal at DP will be poor
-	 * 2. The EN_USB_CLKS is always enabled.
-	 * The PLL's power is controlled by usb and others who
-	 * use pll3 too.
-	 */
-	__raw_writel(BM_ANADIG_USB1_CHRG_DETECT_EN_B  \
-			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,  \
-			anatop_base_addr + HW_ANADIG_USB1_CHRG_DETECT);
 	__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
-			anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+			anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_CLR);
+	return ;
 }
+module_exit(mx6_usb_dr_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx6/usb_h1.c b/arch/arm/mach-mx6/usb_h1.c
index f86a4f4..657c1cb 100644
--- a/arch/arm/mach-mx6/usb_h1.c
+++ b/arch/arm/mach-mx6/usb_h1.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -111,6 +111,16 @@ static int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
 	UH1_USBCMD |= UCMD_RESET;
 	while ((UH1_USBCMD) & (UCMD_RESET))
 		;
+
+	/*
+	 * If the controller reset does not put the PHY be out of
+	 * low power mode, do it manually.
+	 */
+	if (UH1_PORTSC1 & PORTSC_PHCD) {
+		UH1_PORTSC1 &= ~PORTSC_PHCD;
+		mdelay(1);
+	}
+
 	/* Reset USBPHY module */
 	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
 	tmp = __raw_readl(phy_ctrl);
@@ -148,6 +158,8 @@ static int fsl_usb_host_init_ext(struct platform_device *pdev)
 	ret = fsl_usb_host_init(pdev);
 	if (ret) {
 		printk(KERN_ERR "host1 init fails......\n");
+		clk_disable(usb_oh3_clk);
+		clk_put(usb_oh3_clk);
 		return ret;
 	}
 	usbh1_internal_phy_clock_gate(true);
@@ -162,7 +174,6 @@ static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
 
 	fsl_usb_host_uninit(pdata);
 
-	clk_disable(usb_oh3_clk);
 	clk_put(usb_oh3_clk);
 
 }
@@ -192,9 +203,14 @@ static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
 				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_SET);
 		USB_H1_CTRL |= (UCTRL_OWIE);
 	} else {
-		USB_H1_CTRL &= ~(UCTRL_OWIE);
 		__raw_writel(BM_USBPHY_CTRL_ENIDCHG_WKUP | BM_USBPHY_CTRL_ENVBUSCHG_WKUP
-				| BM_USBPHY_CTRL_ENDPDMCHG_WKUP, phy_reg + HW_USBPHY_CTRL_CLR);
+				| BM_USBPHY_CTRL_ENDPDMCHG_WKUP
+				| BM_USBPHY_CTRL_ENAUTOSET_USBCLKS
+				| BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD
+				| BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE
+				| BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE
+				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_CLR);
+		USB_H1_CTRL &= ~(UCTRL_OWIE);
 		/* The interrupt must be disabled for at least 3
 		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
 		udelay(100);
@@ -244,7 +260,7 @@ static void usbh1_platform_rh_resume_swfix(struct fsl_usb2_platform_data *pdata)
 {
 	u32 index = 0;
 
-	if ((UOG_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
+	if ((UH1_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
 		return ;
 	while ((UH1_PORTSC1 & PORTSC_PORT_FORCE_RESUME)
 			&& (index < 1000)) {
@@ -277,7 +293,7 @@ static void usbh1_platform_rh_resume(struct fsl_usb2_platform_data *pdata)
 	/*for mx6sl ,we do not need any sw fix*/
 	if (cpu_is_mx6sl())
 		return ;
-	if ((UOG_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
+	if ((UH1_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
 		return ;
 	while ((UH1_PORTSC1 & PORTSC_PORT_FORCE_RESUME)
 			&& (index < 1000)) {
@@ -316,10 +332,12 @@ static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool ena
 
 		usbh1_internal_phy_clock_gate(false);
 	} else {
-		if (UH1_PORTSC1 & PORTSC_PHCD) {
+		if (UH1_PORTSC1 & PORTSC_PHCD)
 			UH1_PORTSC1 &= ~PORTSC_PHCD;
-			mdelay(1);
-		}
+
+		/* Wait PHY clock stable */
+		mdelay(1);
+
 		usbh1_internal_phy_clock_gate(true);
 		tmp = (BM_USBPHY_PWD_TXPWDFS
 			| BM_USBPHY_PWD_TXPWDIBIAS
@@ -329,6 +347,13 @@ static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool ena
 			| BM_USBPHY_PWD_RXPWDDIFF
 			| BM_USBPHY_PWD_RXPWDRX);
 		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+		/*
+		 * The PHY works at 32Khz clock when it is at low power mode,
+		 * it needs 10 clocks from 32Khz to normal work state, so
+		 * 500us is the safe value for PHY enters stable status
+		 * according to IC engineer.
+		 */
+		udelay(500);
 
 	}
 }
@@ -351,13 +376,16 @@ static void h1_wakeup_handler(struct fsl_usb2_platform_data *pdata)
 
 static void usbh1_wakeup_event_clear(void)
 {
-	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
-	u32 wakeup_irq_bits;
-
-	wakeup_irq_bits = BM_USBPHY_CTRL_RESUME_IRQ | BM_USBPHY_CTRL_WAKEUP_IRQ;
-	if (__raw_readl(phy_reg + HW_USBPHY_CTRL) && wakeup_irq_bits) {
-		/* clear the wakeup interrupt status */
-		__raw_writel(wakeup_irq_bits, phy_reg + HW_USBPHY_CTRL_CLR);
+	int wakeup_req = USB_H1_CTRL & UCTRL_OWIR;
+
+	if (wakeup_req != 0) {
+		printk(KERN_INFO "Unknown wakeup.(H1 OTGSC 0x%x)\n", UH1_OTGSC);
+		/* Disable OWIE to clear OWIR, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USB_H1_CTRL &= ~UCTRL_OWIE;
+		udelay(100);
+		USB_H1_CTRL |= UCTRL_OWIE;
 	}
 }
 
@@ -400,9 +428,8 @@ static int  __init mx6_usb_h1_init(void)
 	struct imx_mxc_ehci_data imx6sl_mxc_ehci_hs_data[] = {
 		imx_mxc_ehci_data_entry_single(MX6SL, 1, HS1)};
 
-	mx6_set_usb_host1_vbus_func(&mx6_set_usb_host1_vbus);
-	if (mx6_set_usb_host1_vbus)
-		mx6_set_usb_host1_vbus(true);
+	mx6_get_host1_vbus_func(&mx6_set_usb_host1_vbus);
+	usbh1_config.platform_driver_vbus = mx6_set_usb_host1_vbus;
 
 	/* Some phy and power's special controls for host1
 	 * 1. The external charger detector needs to be disabled
@@ -438,6 +465,7 @@ static int  __init mx6_usb_h1_init(void)
 		pdev_wakeup = imx6sl_add_fsl_usb2_hs_wakeup(1, &usbh1_wakeup_config);
 	else
 		pdev_wakeup = imx6q_add_fsl_usb2_hs_wakeup(1, &usbh1_wakeup_config);
+	platform_device_add(pdev);
 	((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
 		(struct fsl_usb2_wakeup_platform_data *)(pdev_wakeup->dev.platform_data);
 	return 0;
@@ -456,8 +484,6 @@ static void __exit mx6_usb_h1_exit(void)
 			| BM_ANADIG_USB2_PLL_480_CTRL_POWER \
 			| BM_ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS, \
 			anatop_base_addr + HW_ANADIG_USB2_PLL_480_CTRL_CLR);
-	if (mx6_set_usb_host1_vbus)
-		mx6_set_usb_host1_vbus(false);
 
 	return ;
 }
diff --git a/arch/arm/mach-mx6/usb_h2.c b/arch/arm/mach-mx6/usb_h2.c
index 37cad03..6ce99ab 100644
--- a/arch/arm/mach-mx6/usb_h2.c
+++ b/arch/arm/mach-mx6/usb_h2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,12 +89,7 @@ static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
 
 	fsl_usb_host_uninit(pdata);
 
-	usbh2_internal_phy_clock_gate(false);
-
-	clk_disable(usb_phy3_clk);
 	clk_put(usb_phy3_clk);
-
-	clk_disable(usb_oh3_clk);
 	clk_put(usb_oh3_clk);
 
 }
@@ -237,6 +232,7 @@ void __init mx6_usb_h2_init(void)
 		pdev_wakeup = imx6sl_add_fsl_usb2_hs_wakeup(2, &usbh2_wakeup_config);
 	else
 		pdev_wakeup = imx6q_add_fsl_usb2_hs_wakeup(2, &usbh2_wakeup_config);
+	platform_device_add(pdev);
 	((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
 		pdev_wakeup->dev.platform_data;
 	/* Some phy and power's special controls for host2
diff --git a/arch/arm/mach-mx6/usb_h3.c b/arch/arm/mach-mx6/usb_h3.c
index 820ecd9..cddf552 100644
--- a/arch/arm/mach-mx6/usb_h3.c
+++ b/arch/arm/mach-mx6/usb_h3.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,12 +89,7 @@ static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
 
 	fsl_usb_host_uninit(pdata);
 
-	usbh3_internal_phy_clock_gate(false);
-
-	clk_disable(usb_phy4_clk);
 	clk_put(usb_phy4_clk);
-
-	clk_disable(usb_oh3_clk);
 	clk_put(usb_oh3_clk);
 
 }
@@ -227,6 +222,7 @@ void __init mx6_usb_h3_init(void)
 	pdev = imx6q_add_fsl_ehci_hs(3, &usbh3_config);
 	usbh3_wakeup_config.usb_pdata[0] = pdev->dev.platform_data;
 	pdev_wakeup = imx6q_add_fsl_usb2_hs_wakeup(3, &usbh3_wakeup_config);
+	platform_device_add(pdev);
 	((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
 		pdev_wakeup->dev.platform_data;
 
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index 1ed1fd3..428b243 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -211,6 +211,9 @@ ENTRY(v7_coherent_user_range)
  * isn't mapped, just try the next page.
  */
 9001:
+#ifdef CONFIG_ARM_ERRATA_775420
+	dsb
+#endif
 	mov	r12, r12, lsr #12
 	mov	r12, r12, lsl #12
 	add	r12, r12, #4096
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 0f0badd..feb83cb 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -333,6 +333,23 @@ __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
  * virtual and bus address for that space.
  */
 void *
+dma_alloc_noncached(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
+{
+	void *memory;
+
+	if (dma_alloc_from_coherent(dev, size, handle, &memory))
+		return memory;
+
+	return __dma_alloc(dev, size, handle, gfp,
+			   pgprot_noncached(pgprot_kernel));
+}
+EXPORT_SYMBOL(dma_alloc_noncached);
+
+/*
+ * Allocate DMA-coherent memory space and return both the kernel remapped
+ * virtual and bus address for that space.
+ */
+void *
 dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
 {
 	void *memory;
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 6ff1c90..1aa1780 100755
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := clock.o gpio.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o
+obj-y := clock.o gpio.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o fuse.o
 
 # MX51 uses the TZIC interrupt controller, older platforms use AVIC
 obj-$(CONFIG_MXC_TZIC) += tzic.o
diff --git a/arch/arm/plat-mxc/ahci_sata.c b/arch/arm/plat-mxc/ahci_sata.c
index cee34b6..de172a9 100644
--- a/arch/arm/plat-mxc/ahci_sata.c
+++ b/arch/arm/plat-mxc/ahci_sata.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -152,9 +152,8 @@ int sata_init(void __iomem *addr, unsigned long timer1ms)
 	/* Reset HBA */
 	writel(HOST_RESET, addr + HOST_CTL);
 
-	tmpdata = readl(addr + HOST_VERSIONR);
 	tmpdata = 0;
-	while (readl(addr + HOST_VERSIONR) == 0) {
+	while (readl(addr + HOST_CAP) == 0) {
 		tmpdata++;
 		if (tmpdata > 100000) {
 			pr_err("Can't recover from RESET HBA!\n");
@@ -167,7 +166,6 @@ int sata_init(void __iomem *addr, unsigned long timer1ms)
 		tmpdata |= HOST_CAP_SSS;
 		writel(tmpdata, addr + HOST_CAP);
 	}
-	tmpdata = readl(addr + HOST_CAP);
 
 	if (!(readl(addr + HOST_PORTS_IMPL) & 0x1))
 		writel((readl(addr + HOST_PORTS_IMPL) | 0x1),
@@ -178,7 +176,7 @@ int sata_init(void __iomem *addr, unsigned long timer1ms)
 	/* Release resources when there is no device on the port */
 	do {
 		if ((readl(addr + PORT_SATA_SR) & 0xF) == 0)
-			msleep(25);
+			usleep_range(1000, 2000);
 		else
 			break;
 
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
index 7687a53..47a70d9 100755
--- a/arch/arm/plat-mxc/cpufreq.c
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -23,6 +23,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/suspend.h>
 #include <asm/smp_plat.h>
 #include <asm/cpu.h>
 
@@ -32,15 +33,6 @@
 #define CLK32_FREQ	32768
 #define NANOSECOND	(1000 * 1000 * 1000)
 
-/*If using cpu internal ldo bypass,we need config pmic by I2C in suspend
-interface, but cpufreq driver as sys_dev is more later to suspend than I2C
-driver, so we should implement another I2C operate function which isolated
-with kernel I2C driver, these code is copied from u-boot*/
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-/*0:normal; 1: in the middle of suspend or resume; 2: suspended*/
-static int cpu_freq_suspend_in;
-static struct mutex set_cpufreq_lock;
-#endif
 
 static int cpu_freq_khz_min;
 static int cpu_freq_khz_max;
@@ -51,6 +43,8 @@ static struct cpufreq_frequency_table *imx_freq_table;
 static int cpu_op_nr;
 static struct cpu_op *cpu_op_tbl;
 static u32 pre_suspend_rate;
+static bool cpufreq_suspend;
+static struct mutex set_cpufreq_lock;
 
 extern struct regulator *cpu_regulator;
 extern struct regulator *soc_regulator;
@@ -58,14 +52,16 @@ extern struct regulator *pu_regulator;
 extern int dvfs_core_is_active;
 extern struct cpu_op *(*get_cpu_op)(int *op);
 extern void bus_freq_update(struct clk *clk, bool flag);
+extern void mx6_arm_regulator_bypass(void);
+extern void mx6_soc_pu_regulator_bypass(void);
 
 int set_cpu_freq(int freq)
 {
 	int i, ret = 0;
 	int org_cpu_rate;
-	int gp_volt = 0;
-	int soc_volt = 0;
-	int pu_volt = 0;
+	int gp_volt = 0, org_gp_volt = 0;
+	int soc_volt = 0, org_soc_volt = 0;
+	int pu_volt = 0, org_pu_volt = 0;
 
 	org_cpu_rate = clk_get_rate(cpu_clk);
 	if (org_cpu_rate == freq)
@@ -77,15 +73,14 @@ int set_cpu_freq(int freq)
 			soc_volt = cpu_op_tbl[i].soc_voltage;
 			pu_volt = cpu_op_tbl[i].pu_voltage;
 		}
+		if (org_cpu_rate == cpu_op_tbl[i].cpu_rate) {
+			org_gp_volt = cpu_op_tbl[i].cpu_voltage;
+			org_soc_volt = cpu_op_tbl[i].soc_voltage;
+			org_pu_volt = cpu_op_tbl[i].pu_voltage;
+		}
 	}
-
 	if (gp_volt == 0)
 		return ret;
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	/*Do not change cpufreq if system enter suspend flow*/
-	if (cpu_freq_suspend_in == 2)
-		return -1;
-#endif
 	/*Set the voltage for the GP domain. */
 	if (freq > org_cpu_rate) {
 		/* Check if the bus freq needs to be increased first */
@@ -95,9 +90,9 @@ int set_cpu_freq(int freq)
 			ret = regulator_set_voltage(soc_regulator, soc_volt,
 							soc_volt);
 			if (ret < 0) {
-				printk(KERN_DEBUG
+				printk(KERN_ERR
 					"COULD NOT SET SOC VOLTAGE!!!!\n");
-				return ret;
+				goto err1;
 			}
 		}
 		/*if pu_regulator is enabled, it will be tracked with VDDARM*/
@@ -106,38 +101,38 @@ int set_cpu_freq(int freq)
 			ret = regulator_set_voltage(pu_regulator, pu_volt,
 							pu_volt);
 			if (ret < 0) {
-				printk(KERN_DEBUG
+				printk(KERN_ERR
 					"COULD NOT SET PU VOLTAGE!!!!\n");
-				return ret;
+				goto err2;
 			}
 		}
 		ret = regulator_set_voltage(cpu_regulator, gp_volt,
 					    gp_volt);
 		if (ret < 0) {
-			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
-			return ret;
+			printk(KERN_ERR "COULD NOT SET GP VOLTAGE!!!!\n");
+			goto err3;
 		}
 	}
 	ret = clk_set_rate(cpu_clk, freq);
 	if (ret != 0) {
-		printk(KERN_DEBUG "cannot set CPU clock rate\n");
-		return ret;
+		printk(KERN_ERR "cannot set CPU clock rate\n");
+		goto err4;
 	}
 
 	if (freq < org_cpu_rate) {
 		ret = regulator_set_voltage(cpu_regulator, gp_volt,
 					    gp_volt);
 		if (ret < 0) {
-			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
-			return ret;
+			printk(KERN_ERR "COULD NOT SET GP VOLTAGE!!!!\n");
+			goto err5;
 		}
 		if (!IS_ERR(soc_regulator)) {
 			ret = regulator_set_voltage(soc_regulator, soc_volt,
 							soc_volt);
 			if (ret < 0) {
-				printk(KERN_DEBUG
+				printk(KERN_ERR
 					"COULD NOT SET SOC VOLTAGE BACK!!!!\n");
-				return ret;
+				goto err6;
 			}
 		}
 		/*if pu_regulator is enabled, it will be tracked with VDDARM*/
@@ -146,9 +141,9 @@ int set_cpu_freq(int freq)
 			ret = regulator_set_voltage(pu_regulator, pu_volt,
 							pu_volt);
 			if (ret < 0) {
-				printk(KERN_DEBUG
+				printk(KERN_ERR
 					"COULD NOT SET PU VOLTAGE!!!!\n");
-				return ret;
+				goto err7;
 			}
 		}
 		/* Check if the bus freq can be decreased.*/
@@ -156,6 +151,56 @@ int set_cpu_freq(int freq)
 	}
 
 	return ret;
+	/*Restore back if any regulator or clock rate set fail.*/
+err7:
+	ret = regulator_set_voltage(soc_regulator, org_soc_volt,
+							org_soc_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE SOC VOLTAGE!!!!\n");
+		goto err7;
+	}
+
+err6:
+	ret = regulator_set_voltage(cpu_regulator, org_gp_volt, org_gp_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE GP VOLTAGE!!!!\n");
+		goto err6;
+	}
+
+err5:
+	ret = clk_set_rate(cpu_clk, org_cpu_rate);
+	if (ret != 0) {
+		printk(KERN_ERR "cannot restore CPU clock rate\n");
+		goto err5;
+	}
+	return -1;
+
+err4:
+	ret = regulator_set_voltage(cpu_regulator, org_gp_volt, org_gp_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE GP VOLTAGE!!!!\n");
+		goto err4;
+	}
+
+err3:
+	if (!IS_ERR(pu_regulator) &&
+		regulator_is_enabled(pu_regulator)) {
+		ret = regulator_set_voltage(pu_regulator, org_pu_volt, org_pu_volt);
+		if (ret < 0) {
+			printk(KERN_ERR "COULD NOT RESTORE PU VOLTAGE!!!!\n");
+			goto err3;
+		}
+	}
+err2:
+	ret = regulator_set_voltage(soc_regulator, org_soc_volt,
+							org_soc_volt);
+	if (ret < 0) {
+		printk(KERN_ERR "COULD NOT RESTORE SOC VOLTAGE!!!!\n");
+		goto err2;
+	}
+err1:
+	return -1;
+
 }
 
 static int mxc_verify_speed(struct cpufreq_policy *policy)
@@ -186,7 +231,6 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 	num_cpus = num_possible_cpus();
 	if (policy->cpu > num_cpus)
 		return 0;
-
 	if (dvfs_core_is_active) {
 		struct cpufreq_freqs freqs;
 
@@ -201,6 +245,11 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 		return ret;
 	}
 
+	mutex_lock(&set_cpufreq_lock);
+	if (cpufreq_suspend) {
+		mutex_unlock(&set_cpufreq_lock);
+		return ret;
+	}
 	cpufreq_frequency_table_target(policy, imx_freq_table,
 			target_freq, relation, &index);
 	freq_Hz = imx_freq_table[index].frequency * 1000;
@@ -209,18 +258,23 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 	freqs.new = freq_Hz / 1000;
 	freqs.cpu = policy->cpu;
 	freqs.flags = 0;
-
 	for (i = 0; i < num_cpus; i++) {
 		freqs.cpu = i;
 		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
 	}
-	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	mutex_lock(&set_cpufreq_lock);
 	ret = set_cpu_freq(freq_Hz);
-	mutex_unlock(&set_cpufreq_lock);
-	#else
-	ret = set_cpu_freq(freq_Hz);
-	#endif
+	if (ret) {
+		/*restore cpufreq and tell cpufreq core if set fail*/
+		freqs.old = clk_get_rate(cpu_clk) / 1000;
+		freqs.new = freqs.old;
+		freqs.cpu = policy->cpu;
+		freqs.flags = 0;
+		for (i = 0; i < num_cpus; i++) {
+			freqs.cpu = i;
+			cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		}
+		goto  Set_finish;
+	}
 #ifdef CONFIG_SMP
 	/* Loops per jiffy is not updated by the CPUFREQ driver for SMP systems.
 	  * So update it for all CPUs.
@@ -234,68 +288,16 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 	 * as all CPUs are running at same freq */
 	loops_per_jiffy = per_cpu(cpu_data, 0).loops_per_jiffy;
 #endif
+Set_finish:
 	for (i = 0; i < num_cpus; i++) {
 		freqs.cpu = i;
 		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
 	}
-
-	return ret;
-}
-#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-void mxc_cpufreq_suspend(void)
-{
-	mutex_lock(&set_cpufreq_lock);
-	pre_suspend_rate = clk_get_rate(cpu_clk);
-	/*set flag and raise up cpu frequency if needed*/
-	cpu_freq_suspend_in = 1;
-	if (pre_suspend_rate != (imx_freq_table[0].frequency * 1000)) {
-			set_cpu_freq(imx_freq_table[0].frequency * 1000);
-			loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
-				pre_suspend_rate / 1000, imx_freq_table[0].frequency);
-	}
-	cpu_freq_suspend_in = 2;
 	mutex_unlock(&set_cpufreq_lock);
 
+	return ret;
 }
 
-void mxc_cpufreq_resume(void)
-{
-	mutex_lock(&set_cpufreq_lock);
-	cpu_freq_suspend_in = 1;
-	if (clk_get_rate(cpu_clk) != pre_suspend_rate) {
-		set_cpu_freq(pre_suspend_rate);
-		loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
-			imx_freq_table[0].frequency, pre_suspend_rate / 1000);
-	}
-	cpu_freq_suspend_in = 0;
-	mutex_unlock(&set_cpufreq_lock);
-}
-
-
-#else
-static int mxc_cpufreq_suspend(struct cpufreq_policy *policy)
-{
-	pre_suspend_rate = clk_get_rate(cpu_clk);
-	if (pre_suspend_rate != (imx_freq_table[0].frequency * 1000)) {
-		set_cpu_freq(imx_freq_table[0].frequency * 1000);
-		loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
-			pre_suspend_rate / 1000, imx_freq_table[0].frequency);
-	}
-
-	return 0;
-}
-
-static int mxc_cpufreq_resume(struct cpufreq_policy *policy)
-{
-	if (clk_get_rate(cpu_clk) != pre_suspend_rate) {
-		set_cpu_freq(pre_suspend_rate);
-		loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
-			imx_freq_table[0].frequency, pre_suspend_rate / 1000);
-	}
-	return 0;
-}
-#endif
-
 static int __devinit mxc_cpufreq_init(struct cpufreq_policy *policy)
 {
 	int ret;
@@ -398,21 +400,118 @@ static struct cpufreq_driver mxc_driver = {
 	.get = mxc_get_speed,
 	.init = mxc_cpufreq_init,
 	.exit = mxc_cpufreq_exit,
-#ifndef CONFIG_MX6_INTER_LDO_BYPASS
-	.suspend = mxc_cpufreq_suspend,
-	.resume = mxc_cpufreq_resume,
-#endif
 	.name = "imx",
 	.attr = imx_cpufreq_attr,
 };
 
+static int cpufreq_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	unsigned int i;
+	int num_cpus;
+	int ret;
+	struct cpufreq_freqs freqs;
+
+	num_cpus = num_possible_cpus();
+	mutex_lock(&set_cpufreq_lock);
+	if (event == PM_SUSPEND_PREPARE) {
+		pre_suspend_rate = clk_get_rate(cpu_clk);
+		if (pre_suspend_rate != (imx_freq_table[0].frequency * 1000)) {
+			/*notify cpufreq core will raise up cpufreq to highest*/
+			freqs.old = pre_suspend_rate / 1000;
+			freqs.new = imx_freq_table[0].frequency;
+			freqs.flags = 0;
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+			}
+			ret = set_cpu_freq(imx_freq_table[0].frequency * 1000);
+			/*restore cpufreq and tell cpufreq core if set fail*/
+			if (ret) {
+				freqs.old =  clk_get_rate(cpu_clk)/1000;
+				freqs.new = freqs.old;
+				freqs.flags = 0;
+				for (i = 0; i < num_cpus; i++) {
+					freqs.cpu = i;
+					cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+				}
+				goto Notify_finish;/*if update freq error,return*/
+			}
+#ifdef CONFIG_SMP
+			for_each_possible_cpu(i)
+				per_cpu(cpu_data, i).loops_per_jiffy =
+					cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy,
+					pre_suspend_rate / 1000, imx_freq_table[0].frequency);
+			loops_per_jiffy = per_cpu(cpu_data, 0).loops_per_jiffy;
+#else
+			loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
+				pre_suspend_rate / 1000, imx_freq_table[0].frequency);
+#endif
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+			}
+		}
+		cpufreq_suspend = true;
+	} else if (event == PM_POST_SUSPEND) {
+		if (clk_get_rate(cpu_clk) != pre_suspend_rate) {
+			/*notify cpufreq core will restore rate before suspend*/
+			freqs.old = imx_freq_table[0].frequency;
+			freqs.new = pre_suspend_rate / 1000;
+			freqs.flags = 0;
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+			}
+			ret = set_cpu_freq(pre_suspend_rate);
+			/*restore cpufreq and tell cpufreq core if set fail*/
+			if (ret) {
+				freqs.old =  clk_get_rate(cpu_clk)/1000;
+				freqs.new = freqs.old;
+				freqs.flags = 0;
+				for (i = 0; i < num_cpus; i++) {
+					freqs.cpu = i;
+					cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+				}
+				goto Notify_finish;/*if update freq error,return*/
+			}
+#ifdef CONFIG_SMP
+			for_each_possible_cpu(i)
+				per_cpu(cpu_data, i).loops_per_jiffy =
+					cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy,
+					imx_freq_table[0].frequency, pre_suspend_rate / 1000);
+			loops_per_jiffy = per_cpu(cpu_data, 0).loops_per_jiffy;
+#else
+			loops_per_jiffy = cpufreq_scale(loops_per_jiffy,
+				imx_freq_table[0].frequency, pre_suspend_rate / 1000);
+#endif
+			for (i = 0; i < num_cpus; i++) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+			}
+		}
+		cpufreq_suspend = false;
+	}
+	mutex_unlock(&set_cpufreq_lock);
+	return NOTIFY_OK;
+
+Notify_finish:
+	for (i = 0; i < num_cpus; i++) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+	mutex_unlock(&set_cpufreq_lock);
+	return NOTIFY_OK;
+}
+static struct notifier_block imx_cpufreq_pm_notifier = {
+	.notifier_call = cpufreq_pm_notify,
+};
 extern void mx6_cpu_regulator_init(void);
 static int __init mxc_cpufreq_driver_init(void)
 {
-	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
 	mx6_cpu_regulator_init();
 	mutex_init(&set_cpufreq_lock);
-	#endif
+	register_pm_notifier(&imx_cpufreq_pm_notifier);
 	return cpufreq_register_driver(&mxc_driver);
 }
 
diff --git a/arch/arm/plat-mxc/devices/platform-ahci-imx.c b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
index 30bfeaa..90d994c 100755
--- a/arch/arm/plat-mxc/devices/platform-ahci-imx.c
+++ b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -54,6 +54,9 @@ struct platform_device *__init imx_add_ahci(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_SATA))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("ahci", 0 /* -1? */,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata),  DMA_BIT_MASK(32));
diff --git a/arch/arm/plat-mxc/devices/platform-fec.c b/arch/arm/plat-mxc/devices/platform-fec.c
index 20422cf..0a03ea9 100644
--- a/arch/arm/plat-mxc/devices/platform-fec.c
+++ b/arch/arm/plat-mxc/devices/platform-fec.c
@@ -6,7 +6,7 @@
  * the terms of the GNU General Public License version 2 as published by the
  * Free Software Foundation.
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 #include <linux/dma-mapping.h>
 #include <asm/sizes.h>
@@ -74,6 +74,9 @@ struct platform_device *__init imx_add_fec(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_ENET))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask(data->devid, 0,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
index f32593c..da7b221 100644
--- a/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Based on Uwe Kleine-Koenig's platform-fsl-usb2-udc.c
  * Copyright (C) 2010 Pengutronix
@@ -39,7 +39,51 @@ struct platform_device *__init imx_add_fsl_usb2_otg(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
-	return imx_add_platform_device_dmamask("fsl-usb2-otg", -1,
-			res, ARRAY_SIZE(res),
-			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+
+	int ret = -ENOMEM;
+	const char *name = "fsl-usb2-otg";
+	int id = -1;
+	unsigned int num_resources = ARRAY_SIZE(res);
+	size_t size_data = sizeof(*pdata);
+	u64 dmamask = DMA_BIT_MASK(32);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev)
+		goto err;
+
+	if (dmamask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			/* ret is still -ENOMEM; */
+			goto err;
+
+		*pdev->dev.dma_mask = dmamask;
+		pdev->dev.coherent_dma_mask = dmamask;
+	}
+
+	ret = platform_device_add_resources(pdev, res, num_resources);
+	if (ret)
+		goto err;
+
+	if (data) {
+		ret = platform_device_add_data(pdev, pdata, size_data);
+		if (ret)
+			goto err;
+	}
+
+	return pdev;
+err:
+		if (dmamask)
+			kfree(pdev->dev.dma_mask);
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(imx_add_fsl_usb2_otg);
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
index 34e522a..4c54e11 100644
--- a/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Copyright (C) 2010 Pengutronix
  * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
@@ -58,7 +58,52 @@ struct platform_device *__init imx_add_fsl_usb2_udc(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
-	return imx_add_platform_device_dmamask("fsl-usb2-udc", -1,
-			res, ARRAY_SIZE(res),
-			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+
+	int ret = -ENOMEM;
+	const char *name = "fsl-usb2-udc";
+	int id = -1;
+	unsigned int num_resources = ARRAY_SIZE(res);
+	size_t size_data = sizeof(*pdata);
+	u64 dmamask = DMA_BIT_MASK(32);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev)
+		goto err;
+
+	if (dmamask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			/* ret is still -ENOMEM; */
+			goto err;
+
+		*pdev->dev.dma_mask = dmamask;
+		pdev->dev.coherent_dma_mask = dmamask;
+	}
+
+	ret = platform_device_add_resources(pdev, res, num_resources);
+	if (ret)
+		goto err;
+
+	if (data) {
+		ret = platform_device_add_data(pdev, pdata, size_data);
+		if (ret)
+			goto err;
+	}
+
+	return pdev;
+
+err:
+		if (dmamask)
+			kfree(pdev->dev.dma_mask);
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
 }
+EXPORT_SYMBOL(imx_add_fsl_usb2_udc);
diff --git a/arch/arm/plat-mxc/devices/platform-imx-caam.c b/arch/arm/plat-mxc/devices/platform-imx-caam.c
index 3162490..aaaf501 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-caam.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-caam.c
@@ -31,6 +31,8 @@
 
 const struct imx_caam_data imx6q_imx_caam_data __initconst = {
 	.iobase_caam = MXC_CAAM_BASE_ADDR,
+	.iobase_caam_sm = CAAM_SECMEM_BASE_ADDR,
+	.iobase_snvs = MX6Q_SNVS_BASE_ADDR,
 	.irq_sec_vio = MXC_INT_SNVS_SEC,
 	.irq_snvs = MX6Q_INT_SNVS,
 	.jr[0].offset_jr = 0x1000,
@@ -51,6 +53,18 @@ struct platform_device *__init imx_add_caam(
 			.end = data->iobase_caam + SZ_64K - 1,
 			.flags = IORESOURCE_MEM,
 		}, {
+			/* Define range for secure memory */
+			.name = "iobase_caam_sm",
+			.start = data->iobase_caam_sm,
+			.end = data->iobase_caam_sm + SZ_16K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			/* Define range for SNVS */
+			.name = "iobase_snvs",
+			.start = data->iobase_snvs,
+			.end = data->iobase_snvs + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
 			/* Define interrupt for security violations */
 			.name = "irq_sec_vio",
 			.start = data->irq_sec_vio,
diff --git a/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c b/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
index 404a264..459e6cc 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,6 +55,9 @@ struct platform_device *__init imx_add_imx_epdc(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_EPDC))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("imx_epdc_fb", -1,
 		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
index 813f954..26f4ae7 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -42,6 +42,9 @@ struct platform_device *__init imx_add_hdmi_soc_dai(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("imx-hdmi-soc-dai", 0,
 				res, ARRAY_SIZE(res), NULL, 0);
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
index 33c8a68..7be6756 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -22,7 +22,12 @@
 #include <mach/devices-common.h>
 
 struct platform_device *__init imx_add_hdmi_soc(void)
-{	return imx_add_platform_device("mxc_hdmi_soc", 0,
+{
+
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device("mxc_hdmi_soc", 0,
 				       NULL, 0, NULL, 0);
 }
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx-i2c.c b/arch/arm/plat-mxc/devices/platform-imx-i2c.c
index d11f52d..f2780ad 100755
--- a/arch/arm/plat-mxc/devices/platform-imx-i2c.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-i2c.c
@@ -102,9 +102,12 @@ const struct imx_imx_i2c_data imx53_imx_i2c_data[] __initconst = {
 const struct imx_imx_i2c_data imx6q_imx_i2c_data[] __initconst = {
 #define imx6q_imx_i2c_data_entry(_id, _hwid)				\
 	imx_imx_i2c_data_entry(MX6Q, _id, _hwid, SZ_4K)
+#define imx6dl_imx_i2c_data_entry(_id, _hwid)				\
+	imx_imx_i2c_data_entry(MX6DL, _id, _hwid, SZ_4K)
 	imx6q_imx_i2c_data_entry(0, 1),
 	imx6q_imx_i2c_data_entry(1, 2),
 	imx6q_imx_i2c_data_entry(2, 3),
+	imx6dl_imx_i2c_data_entry(3, 4),
 };
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pcie.c b/arch/arm/plat-mxc/devices/platform-imx-pcie.c
index cf36093..7e0d630 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pcie.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pcie.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,6 +55,9 @@ struct platform_device *__init imx_add_pcie(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_PCIE))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("imx-pcie", -1,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata));
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pm.c b/arch/arm/plat-mxc/devices/platform-imx-pm.c
index f901e18..5b865ad 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pm.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,6 +30,11 @@ const struct imx_pm_imx_data imx6q_pm_imx_data[] __initconst =
 	imx_pm_imx_data_entry_single(MX6Q);
 #endif
 
+#ifdef CONFIG_SOC_IMX6SL
+const struct imx_pm_imx_data imx6sl_pm_imx_data[] __initconst =
+	imx_pm_imx_data_entry_single(MX6SL);
+#endif
+
 struct platform_device *__init imx_add_pm_imx(
 		const struct imx_pm_imx_data *data,
 		const struct pm_platform_data *pdata)
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pxp.c b/arch/arm/plat-mxc/devices/platform-imx-pxp.c
index 418489e..fed58d0 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pxp.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pxp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -54,18 +54,27 @@ struct platform_device *__init imx_add_imx_pxp(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("imx-pxp", -1,
 		res, ARRAY_SIZE(res), NULL, 0, DMA_BIT_MASK(32));
 }
 
 struct platform_device *__init imx_add_imx_pxp_client()
 {
-    return imx_add_platform_device("imx-pxp-client", -1,
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device("imx-pxp-client", -1,
 		NULL, 0, NULL, 0);
 }
 
 struct platform_device *__init imx_add_imx_pxp_v4l2()
 {
-    return imx_add_platform_device_dmamask("pxp-v4l2", -1,
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device_dmamask("pxp-v4l2", -1,
 		NULL, 0, NULL, 0, DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-uart.c b/arch/arm/plat-mxc/devices/platform-imx-uart.c
index 7f70dc9..e76b026 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-uart.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-uart.c
@@ -134,6 +134,7 @@ const struct imx_imx_uart_1irq_data imx6q_imx_uart_data[] __initconst = {
 	imx6q_imx_uart_data_entry(1, 2),
 	imx6q_imx_uart_data_entry(2, 3),
 	imx6q_imx_uart_data_entry(3, 4),
+	imx6q_imx_uart_data_entry(4, 5),
 };
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx_vpu.c b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
index c364391..f0295ad 100755
--- a/arch/arm/plat-mxc/devices/platform-imx_vpu.c
+++ b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  * Jason Chen <jason.chen@freescale.com>
  *
  * This program is free software; you can redistribute it and/or modify it under
@@ -123,7 +123,7 @@ void mx6q_vpu_reset(void)
 	 __raw_writel(reg, src_base + 0x18);
 
 	reg = __raw_readl(src_base);
-	reg |= 0x5;    /* warm reset vpu */
+	reg |= 0x4;    /* warm reset vpu */
 	__raw_writel(reg, src_base);
 	while (__raw_readl(src_base) & 0x04)
 		;
@@ -167,6 +167,9 @@ struct platform_device *__init imx_add_vpu(
 	pdata.iram_enable = data->iram_enable;
 	pdata.iram_size = data->iram_size;
 
+	if (!fuse_dev_is_available(MXC_DEV_VPU))
+		return ERR_PTR(-ENODEV);
+
 	if (cpu_is_mx6dl())
 		pdata.iram_enable = false;
 
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-ehci.c b/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
index 2b9cdff..984fa29 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
@@ -101,8 +101,52 @@ struct platform_device *__init imx_add_fsl_ehci(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
-	return imx_add_platform_device_dmamask("fsl-ehci", data->id,
-			res, ARRAY_SIZE(res),
-			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+	int ret = -ENOMEM;
+	const char *name = "fsl-ehci";
+	int id = data->id;
+	unsigned int num_resources = ARRAY_SIZE(res);
+	size_t size_data = sizeof(*pdata);
+	u64 dmamask = DMA_BIT_MASK(32);
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev)
+		goto err;
+
+	if (dmamask) {
+		/*
+		 * This memory isn't freed when the device is put,
+		 * I don't have a nice idea for that though.  Conceptually
+		 * dma_mask in struct device should not be a pointer.
+		 * See http://thread.gmane.org/gmane.linux.kernel.pci/9081
+		 */
+		pdev->dev.dma_mask =
+			kmalloc(sizeof(*pdev->dev.dma_mask), GFP_KERNEL);
+		if (!pdev->dev.dma_mask)
+			/* ret is still -ENOMEM; */
+			goto err;
+
+		*pdev->dev.dma_mask = dmamask;
+		pdev->dev.coherent_dma_mask = dmamask;
+	}
+
+	ret = platform_device_add_resources(pdev, res, num_resources);
+	if (ret)
+		goto err;
+
+    if (data) {
+		ret = platform_device_add_data(pdev, pdata, size_data);
+		if (ret)
+			goto err;
+	}
+
+	return pdev;
+
+err:
+		if (dmamask)
+			kfree(pdev->dev.dma_mask);
+		platform_device_put(pdev);
+		return ERR_PTR(ret);
+
 }
 EXPORT_SYMBOL(imx_add_fsl_ehci);
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
index e0c1906..2c9a32a 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -45,6 +45,9 @@ struct platform_device *__init imx_add_mxc_hdmi_core(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("mxc_hdmi_core", -1,
 		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
index d495262..cdbdae4 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -43,6 +43,10 @@ struct platform_device *__init imx_add_mxc_hdmi(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
+
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	imx_add_platform_device("mxc_hdmi_cec", 0,
 				       res, ARRAY_SIZE(res), NULL, 0);
 	return imx_add_platform_device_dmamask("mxc_hdmi", -1,
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_mlb.c b/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
index a1ede415..8925f3e 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -40,6 +40,7 @@ struct platform_device *__init imx_add_mlb(
 #endif /* ifdef CONFIG_SOC_IMX53 */
 
 #ifdef CONFIG_SOC_IMX6Q
+
 struct platform_device *__init imx_add_mlb(
 		const struct mxc_mlb_platform_data *pdata)
 {
@@ -65,6 +66,10 @@ struct platform_device *__init imx_add_mlb(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
+
+	if (!fuse_dev_is_available(MXC_DEV_MLB))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("mxc_mlb150", 0,
 			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-viv_gpu.c b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
index 9b02196..52c9b08 100644
--- a/arch/arm/plat-mxc/devices/platform-viv_gpu.c
+++ b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -90,13 +90,36 @@ struct platform_device *__init imx_add_viv_gpu(
 		},
 	};
 
-	if (cpu_is_mx6q() || cpu_is_mx6sl())
-		res_count = ARRAY_SIZE(res);
-	else if (cpu_is_mx6dl())
-		/* No openVG on i.mx6 Solo/DL */
-		res_count = ARRAY_SIZE(res) - 2;
+	res_count = ARRAY_SIZE(res);
 	BUG_ON(!res_count);
 
+	if (!fuse_dev_is_available(MXC_DEV_3D)) {
+		res[1].start = 0;
+		res[1].end = 0;
+		res[2].start = -1;
+		res[2].end = -1;
+	}
+
+	if (!fuse_dev_is_available(MXC_DEV_2D)) {
+		res[3].start = 0;
+		res[3].end = 0;
+		res[4].start = -1;
+		res[4].end = -1;
+	}
+
+	if (!fuse_dev_is_available(MXC_DEV_OVG)) {
+		res[5].start = 0;
+		res[5].end = 0;
+		res[6].start = -1;
+		res[6].end = -1;
+	}
+
+	/* None GPU core exists */
+	if ((res[2].start == -1) &&
+			(res[4].start == -1) &&
+			(res[6].start == -1))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("galcore", 0,
 			res, res_count,
 			pdata, sizeof(*pdata),
diff --git a/arch/arm/plat-mxc/fuse.c b/arch/arm/plat-mxc/fuse.c
new file mode 100644
index 0000000..1238e76
--- /dev/null
+++ b/arch/arm/plat-mxc/fuse.c
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <mach/hardware.h>
+
+#define HW_OCOTP_CFGn(n)	(0x00000410 + (n) * 0x10)
+
+/* Note: the names oder is the same as device enum order defined in mxc.h */
+static char *names[] = {
+	"pxp", "ovg", "dsi_csi2", "enet", "mlb",
+	"epdc", "hdmi", "pcie", "sata", "dtcp",
+	"2d", "3d", "vpu", "divx3", "rv",
+	"sorensen",
+};
+
+int fuse_dev_is_available(enum mxc_dev_type dev)
+{
+	u32 uninitialized_var(reg);
+	u32 uninitialized_var(mask);
+	int ret;
+
+	if (!cpu_is_mx6())
+		return 1;
+
+	/* mx6sl is still not supported */
+	if (cpu_is_mx6sl())
+		return 1;
+
+	switch (dev) {
+	case MXC_DEV_PXP:
+		if (cpu_is_mx6q())
+			return 0;
+
+		if (cpu_is_mx6dl()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x80000000;
+		}
+		break;
+	case MXC_DEV_OVG:
+		if (cpu_is_mx6dl())
+			return 0;
+
+		if (cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x40000000;
+		}
+		break;
+	case MXC_DEV_DSI_CSI2:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x10000000;
+		}
+		break;
+	case MXC_DEV_ENET:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x08000000;
+		}
+		break;
+	case MXC_DEV_MLB:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x04000000;
+		}
+		break;
+	case MXC_DEV_EPDC:
+		if (cpu_is_mx6q())
+			return 0;
+
+		if (cpu_is_mx6dl()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x02000000;
+		}
+		break;
+	case MXC_DEV_HDMI:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000080;
+		}
+		break;
+	case MXC_DEV_PCIE:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000040;
+		}
+		break;
+	case MXC_DEV_SATA:
+		if (cpu_is_mx6dl())
+			return 0;
+
+		if (cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000020;
+		}
+		break;
+	case MXC_DEV_DTCP:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000010;
+		}
+		break;
+	case MXC_DEV_2D:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000008;
+		}
+		break;
+	case MXC_DEV_3D:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000004;
+		}
+		break;
+	case MXC_DEV_VPU:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00008000;
+		}
+		break;
+	case MXC_DEV_DIVX3:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000400;
+		}
+		break;
+	case MXC_DEV_RV:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000200;
+		}
+		break;
+	case MXC_DEV_SORENSEN:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000100;
+		}
+		break;
+	default:
+		/* we treat the unkown device is avaiable by default */
+		return 1;
+	}
+
+	ret = readl(MX6_IO_ADDRESS(OCOTP_BASE_ADDR) + reg) & mask;
+	pr_debug("fuse_check: %s is %s\n", names[dev], ret ?
+					"unavailable" : "available");
+
+	return !ret;
+}
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
index 82b70d5..e12aee5 100755
--- a/arch/arm/plat-mxc/gpio.c
+++ b/arch/arm/plat-mxc/gpio.c
@@ -3,7 +3,7 @@
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * Based on code from Freescale,
- * Copyright (C) 2004-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2004-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -283,8 +283,13 @@ static int mxc_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
 	struct mxc_gpio_port *port =
 		container_of(chip, struct mxc_gpio_port, chip);
+	u32 gpio_direction;
 
-	return (__raw_readl(port->base + GPIO_PSR) >> offset) & 1;
+	gpio_direction = __raw_readl(port->base + GPIO_GDIR);
+	if (((gpio_direction >> offset) & 1)) /* output mode */
+		return (__raw_readl(port->base + GPIO_DR) >> offset) & 1;
+	else /* input mode */
+		return (__raw_readl(port->base + GPIO_PSR) >> offset) & 1;
 }
 
 static int mxc_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index f2bb01c..fdd8450 100755
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -121,6 +121,7 @@ extern void __iomem *imx_otg_base;
 /*      configured_flag                    (0x180)	   configflag (supports HS) */
 #define UH1_PORTSC1		USBH1_REG32(0x184)	/* port status and control */
 /* end EHCI registers: */
+#define UH1_OTGSC		USBH1_REG32(0x1a4)	/* OTG status and control */
 #define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
 
 /*
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index 1ff68bd..f6d616d 100755
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -112,9 +112,11 @@ struct imx_caam_jr_data {
 };
 
 struct imx_caam_data {
-	resource_size_t iobase_caam;
-	resource_size_t irq_sec_vio;
-	resource_size_t irq_snvs;
+	resource_size_t iobase_caam;	/* entirety of CAAM register map */
+	resource_size_t iobase_caam_sm;	/* base of secure memory */
+	resource_size_t iobase_snvs;	/* base of SNVS */
+	resource_size_t irq_sec_vio;	/* SNVS security violation */
+	resource_size_t irq_snvs;	/* SNVS consolidated (incl. RTC) */
 	struct imx_caam_jr_data jr[4];	/* offset+IRQ for each possible ring */
 };
 
diff --git a/arch/arm/plat-mxc/include/mach/dma.h b/arch/arm/plat-mxc/include/mach/dma.h
index 3fccb3b..af2edb8 100644
--- a/arch/arm/plat-mxc/include/mach/dma.h
+++ b/arch/arm/plat-mxc/include/mach/dma.h
@@ -101,5 +101,6 @@ static inline int mxs_dma_is_apbx(struct dma_chan *chan)
 	return !strcmp(dev_name(chan->device->dev), "mxs-dma-apbx");
 }
 
+void sdma_set_event_pending(struct dma_chan *chan);
 
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/epdc.h b/arch/arm/plat-mxc/include/mach/epdc.h
index 36aac88..e6dae37d 100644
--- a/arch/arm/plat-mxc/include/mach/epdc.h
+++ b/arch/arm/plat-mxc/include/mach/epdc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h b/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
index df528bc..59f8399 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,6 +58,9 @@
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
 		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
 
+#define MX6DL_ENET_REF_CLK_PAD_CTRL     (PAD_CTL_PUE |  \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |       \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
 
 #define MX6DL_I2C_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE   |		\
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
@@ -73,15 +76,26 @@
 #define MX6DL_ECSPI_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
 
+#define MX6DL_WEIM_NOR_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm |	\
+		PAD_CTL_SPEED_MED | PAD_CTL_PKE	| PAD_CTL_PUE | 	\
+		PAD_CTL_PUS_100K_UP)
+
 #define MX6DL_ADU_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
 		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
 		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
 
+#define MX6DL_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | \
+		PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_ODE | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
+
 #define MX6DL_GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
 #define MX6DL_GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | PAD_CTL_SRE_FAST)
 #define MX6DL_GPMI_PAD_CTRL2 (MX6DL_GPMI_PAD_CTRL0 | MX6DL_GPMI_PAD_CTRL1)
 #define MX6DL_SPDIF_OUT_PAD_CTRL (PAD_CTL_DSE_120ohm | PAD_CTL_SRE_FAST)
 
+#define ENET_IRQ_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SPEED_MED)
+
 #define MX6DL_PAD_CSI0_DAT10__IPU1_CSI0_D_10                                   \
 		IOMUX_PAD(0x0360, 0x004C, 0, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT10__AUDMUX_AUD3_RXC                                  \
@@ -1255,7 +1269,7 @@
 		IOMUX_PAD(0x04DC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A16__WEIM_WEIM_A_16                                      \
-		IOMUX_PAD(0x04E0, 0x0110, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E0, 0x0110, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A16__IPU1_DI1_DISP_CLK                                   \
 		IOMUX_PAD(0x04E0, 0x0110, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A16__IPU1_CSI1_PIXCLK                                    \
@@ -1272,7 +1286,7 @@
 		IOMUX_PAD(0x04E0, 0x0110, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A17__WEIM_WEIM_A_17                                      \
-		IOMUX_PAD(0x04E4, 0x0114, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E4, 0x0114, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A17__IPU1_DISP1_DAT_12                                   \
 		IOMUX_PAD(0x04E4, 0x0114, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A17__IPU1_CSI1_D_12                                      \
@@ -1289,7 +1303,7 @@
 		IOMUX_PAD(0x04E4, 0x0114, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A18__WEIM_WEIM_A_18                                      \
-		IOMUX_PAD(0x04E8, 0x0118, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E8, 0x0118, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A18__IPU1_DISP1_DAT_13                                   \
 		IOMUX_PAD(0x04E8, 0x0118, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A18__IPU1_CSI1_D_13                                      \
@@ -1306,7 +1320,7 @@
 		IOMUX_PAD(0x04E8, 0x0118, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A19__WEIM_WEIM_A_19                                      \
-		IOMUX_PAD(0x04EC, 0x011C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04EC, 0x011C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A19__IPU1_DISP1_DAT_14                                   \
 		IOMUX_PAD(0x04EC, 0x011C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A19__IPU1_CSI1_D_14                                      \
@@ -1323,7 +1337,7 @@
 		IOMUX_PAD(0x04EC, 0x011C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A20__WEIM_WEIM_A_20                                      \
-		IOMUX_PAD(0x04F0, 0x0120, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F0, 0x0120, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A20__IPU1_DISP1_DAT_15                                   \
 		IOMUX_PAD(0x04F0, 0x0120, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A20__IPU1_CSI1_D_15                                      \
@@ -1340,7 +1354,7 @@
 		IOMUX_PAD(0x04F0, 0x0120, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A21__WEIM_WEIM_A_21                                      \
-		IOMUX_PAD(0x04F4, 0x0124, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F4, 0x0124, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A21__IPU1_DISP1_DAT_16                                   \
 		IOMUX_PAD(0x04F4, 0x0124, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A21__IPU1_CSI1_D_16                                      \
@@ -1357,7 +1371,7 @@
 		IOMUX_PAD(0x04F4, 0x0124, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A22__WEIM_WEIM_A_22                                      \
-		IOMUX_PAD(0x04F8, 0x0128, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F8, 0x0128, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A22__IPU1_DISP1_DAT_17                                   \
 		IOMUX_PAD(0x04F8, 0x0128, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A22__IPU1_CSI1_D_17                                      \
@@ -1372,7 +1386,7 @@
 		IOMUX_PAD(0x04F8, 0x0128, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A23__WEIM_WEIM_A_23                                      \
-		IOMUX_PAD(0x04FC, 0x012C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04FC, 0x012C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A23__IPU1_DISP1_DAT_18                                   \
 		IOMUX_PAD(0x04FC, 0x012C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A23__IPU1_CSI1_D_18                                      \
@@ -1418,7 +1432,7 @@
 #define MX6DL_PAD_EIM_A25__GPIO_5_2                                            \
 		IOMUX_PAD(0x0504, 0x0134, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A25__HDMI_TX_CEC_LINE                                    \
-		IOMUX_PAD(0x0504, 0x0134, 6, 0x085C, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0504, 0x0134, 6, 0x085C, 0, MX6DL_HDMICEC_PAD_CTRL)
 #define MX6DL_PAD_EIM_A25__PL301_SIM_MX6DL_PER1_HBURST_0                       \
 		IOMUX_PAD(0x0504, 0x0134, 7, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A25__EPDC_SDDO_15                                        \
@@ -1468,7 +1482,7 @@
 		IOMUX_PAD(0x0510, 0x0140, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D16__WEIM_WEIM_D_16                                      \
-		IOMUX_PAD(0x0514, 0x0144, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0514, 0x0144, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D16__ECSPI1_SCLK                                         \
 		IOMUX_PAD(0x0514, 0x0144, 1, 0x07D8, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D16__IPU1_DI0_PIN5                                       \
@@ -1487,7 +1501,7 @@
 		IOMUX_PAD(0x0514, 0x0144, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D17__WEIM_WEIM_D_17                                      \
-		IOMUX_PAD(0x0518, 0x0148, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0518, 0x0148, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D17__ECSPI1_MISO                                         \
 		IOMUX_PAD(0x0518, 0x0148, 1, 0x07DC, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D17__IPU1_DI0_PIN6                                       \
@@ -1506,7 +1520,7 @@
 		IOMUX_PAD(0x0518, 0x0148, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D18__WEIM_WEIM_D_18                                      \
-		IOMUX_PAD(0x051C, 0x014C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x051C, 0x014C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D18__ECSPI1_MOSI                                         \
 		IOMUX_PAD(0x051C, 0x014C, 1, 0x07E0, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D18__IPU1_DI0_PIN7                                       \
@@ -1525,7 +1539,7 @@
 		IOMUX_PAD(0x051C, 0x014C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D19__WEIM_WEIM_D_19                                      \
-		IOMUX_PAD(0x0520, 0x0150, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0520, 0x0150, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D19__ECSPI1_SS1                                          \
 		IOMUX_PAD(0x0520, 0x0150, 1, 0x07E8, 1, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D19__IPU1_DI0_PIN8                                       \
@@ -1546,7 +1560,7 @@
 		IOMUX_PAD(0x0520, 0x0150, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D20__WEIM_WEIM_D_20                                      \
-		IOMUX_PAD(0x0524, 0x0154, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0524, 0x0154, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D20__ECSPI4_SS0                                          \
 		IOMUX_PAD(0x0524, 0x0154, 1, 0x0808, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D20__IPU1_DI0_PIN16                                      \
@@ -1565,7 +1579,7 @@
 		IOMUX_PAD(0x0524, 0x0154, 7, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D21__WEIM_WEIM_D_21                                      \
-		IOMUX_PAD(0x0528, 0x0158, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0528, 0x0158, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D21__ECSPI4_SCLK                                         \
 		IOMUX_PAD(0x0528, 0x0158, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D21__IPU1_DI0_PIN17                                      \
@@ -1582,7 +1596,7 @@
 		IOMUX_PAD(0x0528, 0x0158, 7, 0x08F0, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D22__WEIM_WEIM_D_22                                      \
-		IOMUX_PAD(0x052C, 0x015C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x052C, 0x015C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D22__ECSPI4_MISO                                         \
 		IOMUX_PAD(0x052C, 0x015C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D22__IPU1_DI0_PIN1                                       \
@@ -1601,7 +1615,7 @@
 		IOMUX_PAD(0x052C, 0x015C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D23__WEIM_WEIM_D_23                                      \
-		IOMUX_PAD(0x0530, 0x0160, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0530, 0x0160, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D23__IPU1_DI0_D0_CS                                      \
 		IOMUX_PAD(0x0530, 0x0160, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D23__UART3_CTS                                           \
@@ -1622,7 +1636,7 @@
 		IOMUX_PAD(0x0530, 0x0160, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D24__WEIM_WEIM_D_24                                      \
-		IOMUX_PAD(0x0534, 0x0164, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0534, 0x0164, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D24__ECSPI4_SS2                                          \
 		IOMUX_PAD(0x0534, 0x0164, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D24__UART3_TXD                                           \
@@ -1643,7 +1657,7 @@
 		IOMUX_PAD(0x0534, 0x0164, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D25__WEIM_WEIM_D_25                                      \
-		IOMUX_PAD(0x0538, 0x0168, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0538, 0x0168, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D25__ECSPI4_SS3                                          \
 		IOMUX_PAD(0x0538, 0x0168, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D25__UART3_TXD                                           \
@@ -1664,7 +1678,7 @@
 		IOMUX_PAD(0x0538, 0x0168, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D26__WEIM_WEIM_D_26                                      \
-		IOMUX_PAD(0x053C, 0x016C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x053C, 0x016C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D26__IPU1_DI1_PIN11                                      \
 		IOMUX_PAD(0x053C, 0x016C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D26__IPU1_CSI0_D_1                                       \
@@ -1685,7 +1699,7 @@
 		IOMUX_PAD(0x053C, 0x016C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D27__WEIM_WEIM_D_27                                      \
-		IOMUX_PAD(0x0540, 0x0170, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0540, 0x0170, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D27__IPU1_DI1_PIN13                                      \
 		IOMUX_PAD(0x0540, 0x0170, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D27__IPU1_CSI0_D_0                                       \
@@ -1706,7 +1720,7 @@
 		IOMUX_PAD(0x0540, 0x0170, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D28__WEIM_WEIM_D_28                                      \
-		IOMUX_PAD(0x0544, 0x0174, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0544, 0x0174, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D28__I2C1_SDA                                            \
 		IOMUX_PAD(0x0544, 0x0174, 1 | IOMUX_CONFIG_SION, 0x086C, 1, MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_EIM_D28__ECSPI4_MOSI                                         \
@@ -1727,7 +1741,7 @@
 		IOMUX_PAD(0x0544, 0x0174, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D29__WEIM_WEIM_D_29                                      \
-		IOMUX_PAD(0x0548, 0x0178, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0548, 0x0178, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D29__IPU1_DI1_PIN15                                      \
 		IOMUX_PAD(0x0548, 0x0178, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D29__ECSPI4_SS0                                          \
@@ -1746,7 +1760,7 @@
 		IOMUX_PAD(0x0548, 0x0178, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D30__WEIM_WEIM_D_30                                      \
-		IOMUX_PAD(0x054C, 0x017C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x054C, 0x017C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D30__IPU1_DISP1_DAT_21                                   \
 		IOMUX_PAD(0x054C, 0x017C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D30__IPU1_DI0_PIN11                                      \
@@ -1767,7 +1781,7 @@
 		IOMUX_PAD(0x054C, 0x017C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D31__WEIM_WEIM_D_31                                      \
-		IOMUX_PAD(0x0550, 0x0180, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0550, 0x0180, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D31__IPU1_DISP1_DAT_20                                   \
 		IOMUX_PAD(0x0550, 0x0180, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D31__IPU1_DI0_PIN12                                      \
@@ -1790,7 +1804,7 @@
 		IOMUX_PAD(0x0550, 0x0180, 9, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA0__WEIM_WEIM_DA_A_0                                    \
-		IOMUX_PAD(0x0554, 0x0184, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0554, 0x0184, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA0__IPU1_DISP1_DAT_9                                    \
 		IOMUX_PAD(0x0554, 0x0184, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA0__IPU1_CSI1_D_9                                       \
@@ -1807,7 +1821,7 @@
 		IOMUX_PAD(0x0554, 0x0184, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA1__WEIM_WEIM_DA_A_1                                    \
-		IOMUX_PAD(0x0558, 0x0188, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0558, 0x0188, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA1__IPU1_DISP1_DAT_8                                    \
 		IOMUX_PAD(0x0558, 0x0188, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA1__IPU1_CSI1_D_8                                       \
@@ -1826,7 +1840,7 @@
 		IOMUX_PAD(0x0558, 0x0188, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA10__WEIM_WEIM_DA_A_10                                  \
-		IOMUX_PAD(0x055C, 0x018C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x055C, 0x018C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA10__IPU1_DI1_PIN15                                     \
 		IOMUX_PAD(0x055C, 0x018C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA10__IPU1_CSI1_DATA_EN                                  \
@@ -1843,7 +1857,7 @@
 		IOMUX_PAD(0x055C, 0x018C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA11__WEIM_WEIM_DA_A_11                                  \
-		IOMUX_PAD(0x0560, 0x0190, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0560, 0x0190, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA11__IPU1_DI1_PIN2                                      \
 		IOMUX_PAD(0x0560, 0x0190, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA11__IPU1_CSI1_HSYNC                                    \
@@ -1862,7 +1876,7 @@
 		IOMUX_PAD(0x0560, 0x0190, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA12__WEIM_WEIM_DA_A_12                                  \
-		IOMUX_PAD(0x0564, 0x0194, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0564, 0x0194, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA12__IPU1_DI1_PIN3                                      \
 		IOMUX_PAD(0x0564, 0x0194, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA12__IPU1_CSI1_VSYNC                                    \
@@ -1881,7 +1895,7 @@
 		IOMUX_PAD(0x0564, 0x0194, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA13__WEIM_WEIM_DA_A_13                                  \
-		IOMUX_PAD(0x0568, 0x0198, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0568, 0x0198, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA13__IPU1_DI1_D0_CS                                     \
 		IOMUX_PAD(0x0568, 0x0198, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA13__CCM_DI1_EXT_CLK                                    \
@@ -1900,7 +1914,7 @@
 		IOMUX_PAD(0x0568, 0x0198, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA14__WEIM_WEIM_DA_A_14                                  \
-		IOMUX_PAD(0x056C, 0x019C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x056C, 0x019C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA14__IPU1_DI1_D1_CS                                     \
 		IOMUX_PAD(0x056C, 0x019C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA14__CCM_DI0_EXT_CLK                                    \
@@ -1919,7 +1933,7 @@
 		IOMUX_PAD(0x056C, 0x019C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA15__WEIM_WEIM_DA_A_15                                  \
-		IOMUX_PAD(0x0570, 0x01A0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0570, 0x01A0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA15__IPU1_DI1_PIN1                                      \
 		IOMUX_PAD(0x0570, 0x01A0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA15__IPU1_DI1_PIN4                                      \
@@ -1936,7 +1950,7 @@
 		IOMUX_PAD(0x0570, 0x01A0, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA2__WEIM_WEIM_DA_A_2                                    \
-		IOMUX_PAD(0x0574, 0x01A4, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0574, 0x01A4, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA2__IPU1_DISP1_DAT_7                                    \
 		IOMUX_PAD(0x0574, 0x01A4, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA2__IPU1_CSI1_D_7                                       \
@@ -1955,7 +1969,7 @@
 		IOMUX_PAD(0x0574, 0x01A4, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA3__WEIM_WEIM_DA_A_3                                    \
-		IOMUX_PAD(0x0578, 0x01A8, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0578, 0x01A8, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA3__IPU1_DISP1_DAT_6                                    \
 		IOMUX_PAD(0x0578, 0x01A8, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA3__IPU1_CSI1_D_6                                       \
@@ -1974,7 +1988,7 @@
 		IOMUX_PAD(0x0578, 0x01A8, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA4__WEIM_WEIM_DA_A_4                                    \
-		IOMUX_PAD(0x057C, 0x01AC, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x057C, 0x01AC, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA4__IPU1_DISP1_DAT_5                                    \
 		IOMUX_PAD(0x057C, 0x01AC, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA4__IPU1_CSI1_D_5                                       \
@@ -1993,7 +2007,7 @@
 		IOMUX_PAD(0x057C, 0x01AC, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA5__WEIM_WEIM_DA_A_5                                    \
-		IOMUX_PAD(0x0580, 0x01B0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0580, 0x01B0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA5__IPU1_DISP1_DAT_4                                    \
 		IOMUX_PAD(0x0580, 0x01B0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA5__IPU1_CSI1_D_4                                       \
@@ -2012,7 +2026,7 @@
 		IOMUX_PAD(0x0580, 0x01B0, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA6__WEIM_WEIM_DA_A_6                                    \
-		IOMUX_PAD(0x0584, 0x01B4, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0584, 0x01B4, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA6__IPU1_DISP1_DAT_3                                    \
 		IOMUX_PAD(0x0584, 0x01B4, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA6__IPU1_CSI1_D_3                                       \
@@ -2031,7 +2045,7 @@
 		IOMUX_PAD(0x0584, 0x01B4, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA7__WEIM_WEIM_DA_A_7                                    \
-		IOMUX_PAD(0x0588, 0x01B8, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0588, 0x01B8, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA7__IPU1_DISP1_DAT_2                                    \
 		IOMUX_PAD(0x0588, 0x01B8, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA7__IPU1_CSI1_D_2                                       \
@@ -2048,7 +2062,7 @@
 		IOMUX_PAD(0x0588, 0x01B8, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA8__WEIM_WEIM_DA_A_8                                    \
-		IOMUX_PAD(0x058C, 0x01BC, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x058C, 0x01BC, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA8__IPU1_DISP1_DAT_1                                    \
 		IOMUX_PAD(0x058C, 0x01BC, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA8__IPU1_CSI1_D_1                                       \
@@ -2065,7 +2079,7 @@
 		IOMUX_PAD(0x058C, 0x01BC, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA9__WEIM_WEIM_DA_A_9                                    \
-		IOMUX_PAD(0x0590, 0x01C0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0590, 0x01C0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA9__IPU1_DISP1_DAT_0                                    \
 		IOMUX_PAD(0x0590, 0x01C0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA9__IPU1_CSI1_D_0                                       \
@@ -2257,7 +2271,7 @@
 		IOMUX_PAD(0x05BC, 0x01EC, 6, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_ENET_REF_CLK__ENET_TX_CLK                                    \
-		IOMUX_PAD(0x05C0, 0x01F0, 1, 0x0000, 0, MX6DL_ENET_PAD_CTRL)
+		IOMUX_PAD(0x05C0, 0x01F0, 1, 0x0000, 0, MX6DL_ENET_REF_CLK_PAD_CTRL)
 #define MX6DL_PAD_ENET_REF_CLK__ESAI1_FSR                                      \
 		IOMUX_PAD(0x05C0, 0x01F0, 2, 0x082C, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_ENET_REF_CLK__SDMA_DEBUG_BUS_DEVICE_4                        \
@@ -2517,10 +2531,12 @@
 #define MX6DL_PAD_GPIO_5__SIMBA_EVENTI                                         \
 		IOMUX_PAD(0x0600, 0x0230, 7, 0x0000, 0, NO_PAD_CTRL)
 
-#define MX6DL_PAD_GPIO_6__ESAI1_SCKT                                           \
-		IOMUX_PAD(0x0604, 0x0234, 0, 0x0840, 1, NO_PAD_CTRL)
+#define MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6                           \
+		IOMUX_PAD(0x0604, 0x0234, 1 | IOMUX_CONFIG_SION, 0x0000, 0, ENET_IRQ_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1                           \
 		IOMUX_PAD(0x0604, 0x0234, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6DL_PAD_GPIO_6__ESAI1_SCKT                                           \
+		IOMUX_PAD(0x0604, 0x0234, 0, 0x0840, 1, NO_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__I2C3_SDA                                             \
 		IOMUX_PAD(0x0604, 0x0234, 2 | IOMUX_CONFIG_SION, 0x087C, 2, MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__CCM_CCM_OUT_0                                        \
@@ -2753,7 +2769,7 @@
 #define MX6DL_PAD_KEY_ROW2__GPIO_4_11                                          \
 		IOMUX_PAD(0x0648, 0x0260, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE                                   \
-		IOMUX_PAD(0x0648, 0x0260, 6, 0x085C, 1, NO_PAD_CTRL)
+		IOMUX_PAD(0x0648, 0x0260, 6, 0x085C, 1, MX6DL_HDMICEC_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW2__PL301_SIM_MX6DL_PER1_HADDR_4                       \
 		IOMUX_PAD(0x0648, 0x0260, 7, 0x0000, 0, NO_PAD_CTRL)
 
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6q.h b/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
index 9226af1..16cd87f 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,6 +57,10 @@
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+#define MX6Q_ENET_REF_CLK_PAD_CTRL	(PAD_CTL_PUE |	\
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	\
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
 #define MX6Q_GPIO_16_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |    \
 		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED  |    \
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
@@ -81,7 +85,7 @@
 #define MX6Q_ECSPI_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
-#define MX6Q_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | \
+#define MX6Q_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | \
 		PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_ODE | PAD_CTL_SPEED_MED | \
 		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
 
@@ -89,6 +93,13 @@
 		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
 		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
 
+#define MX6Q_WEIM_NOR_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm |	\
+		PAD_CTL_SPEED_MED | PAD_CTL_PKE	| PAD_CTL_PUE | 	\
+		PAD_CTL_PUS_100K_UP)
+
+#define ENET_IRQ_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SPEED_MED)
+
 #define _MX6Q_PAD_SD2_DAT1__USDHC2_DAT1				\
 		IOMUX_PAD(0x0360, 0x004C, 0, 0x0000, 0, 0)
 #define _MX6Q_PAD_SD2_DAT1__ECSPI5_SS0				\
@@ -566,7 +577,7 @@
 #define _MX6Q_PAD_EIM_D30__IPU1_CSI0_D_3				\
 		IOMUX_PAD(0x03E0, 0x00CC, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_EIM_D30__UART3_CTS			\
-		IOMUX_PAD(0x03E0, 0x00CC, 4, 0x092C, 2, 0)
+		IOMUX_PAD(0x03E0, 0x00CC, 4, 0x0000, 0, 0)
 #define _MX6Q_PAD_EIM_D30__GPIO_3_30			\
 		IOMUX_PAD(0x03E0, 0x00CC, 5, 0x0000, 0, 0)
 #define _MX6Q_PAD_EIM_D30__USBOH3_USBH1_OC		\
@@ -2245,7 +2256,7 @@
 #define _MX6Q_PAD_KEY_ROW4__KPP_ROW_4			\
 		IOMUX_PAD(0x05EC, 0x021C, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__UART5_CTS			\
-		IOMUX_PAD(0x05EC, 0x021C, 4, 0x093C, 1, 0)
+		IOMUX_PAD(0x05EC, 0x021C, 4, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__GPIO_4_15			\
 		IOMUX_PAD(0x05EC, 0x021C, 5, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__MMDC_MMDC_DEBUG_50		\
@@ -2321,6 +2332,8 @@
 
 #define _MX6Q_PAD_GPIO_6__ESAI1_SCKT			\
 		IOMUX_PAD(0x0600, 0x0230, 0, 0x0870, 1, 0)
+#define _MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6		\
+		IOMUX_PAD(0x0600, 0x0230, 1 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
 #define _MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
 		IOMUX_PAD(0x0600, 0x0230, 1, 0x0000, 0, 0)
 #define _MX6Q_PAD_GPIO_6__I2C3_SDA			\
@@ -3898,7 +3911,7 @@
 		(_MX6Q_PAD_EIM_EB2__SRC_BT_CFG_30 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16		\
-		(_MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D16__ECSPI1_SCLK		\
 		(_MX6Q_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D16__IPU1_DI0_PIN5		\
@@ -3913,7 +3926,7 @@
 		(_MX6Q_PAD_EIM_D16__I2C2_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17		\
-		(_MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D17__ECSPI1_MISO		\
 		(_MX6Q_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D17__IPU1_DI0_PIN6		\
@@ -3930,7 +3943,7 @@
 		(_MX6Q_PAD_EIM_D17__PL301_MX6QPER1_HBURST_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18		\
-		(_MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D18__ECSPI1_MOSI		\
 		(_MX6Q_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D18__IPU1_DI0_PIN7		\
@@ -3947,7 +3960,7 @@
 		(_MX6Q_PAD_EIM_D18__PL301_MX6QPER1_HBURST_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19		\
-		(_MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D19__ECSPI1_SS1		\
 		(_MX6Q_PAD_EIM_D19__ECSPI1_SS1 | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D19__IPU1_DI0_PIN8		\
@@ -3964,7 +3977,7 @@
 		(_MX6Q_PAD_EIM_D19__PL301_MX6QPER1_HRESP | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20		\
-		(_MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D20__ECSPI4_SS0		\
 		(_MX6Q_PAD_EIM_D20__ECSPI4_SS0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D20__IPU1_DI0_PIN16		\
@@ -3981,7 +3994,7 @@
 		(_MX6Q_PAD_EIM_D20__EPIT2_EPITO | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21		\
-		(_MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D21__ECSPI4_SCLK		\
 		(_MX6Q_PAD_EIM_D21__ECSPI4_SCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D21__IPU1_DI0_PIN17		\
@@ -3998,7 +4011,7 @@
 		(_MX6Q_PAD_EIM_D21__SPDIF_IN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22		\
-		(_MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D22__ECSPI4_MISO		\
 		(_MX6Q_PAD_EIM_D22__ECSPI4_MISO | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D22__IPU1_DI0_PIN1		\
@@ -4015,7 +4028,7 @@
 		(_MX6Q_PAD_EIM_D22__PL301_MX6QPER1_HWRITE | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23		\
-		(_MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D23__IPU1_DI0_D0_CS		\
 		(_MX6Q_PAD_EIM_D23__IPU1_DI0_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D23__UART3_CTS		\
@@ -4051,7 +4064,7 @@
 		(_MX6Q_PAD_EIM_EB3__SRC_BT_CFG_31 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24		\
-		(_MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D24__ECSPI4_SS2		\
 		(_MX6Q_PAD_EIM_D24__ECSPI4_SS2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D24__UART3_TXD		\
@@ -4070,7 +4083,7 @@
 		(_MX6Q_PAD_EIM_D24__UART1_DTR | MUX_PAD_CTRL(MX6Q_UART_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25		\
-		(_MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D25__ECSPI4_SS3		\
 		(_MX6Q_PAD_EIM_D25__ECSPI4_SS3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D25__UART3_TXD		\
@@ -4089,7 +4102,7 @@
 		(_MX6Q_PAD_EIM_D25__UART1_DSR | MUX_PAD_CTRL(MX6Q_UART_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26		\
-		(_MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D26__IPU1_DI1_PIN11		\
 		(_MX6Q_PAD_EIM_D26__IPU1_DI1_PIN11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D26__IPU1_CSI0_D_1		\
@@ -4108,7 +4121,7 @@
 		(_MX6Q_PAD_EIM_D26__IPU1_DISP1_DAT_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27		\
-		(_MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D27__IPU1_DI1_PIN13		\
 		(_MX6Q_PAD_EIM_D27__IPU1_DI1_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D27__IPU1_CSI0_D_0		\
@@ -4127,7 +4140,7 @@
 		(_MX6Q_PAD_EIM_D27__IPU1_DISP1_DAT_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28		\
-		(_MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D28__I2C1_SDA		\
 		(_MX6Q_PAD_EIM_D28__I2C1_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D28__ECSPI4_MOSI		\
@@ -4146,7 +4159,7 @@
 		(_MX6Q_PAD_EIM_D28__IPU1_DI0_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29		\
-		(_MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D29__IPU1_DI1_PIN15		\
 		(_MX6Q_PAD_EIM_D29__IPU1_DI1_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D29__ECSPI4_SS0		\
@@ -4163,7 +4176,7 @@
 		(_MX6Q_PAD_EIM_D29__IPU1_DI0_PIN14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30		\
-		(_MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D30__IPU1_DISP1_DAT_21		\
 		(_MX6Q_PAD_EIM_D30__IPU1_DISP1_DAT_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D30__IPU1_DI0_PIN11		\
@@ -4180,7 +4193,7 @@
 		(_MX6Q_PAD_EIM_D30__PL301_MX6QPER1_HPROT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31		\
-		(_MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D31__IPU1_DISP1_DAT_20		\
 		(_MX6Q_PAD_EIM_D31__IPU1_DISP1_DAT_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D31__IPU1_DI0_PIN12		\
@@ -4216,7 +4229,7 @@
 		(_MX6Q_PAD_EIM_A24__SRC_BT_CFG_24 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23		\
-		(_MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A23__IPU1_DISP1_DAT_18		\
 		(_MX6Q_PAD_EIM_A23__IPU1_DISP1_DAT_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A23__IPU2_CSI1_D_18		\
@@ -4233,7 +4246,7 @@
 		(_MX6Q_PAD_EIM_A23__SRC_BT_CFG_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22		\
-		(_MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A22__IPU1_DISP1_DAT_17		\
 		(_MX6Q_PAD_EIM_A22__IPU1_DISP1_DAT_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A22__IPU2_CSI1_D_17		\
@@ -4246,7 +4259,7 @@
 		(_MX6Q_PAD_EIM_A22__SRC_BT_CFG_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21		\
-		(_MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A21__IPU1_DISP1_DAT_16		\
 		(_MX6Q_PAD_EIM_A21__IPU1_DISP1_DAT_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A21__IPU2_CSI1_D_16		\
@@ -4263,7 +4276,7 @@
 		(_MX6Q_PAD_EIM_A21__SRC_BT_CFG_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20		\
-		(_MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A20__IPU1_DISP1_DAT_15		\
 		(_MX6Q_PAD_EIM_A20__IPU1_DISP1_DAT_15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A20__IPU2_CSI1_D_15		\
@@ -4280,7 +4293,7 @@
 		(_MX6Q_PAD_EIM_A20__SRC_BT_CFG_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19		\
-		(_MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A19__IPU1_DISP1_DAT_14		\
 		(_MX6Q_PAD_EIM_A19__IPU1_DISP1_DAT_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A19__IPU2_CSI1_D_14		\
@@ -4297,7 +4310,7 @@
 		(_MX6Q_PAD_EIM_A19__SRC_BT_CFG_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18		\
-		(_MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A18__IPU1_DISP1_DAT_13		\
 		(_MX6Q_PAD_EIM_A18__IPU1_DISP1_DAT_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A18__IPU2_CSI1_D_13		\
@@ -4314,7 +4327,7 @@
 		(_MX6Q_PAD_EIM_A18__SRC_BT_CFG_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17		\
-		(_MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A17__IPU1_DISP1_DAT_12		\
 		(_MX6Q_PAD_EIM_A17__IPU1_DISP1_DAT_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A17__IPU2_CSI1_D_12		\
@@ -4331,7 +4344,7 @@
 		(_MX6Q_PAD_EIM_A17__SRC_BT_CFG_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16		\
-		(_MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A16__IPU1_DI1_DISP_CLK		\
 		(_MX6Q_PAD_EIM_A16__IPU1_DI1_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A16__IPU2_CSI1_PIXCLK		\
@@ -4445,7 +4458,7 @@
 		(_MX6Q_PAD_EIM_EB1__SRC_BT_CFG_28 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0		\
-		(_MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA0__IPU1_DISP1_DAT_9		\
 		(_MX6Q_PAD_EIM_DA0__IPU1_DISP1_DAT_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA0__IPU2_CSI1_D_9		\
@@ -4460,7 +4473,7 @@
 		(_MX6Q_PAD_EIM_DA0__SRC_BT_CFG_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1		\
-		(_MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA1__IPU1_DISP1_DAT_8		\
 		(_MX6Q_PAD_EIM_DA1__IPU1_DISP1_DAT_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA1__IPU2_CSI1_D_8		\
@@ -4477,7 +4490,7 @@
 		(_MX6Q_PAD_EIM_DA1__SRC_BT_CFG_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2		\
-		(_MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA2__IPU1_DISP1_DAT_7		\
 		(_MX6Q_PAD_EIM_DA2__IPU1_DISP1_DAT_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA2__IPU2_CSI1_D_7		\
@@ -4494,7 +4507,7 @@
 		(_MX6Q_PAD_EIM_DA2__SRC_BT_CFG_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3		\
-		(_MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA3__IPU1_DISP1_DAT_6		\
 		(_MX6Q_PAD_EIM_DA3__IPU1_DISP1_DAT_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA3__IPU2_CSI1_D_6		\
@@ -4511,7 +4524,7 @@
 		(_MX6Q_PAD_EIM_DA3__SRC_BT_CFG_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4		\
-		(_MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA4__IPU1_DISP1_DAT_5		\
 		(_MX6Q_PAD_EIM_DA4__IPU1_DISP1_DAT_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA4__IPU2_CSI1_D_5		\
@@ -4528,7 +4541,7 @@
 		(_MX6Q_PAD_EIM_DA4__SRC_BT_CFG_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5		\
-		(_MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA5__IPU1_DISP1_DAT_4		\
 		(_MX6Q_PAD_EIM_DA5__IPU1_DISP1_DAT_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA5__IPU2_CSI1_D_4		\
@@ -4545,7 +4558,7 @@
 		(_MX6Q_PAD_EIM_DA5__SRC_BT_CFG_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6		\
-		(_MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA6__IPU1_DISP1_DAT_3		\
 		(_MX6Q_PAD_EIM_DA6__IPU1_DISP1_DAT_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA6__IPU2_CSI1_D_3		\
@@ -4562,7 +4575,7 @@
 		(_MX6Q_PAD_EIM_DA6__SRC_BT_CFG_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7		\
-		(_MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA7__IPU1_DISP1_DAT_2		\
 		(_MX6Q_PAD_EIM_DA7__IPU1_DISP1_DAT_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA7__IPU2_CSI1_D_2		\
@@ -4577,7 +4590,7 @@
 		(_MX6Q_PAD_EIM_DA7__SRC_BT_CFG_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8		\
-		(_MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA8__IPU1_DISP1_DAT_1		\
 		(_MX6Q_PAD_EIM_DA8__IPU1_DISP1_DAT_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA8__IPU2_CSI1_D_1		\
@@ -4592,7 +4605,7 @@
 		(_MX6Q_PAD_EIM_DA8__SRC_BT_CFG_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9		\
-		(_MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA9__IPU1_DISP1_DAT_0		\
 		(_MX6Q_PAD_EIM_DA9__IPU1_DISP1_DAT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA9__IPU2_CSI1_D_0		\
@@ -4607,7 +4620,7 @@
 		(_MX6Q_PAD_EIM_DA9__SRC_BT_CFG_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10		\
-		(_MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA10__IPU1_DI1_PIN15		\
 		(_MX6Q_PAD_EIM_DA10__IPU1_DI1_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA10__IPU2_CSI1_DATA_EN		\
@@ -4622,7 +4635,7 @@
 		(_MX6Q_PAD_EIM_DA10__SRC_BT_CFG_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11		\
-		(_MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA11__IPU1_DI1_PIN2		\
 		(_MX6Q_PAD_EIM_DA11__IPU1_DI1_PIN2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA11__IPU2_CSI1_HSYNC		\
@@ -4639,7 +4652,7 @@
 		(_MX6Q_PAD_EIM_DA11__SRC_BT_CFG_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12		\
-		(_MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA12__IPU1_DI1_PIN3		\
 		(_MX6Q_PAD_EIM_DA12__IPU1_DI1_PIN3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA12__IPU2_CSI1_VSYNC		\
@@ -4656,7 +4669,7 @@
 		(_MX6Q_PAD_EIM_DA12__SRC_BT_CFG_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13		\
-		(_MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA13__IPU1_DI1_D0_CS		\
 		(_MX6Q_PAD_EIM_DA13__IPU1_DI1_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA13__CCM_DI1_EXT_CLK		\
@@ -4673,7 +4686,7 @@
 		(_MX6Q_PAD_EIM_DA13__SRC_BT_CFG_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14		\
-		(_MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA14__IPU1_DI1_D1_CS		\
 		(_MX6Q_PAD_EIM_DA14__IPU1_DI1_D1_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA14__CCM_DI0_EXT_CLK		\
@@ -4690,7 +4703,7 @@
 		(_MX6Q_PAD_EIM_DA14__SRC_BT_CFG_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15		\
-		(_MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN1		\
 		(_MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN4		\
@@ -5216,7 +5229,7 @@
 #define  MX6Q_PAD_ENET_REF_CLK__RESERVED_RESERVED		\
 		(_MX6Q_PAD_ENET_REF_CLK__RESERVED_RESERVED | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK		\
-		(_MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK | MUX_PAD_CTRL(MX6Q_ENET_PAD_CTRL))
+		(_MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK | MUX_PAD_CTRL(MX6Q_ENET_REF_CLK_PAD_CTRL))
 #define  MX6Q_PAD_ENET_REF_CLK__ESAI1_FSR		\
 		(_MX6Q_PAD_ENET_REF_CLK__ESAI1_FSR | MUX_PAD_CTRL(MX6Q_ESAI_PAD_CTRL))
 #define  MX6Q_PAD_ENET_REF_CLK__SDMA_DEBUG_BUS_DEVICE_4		\
@@ -5924,18 +5937,20 @@
 #define  MX6Q_PAD_GPIO_3__MLB_MLBCLK		\
 		(_MX6Q_PAD_GPIO_3__MLB_MLBCLK | MUX_PAD_CTRL(MX6Q_MLB150_PAD_CTRL))
 
-#define  MX6Q_PAD_GPIO_6__ESAI1_SCKT		\
-		(_MX6Q_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6		\
+		(_MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6 | MUX_PAD_CTRL(ENET_IRQ_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
 		(_MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1 | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__ESAI1_SCKT		\
+		(_MX6Q_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__GPIO_1_6		\
+		(_MX6Q_PAD_GPIO_6__GPIO_1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__I2C3_SDA		\
 		(_MX6Q_PAD_GPIO_6__I2C3_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0		\
 		(_MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__CSU_CSU_INT_DEB		\
 		(_MX6Q_PAD_GPIO_6__CSU_CSU_INT_DEB | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define  MX6Q_PAD_GPIO_6__GPIO_1_6		\
-		(_MX6Q_PAD_GPIO_6__GPIO_1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__USDHC2_LCTL		\
 		(_MX6Q_PAD_GPIO_6__USDHC2_LCTL | MUX_PAD_CTRL(MX6Q_USDHC_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__MLB_MLBSIG		\
diff --git a/arch/arm/plat-mxc/include/mach/iomux-v3.h b/arch/arm/plat-mxc/include/mach/iomux-v3.h
index c53028f..8bdfe79 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-v3.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-v3.h
@@ -161,14 +161,16 @@ typedef u64 iomux_v3_cfg_t;
 #define GPIO_PORTF	(5 << GPIO_PORT_SHIFT)
 
 /*
- * setups a single pad in the iomuxer
+ * read/write a single pad in the iomuxer
  */
+int mxc_iomux_v3_get_pad(iomux_v3_cfg_t *pad);
 int mxc_iomux_v3_setup_pad(iomux_v3_cfg_t pad);
 
 /*
- * setups mutliple pads
+ * read/write mutliple pads
  * convenient way to call the above function with tables
  */
+ int mxc_iomux_v3_get_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count);
 int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count);
 
 /*
diff --git a/arch/arm/plat-mxc/include/mach/ipu-v3.h b/arch/arm/plat-mxc/include/mach/ipu-v3.h
index 519e628..e2265d4 100755
--- a/arch/arm/plat-mxc/include/mach/ipu-v3.h
+++ b/arch/arm/plat-mxc/include/mach/ipu-v3.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -419,10 +419,10 @@ typedef struct {
  * Enumeration of CSI data bus widths.
  */
 enum {
-	IPU_CSI_DATA_WIDTH_4,
-	IPU_CSI_DATA_WIDTH_8,
-	IPU_CSI_DATA_WIDTH_10,
-	IPU_CSI_DATA_WIDTH_16,
+	IPU_CSI_DATA_WIDTH_4 = 0,
+	IPU_CSI_DATA_WIDTH_8 = 1,
+	IPU_CSI_DATA_WIDTH_10 = 3,
+	IPU_CSI_DATA_WIDTH_16 = 9,
 };
 
 /*!
@@ -587,6 +587,7 @@ struct ipu_soc;
 struct ipu_soc *ipu_get_soc(int id);
 int32_t ipu_init_channel(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
 void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel);
+void ipu_disable_hsp_clk(struct ipu_soc *ipu);
 
 static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
 {
@@ -640,7 +641,7 @@ int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi);
 int ipu_lowpwr_display_enable(void);
 int ipu_lowpwr_display_disable(void);
 
-void ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq);
+int ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq);
 void ipu_disable_irq(struct ipu_soc *ipu, uint32_t irq);
 void ipu_clear_irq(struct ipu_soc *ipu, uint32_t irq);
 int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index 9e44eaa..62282a9 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -72,7 +72,14 @@
 #define MX5_IPU_IRQS 0
 #endif
 
-#define NR_IRQS	(MXC_IPU_IRQ_START + MX3_IPU_IRQS + MX5_IPU_IRQS)
+#ifdef CONFIG_ARCH_MX6
+#define MX6_MSI_IRQS 128
+#else
+#define MX6_MSI_IRQS 0
+#endif
+
+#define IRQ_IMX_MSI_0 (MXC_IPU_IRQ_START + MX3_IPU_IRQS + MX5_IPU_IRQS)
+#define NR_IRQS  (IRQ_IMX_MSI_0 + MX6_MSI_IRQS)
 
 extern int imx_irq_set_priority(unsigned char irq, unsigned char prio);
 
diff --git a/arch/arm/plat-mxc/include/mach/mx6.h b/arch/arm/plat-mxc/include/mach/mx6.h
index dfb3f64..ba38b8a 100644
--- a/arch/arm/plat-mxc/include/mach/mx6.h
+++ b/arch/arm/plat-mxc/include/mach/mx6.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -83,8 +83,8 @@
 #define ROMCP_ARB_BASE_ADDR		0x00000000
 #define ROMCP_ARB_END_ADDR		0x000FFFFF
 #define BOOT_ROM_BASE_ADDR		ROMCP_ARB_BASE_ADDR
-#define CAAM_ARB_BASE_ADDR		0x00100000
-#define CAAM_ARB_END_ADDR		0x00103FFF
+#define CAAM_SECMEM_BASE_ADDR		0x00100000
+#define CAAM_SECMEM_END_ADDR		0x00103FFF
 #define APBH_DMA_ARB_BASE_ADDR		0x00110000
 #define APBH_DMA_ARB_END_ADDR		0x00117FFF
 #define MX6Q_HDMI_ARB_BASE_ADDR		0x00120000
@@ -283,6 +283,8 @@
 #define MX6Q_UART2_BASE_ADDR		UART2_BASE_ADDR
 #define MX6Q_UART3_BASE_ADDR		UART3_BASE_ADDR
 #define MX6Q_UART4_BASE_ADDR		UART4_BASE_ADDR
+#define MX6Q_UART5_BASE_ADDR		UART5_BASE_ADDR
+
 #define MX6Q_FEC_BASE_ADDR		ENET_BASE_ADDR
 #define MX6DL_FEC_BASE_ADDR		ENET_BASE_ADDR
 #define MX6Q_MIPI_DSI_BASE_ADDR		MIPI_DSI_BASE_ADDR
@@ -302,6 +304,8 @@
 #define SRC_GPR9			0x40
 #define SRC_GPR10			0x44
 
+#define SNVS_LPGPR			0x68
+
 /* GPC offsets */
 #define MXC_GPC_CNTR_OFFSET		0x0
 
@@ -484,6 +488,7 @@
 #define MX6Q_INT_UART2			MXC_INT_UART2_ANDED
 #define MX6Q_INT_UART3			MXC_INT_UART3_ANDED
 #define MX6Q_INT_UART4			MXC_INT_UART4_ANDED
+#define MX6Q_INT_UART5			MXC_INT_UART5_ANDED
 #define MX6SL_INT_UART1			MXC_INT_UART1_ANDED
 #define MX6SL_INT_UART2			MXC_INT_UART2_ANDED
 #define MX6SL_INT_UART3			MXC_INT_UART3_ANDED
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 4260d4a..75b99af 100755
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007, 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright 2004-2007, 2011-2013 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
  *
  * This program is free software; you can redistribute it and/or
@@ -275,6 +275,28 @@ int tzic_enable_wake(int is_idle);
 
 extern void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
 extern int tzic_enable_wake(int is_idle);
+
+/* available disableable devices in fuse */
+enum mxc_dev_type {
+	MXC_DEV_PXP,
+	MXC_DEV_OVG,
+	MXC_DEV_DSI_CSI2,
+	MXC_DEV_ENET,
+	MXC_DEV_MLB,
+	MXC_DEV_EPDC,
+	MXC_DEV_HDMI,
+	MXC_DEV_PCIE,
+	MXC_DEV_SATA,
+	MXC_DEV_DTCP,
+	MXC_DEV_2D,
+	MXC_DEV_3D,
+	MXC_DEV_VPU,
+	MXC_DEV_DIVX3,
+	MXC_DEV_RV,
+	MXC_DEV_SORENSEN,
+};
+extern int fuse_dev_is_available(enum mxc_dev_type dev);
+
 #endif
 
 #if defined(CONFIG_ARCH_MX3) || defined(CONFIG_ARCH_MX2)
diff --git a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
index 60946ca..94f7638 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -1085,4 +1085,11 @@ enum {
 
 };
 
+/* IOCTL commands */
+#define HDMI_IOC_MAGIC  'H'
+
+#define HDMI_IOC_GET_RESOURCE	_IO(HDMI_IOC_MAGIC, 0)
+#define HDMI_IOC_GET_CPU_TYPE	_IO(HDMI_IOC_MAGIC, 1)
+
+
 #endif /* __MXC_HDMI_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_vpu.h b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
index 7a6e24f..7869d59 100755
--- a/arch/arm/plat-mxc/include/mach/mxc_vpu.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -16,7 +16,7 @@
  */
 
 /*!
- * @file arch-mxc/mxc_vpu.h
+ * @file plat-mxc/include/mach/mxc_vpu.h
  *
  * @brief VPU system initialization and file operation definition
  *
@@ -58,6 +58,7 @@ struct vpu_mem_desc {
 #define VPU_IOC_QUERY_BITWORK_MEM  _IO(VPU_IOC_MAGIC, 13)
 #define VPU_IOC_SET_BITWORK_MEM    _IO(VPU_IOC_MAGIC, 14)
 #define VPU_IOC_PHYMEM_CHECK	_IO(VPU_IOC_MAGIC, 15)
+#define VPU_IOC_LOCK_DEV	_IO(VPU_IOC_MAGIC, 16)
 
 #define BIT_CODE_RUN			0x000
 #define BIT_CODE_DOWN			0x004
diff --git a/arch/arm/plat-mxc/include/mach/pcie.h b/arch/arm/plat-mxc/include/mach/pcie.h
index 775f651..177410d 100644
--- a/arch/arm/plat-mxc/include/mach/pcie.h
+++ b/arch/arm/plat-mxc/include/mach/pcie.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -35,5 +35,6 @@ struct imx_pcie_platform_data {
 	unsigned int pcie_rst;
 	unsigned int pcie_wake_up;
 	unsigned int pcie_dis;
+	unsigned int type_ep; /* 1 EP, 0 RC */
 };
 #endif /* __ASM_ARCH_IMX_PCIE_H */
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
index c1dfe25..649a97c 100755
--- a/arch/arm/plat-mxc/include/mach/system.h
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -20,6 +20,9 @@
 #include <mach/hardware.h>
 #include <mach/common.h>
 
+#define LDO_MODE_DEFAULT	0
+#define LDO_MODE_BYPASSED	1
+#define LDO_MODE_ENABLED	2
 extern void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
 
 void arch_idle(void);
diff --git a/arch/arm/plat-mxc/iomux-v3.c b/arch/arm/plat-mxc/iomux-v3.c
index 85b7e17..b88208c 100644
--- a/arch/arm/plat-mxc/iomux-v3.c
+++ b/arch/arm/plat-mxc/iomux-v3.c
@@ -56,6 +56,36 @@ int mxc_iomux_v3_setup_pad(iomux_v3_cfg_t pad)
 }
 EXPORT_SYMBOL(mxc_iomux_v3_setup_pad);
 
+/*
+ * Read a single pad in the iomuxer
+ */
+int mxc_iomux_v3_get_pad(iomux_v3_cfg_t *pad)
+{
+	u32 mux_ctrl_ofs = (*pad & MUX_CTRL_OFS_MASK) >> MUX_CTRL_OFS_SHIFT;
+	u32 pad_ctrl_ofs = (*pad & MUX_PAD_CTRL_OFS_MASK)
+						>> MUX_PAD_CTRL_OFS_SHIFT;
+	u32 sel_input_ofs = (*pad & MUX_SEL_INPUT_OFS_MASK)
+						>> MUX_SEL_INPUT_OFS_SHIFT;
+	u32 mux_mode = 0;
+	u32 sel_input = 0;
+	u32 pad_ctrl = 0;
+	iomux_v3_cfg_t pad_info = 0;
+
+	mux_mode = __raw_readl(base + mux_ctrl_ofs) & 0xFF;
+	pad_ctrl = __raw_readl(base + pad_ctrl_ofs) & 0x1FFFF;
+	sel_input = __raw_readl(base + sel_input_ofs) & 0x7;
+
+	pad_info = (((iomux_v3_cfg_t)mux_mode << MUX_MODE_SHIFT) | \
+		((iomux_v3_cfg_t)pad_ctrl << MUX_PAD_CTRL_SHIFT) | \
+		((iomux_v3_cfg_t)sel_input << MUX_SEL_INPUT_SHIFT));
+
+	*pad &= ~(MUX_MODE_MASK | MUX_PAD_CTRL_MASK | MUX_SEL_INPUT_MASK);
+	*pad |= pad_info;
+
+	return 0;
+}
+
+
 int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
 {
 	iomux_v3_cfg_t *p = pad_list;
@@ -72,6 +102,22 @@ int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
 }
 EXPORT_SYMBOL(mxc_iomux_v3_setup_multiple_pads);
 
+/*
+ * Read multiple pads in the iomuxer
+ */
+int mxc_iomux_v3_get_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
+{
+	iomux_v3_cfg_t *p = pad_list;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		mxc_iomux_v3_get_pad(p);
+		p++;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(mxc_iomux_v3_get_multiple_pads);
+
 void mxc_iomux_set_gpr_register(int group, int start_bit, int num_bits, int value)
 {
 	int i = 0;
diff --git a/arch/arm/plat-mxc/pwm.c b/arch/arm/plat-mxc/pwm.c
index b683d2e..eb49057 100755
--- a/arch/arm/plat-mxc/pwm.c
+++ b/arch/arm/plat-mxc/pwm.c
@@ -6,7 +6,7 @@
  * published by the Free Software Foundation.
  *
  * Derived from pxa PWM driver by eric miao <eric.miao@marvell.com>
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #include <linux/module.h>
@@ -87,11 +87,7 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		prescale = period_cycles / 0x10000 + 1;
 
 		period_cycles /= prescale;
-		/* the chip document says the counter counts up to
-		 * period_cycles + 1 and then is reset to 0, so the
-		 *  actual period of the PWM wave is period_cycles + 2
-		 */
-		c = (unsigned long long)(period_cycles + 2) * duty_ns;
+		c = (unsigned long long)period_cycles * duty_ns;
 		do_div(c, period_ns);
 		duty_cycles = c;
 
diff --git a/arch/arm/plat-mxc/system.c b/arch/arm/plat-mxc/system.c
index d2a999b..e216f68 100644
--- a/arch/arm/plat-mxc/system.c
+++ b/arch/arm/plat-mxc/system.c
@@ -33,6 +33,7 @@
 #include <asm/mach-types.h>
 
 static void __iomem *wdog_base;
+extern u32 enable_ldo_mode;
 
 
 static void arch_reset_special_mode(char mode, const char *cmd)
@@ -56,11 +57,14 @@ void arch_reset(char mode, const char *cmd)
 
 #ifdef CONFIG_ARCH_MX6
 	/* wait for reset to assert... */
-	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
-	wcr_enable = 0x14; /*reset system by extern pmic*/
-	#else
-	wcr_enable = (1 << 2);
-	#endif
+	if (enable_ldo_mode == LDO_MODE_BYPASSED) {
+		/*On Sabresd board use WDOG2 to reset external PMIC, so here do
+		* more WDOG2 reset.*/
+		wcr_enable = 0x14;
+		__raw_writew(wcr_enable, IO_ADDRESS(MX6Q_WDOG2_BASE_ADDR));
+		__raw_writew(wcr_enable, IO_ADDRESS(MX6Q_WDOG2_BASE_ADDR));
+	} else
+		wcr_enable = (1 << 2);
 	__raw_writew(wcr_enable, wdog_base);
 	/* errata TKT039676, SRS bit may be missed when
 	SRC sample it, need to write the wdog controller
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index 97d963a..f6acb8a 100755
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -52,7 +52,8 @@
 typedef void (*driver_vbus_func)(bool);
 
 void __iomem *imx_otg_base;
-static  driver_vbus_func s_driver_vbus;
+static  driver_vbus_func s_h1_driver_vbus;
+static  driver_vbus_func s_otg_driver_vbus;
 
 EXPORT_SYMBOL(imx_otg_base);
 
@@ -73,14 +74,26 @@ EXPORT_SYMBOL(usb_icbug_swfix_need);
 
 void mx6_set_host1_vbus_func(driver_vbus_func driver_vbus)
 {
-	s_driver_vbus = driver_vbus;
+	s_h1_driver_vbus = driver_vbus;
 }
 
-void mx6_set_usb_host1_vbus_func(driver_vbus_func *driver_vbus)
+void mx6_get_host1_vbus_func(driver_vbus_func *driver_vbus)
 {
-	*driver_vbus = s_driver_vbus;
+	*driver_vbus = s_h1_driver_vbus;
 }
-EXPORT_SYMBOL(mx6_set_usb_host1_vbus_func);
+EXPORT_SYMBOL(mx6_get_host1_vbus_func);
+
+void mx6_set_otghost_vbus_func(driver_vbus_func driver_vbus)
+{
+	s_otg_driver_vbus = driver_vbus;
+}
+
+void mx6_get_otghost_vbus_func(driver_vbus_func *driver_vbus)
+{
+	*driver_vbus = s_otg_driver_vbus;
+}
+EXPORT_SYMBOL(mx6_get_otghost_vbus_func);
+
 
 
 enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata)
@@ -169,7 +182,7 @@ void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
 
 	pr_debug("%s\n", __func__);
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
-		if (g_xc_ops[i] == xcvr_ops) {
+		if (g_xc_ops[i] && (g_xc_ops[i] == xcvr_ops)) {
 			g_xc_ops[i] = NULL;
 			return;
 		}
@@ -190,7 +203,7 @@ static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
 	}
 
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
-		if (strcmp(g_xc_ops[i]->name, name) == 0) {
+		if (g_xc_ops[i] && (strcmp(g_xc_ops[i]->name, name) == 0)) {
 			return g_xc_ops[i];
 		}
 	}
diff --git a/arch/arm/plat-mxc/usb_wakeup.c b/arch/arm/plat-mxc/usb_wakeup.c
index 5d31d36..00af25f 100755
--- a/arch/arm/plat-mxc/usb_wakeup.c
+++ b/arch/arm/plat-mxc/usb_wakeup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,7 +37,6 @@ struct wakeup_ctrl {
 	struct task_struct *thread;
 	struct completion  event;
 };
-static struct wakeup_ctrl *g_ctrl;
 
 extern int usb_event_is_otg_wakeup(struct fsl_usb2_platform_data *pdata);
 extern void usb_debounce_id_vbus(void);
@@ -218,7 +217,7 @@ static int wakeup_dev_probe(struct platform_device *pdev)
 	status = IS_ERR(ctrl->thread) ? -1 : 0;
 	if (status)
 		goto error2;
-	g_ctrl = ctrl;
+	platform_set_drvdata(pdev, ctrl);
 
 	printk(KERN_DEBUG "the wakeup pdata is 0x%p\n", pdata);
 	return 0;
@@ -231,13 +230,14 @@ error1:
 
 static int  wakeup_dev_exit(struct platform_device *pdev)
 {
-	if (g_ctrl->thread) {
-		g_ctrl->thread_close = true;
-		complete(&g_ctrl->event);
-		kthread_stop(g_ctrl->thread);
-	}
-	free_irq(g_ctrl->wakeup_irq, (void *)g_ctrl);
-	kfree(g_ctrl);
+	struct wakeup_ctrl *wctrl = platform_get_drvdata(pdev);
+
+	wctrl->thread_close = true;
+	complete(&wctrl->event);
+	kthread_stop(wctrl->thread);
+	free_irq(wctrl->wakeup_irq, (void *)wctrl);
+	kfree(wctrl);
+
 	return 0;
 }
 static struct platform_driver wakeup_d = {
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 88210d9..f6b5c0e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1118,5 +1118,6 @@ mx6q_sabrelite		MACH_MX6Q_SABRELITE	MX6Q_SABRELITE		3769
 mx6q_sabresd		MACH_MX6Q_SABRESD	MX6Q_SABRESD		3980
 mx6q_arm2		MACH_MX6Q_ARM2		MX6Q_ARM2		3837
 mx6sl_arm2		MACH_MX6SL_ARM2		MX6SL_ARM2		4091
+mx6q_hdmidongle		MACH_MX6Q_HDMIDONGLE    MX6Q_HDMIDONGLE		4284
 mx6sl_evk		MACH_MX6SL_EVK		MX6SL_EVK		4307
 
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index f25e7ec..d4405f5 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/cpu.h>
+#include <linux/hardirq.h>
 #include <linux/kernel.h>
 #include <linux/notifier.h>
 #include <linux/signal.h>
@@ -389,7 +390,10 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 
 static void vfp_enable(void *unused)
 {
-	u32 access = get_copro_access();
+	u32 access;
+
+	BUG_ON(preemptible());
+	access = get_copro_access();
 
 	/*
 	 * Enable full access to VFP (cp10 and cp11)
@@ -529,7 +533,7 @@ static int __init vfp_init(void)
 	unsigned int cpu_arch = cpu_architecture();
 
 	if (cpu_arch >= CPU_ARCH_ARMv6)
-		vfp_enable(NULL);
+		on_each_cpu(vfp_enable, NULL, 1);
 
 	/*
 	 * First check that there is a VFP that we can use.
@@ -550,8 +554,6 @@ static int __init vfp_init(void)
 	} else {
 		hotcpu_notifier(vfp_hotplug, 0);
 
-		smp_call_function(vfp_enable, NULL, 1);
-
 		VFP_arch = (vfpsid & FPSID_ARCH_MASK) >> FPSID_ARCH_BIT;  /* Extract the architecture version */
 		printk("implementor %02x architecture %d part %02x variant %x rev %x\n",
 			(vfpsid & FPSID_IMPLEMENTER_MASK) >> FPSID_IMPLEMENTER_BIT,
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 2222617..2c1d3ae 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -658,21 +658,28 @@ static void test_ahash_speed(const char *algo, unsigned int sec,
 	struct tcrypt_result tresult;
 	struct ahash_request *req;
 	struct crypto_ahash *tfm;
-	static char output[1024];
+	const int output_size = 1024;
+	char *output = kmalloc(output_size, GFP_KERNEL);
 	int i, ret;
 
+	if (!output) {
+		printk(KERN_INFO "\nUnable to allocate output buffer memory\n");
+		return;
+	}
+
 	printk(KERN_INFO "\ntesting speed of async %s\n", algo);
 
 	tfm = crypto_alloc_ahash(algo, 0, 0);
 	if (IS_ERR(tfm)) {
 		pr_err("failed to load transform for %s: %ld\n",
 		       algo, PTR_ERR(tfm));
+		kfree(output);
 		return;
 	}
 
-	if (crypto_ahash_digestsize(tfm) > sizeof(output)) {
+	if (crypto_ahash_digestsize(tfm) > output_size) {
 		pr_err("digestsize(%u) > outputbuffer(%zu)\n",
-		       crypto_ahash_digestsize(tfm), sizeof(output));
+		       crypto_ahash_digestsize(tfm), output_size);
 		goto out;
 	}
 
@@ -716,6 +723,7 @@ static void test_ahash_speed(const char *algo, unsigned int sec,
 	ahash_request_free(req);
 
 out:
+	kfree(output);
 	crypto_free_ahash(tfm);
 }
 
diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
index a463771..3d66041 100644
--- a/drivers/crypto/caam/Kconfig
+++ b/drivers/crypto/caam/Kconfig
@@ -108,4 +108,43 @@ config CRYPTO_DEV_FSL_CAAM_RNG_TEST
 	help
 	  Selecting this will enable self-test for caam rng.
 
+config CRYPTO_DEV_FSL_CAAM_SM
+	boolean "CAAM Secure Memory / Keystore API (EXPERIMENTAL)"
+	default n
+	help
+	  Enables use of a prototype kernel-level Keystore API with CAAM
+	  Secure Memory for insertion/extraction of bus-protected secrets.
+
+config CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE
+	int "Size of each keystore slot in Secure Memory"
+	depends on CRYPTO_DEV_FSL_CAAM_SM
+	range 5 9
+	default 7
+	help
+	  Select size of allocation units to divide Secure Memory pages into
+	  (the size of a "slot" as referenced inside the API code).
+	  Established as powers of two.
+	  Examples:
+		5 => 32 bytes
+		6 => 64 bytes
+		7 => 128 bytes
+		8 => 256 bytes
+		9 => 512 bytes
 
+config CRYPTO_DEV_FSL_CAAM_SM_TEST
+	boolean "CAAM Secure Memory - Keystore Test/Example (EXPERIMENTAL)"
+	depends on CRYPTO_DEV_FSL_CAAM_SM
+	default n
+	help
+	  Example thread to exercise the Keystore API and to verify that
+	  stored and recovered secrets can be used for general purpose
+	  encryption/decryption.
+
+config CRYPTO_DEV_FSL_CAAM_SECVIO
+	boolean "CAAM/SNVS Security Violation Handler (EXPERIMENTAL)"
+	depends on CRYPTO_DEV_FSL_CAAM
+	default n
+	help
+	  Enables installation of an interrupt handler with registrable
+          handler functions which can be specified to act on the consequences
+          of a security violation.
diff --git a/drivers/crypto/caam/Makefile b/drivers/crypto/caam/Makefile
index deee4b3..36bc651 100644
--- a/drivers/crypto/caam/Makefile
+++ b/drivers/crypto/caam/Makefile
@@ -6,6 +6,9 @@ obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM) += caam.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API) += caamalg.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API) += caamhash.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API) += caamrng.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SM) += sm_store.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST) += sm_test.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO) += secvio.o
 
 caam-objs := ctrl.o jr.o error.o key_gen.o
 
diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index 87b365f..5929950 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -1,7 +1,7 @@
 /*
  * caam - Freescale FSL CAAM support for crypto API
  *
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc.
  *
  * Based on talitos crypto API driver.
  *
@@ -2051,6 +2051,22 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,
 	},
 	{
+		.name = "ecb(aes)",
+		.driver_name = "ecb-aes-caam",
+		.blocksize = AES_BLOCK_SIZE,
+		.type = CRYPTO_ALG_TYPE_ABLKCIPHER,
+		.template_ablkcipher = {
+			.setkey = ablkcipher_setkey,
+			.encrypt = ablkcipher_encrypt,
+			.decrypt = ablkcipher_decrypt,
+			.geniv = "eseqiv",
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize = AES_BLOCK_SIZE,
+			},
+		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_ECB,
+	},
+	{
 		.name = "cbc(des3_ede)",
 		.driver_name = "cbc-3des-caam",
 		.blocksize = DES3_EDE_BLOCK_SIZE,
diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c
index ee06515..4338047 100644
--- a/drivers/crypto/caam/caamhash.c
+++ b/drivers/crypto/caam/caamhash.c
@@ -1,7 +1,7 @@
 /*
  * caam - Freescale FSL CAAM support for ahash functions of crypto API
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * Based on caamalg.c crypto API driver.
  *
@@ -807,7 +807,7 @@ static int ahash_update_ctx(struct ahash_request *req)
 	int *next_buflen = state->current_buf ? &state->buflen_0 :
 			   &state->buflen_1, last_buflen;
 	int in_len = *buflen + req->nbytes, to_hash;
-	u32 *sh_desc = ctx->sh_desc_update, *desc;
+	u32 *sh_desc = ctx->sh_desc_update, *desc = NULL;
 	dma_addr_t ptr = ctx->sh_desc_update_dma;
 	int src_nents, sec4_sg_bytes, sec4_sg_src_index;
 	struct ahash_edesc *edesc;
@@ -1505,14 +1505,12 @@ static int ahash_init(struct ahash_request *req)
 {
 	struct caam_hash_state *state = ahash_request_ctx(req);
 
+	memset(state, 0, sizeof(struct caam_hash_state));
+
 	state->update = ahash_update_first;
 	state->finup = ahash_finup_first;
 	state->final = ahash_final_no_ctx;
 
-	state->current_buf = 0;
-	state->buflen_0 = 0;
-	state->buflen_1 = 0;
-
 	return 0;
 }
 
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index c47e25e..0cadb8e 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -7,6 +7,7 @@
 
 #include "compat.h"
 #include "regs.h"
+#include "snvsregs.h"
 #include "intern.h"
 #include "jr.h"
 #include "desc_constr.h"
@@ -25,6 +26,14 @@ static int caam_remove(struct platform_device *pdev)
 	topregs = (struct caam_full __iomem *)ctrlpriv->ctrl;
 
 #ifndef CONFIG_OF
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO
+	caam_secvio_shutdown(pdev);
+#endif /* SECVIO */
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SM
+	caam_sm_shutdown(pdev);
+#endif
+
 #ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API
 	if (ctrlpriv->rng_inst)
 		caam_rng_shutdown();
@@ -50,6 +59,10 @@ static int caam_remove(struct platform_device *pdev)
 	debugfs_remove_recursive(ctrlpriv->dfs_root);
 #endif
 
+	/* Unmap SNVS and Secure Memory */
+	iounmap(ctrlpriv->snvs);
+	iounmap(ctrlpriv->sm_base);
+
 	/* Unmap controller region */
 	iounmap(&topregs->ctrl);
 
@@ -180,11 +193,13 @@ static void kick_trng(struct platform_device *pdev)
 /* Probe routine for CAAM top (controller) level */
 static int caam_probe(struct platform_device *pdev)
 {
-	int d, ring, rspec;
+	int d, ring, rspec, status;
 	struct device *dev;
 	struct device_node *np;
 	struct caam_ctrl __iomem *ctrl;
 	struct caam_full __iomem *topregs;
+	struct snvs_full __iomem *snvsregs;
+	void __iomem *sm_base;
 	struct caam_drv_private *ctrlpriv;
 	u32 deconum;
 #ifdef CONFIG_DEBUG_FS
@@ -237,7 +252,57 @@ static int caam_probe(struct platform_device *pdev)
 	/* topregs used to derive pointers to CAAM sub-blocks only */
 	topregs = (struct caam_full __iomem *)ctrl;
 
-	/* Get the IRQ of the controller (for security violations only) */
+	/*
+	 * Next, map SNVS register page
+	 * FIXME: MX6 has a separate RTC driver using SNVS. This driver
+	 * will have a mapped pointer to SNVS registers also, which poses
+	 * a conflict if we're not very careful to stay away from registers
+	 * and interrupts that it uses. In the future, pieces of that driver
+	 * may need to migrate down here. In the meantime, use caution with
+	 * this pointer. Also note that the snvs-rtc driver probably controls
+	 * SNVS device clocks.
+	 */
+#ifdef CONFIG_OF
+	/* Get SNVS register page */
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "iobase_snvs");
+	if (!res) {
+		dev_err(dev, "snvs: invalid address resource type\n");
+		return -ENODEV;
+	}
+	snvsregs = ioremap(res->start, res->end - res->start + 1);
+	if (snvsregs == NULL) {
+		dev_err(dev, "snvs: ioremap() failed\n");
+		iounmap(ctrl);
+		return -ENOMEM;
+	}
+#endif
+	ctrlpriv->snvs = (struct snvs_full __force *)snvsregs;
+
+	/* Now map CAAM-Secure Memory Space */
+#ifdef CONFIG_OF
+	/* Get CAAM-SM node and of_iomap() and save */
+#else
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "iobase_caam_sm");
+	if (!res) {
+		dev_err(dev, "caam_sm: invalid address resource type\n");
+		return -ENODEV;
+	}
+	sm_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (sm_base == NULL) {
+		dev_err(dev, "caam_sm: ioremap_nocache() failed\n");
+		iounmap(ctrl);
+		iounmap(snvsregs);
+		return -ENOMEM;
+	}
+#endif
+	ctrlpriv->sm_base = (void __force *)sm_base;
+	ctrlpriv->sm_size = res->end - res->start + 1;
+
+	/*
+	 * Get the IRQ for security violations
+	 */
 #ifdef CONFIG_OF
 	ctrlpriv->secvio_irq = of_irq_to_resource(nprop, 0, NULL);
 #else
@@ -495,20 +560,43 @@ static int caam_probe(struct platform_device *pdev)
  */
 #ifndef CONFIG_OF
 #ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API
-	/* FIXME: check status */
-	caam_algapi_startup(pdev);
+	status = caam_algapi_startup(pdev);
+	if (status) {
+		caam_remove(pdev);
+		return status;
+	}
 #endif
 
 #ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API
-	caam_algapi_hash_startup(pdev);
+	status = caam_algapi_hash_startup(pdev);
+	if (status) {
+		caam_remove(pdev);
+		return status;
+	}
 #endif
 
 #ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API
 	if (ctrlpriv->rng_inst)
 		caam_rng_startup(pdev);
 #endif
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SM
+	status = caam_sm_startup(pdev);
+	if (status) {
+		caam_remove(pdev);
+		return status;
+	}
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST
+	caam_sm_example_init(pdev);
+#endif /* SM_TEST */
+#endif /* SM */
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO
+	caam_secvio_startup(pdev);
+#endif /* SECVIO */
+
 #endif /* CONFIG_OF */
-	return 0;
+	return status;
 }
 
 #ifdef CONFIG_OF
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index adaeb28..573d9d1 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -1102,6 +1102,23 @@ struct sec4_sg_entry {
 #define OP_PCL_PKPROT_ECC			 0x0002
 #define OP_PCL_PKPROT_F2M			 0x0001
 
+/* Blob protocol protinfo bits */
+#define OP_PCL_BLOB_TK			0x0200
+#define OP_PCL_BLOB_EKT			0x0100
+
+#define OP_PCL_BLOB_K2KR_MEM		0x0000
+#define OP_PCL_BLOB_K2KR_C1KR		0x0010
+#define OP_PCL_BLOB_K2KR_C2KR		0x0030
+#define OP_PCL_BLOB_K2KR_AFHAS		0x0050
+#define OP_PCL_BLOB_K2KR_C2KR_SPLIT	0x0070
+
+#define OP_PCL_BLOB_PTXT_SECMEM		0x0008
+#define OP_PCL_BLOB_BLACK		0x0004
+
+#define OP_PCL_BLOB_FMT_NORMAL		0x0000
+#define OP_PCL_BLOB_FMT_MSTR		0x0002
+#define OP_PCL_BLOB_FMT_TEST		0x0003
+
 /* For non-protocol/alg-only op commands */
 #define OP_ALG_TYPE_SHIFT	24
 #define OP_ALG_TYPE_MASK	(0x7 << OP_ALG_TYPE_SHIFT)
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index 1f818ff..991ce0b 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -95,6 +95,9 @@ struct caam_drv_private {
 	struct caam_deco **deco; /* DECO/CCB views */
 	struct caam_assurance *ac;
 	struct caam_queue_if *qi; /* QI control region */
+	struct snvs_full __iomem *snvs;	/* SNVS HP+LP register space */
+	dma_addr_t __iomem *sm_base;	/* Secure memory storage base */
+	u32 sm_size;
 
 	/*
 	 * Detected geometry block. Filled in from device tree if powerpc,
@@ -118,6 +121,14 @@ struct caam_drv_private {
 	struct clk *caam_clk;
 #endif
 
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SM
+	struct device *smdev;	/* Secure Memory dev */
+#endif
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO
+	struct device *secviodev;
+#endif
+
 	/*
 	 * debugfs entries for developer view into driver/device
 	 * variables at runtime.
@@ -157,6 +168,21 @@ void caam_algapi_hash_shutdown(struct platform_device *pdev);
 int caam_rng_startup(struct platform_device *pdev);
 void caam_rng_shutdown(void);
 #endif
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SM
+int caam_sm_startup(struct platform_device *pdev);
+void caam_sm_shutdown(struct platform_device *pdev);
+#endif
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST
+int caam_sm_example_init(struct platform_device *pdev);
+#endif
+
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO
+int caam_secvio_startup(struct platform_device *pdev);
+void caam_secvio_shutdown(struct platform_device *pdev);
+#endif /* SECVIO */
+
 #endif /* CONFIG_OF */
 
 #endif /* INTERN_H */
diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index 280aaaa..d7394ea 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -62,9 +62,6 @@ static void caam_jr_dequeue(unsigned long devarg)
 	unsigned long flags;
 
 	outbusaddr = rd_reg64(&jrp->rregs->outring_base);
-	dma_sync_single_for_cpu(dev, outbusaddr,
-				sizeof(struct jr_outentry) * JOBR_DEPTH,
-				DMA_FROM_DEVICE);
 
 	spin_lock_irqsave(&jrp->outlock, flags);
 
@@ -75,6 +72,10 @@ static void caam_jr_dequeue(unsigned long devarg)
 	       rd_reg32(&jrp->rregs->outring_used)) {
 
 		hw_idx = jrp->out_ring_read_index;
+		dma_sync_single_for_cpu(dev, outbusaddr,
+					sizeof(struct jr_outentry) * JOBR_DEPTH,
+					DMA_FROM_DEVICE);
+
 		for (i = 0; CIRC_CNT(head, tail + i, JOBR_DEPTH) >= 1; i++) {
 			sw_idx = (tail + i) & (JOBR_DEPTH - 1);
 
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index 04ae9d4..248dd93 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -203,7 +203,6 @@ struct jr_outentry {
 #define CHA_ID_AES_HP		(0x4ull << CHA_ID_AES_SHIFT)
 #define CHA_ID_AES_DIFFPWR	(0x1ull << CHA_ID_AES_SHIFT)
 
-
 /*
  * caam_perfmon - Performance Monitor/Secure Memory Status/
  *                CAAM Global Status/Component Version IDs
@@ -227,15 +226,21 @@ struct caam_perfmon {
 #define CTPR_QI_SHIFT		57
 #define CTPR_QI_MASK		(0x1ull << CTPR_QI_SHIFT)
 	u64 comp_parms;	/* CTPR - Compile Parameters Register	*/
-	u64 rsvd1[2];
+
+	/* Secure Memory State Visibility */
+	u32 rsvd1;
+	u32 smstatus;	/* Secure memory status */
+	u32 rsvd2;
+	u32 smpartown;	/* Secure memory partition owner */
 
 	/* CAAM Global Status					fc0-fdf */
 	u64 faultaddr;	/* FAR  - Fault Address		*/
 	u32 faultliodn;	/* FALR - Fault Address LIODN	*/
 	u32 faultdetail;	/* FADR - Fault Addr Detail	*/
-	u32 rsvd2;
+	u32 rsvd3;
 	u32 status;		/* CSTA - CAAM Status */
-	u64 rsvd3;
+	u32 smpart;		/* Secure Memory Partition Parameters */
+	u32 smvid;		/* Secure Memory Version ID */
 
 	/* Component Instantiation Parameters			fe0-fff */
 	u32 rtic_id;		/* RVID - RTIC Version ID	*/
@@ -245,6 +250,62 @@ struct caam_perfmon {
 	u64 caam_id;		/* CAAMVID - CAAM Version ID	*/
 };
 
+#define SMSTATUS_PART_SHIFT	28
+#define SMSTATUS_PART_MASK	(0xf << SMSTATUS_PART_SHIFT)
+#define SMSTATUS_PAGE_SHIFT	16
+#define SMSTATUS_PAGE_MASK	(0x7ff << SMSTATUS_PAGE_SHIFT)
+#define SMSTATUS_MID_SHIFT	8
+#define SMSTATUS_MID_MASK	(0x3f << SMSTATUS_MID_SHIFT)
+#define SMSTATUS_ACCERR_SHIFT	4
+#define SMSTATUS_ACCERR_MASK	(0xf << SMSTATUS_ACCERR_SHIFT)
+#define SMSTATUS_ACCERR_NONE	0
+#define SMSTATUS_ACCERR_ALLOC	1	/* Page not allocated */
+#define SMSTATUS_ACCESS_ID	2	/* Not granted by ID */
+#define SMSTATUS_ACCESS_WRITE	3	/* Writes not allowed */
+#define SMSTATUS_ACCESS_READ	4	/* Reads not allowed */
+#define SMSTATUS_ACCESS_NONKEY	6	/* Non-key reads not allowed */
+#define SMSTATUS_ACCESS_BLOB	9	/* Blob access not allowed */
+#define SMSTATUS_ACCESS_DESCB	10	/* Descriptor Blob access spans pages */
+#define SMSTATUS_ACCESS_NON_SM	11	/* Outside Secure Memory range */
+#define SMSTATUS_ACCESS_XPAGE	12	/* Access crosses pages */
+#define SMSTATUS_ACCESS_INITPG	13	/* Page still initializing */
+#define SMSTATUS_STATE_SHIFT	0
+#define SMSTATUS_STATE_MASK	(0xf << SMSTATUS_STATE_SHIFT)
+#define SMSTATUS_STATE_RESET	0
+#define SMSTATUS_STATE_INIT	1
+#define SMSTATUS_STATE_NORMAL	2
+#define SMSTATUS_STATE_FAIL	3
+
+/* up to 15 rings, 2 bits shifted by ring number */
+#define SMPARTOWN_RING_SHIFT	2
+#define SMPARTOWN_RING_MASK	3
+#define SMPARTOWN_AVAILABLE	0
+#define SMPARTOWN_NOEXIST	1
+#define SMPARTOWN_UNAVAILABLE	2
+#define SMPARTOWN_OURS		3
+
+/* Maximum number of pages possible */
+#define SMPART_MAX_NUMPG_SHIFT	16
+#define SMPART_MAX_NUMPG_MASK	(0x3f << SMPART_MAX_NUMPG_SHIFT)
+
+/* Maximum partition number */
+#define SMPART_MAX_PNUM_SHIFT	12
+#define SMPART_MAX_PNUM_MASK	(0xf << SMPART_MAX_PNUM_SHIFT)
+
+/* Highest possible page number */
+#define SMPART_MAX_PG_SHIFT	0
+#define SMPART_MAX_PG_MASK	(0x3f << SMPART_MAX_PG_SHIFT)
+
+/* Max size of a page */
+#define SMVID_PG_SIZE_SHIFT	16
+#define SMVID_PG_SIZE_MASK	(0x7 << SMVID_PG_SIZE_SHIFT)
+
+/* Major/Minor Version ID */
+#define SMVID_MAJ_VERS_SHIFT	8
+#define SMVID_MAJ_VERS		(0xf << SMVID_MAJ_VERS_SHIFT)
+#define SMVID_MIN_VERS_SHIFT	0
+#define SMVID_MIN_VERS		(0xf << SMVID_MIN_VERS_SHIFT)
+
 /* LIODN programming for DMA configuration */
 #define MSTRID_LOCK_LIODN	0x80000000
 #define MSTRID_LOCK_MAKETRUSTED	0x00010000	/* only for JR masterid */
@@ -446,7 +507,18 @@ struct caam_job_ring {
 	u32 rsvd11;
 	u32 jrcommand;	/* JRCRx - JobR command */
 
-	u32 rsvd12[932];
+	u32 rsvd12[33];
+
+	/* Secure Memory Configuration - if you have it */
+	u32 sm_cmd;	/* SMCJRx - Secure memory command */
+	u32 rsvd13;
+	u32 sm_status;	/* SMCSJRx - Secure memory status */
+	u32 rsvd14;
+	u32 sm_perm;	/* SMAPJRx - Secure memory access perms */
+	u32 sm_group2;	/* SMAP2JRx - Secure memory access group 2 */
+	u32 sm_group1;	/* SMAP1JRx - Secure memory access group 1 */
+
+	u32 rsvd15[891];
 
 	/* Performance Monitor                                  f00-fff */
 	struct caam_perfmon perfmon;
@@ -569,6 +641,62 @@ struct caam_job_ring {
 
 #define JRCR_RESET                  0x01
 
+/* secure memory command */
+#define SMC_PAGE_SHIFT	16
+#define SMC_PAGE_MASK	(0xffff << SMC_PAGE_SHIFT)
+#define SMC_PART_SHIFT	8
+#define SMC_PART_MASK	(0x0f << SMC_PART_SHIFT)
+#define SMC_CMD_SHIFT	0
+#define SMC_CMD_MASK	(0x0f << SMC_CMD_SHIFT)
+
+#define SMC_CMD_ALLOC_PAGE	0x01	/* allocate page to this partition */
+#define SMC_CMD_DEALLOC_PAGE	0x02	/* deallocate page from partition */
+#define SMC_CMD_DEALLOC_PART	0x03	/* deallocate partition */
+#define SMC_CMD_PAGE_INQUIRY	0x05	/* find partition associate with page */
+
+/* secure memory (command) status */
+#define SMCS_PAGE_SHIFT		16
+#define SMCS_PAGE_MASK		(0x0fff << SMCS_PAGE_SHIFT)
+#define SMCS_CMDERR_SHIFT	14
+#define SMCS_CMDERR_MASK	(3 << SMCS_CMDERR_SHIFT)
+#define SMCS_ALCERR_SHIFT	12
+#define SMCS_ALCERR_MASK	(3 << SMCS_ALCERR_SHIFT)
+#define SMCS_PGOWN_SHIFT	6
+#define SMCS_PGWON_MASK		(3 << SMCS_PGOWN_SHIFT)
+#define SMCS_PART_SHIFT		0
+#define SMCS_PART_MASK		(0xf << SMCS_PART_SHIFT)
+
+#define SMCS_CMDERR_NONE	0
+#define SMCS_CMDERR_INCOMP	1	/* Command not yet complete */
+#define SMCS_CMDERR_SECFAIL	2	/* Security failure occurred */
+#define SMCS_CMDERR_OVERFLOW	3	/* Command overflow */
+
+#define SMCS_ALCERR_NONE	0
+#define SMCS_ALCERR_PSPERR	1	/* Partion marked PSP (dealloc only) */
+#define SMCS_ALCERR_PAGEAVAIL	2	/* Page not available */
+#define SMCS_ALCERR_PARTOWN	3	/* Partition ownership error */
+
+#define SMCS_PGOWN_AVAIL	0	/* Page is available */
+#define SMCS_PGOWN_NOEXIST	1	/* Page initializing or nonexistent */
+#define SMCS_PGOWN_NOOWN	2	/* Page owned by another processor */
+#define SMCS_PGOWN_OWNED	3	/* Page belongs to this processor */
+
+/* secure memory access permissions */
+#define SMCS_PERM_KEYMOD_SHIFT	16
+#define SMCA_PERM_KEYMOD_MASK	(0xff << SMCS_PERM_KEYMOD_SHIFT)
+#define SMCA_PERM_CSP_ZERO	0x8000	/* Zero when deallocated or released */
+#define SMCA_PERM_PSP_LOCK	0x4000	/* Part./pages can't be deallocated */
+#define SMCA_PERM_PERM_LOCK	0x2000	/* Lock permissions */
+#define SMCA_PERM_GRP_LOCK	0x1000	/* Lock access groups */
+#define SMCA_PERM_RINGID_SHIFT	10
+#define SMCA_PERM_RINGID_MASK	(3 << SMCA_PERM_RINGID_SHIFT)
+#define SMCA_PERM_G2_BLOB	0x0080	/* Group 2 blob import/export */
+#define SMCA_PERM_G2_WRITE	0x0020	/* Group 2 write */
+#define SMCA_PERM_G2_READ	0x0010	/* Group 2 read */
+#define SMCA_PERM_G1_BLOB	0x0008	/* Group 1... */
+#define SMCA_PERM_G1_WRITE	0x0002
+#define SMCA_PERM_G1_READ	0x0001
+
 /*
  * caam_assurance - Assurance Controller View
  * base + 0x6000 padded out to 0x1000
diff --git a/drivers/crypto/caam/secvio.c b/drivers/crypto/caam/secvio.c
new file mode 100644
index 0000000..b3f61ab
--- /dev/null
+++ b/drivers/crypto/caam/secvio.c
@@ -0,0 +1,310 @@
+
+/*
+ * CAAM/SEC 4.x Security Violation Handler
+ * Copyright (C) 2012 Freescale Semiconductor, Inc., All Rights Reserved
+ */
+
+#include "compat.h"
+#include "intern.h"
+#include "secvio.h"
+#include "regs.h"
+
+/*
+ * These names are associated with each violation handler.
+ * The source names were taken from MX6, and are based on recommendations
+ * for most common SoCs.
+ */
+static const u8 *violation_src_name[] = {
+	"CAAM Security Violation",
+	"JTAG Alarm",
+	"Watchdog",
+	"(reserved)",
+	"External Boot",
+	"Tamper Detect",
+};
+
+/* Top-level security violation interrupt */
+static irqreturn_t caam_secvio_interrupt(int irq, void *snvsdev)
+{
+	struct device *dev = snvsdev;
+	struct caam_drv_private_secvio *svpriv = dev_get_drvdata(dev);
+	u32 irqstate;
+
+	/* Check the HP secvio status register */
+	irqstate = rd_reg32(&svpriv->svregs->hp.secvio_status) |
+			    HP_SECVIOST_SECVIOMASK;
+	if (!irqstate)
+		return IRQ_NONE;
+
+	/* Mask out one or more causes for deferred service */
+	clrbits32(&svpriv->svregs->hp.secvio_int_ctl, irqstate);
+
+	/* Now ACK causes */
+	setbits32(&svpriv->svregs->hp.secvio_status, irqstate);
+
+	/* And run deferred service */
+	preempt_disable();
+	tasklet_schedule(&svpriv->irqtask[smp_processor_id()]);
+	preempt_enable();
+
+	return IRQ_HANDLED;
+}
+
+/* Deferred service handler. Tasklet arg is simply the SNVS dev */
+static void caam_secvio_dispatch(unsigned long indev)
+{
+	struct device *dev = (struct device *)indev;
+	struct caam_drv_private_secvio *svpriv = dev_get_drvdata(dev);
+	unsigned long flags, cause;
+	int i;
+
+
+	/*
+	 * Capture the interrupt cause, using masked interrupts as
+	 * identification. This only works if all are enabled; if
+	  * this changes in the future, a "cause queue" will have to
+	 * be built
+	 */
+	cause = rd_reg32(&svpriv->svregs->hp.secvio_int_ctl) &
+			(HP_SECVIO_INTEN_SRC5 | HP_SECVIO_INTEN_SRC4 |
+			 HP_SECVIO_INTEN_SRC3 | HP_SECVIO_INTEN_SRC2 |
+			 HP_SECVIO_INTEN_SRC1 | HP_SECVIO_INTEN_SRC0);
+
+	/* Look through causes, call each handler if exists */
+	for (i = 0; i < MAX_SECVIO_SOURCES; i++)
+		if (cause & (1 << i)) {
+			spin_lock_irqsave(&svpriv->svlock, flags);
+			svpriv->intsrc[i].handler(dev, i,
+						  svpriv->intsrc[i].ext);
+			spin_unlock_irqrestore(&svpriv->svlock, flags);
+		};
+
+	/* Re-enable now-serviced interrupts */
+	setbits32(&svpriv->svregs->hp.secvio_int_ctl, cause);
+}
+
+/*
+ * Default cause handler, used in lieu of an application-defined handler.
+ * All it does at this time is print a console message. It could force a halt.
+ */
+static void caam_secvio_default(struct device *dev, u32 cause, void *ext)
+{
+	struct caam_drv_private_secvio *svpriv = dev_get_drvdata(dev);
+
+	dev_err(dev, "Unhandled Security Violation Interrupt %d = %s\n",
+		cause, svpriv->intsrc[cause].intname);
+}
+
+/*
+ * Install an application-defined handler for a specified cause
+ * Arguments:
+ * - dev        points to SNVS-owning device
+ * - cause      interrupt source cause
+ * - handler    application-defined handler, gets called with dev
+ *              source cause, and locally-defined handler argument
+ * - cause_description   points to a string to override the default cause
+ *                       name, this can be used as an alternate for error
+ *                       messages and such. If left NULL, the default
+ *                       description string is used.
+ * - ext        pointer to any extra data needed by the handler.
+ */
+int caam_secvio_install_handler(struct device *dev, enum secvio_cause cause,
+				void (*handler)(struct device *dev, u32 cause,
+						void *ext),
+				u8 *cause_description, void *ext)
+{
+	unsigned long flags;
+	struct caam_drv_private_secvio *svpriv;
+
+	svpriv = dev_get_drvdata(dev);
+
+	if ((handler == NULL) || (cause > SECVIO_CAUSE_SOURCE_5))
+		return -EINVAL;
+
+	spin_lock_irqsave(&svpriv->svlock, flags);
+	svpriv->intsrc[cause].handler = handler;
+	if (cause_description != NULL)
+		svpriv->intsrc[cause].intname = cause_description;
+	if (ext != NULL)
+		svpriv->intsrc[cause].ext = ext;
+	spin_unlock_irqrestore(&svpriv->svlock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(caam_secvio_install_handler);
+
+/*
+ * Remove an application-defined handler for a specified cause (and, by
+ * implication, restore the "default".
+ * Arguments:
+ * - dev	points to SNVS-owning device
+ * - cause	interrupt source cause
+ */
+int caam_secvio_remove_handler(struct device *dev, enum secvio_cause cause)
+{
+	unsigned long flags;
+	struct caam_drv_private_secvio *svpriv;
+
+	svpriv = dev_get_drvdata(dev);
+
+	if (cause > SECVIO_CAUSE_SOURCE_5)
+		return -EINVAL;
+
+	spin_lock_irqsave(&svpriv->svlock, flags);
+	svpriv->intsrc[cause].intname = violation_src_name[cause];
+	svpriv->intsrc[cause].handler = caam_secvio_default;
+	svpriv->intsrc[cause].ext = NULL;
+	spin_unlock_irqrestore(&svpriv->svlock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(caam_secvio_remove_handler);
+
+int caam_secvio_startup(struct platform_device *pdev)
+{
+	struct device *ctrldev, *svdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_secvio *svpriv;
+	struct platform_device *svpdev;
+	int i, error;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+
+	/*
+	 * Set up the private block for secure memory
+	 * Only one instance is possible
+	 */
+	svpriv = kzalloc(sizeof(struct caam_drv_private_secvio), GFP_KERNEL);
+	if (svpriv == NULL) {
+		dev_err(ctrldev, "can't alloc private mem for secvio\n");
+		return -ENOMEM;
+	}
+	svpriv->parentdev = ctrldev;
+
+	/* Create the security violation dev */
+#ifdef CONFIG_OF
+	svpdev = of_platform_device_create(np, NULL, ctrldev);
+#else
+	svpdev = platform_device_register_data(ctrldev, "caam_secvio", 0,
+					       svpriv,
+				sizeof(struct caam_drv_private_secvio));
+#endif
+	if (svpdev == NULL) {
+		kfree(svpriv);
+		return -EINVAL;
+	}
+	svdev = &svpdev->dev;
+	dev_set_drvdata(svdev, svpriv);
+	ctrlpriv->secviodev = svdev;
+	svpriv->svregs = ctrlpriv->snvs;
+
+	/*
+	 * Now we have all the dev data set up. Init interrupt
+	 * source descriptions
+	 */
+	for (i = 0; i < MAX_SECVIO_SOURCES; i++) {
+		svpriv->intsrc[i].intname = violation_src_name[i];
+		svpriv->intsrc[i].handler = caam_secvio_default;
+	}
+
+	/* Connect main handler */
+	for_each_possible_cpu(i)
+		tasklet_init(&svpriv->irqtask[i], caam_secvio_dispatch,
+			     (unsigned long)svdev);
+
+	error = request_irq(ctrlpriv->secvio_irq, caam_secvio_interrupt,
+			    IRQF_SHARED, "caam-secvio", svdev);
+	if (error) {
+		dev_err(svdev, "can't connect secvio interrupt\n");
+		irq_dispose_mapping(ctrlpriv->secvio_irq);
+		ctrlpriv->secvio_irq = 0;
+		return -EINVAL;
+	}
+
+	/* Enable all sources */
+	wr_reg32(&svpriv->svregs->hp.secvio_int_ctl, HP_SECVIO_INTEN_ALL);
+
+	dev_info(svdev, "security violation service handlers armed\n");
+
+	return 0;
+}
+
+void caam_secvio_shutdown(struct platform_device *pdev)
+{
+	struct device *ctrldev, *svdev;
+	struct caam_drv_private *priv;
+	struct caam_drv_private_secvio *svpriv;
+	int i;
+
+	ctrldev = &pdev->dev;
+	priv = dev_get_drvdata(ctrldev);
+	svdev = priv->secviodev;
+	svpriv = dev_get_drvdata(svdev);
+
+	/* Shut off all sources */
+	wr_reg32(&svpriv->svregs->hp.secvio_int_ctl, 0);
+
+	/* Remove tasklets and release interrupt */
+	for_each_possible_cpu(i)
+		tasklet_kill(&svpriv->irqtask[i]);
+
+	free_irq(priv->secvio_irq, svdev);
+
+	kfree(svpriv);
+}
+
+
+#ifdef CONFIG_OF
+static void __exit caam_secvio_exit(void)
+{
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	of_node_put(dev_node);
+
+	caam_sm_shutdown(pdev);
+}
+
+static int __init caam_secvio_init(void)
+{
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+
+	/*
+	 * Do of_find_compatible_node() then of_find_device_by_node()
+	 * once a functional device tree is available
+	 */
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	of_node_put(dev_node);
+
+	return caam_secvio_startup(pdev);
+}
+
+module_init(caam_secvio_init);
+module_exit(caam_secvio_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL CAAM/SNVS Security Violation Handler");
+MODULE_AUTHOR("Freescale Semiconductor - NMSG/MAD");
+#endif
diff --git a/drivers/crypto/caam/secvio.h b/drivers/crypto/caam/secvio.h
new file mode 100644
index 0000000..909ffad
--- /dev/null
+++ b/drivers/crypto/caam/secvio.h
@@ -0,0 +1,64 @@
+
+/*
+ * CAAM Security Violation Handler
+ * Copyright (C) 2012 Freescale Semiconductor, Inc., All Rights Reserved
+ */
+
+#ifndef SECVIO_H
+#define SECVIO_H
+
+#include "snvsregs.h"
+
+
+/*
+ * Defines the published interfaces to install/remove application-specified
+ * handlers for catching violations
+ */
+
+#define MAX_SECVIO_SOURCES 6
+
+/* these are the untranslated causes */
+enum secvio_cause {
+	SECVIO_CAUSE_SOURCE_0,
+	SECVIO_CAUSE_SOURCE_1,
+	SECVIO_CAUSE_SOURCE_2,
+	SECVIO_CAUSE_SOURCE_3,
+	SECVIO_CAUSE_SOURCE_4,
+	SECVIO_CAUSE_SOURCE_5
+};
+
+/* These are common "recommended" cause definitions for most devices */
+#define SECVIO_CAUSE_CAAM_VIOLATION SECVIO_CAUSE_SOURCE_0
+#define SECVIO_CAUSE JTAG_ALARM SECVIO_CAUSE_SOURCE_1
+#define SECVIO_CAUSE_WATCHDOG SECVIO_CAUSE_SOURCE_2
+#define SECVIO_CAUSE_EXTERNAL_BOOT SECVIO_CAUSE_SOURCE_4
+#define SECVIO_CAUSE_TAMPER_DETECT SECVIO_CAUSE_SOURCE_5
+
+int caam_secvio_install_handler(struct device *dev, enum secvio_cause cause,
+				void (*handler)(struct device *dev, u32 cause,
+						void *ext),
+				u8 *cause_description, void *ext);
+int caam_secvio_remove_handler(struct device *dev, enum  secvio_cause cause);
+
+/*
+ * Private data definitions for the secvio "driver"
+ */
+
+struct secvio_int_src {
+	const u8 *intname;	/* Points to a descriptive name for source */
+	void *ext;		/* Extended data to pass to the handler */
+	void (*handler)(struct device *dev, u32 cause, void *ext);
+};
+
+struct caam_drv_private_secvio {
+	struct device *parentdev;	/* points back to the controller */
+	spinlock_t svlock ____cacheline_aligned;
+	struct tasklet_struct irqtask[NR_CPUS];
+	struct snvs_full __iomem *svregs;	/* both HP and LP domains */
+
+	/* Registered handlers for each violation */
+	struct secvio_int_src intsrc[MAX_SECVIO_SOURCES];
+
+};
+
+#endif /* SECVIO_H */
diff --git a/drivers/crypto/caam/sg_sw_sec4.h b/drivers/crypto/caam/sg_sw_sec4.h
index e05fc58..f3f5187 100644
--- a/drivers/crypto/caam/sg_sw_sec4.h
+++ b/drivers/crypto/caam/sg_sw_sec4.h
@@ -1,7 +1,7 @@
 /*
  * CAAM/SEC 4.x functions for using scatterlists in caam driver
  *
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc.
  *
  */
 
@@ -93,9 +93,13 @@ static int dma_map_sg_chained(struct device *dev, struct scatterlist *sg,
 {
 	if (unlikely(chained)) {
 		int i;
+		struct scatterlist *tsg = sg;
+		/* Needs a temp copy for sg pointer, otherwise
+		 * scatterwalke_sg_next will return null when list is
+		 * ended */
 		for (i = 0; i < nents; i++) {
-			dma_map_sg(dev, sg, 1, dir);
-			sg = scatterwalk_sg_next(sg);
+			dma_map_sg(dev, tsg, 1, dir);
+			tsg = scatterwalk_sg_next(tsg);
 		}
 	} else {
 		dma_map_sg(dev, sg, nents, dir);
diff --git a/drivers/crypto/caam/sm.h b/drivers/crypto/caam/sm.h
new file mode 100644
index 0000000..7124efa
--- /dev/null
+++ b/drivers/crypto/caam/sm.h
@@ -0,0 +1,86 @@
+
+/*
+ * CAAM Secure Memory/Keywrap API Definitions
+ * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ */
+
+#ifndef SM_H
+#define SM_H
+
+
+/* Storage access permissions */
+#define SM_PERM_READ 0x01
+#define SM_PERM_WRITE 0x02
+#define SM_PERM_BLOB 0x03
+
+
+/* Keystore maintenance functions */
+void sm_init_keystore(struct device *dev);
+u32 sm_detect_keystore_units(struct device *dev);
+int sm_establish_keystore(struct device *dev, u32 unit);
+void sm_release_keystore(struct device *dev, u32 unit);
+
+/* Keystore accessor functions */
+extern int sm_keystore_slot_alloc(struct device *dev, u32 unit, u32 size,
+				  u32 *slot);
+extern int sm_keystore_slot_dealloc(struct device *dev, u32 unit, u32 slot);
+extern int sm_keystore_slot_load(struct device *dev, u32 unit, u32 slot,
+				 const u8 *key_data, u32 key_length);
+extern int sm_keystore_slot_read(struct device *dev, u32 unit, u32 slot,
+				 u32 key_length, u8 *key_data);
+extern int sm_keystore_slot_encapsulate(struct device *dev, u32 unit,
+					u32 inslot, u32 outslot, u16 secretlen,
+					u8 *keymod, u16 keymodlen);
+extern int sm_keystore_slot_decapsulate(struct device *dev, u32 unit,
+					u32 inslot, u32 outslot, u16 secretlen,
+					u8 *keymod, u16 keymodlen);
+
+/* Data structure to hold per-slot information */
+struct keystore_data_slot_info {
+	u8	allocated;	/* Track slot assignments */
+	u32	key_length;	/* Size of the key */
+};
+
+/* Data structure to hold keystore information */
+struct keystore_data {
+	void	*base_address;	/* Base of the Secure Partition */
+	u32	slot_count;	/* Number of slots in the keystore */
+	struct keystore_data_slot_info *slot; /* Per-slot information */
+};
+
+/* store the detected attributes of a secure memory page */
+struct sm_page_descriptor {
+	u16 phys_pagenum;	/* may be discontiguous */
+	u16 own_part;		/* Owning partition */
+	void *pg_base;		/* Calculated virtual address */
+	struct keystore_data *ksdata;
+};
+
+struct caam_drv_private_sm {
+	struct device *parentdev;	/* this ends up as the controller */
+	struct device *smringdev;	/* ring that owns this instance */
+	spinlock_t kslock ____cacheline_aligned;
+
+	/* Default parameters for geometry */
+	u32 max_pages;		/* maximum pages this instance can support */
+	u32 top_partition;	/* highest partition number in this instance */
+	u32 top_page;		/* highest page number in this instance */
+	u32 page_size;		/* page size */
+	u32 slot_size;		/* selected size of each storage block */
+
+	/* Partition/Page Allocation Map */
+	u32 localpages;		/* Number of pages we can access */
+	struct sm_page_descriptor *pagedesc;	/* Allocated per-page */
+
+	/* Installed handlers for keystore access */
+	int (*data_init)(struct device *dev, u32 unit);
+	void (*data_cleanup)(struct device *dev, u32 unit);
+	int (*slot_alloc)(struct device *dev, u32 unit, u32 size, u32 *slot);
+	int (*slot_dealloc)(struct device *dev, u32 unit, u32 slot);
+	void *(*slot_get_address)(struct device *dev, u32 unit, u32 handle);
+	u32 (*slot_get_base)(struct device *dev, u32 unit, u32 handle);
+	u32 (*slot_get_offset)(struct device *dev, u32 unit, u32 handle);
+	u32 (*slot_get_slot_size)(struct device *dev, u32 unit, u32 handle);
+};
+
+#endif /* SM_H */
diff --git a/drivers/crypto/caam/sm_store.c b/drivers/crypto/caam/sm_store.c
new file mode 100644
index 0000000..673631e
--- /dev/null
+++ b/drivers/crypto/caam/sm_store.c
@@ -0,0 +1,890 @@
+
+/*
+ * CAAM Secure Memory Storage Interface
+ * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Loosely based on the SHW Keystore API for SCC/SCC2
+ * Experimental implementation and NOT intended for upstream use. Expect
+ * this interface to be amended significantly in the future once it becomes
+ * integrated into live applications.
+ *
+ * Known issues:
+ *
+ * - Executes one instance of an secure memory "driver". This is tied to the
+ *   fact that job rings can't run as standalone instances in the present
+ *   configuration.
+ *
+ * - It does not expose a userspace interface. The value of a userspace
+ *   interface for access to secrets is a point for further architectural
+ *   discussion.
+ *
+ * - Partition/permission management is not part of this interface. It
+ *   depends on some level of "knowledge" agreed upon between bootloader,
+ *   provisioning applications, and OS-hosted software (which uses this
+ *   driver).
+ *
+ * - No means of identifying the location or purpose of secrets managed by
+ *   this interface exists; "slot location" and format of a given secret
+ *   needs to be agreed upon between bootloader, provisioner, and OS-hosted
+ *   application.
+ */
+
+#include "compat.h"
+#include "regs.h"
+#include "jr.h"
+#include "desc.h"
+#include "intern.h"
+#include "error.h"
+#include "sm.h"
+
+
+#ifdef SM_DEBUG_CONT
+void sm_show_page(struct device *dev, struct sm_page_descriptor *pgdesc)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	u32 i, *smdata;
+
+	dev_info(dev, "physical page %d content at 0x%08x\n",
+		 pgdesc->phys_pagenum, pgdesc->pg_base);
+	smdata = pgdesc->pg_base;
+	for (i = 0; i < (smpriv->page_size / sizeof(u32)); i += 4)
+		dev_info(dev, "[0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			 (u32)&smdata[i], smdata[i], smdata[i+1], smdata[i+2],
+			 smdata[i+3]);
+}
+#endif
+
+/*
+ * Construct a secure memory blob encapsulation job descriptor
+ *
+ * - desc	pointer to hold new (to be allocated) pointer to the generated
+ *		descriptor for later use. Calling thread can kfree the
+ *		descriptor after execution.
+ * - keymod	Physical pointer to key modifier (contiguous piece).
+ * - keymodsz	Size of key modifier in bytes (should normally be 8).
+ * - secretbuf	Physical pointer (within an accessible secure memory page)
+ *		of the secret to be encapsulated.
+ * - outbuf	Physical pointer (within an accessible secure memory page)
+ *		of the encapsulated output. This will be larger than the
+ *		input secret because of the added encapsulation data.
+ * - secretsz	Size of input secret, in bytes.
+ * - auth	If nonzero, use AES-CCM for encapsulation, else use ECB
+ *
+ * Note: this uses 32-bit pointers at present
+ */
+#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */
+static int blob_encap_desc(u32 **desc, dma_addr_t keymod, u16 keymodsz,
+			   dma_addr_t secretbuf, dma_addr_t outbuf,
+			   u16 secretsz, bool auth)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+
+	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
+	idx = 1;
+
+	/* Load key modifier */
+	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB | LDST_SRCDST_BYTE_KEY |
+			 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK) |
+			 (keymodsz & LDST_LEN_MASK);
+
+	tmpdesc[idx++] = (u32)keymod;
+
+	/* Encapsulate to secure memory */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | secretsz;
+	tmpdesc[idx++] = (u32)secretbuf;
+
+	/* Add space for BKEK and MAC tag */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | (secretsz + (32 + 16));
+
+	tmpdesc[idx++] = (u32)outbuf;
+	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB |
+		     OP_PCL_BLOB_PTXT_SECMEM;
+	if (auth)
+		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
+
+	idx++;
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (tdesc == NULL)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+	return dsize;
+}
+
+/*
+ * Construct a secure memory blob decapsulation job descriptor
+ *
+ * - desc	pointer to hold new (to be allocated) pointer to the generated
+ *		descriptor for later use. Calling thread can kfree the
+ *		descriptor after execution.
+ * - keymod	Physical pointer to key modifier (contiguous piece).
+ * - keymodsz	Size of key modifier in bytes (should normally be 16).
+ * - blobbuf	Physical pointer (within an accessible secure memory page)
+ *		of the blob to be decapsulated.
+ * - outbuf	Physical pointer (within an accessible secure memory page)
+ *		of the decapsulated output.
+ * - secretsz	Size of input blob, in bytes.
+ * - auth	If nonzero, assume AES-CCM for decapsulation, else use ECB
+ *
+ * Note: this uses 32-bit pointers at present
+ */
+static int blob_decap_desc(u32 **desc, dma_addr_t keymod, u16 keymodsz,
+			   dma_addr_t blobbuf, dma_addr_t outbuf,
+			   u16 blobsz, bool auth)
+{
+	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
+	u16 dsize, idx;
+
+	memset(tmpdesc, 0, INITIAL_DESCSZ * sizeof(u32));
+	idx = 1;
+
+	/* Load key modifier */
+	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB | LDST_SRCDST_BYTE_KEY |
+			 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK) |
+			 (keymodsz & LDST_LEN_MASK);
+
+	tmpdesc[idx++] = (u32)keymod;
+
+	/* Compensate BKEK + MAC tag */
+	tmpdesc[idx++] = CMD_SEQ_IN_PTR | (blobsz + 32 + 16);
+
+	tmpdesc[idx++] = (u32)blobbuf;
+	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | blobsz;
+	tmpdesc[idx++] = (u32)outbuf;
+
+	/* Decapsulate from secure memory partition to black blob */
+	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB |
+		     OP_PCL_BLOB_PTXT_SECMEM | OP_PCL_BLOB_BLACK;
+	if (auth)
+		tmpdesc[idx] |= OP_PCL_BLOB_EKT;
+
+	idx++;
+	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
+	dsize = idx * sizeof(u32);
+
+	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
+	if (tdesc == NULL)
+		return 0;
+
+	memcpy(tdesc, tmpdesc, dsize);
+	*desc = tdesc;
+	return dsize;
+}
+
+/*
+ * Pseudo-synchronous ring access functions for carrying out key
+ * encapsulation and decapsulation
+ */
+
+struct sm_key_job_result {
+	int error;
+	struct completion completion;
+};
+
+void sm_key_job_done(struct device *dev, u32 *desc, u32 err, void *context)
+{
+	struct sm_key_job_result *res = context;
+
+	res->error = err;	/* save off the error for postprocessing */
+	complete(&res->completion);	/* mark us complete */
+}
+
+static int sm_key_job(struct device *ksdev, u32 *jobdesc)
+{
+	struct sm_key_job_result testres;
+	struct caam_drv_private_sm *kspriv;
+	int rtn = 0;
+
+	kspriv = dev_get_drvdata(ksdev);
+
+	init_completion(&testres.completion);
+
+	rtn = caam_jr_enqueue(kspriv->smringdev, jobdesc, sm_key_job_done,
+			      &testres);
+	if (!rtn) {
+		wait_for_completion_interruptible(&testres.completion);
+		rtn = testres.error;
+	}
+	return rtn;
+}
+
+/*
+ * Following section establishes the default methods for keystore access
+ * They are NOT intended for use external to this module
+ *
+ * In the present version, these are the only means for the higher-level
+ * interface to deal with the mechanics of accessing the phyiscal keystore
+ */
+
+
+int slot_alloc(struct device *dev, u32 unit, u32 size, u32 *slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	struct keystore_data *ksdata = smpriv->pagedesc[unit].ksdata;
+	u32 i;
+
+#ifdef SM_DEBUG
+	dev_info(dev, "slot_alloc(): requesting slot for %d bytes\n", size);
+#endif
+
+	if (size > smpriv->slot_size)
+		return -EKEYREJECTED;
+
+	for (i = 0; i < ksdata->slot_count; i++) {
+		if (ksdata->slot[i].allocated == 0) {
+			ksdata->slot[i].allocated = 1;
+			(*slot) = i;
+#ifdef SM_DEBUG
+			dev_info(dev, "slot_alloc(): new slot %d allocated\n",
+				 *slot);
+#endif
+			return 0;
+		}
+	}
+
+	return -ENOSPC;
+}
+
+int slot_dealloc(struct device *dev, u32 unit, u32 slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	struct keystore_data *ksdata = smpriv->pagedesc[unit].ksdata;
+	u8 __iomem *slotdata;
+
+#ifdef SM_DEBUG
+	dev_info(dev, "slot_dealloc(): releasing slot %d\n", slot);
+#endif
+	if (slot >= ksdata->slot_count)
+		return -EINVAL;
+	slotdata = ksdata->base_address + slot * smpriv->slot_size;
+
+	if (ksdata->slot[slot].allocated == 1) {
+		/* Forcibly overwrite the data from the keystore */
+		memset(ksdata->base_address + slot * smpriv->slot_size, 0,
+		       smpriv->slot_size);
+
+		ksdata->slot[slot].allocated = 0;
+#ifdef SM_DEBUG
+		dev_info(dev, "slot_dealloc(): slot %d released\n", slot);
+#endif
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+void *slot_get_address(struct device *dev, u32 unit, u32 slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	struct keystore_data *ksdata = smpriv->pagedesc[unit].ksdata;
+
+	if (slot >= ksdata->slot_count)
+		return NULL;
+
+#ifdef SM_DEBUG
+	dev_info(dev, "slot_get_address(): slot %d is 0x%08x\n", slot,
+		 (u32)ksdata->base_address + slot * smpriv->slot_size);
+#endif
+
+	return ksdata->base_address + slot * smpriv->slot_size;
+}
+
+u32 slot_get_base(struct device *dev, u32 unit, u32 slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	struct keystore_data *ksdata = smpriv->pagedesc[unit].ksdata;
+
+	/*
+	 * There could potentially be more than one secure partition object
+	 * associated with this keystore.  For now, there is just one.
+	 */
+
+	(void)slot;
+
+#ifdef SM_DEBUG
+	dev_info(dev, "slot_get_base(): slot %d = 0x%08x\n",
+		slot, (u32)ksdata->base_address);
+#endif
+
+	return (u32)(ksdata->base_address);
+}
+
+u32 slot_get_offset(struct device *dev, u32 unit, u32 slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	struct keystore_data *ksdata = smpriv->pagedesc[unit].ksdata;
+
+	if (slot >= ksdata->slot_count)
+		return -EINVAL;
+
+#ifdef SM_DEBUG
+	dev_info(dev, "slot_get_offset(): slot %d = %d\n", slot,
+		slot * smpriv->slot_size);
+#endif
+
+	return slot * smpriv->slot_size;
+}
+
+u32 slot_get_slot_size(struct device *dev, u32 unit, u32 slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+
+
+#ifdef SM_DEBUG
+	dev_info(dev, "slot_get_slot_size(): slot %d = %d\n", slot,
+		 smpriv->slot_size);
+#endif
+	/* All slots are the same size in the default implementation */
+	return smpriv->slot_size;
+}
+
+
+
+int kso_init_data(struct device *dev, u32 unit)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = -EINVAL;
+	struct keystore_data *keystore_data = NULL;
+	u32 slot_count;
+	u32 keystore_data_size;
+
+	/*
+	 * Calculate the required size of the keystore data structure, based
+	 * on the number of keys that can fit in the partition.
+	 */
+	slot_count = smpriv->page_size / smpriv->slot_size;
+#ifdef SM_DEBUG
+	dev_info(dev, "kso_init_data: %d slots initializing\n", slot_count);
+#endif
+
+	keystore_data_size = sizeof(struct keystore_data) +
+				slot_count *
+				sizeof(struct keystore_data_slot_info);
+
+	keystore_data = kzalloc(keystore_data_size, GFP_KERNEL);
+
+	if (keystore_data == NULL) {
+		retval = -ENOSPC;
+		goto out;
+	}
+
+#ifdef SM_DEBUG
+	dev_info(dev, "kso_init_data: keystore data size = %d\n",
+		 keystore_data_size);
+#endif
+
+	/*
+	 * Place the slot information structure directly after the keystore data
+	 * structure.
+	 */
+	keystore_data->slot = (struct keystore_data_slot_info *)
+			      (keystore_data + 1);
+	keystore_data->slot_count = slot_count;
+
+	smpriv->pagedesc[unit].ksdata = keystore_data;
+	smpriv->pagedesc[unit].ksdata->base_address =
+		smpriv->pagedesc[unit].pg_base;
+
+	retval = 0;
+
+out:
+	if (retval != 0)
+		if (keystore_data != NULL)
+			kfree(keystore_data);
+
+
+	return retval;
+}
+
+void kso_cleanup_data(struct device *dev, u32 unit)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	struct keystore_data *keystore_data = NULL;
+
+	if (smpriv->pagedesc[unit].ksdata != NULL)
+		keystore_data = smpriv->pagedesc[unit].ksdata;
+
+	/* Release the allocated keystore management data */
+	kfree(smpriv->pagedesc[unit].ksdata);
+
+	return;
+}
+
+
+
+/*
+ * Keystore management section
+ */
+
+void sm_init_keystore(struct device *dev)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+
+	smpriv->data_init = kso_init_data;
+	smpriv->data_cleanup = kso_cleanup_data;
+	smpriv->slot_alloc = slot_alloc;
+	smpriv->slot_dealloc = slot_dealloc;
+	smpriv->slot_get_address = slot_get_address;
+	smpriv->slot_get_base = slot_get_base;
+	smpriv->slot_get_offset = slot_get_offset;
+	smpriv->slot_get_slot_size = slot_get_slot_size;
+#ifdef SM_DEBUG
+	dev_info(dev, "sm_init_keystore(): handlers installed\n");
+#endif
+}
+EXPORT_SYMBOL(sm_init_keystore);
+
+/* Return available pages/units */
+u32 sm_detect_keystore_units(struct device *dev)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+
+	return smpriv->localpages;
+}
+EXPORT_SYMBOL(sm_detect_keystore_units);
+
+/*
+ * Do any keystore specific initializations
+ */
+int sm_establish_keystore(struct device *dev, u32 unit)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+
+#ifdef SM_DEBUG
+	dev_info(dev, "sm_establish_keystore(): unit %d initializing\n", unit);
+#endif
+
+	if (smpriv->data_init == NULL)
+		return -EINVAL;
+
+	/* Call the data_init function for any user setup */
+	return smpriv->data_init(dev, unit);
+}
+EXPORT_SYMBOL(sm_establish_keystore);
+
+void sm_release_keystore(struct device *dev, u32 unit)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+
+#ifdef SM_DEBUG
+	dev_info(dev, "sm_establish_keystore(): unit %d releasing\n", unit);
+#endif
+	if ((smpriv != NULL) && (smpriv->data_cleanup != NULL))
+		smpriv->data_cleanup(dev, unit);
+
+	return;
+}
+EXPORT_SYMBOL(sm_release_keystore);
+
+/*
+ * Subsequent interfacce (sm_keystore_*) forms the accessor interfacce to
+ * the keystore
+ */
+int sm_keystore_slot_alloc(struct device *dev, u32 unit, u32 size, u32 *slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = -EINVAL;
+
+	spin_lock(&smpriv->kslock);
+
+	if ((smpriv->slot_alloc == NULL) ||
+	    (smpriv->pagedesc[unit].ksdata == NULL))
+		goto out;
+
+	retval =  smpriv->slot_alloc(dev, unit, size, slot);
+
+out:
+	spin_unlock(&smpriv->kslock);
+	return retval;
+}
+EXPORT_SYMBOL(sm_keystore_slot_alloc);
+
+int sm_keystore_slot_dealloc(struct device *dev, u32 unit, u32 slot)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = -EINVAL;
+
+	spin_lock(&smpriv->kslock);
+
+	if ((smpriv->slot_alloc == NULL) ||
+	    (smpriv->pagedesc[unit].ksdata == NULL))
+		goto out;
+
+	retval = smpriv->slot_dealloc(dev, unit, slot);
+out:
+	spin_unlock(&smpriv->kslock);
+	return retval;
+}
+EXPORT_SYMBOL(sm_keystore_slot_dealloc);
+
+int sm_keystore_slot_load(struct device *dev, u32 unit, u32 slot,
+			  const u8 *key_data, u32 key_length)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = -EINVAL;
+	u32 slot_size;
+	u32 i;
+	u8 __iomem *slot_location;
+
+	spin_lock(&smpriv->kslock);
+
+	slot_size = smpriv->slot_get_slot_size(dev, unit, slot);
+
+	if (key_length > slot_size) {
+		retval = -EFBIG;
+		goto out;
+	}
+
+	slot_location = smpriv->slot_get_address(dev, unit, slot);
+
+	for (i = 0; i < key_length; i++)
+		slot_location[i] = key_data[i];
+
+	retval = 0;
+
+out:
+	spin_unlock(&smpriv->kslock);
+	return retval;
+}
+EXPORT_SYMBOL(sm_keystore_slot_load);
+
+int sm_keystore_slot_read(struct device *dev, u32 unit, u32 slot,
+			  u32 key_length, u8 *key_data)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = -EINVAL;
+	u8 __iomem *slot_addr;
+	u32 slot_size;
+
+	spin_lock(&smpriv->kslock);
+
+	slot_addr = smpriv->slot_get_address(dev, unit, slot);
+	slot_size = smpriv->slot_get_slot_size(dev, unit, slot);
+
+	if (key_length > slot_size) {
+		retval = -EKEYREJECTED;
+		goto out;
+	}
+
+	memcpy(key_data, slot_addr, key_length);
+	retval = 0;
+
+out:
+	spin_unlock(&smpriv->kslock);
+	return retval;
+}
+EXPORT_SYMBOL(sm_keystore_slot_read);
+
+int sm_keystore_slot_encapsulate(struct device *dev, u32 unit, u32 inslot,
+				 u32 outslot, u16 secretlen, u8 *keymod,
+				 u16 keymodlen)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = 0;
+	u32 slot_length, dsize, jstat;
+	u32 __iomem *encapdesc = NULL;
+	u8 __iomem *lkeymod, *inpslotaddr, *outslotaddr;
+	dma_addr_t keymod_dma;
+
+	/* Ensure that the full blob  will fit in the key slot */
+	slot_length = smpriv->slot_get_slot_size(dev, unit, outslot);
+	if ((secretlen + 48) > slot_length)
+		goto out;
+
+	/* Get the base addresses of both keystore slots */
+	inpslotaddr = (u8 *)smpriv->slot_get_address(dev, unit, inslot);
+	outslotaddr = (u8 *)smpriv->slot_get_address(dev, unit, outslot);
+
+	/* Build the key modifier */
+	lkeymod = kmalloc(keymodlen, GFP_KERNEL | GFP_DMA);
+	memcpy(lkeymod, keymod, keymodlen);
+	keymod_dma = dma_map_single(dev, lkeymod, keymodlen, DMA_TO_DEVICE);
+	dma_sync_single_for_device(dev, keymod_dma, keymodlen, DMA_TO_DEVICE);
+
+	/* Build the encapsulation job descriptor */
+	dsize = blob_encap_desc(&encapdesc, keymod_dma, keymodlen,
+				__pa(inpslotaddr), __pa(outslotaddr),
+				secretlen, 0);
+	if (!dsize) {
+		dev_err(dev, "can't alloc an encap descriptor\n");
+		retval = -ENOMEM;
+		goto out;
+	}
+	jstat = sm_key_job(dev, encapdesc);
+
+	dma_unmap_single(dev, keymod_dma, keymodlen, DMA_TO_DEVICE);
+	kfree(encapdesc);
+
+out:
+	return retval;
+
+}
+EXPORT_SYMBOL(sm_keystore_slot_encapsulate);
+
+int sm_keystore_slot_decapsulate(struct device *dev, u32 unit, u32 inslot,
+				 u32 outslot, u16 secretlen, u8 *keymod,
+				 u16 keymodlen)
+{
+	struct caam_drv_private_sm *smpriv = dev_get_drvdata(dev);
+	int retval = 0;
+	u32 slot_length, dsize, jstat;
+	u32 __iomem *decapdesc = NULL;
+	u8 __iomem *lkeymod, *inpslotaddr, *outslotaddr;
+	dma_addr_t keymod_dma;
+
+	/* Ensure that the decap data will fit in the key slot */
+	slot_length = smpriv->slot_get_slot_size(dev, unit, outslot);
+	if (secretlen > slot_length)
+		goto out;
+
+	/* Get the base addresses of both keystore slots */
+	inpslotaddr = (u8 *)smpriv->slot_get_address(dev, unit, inslot);
+	outslotaddr = (u8 *)smpriv->slot_get_address(dev, unit, outslot);
+
+	/* Build the key modifier */
+	lkeymod = kmalloc(keymodlen, GFP_KERNEL | GFP_DMA);
+	memcpy(lkeymod, keymod, keymodlen);
+	keymod_dma = dma_map_single(dev, lkeymod, keymodlen, DMA_TO_DEVICE);
+	dma_sync_single_for_device(dev, keymod_dma, keymodlen, DMA_TO_DEVICE);
+
+	/* Build the decapsulation job descriptor */
+	dsize = blob_decap_desc(&decapdesc, keymod_dma, keymodlen,
+				__pa(inpslotaddr), __pa(outslotaddr),
+				secretlen, 0);
+	if (!dsize) {
+		dev_err(dev, "can't alloc a decap descriptor\n");
+		retval = -ENOMEM;
+		goto out;
+	}
+	jstat = sm_key_job(dev, decapdesc);
+
+	dma_unmap_single(dev, keymod_dma, keymodlen, DMA_TO_DEVICE);
+	kfree(decapdesc);
+
+out:
+	return retval;
+
+}
+EXPORT_SYMBOL(sm_keystore_slot_decapsulate);
+
+
+/*
+ * Initialization/shutdown subsystem
+ * Assumes statically-invoked startup/shutdown from the controller driver
+ * for the present time, to be reworked when a device tree becomes
+ * available. This code will not modularize in present form.
+ *
+ * Also, simply uses ring 0 for execution at the present
+ */
+
+int caam_sm_startup(struct platform_device *pdev)
+{
+	struct device *ctrldev, *smdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_sm *smpriv;
+	struct caam_drv_private_jr *jrpriv;	/* need this for reg page */
+	struct platform_device *sm_pdev;
+	struct sm_page_descriptor *lpagedesc;
+	u32 page, pgstat, lpagect, detectedpage;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+
+	/*
+	 * Set up the private block for secure memory
+	 * Only one instance is possible
+	 */
+	smpriv = kzalloc(sizeof(struct caam_drv_private_sm), GFP_KERNEL);
+	if (smpriv == NULL) {
+		dev_err(ctrldev, "can't alloc private mem for secure memory\n");
+		return -ENOMEM;
+	}
+	smpriv->parentdev = ctrldev; /* copy of parent dev is handy */
+
+	/* Create the dev */
+#ifdef CONFIG_OF
+	sm_pdev = of_platform_device_create(np, NULL, ctrldev);
+#else
+	sm_pdev = platform_device_register_data(ctrldev, "caam_sm", 0,
+						smpriv,
+					sizeof(struct caam_drv_private_sm));
+#endif
+	if (sm_pdev == NULL) {
+		kfree(smpriv);
+		return -EINVAL;
+	}
+	smdev = &sm_pdev->dev;
+	dev_set_drvdata(smdev, smpriv);
+	ctrlpriv->smdev = smdev;
+
+	/*
+	 * Collect configuration limit data for reference
+	 * This batch comes from the partition data/vid registers in perfmon
+	 */
+	smpriv->max_pages = ((rd_reg32(&ctrlpriv->ctrl->perfmon.smpart)
+			    & SMPART_MAX_NUMPG_MASK) >>
+			    SMPART_MAX_NUMPG_SHIFT) + 1;
+	smpriv->top_partition = ((rd_reg32(&ctrlpriv->ctrl->perfmon.smpart)
+				& SMPART_MAX_PNUM_MASK) >>
+				SMPART_MAX_PNUM_SHIFT) + 1;
+	smpriv->top_page =  ((rd_reg32(&ctrlpriv->ctrl->perfmon.smpart)
+			    & SMPART_MAX_PG_MASK) >> SMPART_MAX_PG_SHIFT) + 1;
+	smpriv->page_size = 1024 << ((rd_reg32(&ctrlpriv->ctrl->perfmon.smvid)
+			    & SMVID_PG_SIZE_MASK) >> SMVID_PG_SIZE_SHIFT);
+	smpriv->slot_size = 1 << CONFIG_CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE;
+
+#ifdef SM_DEBUG
+	dev_info(smdev, "max pages = %d, top partition = %d\n",
+			smpriv->max_pages, smpriv->top_partition);
+	dev_info(smdev, "top page = %d, page size = %d (total = %d)\n",
+			smpriv->top_page, smpriv->page_size,
+			smpriv->top_page * smpriv->page_size);
+	dev_info(smdev, "selected slot size = %d\n", smpriv->slot_size);
+#endif
+
+	/*
+	 * Now probe for partitions/pages to which we have access. Note that
+	 * these have likely been set up by a bootloader or platform
+	 * provisioning application, so we have to assume that we "inherit"
+	 * a configuration and work within the constraints of what it might be.
+	 *
+	 * Assume use of the zeroth ring in the present iteration (until
+	 * we can divorce the controller and ring drivers, and then assign
+	 * an SM instance to any ring instance).
+	 */
+	smpriv->smringdev = ctrlpriv->jrdev[0];
+	jrpriv = dev_get_drvdata(smpriv->smringdev);
+	lpagect = 0;
+	lpagedesc = kzalloc(sizeof(struct sm_page_descriptor)
+			    * smpriv->max_pages, GFP_KERNEL);
+	if (lpagedesc == NULL) {
+		kfree(smpriv);
+		return -ENOMEM;
+	}
+
+	for (page = 0; page < smpriv->max_pages; page++) {
+		wr_reg32(&jrpriv->rregs->sm_cmd,
+			 ((page << SMC_PAGE_SHIFT) & SMC_PAGE_MASK) |
+			 (SMC_CMD_PAGE_INQUIRY & SMC_CMD_MASK));
+		pgstat = rd_reg32(&jrpriv->rregs->sm_status);
+		if (((pgstat & SMCS_PGWON_MASK) >> SMCS_PGOWN_SHIFT)
+		    == SMCS_PGOWN_OWNED) { /* our page? */
+			lpagedesc[page].phys_pagenum =
+				(pgstat & SMCS_PAGE_MASK) >> SMCS_PAGE_SHIFT;
+			lpagedesc[page].own_part =
+				(pgstat & SMCS_PART_SHIFT) >> SMCS_PART_MASK;
+			lpagedesc[page].pg_base = ctrlpriv->sm_base +
+				((smpriv->page_size * page) / sizeof(u32));
+			lpagect++;
+#ifdef SM_DEBUG
+			dev_info(smdev,
+				"physical page %d, owning partition = %d\n",
+				lpagedesc[page].phys_pagenum,
+				lpagedesc[page].own_part);
+#endif
+		}
+	}
+
+	smpriv->pagedesc = kmalloc(sizeof(struct sm_page_descriptor) * lpagect,
+				   GFP_KERNEL);
+	if (smpriv->pagedesc == NULL) {
+		kfree(lpagedesc);
+		kfree(smpriv);
+		return -ENOMEM;
+	}
+	smpriv->localpages = lpagect;
+
+	detectedpage = 0;
+	for (page = 0; page < smpriv->max_pages; page++) {
+		if (lpagedesc[page].pg_base != NULL) {	/* e.g. live entry */
+			memcpy(&smpriv->pagedesc[detectedpage],
+			       &lpagedesc[page],
+			       sizeof(struct sm_page_descriptor));
+#ifdef SM_DEBUG_CONT
+			sm_show_page(smdev, &smpriv->pagedesc[detectedpage]);
+#endif
+			detectedpage++;
+		}
+	}
+
+	kfree(lpagedesc);
+
+	sm_init_keystore(smdev);
+
+	return 0;
+}
+
+void caam_sm_shutdown(struct platform_device *pdev)
+{
+	struct device *ctrldev, *smdev;
+	struct caam_drv_private *priv;
+	struct caam_drv_private_sm *smpriv;
+
+	ctrldev = &pdev->dev;
+	priv = dev_get_drvdata(ctrldev);
+	smdev = priv->smdev;
+	smpriv = dev_get_drvdata(smdev);
+
+	kfree(smpriv->pagedesc);
+	kfree(smpriv);
+}
+
+#ifdef CONFIG_OF
+static void __exit caam_sm_exit(void)
+{
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	of_node_put(dev_node);
+
+	caam_sm_shutdown(pdev);
+}
+
+static int __init caam_sm_init(void)
+{
+	struct device_node *dev_node;
+	struct platform_device *pdev;
+
+	/*
+	 * Do of_find_compatible_node() then of_find_device_by_node()
+	 * once a functional device tree is available
+	 */
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node) {
+		dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
+		if (!dev_node)
+			return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(dev_node);
+	if (!pdev)
+		return -ENODEV;
+
+	of_node_put(dev_node);
+
+	return caam_sm_startup(pdev);
+}
+
+module_init(caam_sm_init);
+module_exit(caam_sm_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL CAAM Secure Memory / Keystore");
+MODULE_AUTHOR("Freescale Semiconductor - NMSG/MAD");
+#endif
diff --git a/drivers/crypto/caam/sm_test.c b/drivers/crypto/caam/sm_test.c
new file mode 100644
index 0000000..6e95f9a
--- /dev/null
+++ b/drivers/crypto/caam/sm_test.c
@@ -0,0 +1,795 @@
+/*
+ * Secure Memory / Keystore Exemplification Module
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved
+ *
+ * Serves as a functional example, and as a self-contained unit test for
+ * the functionality contained in sm_store.c.
+ *
+ * The example function, caam_sm_example_init(), runs a thread that:
+ *
+ * - initializes a set of fixed keys
+ * - stores one copy in clear buffers
+ * - stores them again in secure memory
+ * - extracts stored keys back out for use
+ * - intializes 3 data buffers for a test:
+ *   (1) containing cleartext
+ *   (2) to hold ciphertext encrypted with an extracted black key
+ *   (3) to hold extracted cleartext decrypted with an equivalent clear key
+ *
+ * The function then builds simple job descriptors that reference the key
+ * material and buffers as initialized, and executes an encryption job
+ * with a black key, and a decryption job using a the same key held in the
+ * clear. The output of the decryption job is compared to the original
+ * cleartext; if they don't compare correctly, one can assume a key problem
+ * exists, where the function will exit with an error.
+ *
+ * This module can use a substantial amount of refactoring, which may occur
+ * after the API gets some mileage. Furthermore, expect this module to
+ * eventually disappear once the API is integrated into "real" software.
+ */
+
+#include "compat.h"
+#include "intern.h"
+#include "desc.h"
+#include "error.h"
+#include "jr.h"
+#include "sm.h"
+
+static u8 skeymod[] = {
+	0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
+	0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00
+};
+static u8 symkey[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
+};
+
+static u8 symdata[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x0f, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+	0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+	0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
+	0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
+	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+	0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
+	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
+	0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
+	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
+	0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
+	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
+	0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
+	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
+};
+
+static int mk_job_desc(u32 *desc, dma_addr_t key, u16 keysz, dma_addr_t indata,
+		       dma_addr_t outdata, u16 sz, u32 cipherdir, u32 keymode)
+{
+	desc[1] = CMD_KEY | CLASS_1 | (keysz & KEY_LENGTH_MASK) | keymode;
+	desc[2] = (u32)key;
+	desc[3] = CMD_OPERATION | OP_TYPE_CLASS1_ALG | OP_ALG_AAI_ECB |
+		  cipherdir;
+	desc[4] = CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 |
+		  FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1 | sz;
+	desc[5] = (u32)indata;
+	desc[6] = CMD_FIFO_STORE | FIFOST_TYPE_MESSAGE_DATA | sz;
+	desc[7] = (u32)outdata;
+
+	desc[0] = CMD_DESC_HDR | HDR_ONE | (8 & HDR_DESCLEN_MASK);
+	return 8 * sizeof(u32);
+}
+
+struct exec_test_result {
+	int error;
+	struct completion completion;
+};
+
+void exec_test_done(struct device *dev, u32 *desc, u32 err, void *context)
+{
+	struct exec_test_result *res = context;
+
+	if (err) {
+		char tmp[CAAM_ERROR_STR_MAX];
+		dev_err(dev, "%08x: %s\n", err, caam_jr_strstatus(tmp, err));
+	}
+
+	res->error = err;
+	complete(&res->completion);
+}
+
+static int exec_test_job(struct device *ksdev, u32 *jobdesc)
+{
+	struct exec_test_result testres;
+	struct caam_drv_private_sm *kspriv;
+	int rtn = 0;
+
+	kspriv = dev_get_drvdata(ksdev);
+
+	init_completion(&testres.completion);
+
+	rtn = caam_jr_enqueue(kspriv->smringdev, jobdesc, exec_test_done,
+			      &testres);
+	if (!rtn) {
+		wait_for_completion_interruptible(&testres.completion);
+		rtn = testres.error;
+	}
+	return rtn;
+}
+
+
+int caam_sm_example_init(struct platform_device *pdev)
+{
+	struct device *ctrldev, *ksdev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_drv_private_sm *kspriv;
+	u32 unit, units, jdescsz;
+	int stat, jstat, rtnval = 0;
+	u8 __iomem *syminp, *symint, *symout = NULL;
+	dma_addr_t syminp_dma, symint_dma, symout_dma;
+	u8 __iomem *black_key_des, *black_key_aes128;
+	u8 __iomem  *black_key_aes256;
+	dma_addr_t black_key_des_dma, black_key_aes128_dma;
+	dma_addr_t black_key_aes256_dma;
+	u8 __iomem *clear_key_des, *clear_key_aes128, *clear_key_aes256;
+	dma_addr_t clear_key_des_dma, clear_key_aes128_dma;
+	dma_addr_t clear_key_aes256_dma;
+	u32 __iomem *jdesc;
+	u32 keyslot_des, keyslot_aes128, keyslot_aes256 = 0;
+
+	jdesc = NULL;
+	black_key_des = black_key_aes128 = black_key_aes256 = NULL;
+	clear_key_des = clear_key_aes128 = clear_key_aes256 = NULL;
+
+	/* We can lose this cruft once we can get a pdev by name */
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	ksdev = ctrlpriv->smdev;
+	kspriv = dev_get_drvdata(ksdev);
+	if (kspriv == NULL)
+		return -ENODEV;
+
+	/* Now that we have the dev for the single SM instance, connect */
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test_init() running\n");
+#endif
+	/* Probe to see what keystores are available to us */
+	units = sm_detect_keystore_units(ksdev);
+	if (!units)
+		dev_err(ksdev, "caam_sm_test: no keystore units available\n");
+
+	/*
+	 * MX6 bootloader stores some stuff in unit 0, so let's
+	 * use 1 or above
+	 */
+	if (units < 2) {
+		dev_err(ksdev, "caam_sm_test: insufficient keystore units\n");
+		return -ENODEV;
+	}
+	unit = 1;
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: %d keystore units available\n", units);
+#endif
+
+	/* Initialize/Establish Keystore */
+	sm_establish_keystore(ksdev, unit);	/* Initalize store in #1 */
+
+	/*
+	 * Top of main test thread
+	 */
+
+	/* Allocate test data blocks (input, intermediate, output) */
+	syminp = kmalloc(256, GFP_KERNEL | GFP_DMA);
+	symint = kmalloc(256, GFP_KERNEL | GFP_DMA);
+	symout = kmalloc(256, GFP_KERNEL | GFP_DMA);
+	if ((syminp == NULL) || (symint == NULL) || (symout == NULL)) {
+		rtnval = -ENOMEM;
+		dev_err(ksdev, "caam_sm_test: can't get test data buffers\n");
+		goto freemem;
+	}
+
+	/* Allocate storage for 3 black keys: encapsulated 8, 16, 32 */
+	black_key_des = kmalloc(16, GFP_KERNEL | GFP_DMA); /* padded to 16... */
+	black_key_aes128 = kmalloc(16, GFP_KERNEL | GFP_DMA);
+	black_key_aes256 = kmalloc(16, GFP_KERNEL | GFP_DMA);
+	if ((black_key_des == NULL) || (black_key_aes128 == NULL) ||
+	    (black_key_aes256 == NULL)) {
+		rtnval = -ENOMEM;
+		dev_err(ksdev, "caam_sm_test: can't black key buffers\n");
+		goto freemem;
+	}
+
+	clear_key_des = kmalloc(8, GFP_KERNEL | GFP_DMA);
+	clear_key_aes128 = kmalloc(16, GFP_KERNEL | GFP_DMA);
+	clear_key_aes256 = kmalloc(32, GFP_KERNEL | GFP_DMA);
+	if ((clear_key_des == NULL) || (clear_key_aes128 == NULL) ||
+	    (clear_key_aes256 == NULL)) {
+		rtnval = -ENOMEM;
+		dev_err(ksdev, "caam_sm_test: can't get clear key buffers\n");
+		goto freemem;
+	}
+
+	/* Allocate storage for job descriptor */
+	jdesc = kmalloc(8 * sizeof(u32), GFP_KERNEL | GFP_DMA);
+	if (jdesc == NULL) {
+		rtnval = -ENOMEM;
+		dev_err(ksdev, "caam_sm_test: can't get descriptor buffers\n");
+		goto freemem;
+	}
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: all buffers allocated\n");
+#endif
+
+	/* Load up input data block, clear outputs */
+	memcpy(syminp, symdata, 256);
+	memset(symint, 0, 256);
+	memset(symout, 0, 256);
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[0], syminp[1], syminp[2], syminp[3],
+		 syminp[4], syminp[5], syminp[6], syminp[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[0], symout[1], symout[2], symout[3],
+		 symout[4], symout[5], symout[6], symout[7]);
+
+	dev_info(ksdev, "caam_sm_test: data buffers initialized\n");
+#endif
+
+	/* Load up clear keys */
+	memcpy(clear_key_des, symkey, 8);
+	memcpy(clear_key_aes128, symkey, 16);
+	memcpy(clear_key_aes256, symkey, 32);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: all clear keys loaded\n");
+#endif
+
+	/*
+	 * Place clear keys in keystore.
+	 * All the interesting stuff happens here.
+	 */
+	/* 8 bit DES key */
+	stat = sm_keystore_slot_alloc(ksdev, unit, 8, &keyslot_des);
+	if (stat)
+		goto freemem;
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: 8 byte key slot in %d\n" keyslot_des);
+#endif
+	stat = sm_keystore_slot_load(ksdev, unit, keyslot_des, clear_key_des,
+				     8);
+	if (stat) {
+#ifdef SM_TEST_DETAIL
+		dev_info(ksdev, "caam_sm_test: can't load 8 byte key in %d\n",
+			 keyslot_des);
+#endif
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_des);
+		goto freemem;
+	}
+
+	/* 16 bit AES key */
+	stat = sm_keystore_slot_alloc(ksdev, unit, 16, &keyslot_aes128);
+	if (stat) {
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_des);
+		goto freemem;
+	}
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: 16 byte key slot in %d\n",
+		 keyslot_aes128);
+#endif
+	stat = sm_keystore_slot_load(ksdev, unit, keyslot_aes128,
+				     clear_key_aes128, 16);
+	if (stat) {
+#ifdef SM_TEST_DETAIL
+		dev_info(ksdev, "caam_sm_test: can't load 16 byte key in %d\n",
+			 keyslot_aes128);
+#endif
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_aes128);
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_des);
+		goto freemem;
+	}
+
+	/* 32 bit AES key */
+	stat = sm_keystore_slot_alloc(ksdev, unit, 32, &keyslot_aes256);
+	if (stat) {
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_aes128);
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_des);
+		goto freemem;
+	}
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: 32 byte key slot in %d\n",
+		 keyslot_aes256);
+#endif
+	stat = sm_keystore_slot_load(ksdev, unit, keyslot_aes256,
+				     clear_key_aes256, 32);
+	if (stat) {
+#ifdef SM_TEST_DETAIL
+		dev_info(ksdev, "caam_sm_test: can't load 32 byte key in %d\n",
+			 keyslot_aes128);
+#endif
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_aes256);
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_aes128);
+		sm_keystore_slot_dealloc(ksdev, unit, keyslot_des);
+		goto freemem;
+	}
+
+	/* Encapsulate all keys as SM blobs */
+	stat = sm_keystore_slot_encapsulate(ksdev, unit, keyslot_des,
+					    keyslot_des, 8, skeymod, 8);
+	if (stat) {
+		dev_info(ksdev, "caam_sm_test: can't encapsulate DES key\n");
+		goto freekeys;
+	}
+
+	stat = sm_keystore_slot_encapsulate(ksdev, unit, keyslot_aes128,
+					    keyslot_aes128, 16, skeymod, 8);
+	if (stat) {
+		dev_info(ksdev, "caam_sm_test: can't encapsulate AES128 key\n");
+		goto freekeys;
+	}
+
+	stat = sm_keystore_slot_encapsulate(ksdev, unit, keyslot_aes256,
+					    keyslot_aes256, 32, skeymod, 8);
+	if (stat) {
+		dev_info(ksdev, "caam_sm_test: can't encapsulate AES256 key\n");
+		goto freekeys;
+	}
+
+	/* Now decapsulate as black key blobs */
+	stat = sm_keystore_slot_decapsulate(ksdev, unit, keyslot_des,
+					    keyslot_des, 8, skeymod, 8);
+	if (stat) {
+		dev_info(ksdev, "caam_sm_test: can't decapsulate DES key\n");
+		goto freekeys;
+	}
+
+	stat = sm_keystore_slot_decapsulate(ksdev, unit, keyslot_aes128,
+					    keyslot_aes128, 16, skeymod, 8);
+	if (stat) {
+		dev_info(ksdev, "caam_sm_test: can't decapsulate AES128 key\n");
+		goto freekeys;
+	}
+
+	stat = sm_keystore_slot_decapsulate(ksdev, unit, keyslot_aes256,
+					    keyslot_aes256, 32, skeymod, 8);
+	if (stat) {
+		dev_info(ksdev, "caam_sm_test: can't decapsulate AES128 key\n");
+		goto freekeys;
+	}
+
+	/* Extract 8/16/32 byte black keys */
+	sm_keystore_slot_read(ksdev, unit, keyslot_des, 8, black_key_des);
+	sm_keystore_slot_read(ksdev, unit, keyslot_aes128, 16,
+			      black_key_aes128);
+	sm_keystore_slot_read(ksdev, unit, keyslot_aes256, 32,
+			      black_key_aes256);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: all black keys extracted\n");
+#endif
+
+	/* DES encrypt using 8 byte black key */
+	black_key_des_dma = dma_map_single(ksdev, black_key_des, 8,
+					   DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, black_key_des_dma, 8, DMA_TO_DEVICE);
+	syminp_dma = dma_map_single(ksdev, syminp, 256, DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, syminp_dma, 256, DMA_TO_DEVICE);
+	symint_dma = dma_map_single(ksdev, symint, 256, DMA_FROM_DEVICE);
+
+	jdescsz = mk_job_desc(jdesc, black_key_des_dma, 8, syminp_dma,
+			      symint_dma, 256,
+			      OP_ALG_ENCRYPT | OP_ALG_ALGSEL_DES, 0);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "jobdesc:\n");
+	dev_info(ksdev, "0x%08x\n", jdesc[0]);
+	dev_info(ksdev, "0x%08x\n", jdesc[1]);
+	dev_info(ksdev, "0x%08x\n", jdesc[2]);
+	dev_info(ksdev, "0x%08x\n", jdesc[3]);
+	dev_info(ksdev, "0x%08x\n", jdesc[4]);
+	dev_info(ksdev, "0x%08x\n", jdesc[5]);
+	dev_info(ksdev, "0x%08x\n", jdesc[6]);
+	dev_info(ksdev, "0x%08x\n", jdesc[7]);
+#endif
+
+	jstat = exec_test_job(ksdev, jdesc);
+
+	dma_sync_single_for_cpu(ksdev, symint_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symint_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, syminp_dma, 256, DMA_TO_DEVICE);
+	dma_unmap_single(ksdev, black_key_des_dma, 8, DMA_TO_DEVICE);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "input block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[0], syminp[1], syminp[2], syminp[3],
+		 syminp[4], syminp[5], syminp[6], syminp[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[8], syminp[9], syminp[10], syminp[11],
+		 syminp[12], syminp[13], syminp[14], syminp[15]);
+	dev_info(ksdev, "intermediate block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[8], symint[9], symint[10], symint[11],
+		 symint[12], symint[13], symint[14], symint[15]);
+	dev_info(ksdev, "caam_sm_test: encrypt cycle with 8 byte key\n");
+#endif
+
+	/* DES decrypt using 8 byte clear key */
+	clear_key_des_dma = dma_map_single(ksdev, clear_key_des, 8,
+					   DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, clear_key_des_dma, 8, DMA_TO_DEVICE);
+	symint_dma = dma_map_single(ksdev, symint, 256, DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, symint_dma, 256, DMA_TO_DEVICE);
+	symout_dma = dma_map_single(ksdev, symout, 256, DMA_FROM_DEVICE);
+
+	jdescsz = mk_job_desc(jdesc, clear_key_des_dma, 8, symint_dma,
+			      symout_dma, 256,
+			      OP_ALG_DECRYPT | OP_ALG_ALGSEL_DES, 0);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "jobdesc:\n");
+	dev_info(ksdev, "0x%08x\n", jdesc[0]);
+	dev_info(ksdev, "0x%08x\n", jdesc[1]);
+	dev_info(ksdev, "0x%08x\n", jdesc[2]);
+	dev_info(ksdev, "0x%08x\n", jdesc[3]);
+	dev_info(ksdev, "0x%08x\n", jdesc[4]);
+	dev_info(ksdev, "0x%08x\n", jdesc[5]);
+	dev_info(ksdev, "0x%08x\n", jdesc[6]);
+	dev_info(ksdev, "0x%08x\n", jdesc[7]);
+#endif
+
+	jstat = exec_test_job(ksdev, jdesc);
+
+	dma_sync_single_for_cpu(ksdev, symout_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symout_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symint_dma, 256, DMA_TO_DEVICE);
+	dma_unmap_single(ksdev, clear_key_des_dma, 8, DMA_TO_DEVICE);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "intermediate block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[8], symint[9], symint[10], symint[11],
+		 symint[12], symint[13], symint[14], symint[15]);
+	dev_info(ksdev, "decrypted block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[0], symout[1], symout[2], symout[3],
+		 symout[4], symout[5], symout[6], symout[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[8], symout[9], symout[10], symout[11],
+		 symout[12], symout[13], symout[14], symout[15]);
+	dev_info(ksdev, "caam_sm_test: decrypt cycle with 8 byte key\n");
+#endif
+
+	/* Check result */
+	if (memcmp(symout, syminp, 256)) {
+		dev_info(ksdev, "caam_sm_test: 8-byte key test mismatch\n");
+		rtnval = -1;
+		goto freekeys;
+	} else
+		dev_info(ksdev, "caam_sm_test: 8-byte key test match OK\n");
+
+	/* AES-128 encrypt using 16 byte black key */
+	black_key_aes128_dma = dma_map_single(ksdev, black_key_aes128, 16,
+					      DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, black_key_aes128_dma, 16,
+				   DMA_TO_DEVICE);
+	syminp_dma = dma_map_single(ksdev, syminp, 256, DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, syminp_dma, 256, DMA_TO_DEVICE);
+	symint_dma = dma_map_single(ksdev, symint, 256, DMA_FROM_DEVICE);
+
+	jdescsz = mk_job_desc(jdesc, black_key_aes128_dma, 16, syminp_dma,
+			      symint_dma, 256,
+			      OP_ALG_ENCRYPT | OP_ALG_ALGSEL_AES, 0);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "jobdesc:\n");
+	dev_info(ksdev, "0x%08x\n", jdesc[0]);
+	dev_info(ksdev, "0x%08x\n", jdesc[1]);
+	dev_info(ksdev, "0x%08x\n", jdesc[2]);
+	dev_info(ksdev, "0x%08x\n", jdesc[3]);
+	dev_info(ksdev, "0x%08x\n", jdesc[4]);
+	dev_info(ksdev, "0x%08x\n", jdesc[5]);
+	dev_info(ksdev, "0x%08x\n", jdesc[6]);
+	dev_info(ksdev, "0x%08x\n", jdesc[7]);
+#endif
+
+	jstat = exec_test_job(ksdev, jdesc);
+
+	dma_sync_single_for_cpu(ksdev, symint_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symint_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, syminp_dma, 256, DMA_TO_DEVICE);
+	dma_unmap_single(ksdev, black_key_aes128_dma, 16, DMA_TO_DEVICE);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "input block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[0], syminp[1], syminp[2], syminp[3],
+		 syminp[4], syminp[5], syminp[6], syminp[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[8], syminp[9], syminp[10], syminp[11],
+		 syminp[12], syminp[13], syminp[14], syminp[15]);
+	dev_info(ksdev, "intermediate block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[8], symint[9], symint[10], symint[11],
+		 symint[12], symint[13], symint[14], symint[15]);
+	dev_info(ksdev, "caam_sm_test: encrypt cycle with 16 byte key\n");
+#endif
+
+	/* AES-128 decrypt using 16 byte clear key */
+	clear_key_aes128_dma = dma_map_single(ksdev, clear_key_aes128, 16,
+					      DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, clear_key_aes128_dma, 16,
+				   DMA_TO_DEVICE);
+	symint_dma = dma_map_single(ksdev, symint, 256, DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, symint_dma, 256, DMA_TO_DEVICE);
+	symout_dma = dma_map_single(ksdev, symout, 256, DMA_FROM_DEVICE);
+
+	jdescsz = mk_job_desc(jdesc, clear_key_aes128_dma, 16, symint_dma,
+			      symout_dma, 256,
+			      OP_ALG_DECRYPT | OP_ALG_ALGSEL_AES, 0);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "jobdesc:\n");
+	dev_info(ksdev, "0x%08x\n", jdesc[0]);
+	dev_info(ksdev, "0x%08x\n", jdesc[1]);
+	dev_info(ksdev, "0x%08x\n", jdesc[2]);
+	dev_info(ksdev, "0x%08x\n", jdesc[3]);
+	dev_info(ksdev, "0x%08x\n", jdesc[4]);
+	dev_info(ksdev, "0x%08x\n", jdesc[5]);
+	dev_info(ksdev, "0x%08x\n", jdesc[6]);
+	dev_info(ksdev, "0x%08x\n", jdesc[7]);
+#endif
+	jstat = exec_test_job(ksdev, jdesc);
+
+	dma_sync_single_for_cpu(ksdev, symout_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symout_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symint_dma, 256, DMA_TO_DEVICE);
+	dma_unmap_single(ksdev, clear_key_aes128_dma, 16, DMA_TO_DEVICE);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "intermediate block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[8], symint[9], symint[10], symint[11],
+		 symint[12], symint[13], symint[14], symint[15]);
+	dev_info(ksdev, "decrypted block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[0], symout[1], symout[2], symout[3],
+		 symout[4], symout[5], symout[6], symout[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[8], symout[9], symout[10], symout[11],
+		 symout[12], symout[13], symout[14], symout[15]);
+	dev_info(ksdev, "caam_sm_test: decrypt cycle with 16 byte key\n");
+#endif
+
+	/* Check result */
+	if (memcmp(symout, syminp, 256)) {
+		dev_info(ksdev, "caam_sm_test: 16-byte key test mismatch\n");
+		rtnval = -1;
+		goto freekeys;
+	} else
+		dev_info(ksdev, "caam_sm_test: 16-byte key test match OK\n");
+
+	/* AES-256 encrypt using 32 byte black key */
+	black_key_aes256_dma = dma_map_single(ksdev, black_key_aes256, 32,
+					      DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, black_key_aes256_dma, 32,
+				   DMA_TO_DEVICE);
+	syminp_dma = dma_map_single(ksdev, syminp, 256, DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, syminp_dma, 256, DMA_TO_DEVICE);
+	symint_dma = dma_map_single(ksdev, symint, 256, DMA_FROM_DEVICE);
+
+	jdescsz = mk_job_desc(jdesc, black_key_aes256_dma, 32, syminp_dma,
+			      symint_dma, 256,
+			      OP_ALG_ENCRYPT | OP_ALG_ALGSEL_AES, 0);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "jobdesc:\n");
+	dev_info(ksdev, "0x%08x\n", jdesc[0]);
+	dev_info(ksdev, "0x%08x\n", jdesc[1]);
+	dev_info(ksdev, "0x%08x\n", jdesc[2]);
+	dev_info(ksdev, "0x%08x\n", jdesc[3]);
+	dev_info(ksdev, "0x%08x\n", jdesc[4]);
+	dev_info(ksdev, "0x%08x\n", jdesc[5]);
+	dev_info(ksdev, "0x%08x\n", jdesc[6]);
+	dev_info(ksdev, "0x%08x\n", jdesc[7]);
+#endif
+
+	jstat = exec_test_job(ksdev, jdesc);
+
+	dma_sync_single_for_cpu(ksdev, symint_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symint_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, syminp_dma, 256, DMA_TO_DEVICE);
+	dma_unmap_single(ksdev, black_key_aes256_dma, 32, DMA_TO_DEVICE);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "input block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[0], syminp[1], syminp[2], syminp[3],
+		 syminp[4], syminp[5], syminp[6], syminp[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 syminp[8], syminp[9], syminp[10], syminp[11],
+		 syminp[12], syminp[13], syminp[14], syminp[15]);
+	dev_info(ksdev, "intermediate block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[8], symint[9], symint[10], symint[11],
+		 symint[12], symint[13], symint[14], symint[15]);
+	dev_info(ksdev, "caam_sm_test: encrypt cycle with 32 byte key\n");
+#endif
+
+	/* AES-256 decrypt using 32-byte black key */
+	clear_key_aes256_dma = dma_map_single(ksdev, clear_key_aes256, 32,
+					      DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, clear_key_aes256_dma, 32,
+				   DMA_TO_DEVICE);
+	symint_dma = dma_map_single(ksdev, symint, 256, DMA_TO_DEVICE);
+	dma_sync_single_for_device(ksdev, symint_dma, 256, DMA_TO_DEVICE);
+	symout_dma = dma_map_single(ksdev, symout, 256, DMA_FROM_DEVICE);
+
+	jdescsz = mk_job_desc(jdesc, clear_key_aes256_dma, 32, symint_dma,
+			      symout_dma, 256,
+			      OP_ALG_DECRYPT | OP_ALG_ALGSEL_AES, 0);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "jobdesc:\n");
+	dev_info(ksdev, "0x%08x\n", jdesc[0]);
+	dev_info(ksdev, "0x%08x\n", jdesc[1]);
+	dev_info(ksdev, "0x%08x\n", jdesc[2]);
+	dev_info(ksdev, "0x%08x\n", jdesc[3]);
+	dev_info(ksdev, "0x%08x\n", jdesc[4]);
+	dev_info(ksdev, "0x%08x\n", jdesc[5]);
+	dev_info(ksdev, "0x%08x\n", jdesc[6]);
+	dev_info(ksdev, "0x%08x\n", jdesc[7]);
+#endif
+
+	jstat = exec_test_job(ksdev, jdesc);
+
+	dma_sync_single_for_cpu(ksdev, symout_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symout_dma, 256, DMA_FROM_DEVICE);
+	dma_unmap_single(ksdev, symint_dma, 256, DMA_TO_DEVICE);
+	dma_unmap_single(ksdev, clear_key_aes256_dma, 32, DMA_TO_DEVICE);
+
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "intermediate block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[0], symint[1], symint[2], symint[3],
+		 symint[4], symint[5], symint[6], symint[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symint[8], symint[9], symint[10], symint[11],
+		 symint[12], symint[13], symint[14], symint[15]);
+	dev_info(ksdev, "decrypted block:\n");
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[0], symout[1], symout[2], symout[3],
+		 symout[4], symout[5], symout[6], symout[7]);
+	dev_info(ksdev, "0x%02x 0x%02x 0x%02x 0x%02x " \
+			"0x%02x 0x%02x 0x%02x 0x%02x\n",
+		 symout[8], symout[9], symout[10], symout[11],
+		 symout[12], symout[13], symout[14], symout[15]);
+	dev_info(ksdev, "caam_sm_test: decrypt cycle with 32 byte key\n");
+#endif
+
+	/* Check result */
+	if (memcmp(symout, syminp, 256)) {
+		dev_info(ksdev, "caam_sm_test: 32-byte key test mismatch\n");
+		rtnval = -1;
+		goto freekeys;
+	} else
+		dev_info(ksdev, "caam_sm_test: 32-byte key test match OK\n");
+
+
+	/* Remove 8/16/32 byte keys from keystore */
+freekeys:
+	stat = sm_keystore_slot_dealloc(ksdev, unit, keyslot_des);
+	if (stat)
+		dev_info(ksdev, "caam_sm_test: can't release slot %d\n",
+			 keyslot_des);
+
+	stat = sm_keystore_slot_dealloc(ksdev, unit, keyslot_aes128);
+	if (stat)
+		dev_info(ksdev, "caam_sm_test: can't release slot %d\n",
+			 keyslot_aes128);
+
+	stat = sm_keystore_slot_dealloc(ksdev, unit, keyslot_aes256);
+	if (stat)
+		dev_info(ksdev, "caam_sm_test: can't release slot %d\n",
+			 keyslot_aes256);
+
+
+	/* Free resources */
+freemem:
+#ifdef SM_TEST_DETAIL
+	dev_info(ksdev, "caam_sm_test: cleaning up\n");
+#endif
+	kfree(syminp);
+	kfree(symint);
+	kfree(symout);
+	kfree(clear_key_des);
+	kfree(clear_key_aes128);
+	kfree(clear_key_aes256);
+	kfree(black_key_des);
+	kfree(black_key_aes128);
+	kfree(black_key_aes256);
+	kfree(jdesc);
+
+	/* Disconnect from keystore and leave */
+	sm_release_keystore(ksdev, unit);
+
+	return rtnval;
+}
+
+void caam_sm_example_shutdown(void)
+{
+	/* unused in present version */
+}
+
+/* Module-based initialization needs to wait for dev tree */
+#ifdef CONFIG_OF
+module_init(caam_sm_example_init);
+module_exit(caam_sm_example_shutdown);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL CAAM Keystore Usage Example");
+MODULE_AUTHOR("Freescale Semiconductor - NMSG/MAD");
+#endif
diff --git a/drivers/crypto/caam/snvsregs.h b/drivers/crypto/caam/snvsregs.h
new file mode 100644
index 0000000..5655f6e
--- /dev/null
+++ b/drivers/crypto/caam/snvsregs.h
@@ -0,0 +1,237 @@
+/*
+ * SNVS hardware register-level view
+ *
+ * Copyright (C) 2012 Freescale Semiconductor, Inc., All Rights Reserved
+ */
+
+#ifndef SNVSREGS_H
+#define SNVSREGS_H
+
+#include <linux/types.h>
+#include <linux/io.h>
+
+/*
+ * SNVS High Power Domain
+ * Includes security violations, HA counter, RTC, alarm
+ */
+struct snvs_hp {
+	u32 lock;
+	u32 cmd;
+	u32 ctl;
+	u32 secvio_int_en;	/* Security Violation Interrupt Enable */
+	u32 secvio_int_ctl;	/* Security Violation Interrupt Control */
+	u32 status;
+	u32 secvio_status;	/* Security Violation Status */
+	u32 ha_counteriv;	/* High Assurance Counter IV */
+	u32 ha_counter;		/* High Assurance Counter */
+	u32 rtc_msb;		/* Real Time Clock/Counter MSB */
+	u32 rtc_lsb;		/* Real Time Counter LSB */
+	u32 time_alarm_msb;	/* Time Alarm MSB */
+	u32 time_alarm_lsb;	/* Time Alarm LSB */
+};
+
+#define HP_LOCK_HAC_LCK		0x00040000
+#define HP_LOCK_HPSICR_LCK	0x00020000
+#define HP_LOCK_HPSVCR_LCK	0x00010000
+#define HP_LOCK_MKEYSEL_LCK	0x00000200
+#define HP_LOCK_TAMPCFG_LCK	0x00000100
+#define HP_LOCK_TAMPFLT_LCK	0x00000080
+#define HP_LOCK_SECVIO_LCK	0x00000040
+#define HP_LOCK_GENP_LCK	0x00000020
+#define HP_LOCK_MONOCTR_LCK	0x00000010
+#define HP_LOCK_CALIB_LCK	0x00000008
+#define HP_LOCK_SRTC_LCK	0x00000004
+#define HP_LOCK_ZMK_RD_LCK	0x00000002
+#define HP_LOCK_ZMK_WT_LCK	0x00000001
+
+#define HP_CMD_NONPRIV_AXS	0x80000000
+#define HP_CMD_HAC_STOP		0x00080000
+#define HP_CMD_HAC_CLEAR	0x00040000
+#define HP_CMD_HAC_LOAD		0x00020000
+#define HP_CMD_HAC_CFG_EN	0x00010000
+#define HP_CMD_SNVS_MSTR_KEY	0x00002000
+#define HP_CMD_PROG_ZMK		0x00001000
+#define HP_CMD_SW_LPSV		0x00000400
+#define HP_CMD_SW_FSV		0x00000200
+#define HP_CMD_SW_SV		0x00000100
+#define HP_CMD_LP_SWR_DIS	0x00000020
+#define HP_CMD_LP_SWR		0x00000010
+#define HP_CMD_SSM_SFNS_DIS	0x00000004
+#define HP_CMD_SSM_ST_DIS	0x00000002
+#define HP_CMD_SMM_ST		0x00000001
+
+#define HP_CTL_TIME_SYNC	0x00010000
+#define HP_CTL_CAL_VAL_SHIFT	10
+#define HP_CTL_CAL_VAL_MASK	(0x1f << HP_CTL_CALIB_SHIFT)
+#define HP_CTL_CALIB_EN		0x00000100
+#define HP_CTL_PI_FREQ_SHIFT	4
+#define HP_CTL_PI_FREQ_MASK	(0xf << HP_CTL_PI_FREQ_SHIFT)
+#define HP_CTL_PI_EN		0x00000008
+#define HP_CTL_TIMEALARM_EN	0x00000002
+#define HP_CTL_RTC_EN		0x00000001
+
+#define HP_SECVIO_INTEN_EN	0x10000000
+#define HP_SECVIO_INTEN_SRC5	0x00000020
+#define HP_SECVIO_INTEN_SRC4	0x00000010
+#define HP_SECVIO_INTEN_SRC3	0x00000008
+#define HP_SECVIO_INTEN_SRC2	0x00000004
+#define HP_SECVIO_INTEN_SRC1	0x00000002
+#define HP_SECVIO_INTEN_SRC0	0x00000001
+#define HP_SECVIO_INTEN_ALL	0x8000003f
+
+#define HP_SECVIO_ICTL_CFG_SHIFT	30
+#define HP_SECVIO_ICTL_CFG_MASK		(0x3 << HP_SECVIO_ICTL_CFG_SHIFT)
+#define HP_SECVIO_ICTL_CFG5_SHIFT	5
+#define HP_SECVIO_ICTL_CFG5_MASK	(0x3 << HP_SECVIO_ICTL_CFG5_SHIFT)
+#define HP_SECVIO_ICTL_CFG_DISABLE	0
+#define HP_SECVIO_ICTL_CFG_NONFATAL	1
+#define HP_SECVIO_ICTL_CFG_FATAL	2
+#define HP_SECVIO_ICTL_CFG4_FATAL	0x00000010
+#define HP_SECVIO_ICTL_CFG3_FATAL	0x00000008
+#define HP_SECVIO_ICTL_CFG2_FATAL	0x00000004
+#define HP_SECVIO_ICTL_CFG1_FATAL	0x00000002
+#define HP_SECVIO_ICTL_CFG0_FATAL	0x00000001
+
+#define HP_STATUS_ZMK_ZERO		0x80000000
+#define HP_STATUS_OTPMK_ZERO		0x08000000
+#define HP_STATUS_OTPMK_SYN_SHIFT	16
+#define HP_STATUS_OTPMK_SYN_MASK	(0x1ff << HP_STATUS_OTPMK_SYN_SHIFT)
+#define HP_STATUS_SSM_ST_SHIFT		8
+#define HP_STATUS_SSM_ST_MASK		(0xf << HP_STATUS_SSM_ST_SHIFT)
+#define HP_STATUS_SSM_ST_INIT		0
+#define HP_STATUS_SSM_ST_HARDFAIL	1
+#define HP_STATUS_SSM_ST_SOFTFAIL	3
+#define HP_STATUS_SSM_ST_INITINT	8
+#define HP_STATUS_SSM_ST_CHECK		9
+#define HP_STATUS_SSM_ST_NONSECURE	11
+#define HP_STATUS_SSM_ST_TRUSTED	13
+#define HP_STATUS_SSM_ST_SECURE		15
+
+#define HP_SECVIOST_ZMK_ECC_FAIL	0x08000000	/* write to clear */
+#define HP_SECVIOST_ZMK_SYN_SHIFT	16
+#define HP_SECVIOST_ZMK_SYN_MASK	(0x1ff << HP_SECVIOST_ZMK_SYN_SHIFT)
+#define HP_SECVIOST_SECVIO5		0x00000020
+#define HP_SECVIOST_SECVIO4		0x00000010
+#define HP_SECVIOST_SECVIO3		0x00000008
+#define HP_SECVIOST_SECVIO2		0x00000004
+#define HP_SECVIOST_SECVIO1		0x00000002
+#define HP_SECVIOST_SECVIO0		0x00000001
+#define HP_SECVIOST_SECVIOMASK		0x0000003f
+
+/*
+ * SNVS Low Power Domain
+ * Includes glitch detector, SRTC, alarm, monotonic counter, ZMK
+ */
+struct snvs_lp {
+	u32 lock;
+	u32 ctl;
+	u32 mstr_key_ctl;	/* Master Key Control */
+	u32 secvio_ctl;		/* Security Violation Control */
+	u32 tamper_filt_cfg;	/* Tamper Glitch Filters Configuration */
+	u32 tamper_det_cfg;	/* Tamper Detectors Configuration */
+	u32 status;
+	u32 srtc_msb;		/* Secure Real Time Clock/Counter MSB */
+	u32 srtc_lsb;		/* Secure Real Time Clock/Counter LSB */
+	u32 time_alarm;		/* Time Alarm */
+	u32 smc_msb;		/* Secure Monotonic Counter MSB */
+	u32 smc_lsb;		/* Secure Monotonic Counter LSB */
+	u32 pwr_glitch_det;	/* Power Glitch Detector */
+	u32 gen_purpose;
+	u32 zmk[8];		/* Zeroizable Master Key */
+};
+
+#define LP_LOCK_MKEYSEL_LCK	0x00000200
+#define LP_LOCK_TAMPDET_LCK	0x00000100
+#define LP_LOCK_TAMPFLT_LCK	0x00000080
+#define LP_LOCK_SECVIO_LCK	0x00000040
+#define LP_LOCK_GENP_LCK	0x00000020
+#define LP_LOCK_MONOCTR_LCK	0x00000010
+#define LP_LOCK_CALIB_LCK	0x00000008
+#define LP_LOCK_SRTC_LCK	0x00000004
+#define LP_LOCK_ZMK_RD_LCK	0x00000002
+#define LP_LOCK_ZMK_WT_LCK	0x00000001
+
+#define LP_CTL_CAL_VAL_SHIFT	10
+#define LP_CTL_CAL_VAL_MASK	(0x1f << LP_CTL_CAL_VAL_SHIFT)
+#define LP_CTL_CALIB_EN		0x00000100
+#define LP_CTL_SRTC_INVAL_EN	0x00000010
+#define LP_CTL_WAKE_INT_EN	0x00000008
+#define LP_CTL_MONOCTR_EN	0x00000004
+#define LP_CTL_TIMEALARM_EN	0x00000002
+#define LP_CTL_SRTC_EN		0x00000001
+
+#define LP_MKEYCTL_ZMKECC_SHIFT	8
+#define LP_MKEYCTL_ZMKECC_MASK	(0xff << LP_MKEYCTL_ZMKECC_SHIFT)
+#define LP_MKEYCTL_ZMKECC_EN	0x00000010
+#define LP_MKEYCTL_ZMKECC_VAL	0x00000008
+#define LP_MKEYCTL_ZMKECC_PROG	0x00000004
+#define LP_MKEYCTL_MKSEL_SHIFT	0
+#define LP_MKEYCTL_MKSEL_MASK	(3 << LP_MKEYCTL_MKSEL_SHIFT)
+#define LP_MKEYCTL_MK_OTP	0
+#define LP_MKEYCTL_MK_ZMK	2
+#define LP_MKEYCTL_MK_COMB	3
+
+#define LP_SECVIO_CTL_SRC5	0x20
+#define LP_SECVIO_CTL_SRC4	0x10
+#define LP_SECVIO_CTL_SRC3	0x08
+#define LP_SECVIO_CTL_SRC2	0x04
+#define LP_SECVIO_CTL_SRC1	0x02
+#define LP_SECVIO_CTL_SRC0	0x01
+
+#define LP_TAMPFILT_EXT2_EN	0x80000000
+#define LP_TAMPFILT_EXT2_SHIFT	24
+#define LP_TAMPFILT_EXT2_MASK	(0x1f << LP_TAMPFILT_EXT2_SHIFT)
+#define LP_TAMPFILT_EXT1_EN	0x00800000
+#define LP_TAMPFILT_EXT1_SHIFT	16
+#define LP_TAMPFILT_EXT1_MASK	(0x1f << LP_TAMPFILT_EXT1_SHIFT)
+#define LP_TAMPFILT_WM_EN	0x00000080
+#define LP_TAMPFILT_WM_SHIFT	0
+#define LP_TAMPFILT_WM_MASK	(0x1f << LP_TAMPFILT_WM_SHIFT)
+
+#define LP_TAMPDET_OSC_BPS	0x10000000
+#define LP_TAMPDET_VRC_SHIFT	24
+#define LP_TAMPDET_VRC_MASK	(3 << LP_TAMPFILT_VRC_SHIFT)
+#define LP_TAMPDET_HTDC_SHIFT	20
+#define LP_TAMPDET_HTDC_MASK	(3 << LP_TAMPFILT_HTDC_SHIFT)
+#define LP_TAMPDET_LTDC_SHIFT	16
+#define LP_TAMPDET_LTDC_MASK	(3 << LP_TAMPFILT_LTDC_SHIFT)
+#define LP_TAMPDET_POR_OBS	0x00008000
+#define LP_TAMPDET_PFD_OBS	0x00004000
+#define LP_TAMPDET_ET2_EN	0x00000400
+#define LP_TAMPDET_ET1_EN	0x00000200
+#define LP_TAMPDET_WMT2_EN	0x00000100
+#define LP_TAMPDET_WMT1_EN	0x00000080
+#define LP_TAMPDET_VT_EN	0x00000040
+#define LP_TAMPDET_TT_EN	0x00000020
+#define LP_TAMPDET_CT_EN	0x00000010
+#define LP_TAMPDET_MCR_EN	0x00000004
+#define LP_TAMPDET_SRTCR_EN	0x00000002
+
+#define LP_STATUS_SECURE
+#define LP_STATUS_NONSECURE
+#define LP_STATUS_SCANEXIT	0x00100000	/* all write 1 clear here on */
+#define LP_STATUS_EXT_SECVIO	0x00010000
+#define LP_STATUS_ET2		0x00000400
+#define LP_STATUS_ET1		0x00000200
+#define LP_STATUS_WMT2		0x00000100
+#define LP_STATUS_WMT1		0x00000080
+#define LP_STATUS_VTD		0x00000040
+#define LP_STATUS_TTD		0x00000020
+#define LP_STATUS_CTD		0x00000010
+#define LP_STATUS_PGD		0x00000008
+#define LP_STATUS_MCR		0x00000004
+#define LP_STATUS_SRTCR		0x00000002
+#define LP_STATUS_LPTA		0x00000001
+
+/* Full SNVS register page, including version/options */
+struct snvs_full {
+	struct snvs_hp hp;
+	struct snvs_lp lp;
+	u32 rsvd[731];		/* deadspace 0x08c-0xbf7 */
+
+	/* Version / Revision / Option ID space - end of register page */
+	u32 vid;		/* 0xbf8 HP Version ID (VID 1) */
+	u32 opt_rev;		/* 0xbfc HP Options / Revision (VID 2) */
+};
+
+#endif /* SNVSREGS_H */
diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index 4ac8319..81434d6 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -7,7 +7,7 @@
  *
  * Based on code from Freescale:
  *
- * Copyright 2004-2012 Freescale Semiconductor, Inc.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -33,11 +33,14 @@
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
 #include <linux/delay.h>
+#include <linux/genalloc.h>
 
 #include <asm/irq.h>
 #include <mach/sdma.h>
 #include <mach/dma.h>
 #include <mach/hardware.h>
+#include <mach/iram.h>
+
 
 /* SDMA registers */
 #define SDMA_H_C0PTR		0x000
@@ -266,6 +269,7 @@ struct sdma_channel {
 	unsigned int			pc_to_device;
 	unsigned int			device_to_device;
 	unsigned int			other_script;
+	unsigned int                    pc_to_pc;
 	enum sdma_mode			mode;
 	dma_addr_t			per_address, per_address2;
 	u32				event_mask0, event_mask1;
@@ -327,6 +331,7 @@ struct sdma_engine {
 	struct clk			*clk;
 	struct sdma_script_start_addrs	*script_addrs;
 	spinlock_t			irq_reg_lock;
+	spinlock_t			channel_0_lock;
 };
 
 #define SDMA_H_CONFIG_DSPDMA	(1 << 12) /* indicates if the DSPDMA is used */
@@ -334,6 +339,7 @@ struct sdma_engine {
 #define SDMA_H_CONFIG_ACR	(1 << 4)  /* indicates if AHB freq /core freq = 2 or 1 */
 #define SDMA_H_CONFIG_CSM	(3)       /* indicates which context switch mode is selected*/
 
+
 static inline u32 chnenbl_ofs(struct sdma_engine *sdma, unsigned int event)
 {
 	u32 chnenbl0 = (sdma->version == 2 ? SDMA_CHNENBL0_V2 : SDMA_CHNENBL0_V1);
@@ -384,14 +390,23 @@ static int sdma_run_channel(struct sdma_channel *sdmac)
 {
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
+	unsigned long timeout = 1000;
 	int ret;
 
-	init_completion(&sdmac->done);
+	writel(1 << channel, sdma->regs + SDMA_H_START);
 
-	wmb();
-	writel_relaxed(1 << channel, sdma->regs + SDMA_H_START);
+	while (!(ret = readl_relaxed(sdma->regs + SDMA_H_INTR) & 1)) {
+		if (timeout-- <= 0)
+			break;
+		udelay(1);
+	}
 
-	ret = wait_for_completion_timeout(&sdmac->done, HZ);
+	if (ret) {
+		/* Clear the interrupt status */
+		writel_relaxed(ret, sdma->regs + SDMA_H_INTR);
+	} else {
+		dev_err(sdma->dev, "Timeout waiting for CH0 ready\n");
+	}
 
 	return ret ? 0 : -ETIMEDOUT;
 }
@@ -402,14 +417,21 @@ static int sdma_load_script(struct sdma_engine *sdma, void *buf, int size,
 	struct sdma_buffer_descriptor *bd0 = sdma->channel[0].bd;
 	void *buf_virt;
 	dma_addr_t buf_phys;
+	unsigned long flags;
 	int ret;
 
+#ifdef CONFIG_SDMA_IRAM
+	buf_virt = iram_alloc(size, (unsigned long *)&buf_phys);
+#else
 	buf_virt = dma_alloc_coherent(NULL,
 			size,
 			&buf_phys, GFP_KERNEL);
+#endif
 	if (!buf_virt)
 		return -ENOMEM;
 
+	spin_lock_irqsave(&sdma->channel_0_lock, flags);
+
 	bd0->mode.command = C0_SETPM;
 	bd0->mode.status = BD_DONE | BD_INTR | BD_WRAP | BD_EXTD;
 	bd0->mode.count = size / 2;
@@ -420,7 +442,12 @@ static int sdma_load_script(struct sdma_engine *sdma, void *buf, int size,
 
 	ret = sdma_run_channel(&sdma->channel[0]);
 
+	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
+#ifdef CONFIG_SDMA_IRAM
+	iram_free(buf_phys, size);
+#else
 	dma_free_coherent(NULL, size, buf_virt, buf_phys);
+#endif
 
 	return ret;
 }
@@ -517,10 +544,6 @@ static void mxc_sdma_handle_channel(struct sdma_channel *sdmac)
 {
 	complete(&sdmac->done);
 
-	/* not interested in channel 0 interrupts */
-	if (sdmac->channel == 0)
-		return;
-
 	switch (sdmac->mode) {
 	case SDMA_MODE_LOOP:
 		sdma_handle_channel_loop(sdmac);
@@ -547,6 +570,8 @@ static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 
 	spin_lock_irqsave(&sdma->irq_reg_lock, flag);
 	stat = readl_relaxed(sdma->regs + SDMA_H_INTR);
+	/* not interested in channel 0 interrupts */
+	stat &= ~1;
 	writel_relaxed(stat, sdma->regs + SDMA_H_INTR);
 	spin_unlock_irqrestore(&sdma->irq_reg_lock, flag);
 
@@ -591,6 +616,7 @@ static void sdma_get_pc(struct sdma_channel *sdmac,
 	sdmac->pc_to_device = 0;
 	sdmac->device_to_device = 0;
 	sdmac->other_script = 0;
+	sdmac->pc_to_pc = 0;
 
 	switch (peripheral_type) {
 	case IMX_DMATYPE_MEMORY:
@@ -663,6 +689,7 @@ static void sdma_get_pc(struct sdma_channel *sdmac,
 	sdmac->pc_to_device = emi_2_per;
 	sdmac->device_to_device = per_2_per;
 	sdmac->other_script = other;
+	sdmac->pc_to_pc = emi_2_emi;
 }
 
 static int sdma_set_context_reg(struct sdma_channel *sdmac,
@@ -693,6 +720,7 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 	struct sdma_context_data *context = sdma->context;
 	struct sdma_buffer_descriptor *bd0 = sdma->channel[0].bd;
 	int ret;
+	unsigned long flags;
 
 
 	if (sdmac->direction == DMA_DEV_TO_MEM)
@@ -701,6 +729,8 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 		load_address = sdmac->device_to_device;
 	else if (sdmac->direction == DMA_MEM_TO_DEV)
 		load_address = sdmac->pc_to_device;
+	else if (sdmac->direction == DMA_MEM_TO_MEM)
+		load_address = sdmac->pc_to_pc;
 	else
 		load_address = sdmac->other_script;
 
@@ -715,6 +745,7 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 	dev_dbg(sdma->dev, "event_mask0 = 0x%08x\n", sdmac->event_mask0);
 	dev_dbg(sdma->dev, "event_mask1 = 0x%08x\n", sdmac->event_mask1);
 
+	spin_lock_irqsave(&sdma->channel_0_lock, flags);
 	memset(context, 0, sizeof(*context));
 	context->channel_state.pc = load_address;
 
@@ -731,6 +762,7 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 
 	ret = sdma_run_channel(&sdma->channel[0]);
 
+	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
 	return ret;
 }
 
@@ -877,7 +909,11 @@ static int sdma_request_channel(struct sdma_channel *sdmac)
 	int channel = sdmac->channel;
 	int ret = -EBUSY;
 
-	sdmac->bd = dma_alloc_coherent(NULL, PAGE_SIZE, &sdmac->bd_phys, GFP_KERNEL);
+#ifdef CONFIG_SDMA_IRAM
+	sdmac->bd = iram_alloc(PAGE_SIZE, (unsigned long *)&sdmac->bd_phys);
+#else
+	sdmac->bd = dma_alloc_noncached(NULL, PAGE_SIZE, &sdmac->bd_phys, GFP_KERNEL);
+#endif
 	if (!sdmac->bd) {
 		ret = -ENOMEM;
 		goto out;
@@ -1040,8 +1076,11 @@ static void sdma_free_chan_resources(struct dma_chan *chan)
 
 	sdma_set_channel_priority(sdmac, 0);
 
+#ifdef CONFIG_SDMA_IRAM
+	iram_free(sdmac->bd_phys, PAGE_SIZE);
+#else
 	dma_free_coherent(NULL, PAGE_SIZE, sdmac->bd, sdmac->bd_phys);
-
+#endif
 	clk_disable(sdma->clk);
 }
 
@@ -1056,8 +1095,20 @@ static struct dma_async_tx_descriptor *sdma_prep_slave_sg(
 	int channel = sdmac->channel;
 	struct scatterlist *sg;
 
-	if (sdmac->status == DMA_IN_PROGRESS)
-		return NULL;
+	/*
+	 * For SDMA M2M use, we need 2 scatterlists, the src addresses are
+	 * stored in the first sg, and the dst addresses are stored in the
+	 * second sg. In the former code, when the first sg entered 'sdma_
+	 * prep_slave_sg', 'sdmac->status' would be set to 'DMA_IN_PROGRESS',
+	 * and the second sg would return 'NULL' when entered 'sdma_prep_slave
+	 * _sg'. To avoid this error, in the code, we check if for M2M use,
+	 * the second sg will not return 'NULL' when enters 'sdma_prep_slave
+	 * _sg'.
+	 */
+	if (!((direction == DMA_MEM_TO_MEM) && (flags == 0))) {
+		if (sdmac->status == DMA_IN_PROGRESS)
+			return NULL;
+	}
 	sdmac->status = DMA_IN_PROGRESS;
 
 	sdmac->mode = SDMA_MODE_NORMAL;
@@ -1082,6 +1133,12 @@ static struct dma_async_tx_descriptor *sdma_prep_slave_sg(
 		struct sdma_buffer_descriptor *bd = &sdmac->bd[i];
 		int param;
 
+		if (sdmac->direction == DMA_MEM_TO_MEM) {
+			if (flags == 1)
+				bd->buffer_addr = sg->dma_address;
+			if (flags == 0)
+				bd->ext_buffer_addr = sg->dma_address;
+		} else
 		bd->buffer_addr = sg->dma_address;
 
 		count = sg->length;
@@ -1268,6 +1325,8 @@ static int sdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 			sdmac->per_address = dmaengine_cfg->dst_addr;
 			sdmac->watermark_level = dmaengine_cfg->dst_maxburst;
 			sdmac->word_size = dmaengine_cfg->dst_addr_width;
+		} else if (dmaengine_cfg->direction == DMA_MEM_TO_MEM) {
+			sdmac->word_size = dmaengine_cfg->dst_addr_width;
 		}
 		sdmac->direction = dmaengine_cfg->direction;
 		return sdma_config_channel(sdmac);
@@ -1300,6 +1359,22 @@ static void sdma_issue_pending(struct dma_chan *chan)
 	 */
 }
 
+void sdma_set_event_pending(struct dma_chan *chan)
+{
+	struct sdma_channel *sdmac = to_sdma_chan(chan);
+	struct sdma_engine *sdma = sdmac->sdma;
+	u32 reg;
+	u32 channel;
+
+	channel = sdmac->channel;
+	reg = readl_relaxed(sdma->regs + SDMA_H_EVTPEND);
+	reg |= 1 << channel;
+	writel_relaxed(reg, sdma->regs + SDMA_H_EVTPEND);
+
+	return;
+}
+EXPORT_SYMBOL(sdma_set_event_pending);
+
 #define SDMA_SCRIPT_ADDRS_ARRAY_SIZE_V1	38
 
 static void sdma_add_scripts(struct sdma_engine *sdma,
@@ -1389,10 +1464,17 @@ static int __init sdma_init(struct sdma_engine *sdma)
 	/* Be sure SDMA has not started yet */
 	writel_relaxed(0, sdma->regs + SDMA_H_C0PTR);
 
+#ifdef CONFIG_SDMA_IRAM
+	sdma->channel_control = iram_alloc(MAX_DMA_CHANNELS *
+			sizeof(struct sdma_channel_control)
+			+ sizeof(struct sdma_context_data),
+			(unsigned long *)&ccb_phys);
+#else
 	sdma->channel_control = dma_alloc_coherent(NULL,
 			MAX_DMA_CHANNELS * sizeof (struct sdma_channel_control) +
 			sizeof(struct sdma_context_data),
 			&ccb_phys, GFP_KERNEL);
+#endif
 
 	if (!sdma->channel_control) {
 		ret = -ENOMEM;
@@ -1418,7 +1500,7 @@ static int __init sdma_init(struct sdma_engine *sdma)
 
 	ret = sdma_request_channel(&sdma->channel[0]);
 	if (ret)
-		goto err_dma_alloc;
+		goto err_dma_request;
 
 	sdma_config_ownership(&sdma->channel[0], false, true, false);
 
@@ -1441,6 +1523,12 @@ static int __init sdma_init(struct sdma_engine *sdma)
 
 	return 0;
 
+err_dma_request:
+#ifdef CONFIG_SDMA_IRAM
+	iram_free((unsigned long)ccb_phys, MAX_DMA_CHANNELS
+			* sizeof(struct sdma_channel_control)
+			+ sizeof(struct sdma_context_data));
+#endif
 err_dma_alloc:
 	clk_disable(sdma->clk);
 	dev_err(sdma->dev, "initialisation failed with %d\n", ret);
@@ -1460,6 +1548,8 @@ static int __init sdma_probe(struct platform_device *pdev)
 	if (!sdma)
 		return -ENOMEM;
 
+	spin_lock_init(&sdma->channel_0_lock);
+
 	sdma->dev = &pdev->dev;
 
 	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index c609877..7169b44 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index d2f5809..11dde5f 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/vivante/Makefile b/drivers/gpu/drm/vivante/Makefile
index 7ebc0e5..d87c8e8 100644
--- a/drivers/gpu/drm/vivante/Makefile
+++ b/drivers/gpu/drm/vivante/Makefile
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/vivante/vivante_drv.c b/drivers/gpu/drm/vivante/vivante_drv.c
index 8aa5d07..4224608 100644
--- a/drivers/gpu/drm/vivante/vivante_drv.c
+++ b/drivers/gpu/drm/vivante/vivante_drv.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/vivante/vivante_drv.h b/drivers/gpu/drm/vivante/vivante_drv.h
index 83588bf..03f5884 100644
--- a/drivers/gpu/drm/vivante/vivante_drv.h
+++ b/drivers/gpu/drm/vivante/vivante_drv.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index df9fca3..8cec196 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -96,7 +96,7 @@
  * Duplicated divider values removed from list
  */
 
-static u16 __initdata i2c_clk_div[50][2] = {
+static u16 i2c_clk_div[50][2] = {
 	{ 22,	0x20 }, { 24,	0x21 }, { 26,	0x22 }, { 28,	0x23 },
 	{ 30,	0x00 },	{ 32,	0x24 }, { 36,	0x25 }, { 40,	0x26 },
 	{ 42,	0x03 }, { 44,	0x27 },	{ 48,	0x28 }, { 52,	0x05 },
@@ -123,6 +123,7 @@ struct imx_i2c_struct {
 	unsigned int 		disable_delay;
 	int			stopped;
 	unsigned int		ifdr; /* IMX_I2C_IFDR */
+	unsigned int		cur_clk;
 };
 
 /** Functions for IMX I2C adapter driver ***************************************
@@ -181,13 +182,68 @@ static int i2c_imx_acked(struct imx_i2c_struct *i2c_imx)
 	return 0;
 }
 
+static void i2c_imx_set_clk(struct imx_i2c_struct *i2c_imx,
+							unsigned int rate)
+{
+	unsigned int i2c_clk_rate;
+	unsigned int div;
+	int i;
+
+	/* Divider value calculation */
+	i2c_clk_rate = clk_get_rate(i2c_imx->clk);
+	if (i2c_imx->cur_clk == i2c_clk_rate)
+		return;
+	else
+		i2c_imx->cur_clk = i2c_clk_rate;
+	div = (i2c_clk_rate + rate - 1) / rate;
+	if (div < i2c_clk_div[0][0])
+		i = 0;
+	else if (div > i2c_clk_div[ARRAY_SIZE(i2c_clk_div) - 1][0])
+		i = ARRAY_SIZE(i2c_clk_div) - 1;
+	else
+		for (i = 0; i2c_clk_div[i][0] < div; i++)
+			;
+
+	/* Store divider value */
+	i2c_imx->ifdr = i2c_clk_div[i][1];
+
+	/*
+	 * There dummy delay is calculated.
+	 * It should be about one I2C clock period long.
+	 * This delay is used in I2C bus disable function
+	 * to fix chip hardware bug.
+	 */
+	i2c_imx->disable_delay = (500000U * i2c_clk_div[i][0]
+		+ (i2c_clk_rate / 2) - 1) / (i2c_clk_rate / 2);
+
+	/* dev_dbg() can't be used, because adapter is not yet registered */
+#ifdef CONFIG_I2C_DEBUG_BUS
+	printk(KERN_DEBUG "I2C: <%s> I2C_CLK=%d, REQ DIV=%d\n",
+		__func__, i2c_clk_rate, div);
+	printk(KERN_DEBUG "I2C: <%s> IFDR[IC]=0x%x, REAL DIV=%d\n",
+		__func__, i2c_clk_div[i][1], i2c_clk_div[i][0]);
+#endif
+}
+
 static int i2c_imx_start(struct imx_i2c_struct *i2c_imx)
 {
 	unsigned int temp = 0;
+	struct imxi2c_platform_data *pdata;
 	int result;
 
 	dev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);
 
+	/* Currently on Arik/Rigel, the I2C clk is from IPG_PERCLK which is
+	 * sourced from IPG_CLK. In low bus freq mode, IPG_CLK is at 12MHz
+	 * and IPG_PERCLK is down to 4MHz.
+	 * Update I2C divider before set i2c clock.
+	 */
+	pdata = i2c_imx->adapter.dev.parent->platform_data;
+	if (pdata && pdata->bitrate)
+		i2c_imx_set_clk(i2c_imx, pdata->bitrate);
+	else
+		i2c_imx_set_clk(i2c_imx, IMX_I2C_BIT_RATE);
+
 	clk_enable(i2c_imx->clk);
 	writeb(i2c_imx->ifdr, i2c_imx->base + IMX_I2C_IFDR);
 	/* Enable I2C controller */
@@ -240,44 +296,6 @@ static void i2c_imx_stop(struct imx_i2c_struct *i2c_imx)
 	clk_disable(i2c_imx->clk);
 }
 
-static void __init i2c_imx_set_clk(struct imx_i2c_struct *i2c_imx,
-							unsigned int rate)
-{
-	unsigned int i2c_clk_rate;
-	unsigned int div;
-	int i;
-
-	/* Divider value calculation */
-	i2c_clk_rate = clk_get_rate(i2c_imx->clk);
-	div = (i2c_clk_rate + rate - 1) / rate;
-	if (div < i2c_clk_div[0][0])
-		i = 0;
-	else if (div > i2c_clk_div[ARRAY_SIZE(i2c_clk_div) - 1][0])
-		i = ARRAY_SIZE(i2c_clk_div) - 1;
-	else
-		for (i = 0; i2c_clk_div[i][0] < div; i++);
-
-	/* Store divider value */
-	i2c_imx->ifdr = i2c_clk_div[i][1];
-
-	/*
-	 * There dummy delay is calculated.
-	 * It should be about one I2C clock period long.
-	 * This delay is used in I2C bus disable function
-	 * to fix chip hardware bug.
-	 */
-	i2c_imx->disable_delay = (500000U * i2c_clk_div[i][0]
-		+ (i2c_clk_rate / 2) - 1) / (i2c_clk_rate / 2);
-
-	/* dev_dbg() can't be used, because adapter is not yet registered */
-#ifdef CONFIG_I2C_DEBUG_BUS
-	printk(KERN_DEBUG "I2C: <%s> I2C_CLK=%d, REQ DIV=%d\n",
-		__func__, i2c_clk_rate, div);
-	printk(KERN_DEBUG "I2C: <%s> IFDR[IC]=0x%x, REAL DIV=%d\n",
-		__func__, i2c_clk_div[i][1], i2c_clk_div[i][0]);
-#endif
-}
-
 static irqreturn_t i2c_imx_isr(int irq, void *dev_id)
 {
 	struct imx_i2c_struct *i2c_imx = dev_id;
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 7cf975a..3420cdb 100755
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -199,6 +199,16 @@ config TOUCHSCREEN_ELAN
 	  To compile this driver as a module, choose M here: the
 	  module will be called elan-touch.
 
+config TOUCHSCREEN_EGALAX_SINGLE_TOUCH
+	bool "EETI eGalax touchscreen as single-touch"
+	default N
+	depends on TOUCHSCREEN_EGALAX
+	help
+	  If you say yes here you get single-touch touchscreen support
+	  on the eGalax I2C controller.
+	  If you say "no", you'll get the normal multi-touch.
+
+
 config TOUCHSCREEN_FUJITSU
 	tristate "Fujitsu serial touchscreen"
 	select SERIO
@@ -662,6 +672,19 @@ config TOUCHSCREEN_USB_NEXIO
 	bool "NEXIO/iNexio device support" if EXPERT
 	depends on TOUCHSCREEN_USB_COMPOSITE
 
+config TOUCHSCREEN_NOVATEK
+       tristate "NOVATEK touchscreens"
+       depends on I2C
+       help
+         Say Y here if you have a Novatek NT11003 Touchscreen
+	 controller.
+
+	 If unsure, say N.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called novatek_ts
+
+
 config TOUCHSCREEN_TOUCHIT213
 	tristate "Sahara TouchIT-213 touchscreen"
 	select SERIO
@@ -748,7 +771,6 @@ config TOUCHSCREEN_P1003
 	 To compile this driver as a module, choose M here: the
 	 module will be called p1003-ts.
 
-
 config TOUCHSCREEN_TPS6507X
 	tristate "TPS6507x based touchscreens"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index e614512..94a71c1 100755
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -63,5 +63,6 @@ obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_P1003)		+= p1003_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_MAX11801)	+= max11801_ts.o
+obj-$(CONFIG_TOUCHSCREEN_NOVATEK)	+= novatek_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ELAN)		+= elan_ts.o
diff --git a/drivers/input/touchscreen/egalax_ts.c b/drivers/input/touchscreen/egalax_ts.c
index fff8afe..0b6cde7 100644
--- a/drivers/input/touchscreen/egalax_ts.c
+++ b/drivers/input/touchscreen/egalax_ts.c
@@ -139,7 +139,7 @@ retry:
 		events[id].x = x;
 		events[id].y = y;
 
-#ifdef FORCE_SINGLE_POINTER_SUPPORT
+#ifdef CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH
 		input_report_abs(input_dev, ABS_X, x);
 		input_report_abs(input_dev, ABS_Y, y);
 		input_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);
@@ -166,7 +166,7 @@ retry:
 		dev_dbg(&client->dev, "release id:%d\n", id);
 		events[id].valid = 0;
 		events[id].status = 0;
-#ifdef FORCE_SINGLE_POINTER_SUPPORT
+#ifdef CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH
 		input_report_key(input_dev, BTN_TOUCH, 0);
 		input_report_abs(input_dev, ABS_PRESSURE, 0);
 #else
@@ -256,8 +256,9 @@ static int __devinit egalax_ts_probe(struct i2c_client *client,
 	__set_bit(ABS_PRESSURE, input_dev->absbit);
 	input_set_abs_params(input_dev, ABS_X, 0, 32767, 0, 0);
 	input_set_abs_params(input_dev, ABS_Y, 0, 32767, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);
 
-#ifndef FORCE_SINGLE_POINTER_SUPPORT
+#ifndef CONFIG_TOUCHSCREEN_EGALAX_SINGLE_TOUCH
 	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, 32767, 0, 0);
 	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, 32767, 0, 0);
 	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
diff --git a/drivers/input/touchscreen/novatek_ts.c b/drivers/input/touchscreen/novatek_ts.c
new file mode 100644
index 0000000..84b1024
--- /dev/null
+++ b/drivers/input/touchscreen/novatek_ts.c
@@ -0,0 +1,407 @@
+/*
+ * Driver for Novatek NT11003 Multiple Touch Controller
+ *
+ * Copyright (C) 2012 Novatek Ltd.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/i2c/novatek_ts.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#define NOVATEK_I2C_NAME	"novatek-ts"
+#define MAX_SUPPORT_POINTS	5
+#define FINGER_EVENT_LEN	6
+
+#define NOVATEK_MAX_X		1280
+#define NOVATEK_MAX_Y		800
+#define NT_QUIRK_ID		((0xFF >> 3) - 1)
+
+struct tp_event {
+	u16 x;
+	u16 y;
+	s16 id;
+	u16 pressure;
+	u8 status;
+};
+
+struct novatek_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	u8 fingers[MAX_SUPPORT_POINTS];
+	uint16_t abs_x_max;
+	uint16_t abs_y_max;
+	uint8_t max_touch_num;
+};
+
+static struct i2c_client *this_client;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend novatek_power;
+static void novatek_suspend_early(struct early_suspend *h);
+static void novatek_resume_early(struct early_suspend *h);
+#endif
+
+#define FINGER_STATUS_MASK 0x3;
+enum {
+	FINGER_DOWN = 1,
+	FINGER_MOVE,
+	FINGER_UP,
+};
+
+static int novatek_init_panel(struct novatek_ts_data *ts)
+{
+	ts->abs_x_max = NOVATEK_MAX_X;
+	ts->abs_y_max = NOVATEK_MAX_Y;
+	ts->max_touch_num = MAX_SUPPORT_POINTS;
+
+	return 0;
+}
+
+static void parser_finger_events(u8 *buf, struct tp_event *event)
+{
+	event->id = (buf[0] >> 3) - 1;
+	event->status = buf[0] & FINGER_STATUS_MASK;
+	event->x = (buf[1] << 4) | ((buf[3] & 0xf0) >> 4);
+	event->y = (buf[2] << 4) | (buf[3] & 0xf);
+	event->pressure = buf[5];
+}
+
+static int novatek_ts_chipid(struct i2c_client *client)
+{
+	struct novatek_ts_data *ts = i2c_get_clientdata(client);
+	u8 id_data[] = { 0xff, 0xf0, 0x00 };
+	int ret;
+
+	ret = i2c_master_send(ts->client, id_data, ARRAY_SIZE(id_data));
+
+	if (ret < 0)
+		return -ret;
+
+	return i2c_smbus_read_byte_data(ts->client, 0);
+}
+
+static irqreturn_t novatek_ts_threaded_irq_handler(int irq, void *dev_id)
+{
+	struct novatek_ts_data *ts = dev_id;
+	struct i2c_client *client = ts->client;
+	struct input_dev *input_dev = ts->input_dev;
+	u8 buffer[MAX_SUPPORT_POINTS * FINGER_EVENT_LEN];
+	struct tp_event event;
+	bool down;
+	int ret;
+	int i;
+
+	memset(buffer, 0, ARRAY_SIZE(buffer));
+	ret = i2c_smbus_read_i2c_block_data(client, 0,
+					ARRAY_SIZE(buffer), buffer);
+
+	dev_vdbg(&client->dev, "------------------------\n");
+	for (i = 0; i < ARRAY_SIZE(buffer); i++)
+		dev_vdbg(&client->dev, "reg:%d val:0x%X\n", i, buffer[i]);
+
+	for (i = 0; i < MAX_SUPPORT_POINTS; i++) {
+		memset(&event, 0, sizeof(event));
+		parser_finger_events(&buffer[i * FINGER_EVENT_LEN], &event);
+
+		/* workaround FW sometime report touch up is not
+		 * corrent, but report all 0xFF package, so it lost
+		 * track of ID, so workaround by add a touch ID by the
+		 * parser id. */
+		if (ts->fingers[i] == FINGER_MOVE && event.status == FINGER_UP
+		    && event.id == NT_QUIRK_ID)
+			event.id = i;
+
+		if (event.status == 0)
+			continue;
+
+		/* ignore the event already up. */
+		if (event.status == FINGER_UP && ts->fingers[i] == FINGER_UP)
+			continue;
+
+		input_mt_slot(input_dev, event.id);
+
+		down = (event.status == FINGER_UP) ? false : true;
+
+		dev_dbg(&client->dev,
+			"id: %d status:%d x:%d  y:%d pressure:%d down:%d\n",
+			event.id, event.status, event.x, event.y,
+			event.pressure, down);
+
+		ts->fingers[i] = event.status;
+
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, down);
+
+		if (down) {
+			input_report_abs(input_dev, ABS_MT_POSITION_X, event.x);
+			input_report_abs(input_dev, ABS_MT_POSITION_Y, event.y);
+			input_report_abs(input_dev, ABS_MT_PRESSURE,
+					event.pressure);
+		}
+
+		input_mt_report_pointer_emulation(input_dev, true);
+		input_sync(input_dev);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int novatek_gpio_reset_chip(struct i2c_client *client, int gpio)
+{
+	int ret;
+	ret = gpio_request(gpio, "novatek reset");
+	if (ret) {
+		dev_err(&client->dev, "failed to request reset gpio.\n");
+		return ret;
+	}
+
+	gpio_direction_output(gpio, 1);
+	udelay(1);
+	gpio_set_value(gpio, 0);
+	msleep(25);
+	gpio_set_value(gpio, 1);
+
+	gpio_free(gpio);
+
+	/* This chip needs time after reset pin. Otherwise, the i2c
+	 * command will failed.*/
+	msleep(25);
+
+	return 0;
+}
+
+static int novatek_ts_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int ret = 0;
+	int chipid = 0;
+	int reset_gpio;
+	struct novatek_ts_data *ts;
+	struct novatek_platform_data *pdata;
+
+	pdata = client->dev.platform_data;
+	reset_gpio = pdata->reset_gpio;
+
+	if (reset_gpio > 0)
+		novatek_gpio_reset_chip(client, reset_gpio);
+	else
+		dev_warn(&client->dev,
+			"no reset gpio given, can not reset chip\n");
+
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	ret = novatek_init_panel(ts);
+	ts->client = this_client = client;
+	i2c_set_clientdata(client, ts);
+
+	chipid = novatek_ts_chipid(ts->client);
+	if (chipid < 0) {
+		dev_err(&client->dev, "read chip id failed: %d\n", chipid);
+		goto err_init_panel_fail;
+	} else
+		dev_info(&client->dev, "success read chip id:%x\n", chipid);
+
+	ret = request_threaded_irq(client->irq, NULL,
+				novatek_ts_threaded_irq_handler,
+				IRQF_TRIGGER_FALLING, "novatek_ts", ts);
+	if (ret != 0) {
+		dev_err(&client->dev, "request irq failed.\n");
+		goto err_irq_request_failed;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+	__set_bit(EV_KEY, ts->input_dev->evbit);
+	__set_bit(BTN_TOUCH, ts->input_dev->keybit);
+
+	input_set_abs_params(ts->input_dev, ABS_X, 0, ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, ts->abs_y_max, 0, 0);
+	input_set_abs_params(ts->input_dev,
+			     ABS_MT_POSITION_X, 0, ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev,
+			     ABS_MT_POSITION_Y, 0, ts->abs_y_max, 0, 0);
+	input_mt_init_slots(ts->input_dev, MAX_SUPPORT_POINTS);
+
+	input_set_drvdata(ts->input_dev, ts);
+
+	ts->input_dev->name = "Novatek NT11003 Touch Screen";
+	ts->input_dev->id.bustype = BUS_I2C;
+
+	ret = input_register_device(ts->input_dev);
+	if (ret != 0) {
+		dev_err(&client->dev,
+			"Probe: unable to register %s input device\n",
+			ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+
+	i2c_set_clientdata(client, ts);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	novatek_power.suspend = novatek_suspend_early;
+	novatek_power.resume = novatek_resume_early;
+	novatek_power.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	novatek_power.data  = &client->dev;
+	register_early_suspend(&novatek_power);
+#endif
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+err_input_dev_alloc_failed:
+	free_irq(client->irq, ts);
+err_irq_request_failed:
+err_init_panel_fail:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+	return ret;
+}
+
+static int novatek_ts_remove(struct i2c_client *client)
+{
+	struct novatek_ts_data *ts = i2c_get_clientdata(client);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&novatek_power);
+#endif
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
+	free_irq(client->irq, ts);
+	kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int novatek_suspend_resume_cmd(struct i2c_client *client, bool suspend)
+{
+	int ret;
+	uint8_t serial_mode_data[] = { 0xFF, 0x8F, 0xFF };
+	uint8_t resume_data[] = { 0x00, 0x00 };
+	uint8_t suspend_data[] = { 0x00, 0xAE };
+
+	ret = i2c_master_send(client, serial_mode_data,
+				ARRAY_SIZE(serial_mode_data));
+	if (ret < 0) {
+		dev_err(&client->dev, "i2c master send failed:%d\n", ret);
+		goto err;
+	}
+
+	if (suspend)
+		ret = i2c_master_send(client, suspend_data,
+				      ARRAY_SIZE(suspend_data));
+	else
+		ret = i2c_master_send(client, resume_data,
+				      ARRAY_SIZE(resume_data));
+
+	if (ret < 0) {
+		dev_err(&client->dev, "i2c master send failed:%d\n", ret);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return ret;
+}
+
+int novatek_ts_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	return novatek_suspend_resume_cmd(client, true);
+}
+
+int novatek_ts_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	return novatek_suspend_resume_cmd(client, false);
+}
+
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void novatek_suspend_early(struct early_suspend *h)
+{
+	struct device *dev = h->data;
+	novatek_ts_suspend(dev);
+}
+
+static void novatek_resume_early(struct early_suspend *h)
+{
+	struct device *dev = h->data;
+	novatek_ts_resume(dev);
+}
+#endif
+
+static const struct i2c_device_id novatek_ts_id[] = {
+	{NOVATEK_I2C_NAME, 0},
+	{}
+};
+
+static SIMPLE_DEV_PM_OPS(novatek_ts_pm_ops, novatek_ts_suspend, \
+			 novatek_ts_resume);
+static struct i2c_driver novatek_ts_driver = {
+	.driver = {
+		.name = NOVATEK_I2C_NAME,
+		.owner = THIS_MODULE,
+#if (defined CONFIG_PM) && !(defined CONFIG_HAS_EARLYSUSPEND)
+		.pm = &novatek_ts_pm_ops,
+#endif
+	},
+	.probe = novatek_ts_probe,
+	.remove = novatek_ts_remove,
+	.id_table = novatek_ts_id,
+
+};
+
+static int __devinit novatek_ts_init(void)
+{
+	return i2c_add_driver(&novatek_ts_driver);
+}
+
+static void __exit novatek_ts_exit(void)
+{
+	i2c_del_driver(&novatek_ts_driver);
+}
+
+module_init(novatek_ts_init);
+module_exit(novatek_ts_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Touchscreen driver for Novatek NT11003 touch controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index e0b1633..a872632 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -652,6 +652,7 @@ config VIDEO_MXS_PXP
 config VIDEO_MXC_PXP_V4L2
         tristate "MXC PxP V4L2 driver"
         depends on VIDEO_DEV && VIDEO_V4L2 && (ARCH_MX5 || SOC_IMX6SL)
+        select FB_MXC_ELCDIF_FB
         select VIDEOBUF_DMA_CONTIG
         ---help---
           This is a video4linux driver for the Freescale PxP
diff --git a/drivers/media/video/mxc/capture/Kconfig b/drivers/media/video/mxc/capture/Kconfig
index 243b888..a862636 100644
--- a/drivers/media/video/mxc/capture/Kconfig
+++ b/drivers/media/video/mxc/capture/Kconfig
@@ -26,11 +26,6 @@ config VIDEO_MXC_CSI_DMA
 	  with this method the CSC (Color Space Conversion) and resize are not supported.
 	  If unsure, say N.
 
-choice
-	prompt "Select Camera/TV Decoder"
-	default MXC_CAMERA_OV3640
-	depends on VIDEO_MXC_CAMERA
-
 config MXC_CAMERA_MC521DA
 	tristate "Magnachip mc521da camera support"
 	select I2C_MXC
@@ -105,7 +100,6 @@ config MXC_TVIN_ADV7180
 	---help---
 	  If you plan to use the adv7180 video decoder with your MXC system, say Y here.
 
-endchoice
 
 config MXC_CAMERA_OV5640_MIPI
 	tristate "OmniVision ov5640 camera support using mipi"
diff --git a/drivers/media/video/mxc/capture/adv7180.c b/drivers/media/video/mxc/capture/adv7180.c
index 2656afb..3c12fdc 100644
--- a/drivers/media/video/mxc/capture/adv7180.c
+++ b/drivers/media/video/mxc/capture/adv7180.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,16 +21,11 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
 #include <linux/types.h>
 #include <linux/delay.h>
-#include <linux/semaphore.h>
 #include <linux/device.h>
 #include <linux/i2c.h>
-#include <linux/wait.h>
 #include <linux/videodev2.h>
-#include <linux/workqueue.h>
 #include <linux/regulator/consumer.h>
 #include <linux/fsl_devices.h>
 #include <media/v4l2-chip-ident.h>
@@ -238,10 +233,6 @@ static void adv7180_get_std(v4l2_std_id *std)
 
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180_get_std\n");
 
-	/* Make sure power on */
-	if (tvin_plat->pwdn)
-		tvin_plat->pwdn(0);
-
 	/* Read the AD_RESULT to get the detect output video standard */
 	tmp = adv7180_read(ADV7180_STATUS_1) & 0x70;
 
@@ -332,13 +323,14 @@ static int ioctl_s_power(struct v4l2_int_device *s, int on)
 
 	if (on && !sensor->sen.on) {
 		gpio_sensor_active();
-
-		/* Make sure pwoer on */
-		if (tvin_plat->pwdn)
-			tvin_plat->pwdn(0);
-
-		if (adv7180_write_reg(ADV7180_PWR_MNG, 0) != 0)
+		if (adv7180_write_reg(ADV7180_PWR_MNG, 0x04) != 0)
 			return -EIO;
+
+		/*
+		 * FIXME:Additional 400ms to wait the chip to be stable?
+		 * This is a workaround for preview scrolling issue.
+		 */
+		msleep(400);
 	} else if (!on && sensor->sen.on) {
 		if (adv7180_write_reg(ADV7180_PWR_MNG, 0x24) != 0)
 			return -EIO;
@@ -503,10 +495,6 @@ static int ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
 
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180:ioctl_g_ctrl\n");
 
-	/* Make sure power on */
-	if (tvin_plat->pwdn)
-		tvin_plat->pwdn(0);
-
 	switch (vc->id) {
 	case V4L2_CID_BRIGHTNESS:
 		dev_dbg(&adv7180_data.sen.i2c_client->dev,
@@ -601,10 +589,6 @@ static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
 
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180:ioctl_s_ctrl\n");
 
-	/* Make sure power on */
-	if (tvin_plat->pwdn)
-		tvin_plat->pwdn(0);
-
 	switch (vc->id) {
 	case V4L2_CID_BRIGHTNESS:
 		dev_dbg(&adv7180_data.sen.i2c_client->dev,
@@ -680,6 +664,26 @@ static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
 }
 
 /*!
+ * ioctl_enum_framesizes - V4L2 sensor interface handler for
+ *			   VIDIOC_ENUM_FRAMESIZES ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fsize: standard V4L2 VIDIOC_ENUM_FRAMESIZES ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+				 struct v4l2_frmsizeenum *fsize)
+{
+	if (fsize->index >= 1)
+		return -EINVAL;
+
+	fsize->discrete.width = video_fmts[video_idx].active_width;
+	fsize->discrete.height  = video_fmts[video_idx].active_height;
+
+	return 0;
+}
+
+/*!
  * ioctl_g_chip_ident - V4L2 sensor interface handler for
  *			VIDIOC_DBG_G_CHIP_IDENT ioctl
  * @s: pointer to standard V4L2 device structure
@@ -768,6 +772,8 @@ static struct v4l2_int_ioctl_desc adv7180_ioctl_desc[] = {
 	{vidioc_int_queryctrl_num, (v4l2_int_ioctl_func*)ioctl_queryctrl},
 	{vidioc_int_g_ctrl_num, (v4l2_int_ioctl_func*)ioctl_g_ctrl},
 	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func*)ioctl_s_ctrl},
+	{vidioc_int_enum_framesizes_num,
+				(v4l2_int_ioctl_func *) ioctl_enum_framesizes},
 	{vidioc_int_g_chip_ident_num,
 				(v4l2_int_ioctl_func *)ioctl_g_chip_ident},
 };
@@ -1181,14 +1187,12 @@ static int adv7180_probe(struct i2c_client *client,
  */
 static int adv7180_detach(struct i2c_client *client)
 {
-	struct fsl_mxc_tvin_platform_data *plat_data = client->dev.platform_data;
-
 	dev_dbg(&adv7180_data.sen.i2c_client->dev,
 		"%s:Removing %s video decoder @ 0x%02X from adapter %s\n",
 		__func__, IF_NAME, client->addr << 1, client->adapter->name);
 
-	if (plat_data->pwdn)
-		plat_data->pwdn(1);
+	/* Power down via i2c */
+	adv7180_write_reg(ADV7180_PWR_MNG, 0x24);
 
 	if (dvddio_regulator) {
 		regulator_disable(dvddio_regulator);
diff --git a/drivers/media/video/mxc/capture/adv7280_mipi_tvin.c b/drivers/media/video/mxc/capture/adv7280_mipi_tvin.c
index d4e1d2d..06827ca 100644
--- a/drivers/media/video/mxc/capture/adv7280_mipi_tvin.c
+++ b/drivers/media/video/mxc/capture/adv7280_mipi_tvin.c
@@ -26,11 +26,14 @@
 #include <linux/types.h>
 #include <linux/device.h>
 #include <linux/i2c.h>
+#include <linux/err.h>
 #include <linux/delay.h>
 #include <linux/fsl_devices.h>
+#include <linux/regulator/consumer.h>
 
 #define ADV7280_SAMPLE_SILICON         0x40
 #define ADV7280_PROD_SILICON           0x41
+#define ADV7280_CSI_TX_ADDR            0x50
 /** ADV7280 register definitions */
 #define ADV7280_INPUT_CTL              0x00	/* Input Control */
 #define ADV7280_STATUS_1               0x10	/* Status #1 */
@@ -42,6 +45,7 @@
 #define ADV7280_SD_SATURATION_CR       0xe4	/* SD Saturation Cr */
 #define ADV7280_PM_REG                 0x0f /* Power Management */
 #define ADV7280_ADI_CONTROL1           0x0E /* ADI Control 1 */
+#define ADV7280_CSI_TX_SLAVE_ADDR      0xFE /* csi-tx slave address register */
 /* adv7280 power management reset bit */
 #define ADV7280_PM_RESET_BIT           0x80
 /** adv7280 input video masks */
@@ -51,10 +55,15 @@
 #define ADV7280_NTSC_MODE_BIT          0x00 /* NTSC mode bit    */
 #define ADV7280_NTSC_4_43_MODE_BIT     0x10 /* NTSC 4.43 mode bit*/
 /** adv7280 voltages */
-#define ADV7280_VOLTAGE_ANALOG         2800000
-#define ADV7280_VOLTAGE_DIGITAL_CORE   1500000
+#define ADV7280_VOLTAGE_ANALOG         1800000
+#define ADV7280_VOLTAGE_DIGITAL_CORE   3300000
 #define ADV7280_VOLTAGE_DIGITAL_IO     1800000
 
+static struct regulator *dvddio_regulator;
+static struct regulator *dvdd_regulator;
+static struct regulator *avdd_regulator;
+static struct regulator *pvdd_regulator;
+
 struct reg_value {
 	u8 reg;
 	u8 value;
@@ -62,9 +71,11 @@ struct reg_value {
 	u32 delay_ms;
 };
 
-struct adv7280_priv {
-	struct fsl_mxc_tvin_platform_data *pdata;
+struct adv7280_chipset {
+	struct device *dev;
 	struct i2c_client *client;
+	struct i2c_client *client_csi_tx;
+	struct fsl_mxc_tvin_platform_data *pdata;
 };
 
 /*!
@@ -86,22 +97,29 @@ static struct reg_value adv7280_init_params[] = {
 	{0x17, 0x41, 0x00, 0}, /* select SH1 */
 	{0x1D, 0x40, 0x00, 0}, /* enable LCC output driver */
 	{0x52, 0xC0, 0x00, 0}, /* ADI recommended*/
-	{0xFE, 0xA0, 0x00, 0}, /* set CSI-Tx slave address to 0xA0 */
+	{0xFE, 0xA2, 0x00, 0}, /* set CSI-Tx slave address to 0x51 */
 	{0x59, 0x15, 0x00, 0}, /* GPO control */
 };
 
+static struct reg_value adv7280_init_mipi_csi_top[] = {
+	{0xDE, 0x03, 0x00, 0x00}, /* dphy pwrdwn, Pwrdwn control DPHY_PWDN */
+	{0xDC, 0x30, 0x00, 0x00}, /* enable mipi data/clk lanes */
+	{0xD2, 0x00, 0x00, 0x00}, /* mipi data lane */
+	{0xD1, 0x00, 0x00, 0x00}, /* mipi clk lane */
+	{0x00, 0x00, 0x00, 0x00}, /* csi_tx_pwrdwn */
+};
+
 /*! Read one register from a ADV7280 i2c slave device.
  *  @param *reg     register in the device we wish to access.
  *  @return         0 if success, an error code otherwise.
  */
-static inline int adv7280_read_reg(struct adv7280_priv *adv7280, u8 reg)
+static inline int adv7280_read_reg(struct i2c_client *client, u8 reg)
 {
 	int ret;
 
-	ret = i2c_smbus_read_byte_data(adv7280->client, reg);
+	ret = i2c_smbus_read_byte_data(client, reg);
 	if (ret < 0) {
-		dev_dbg(&adv7280->client->dev, "%s:read reg error: reg=%2x\n",
-				__func__, reg);
+		dev_dbg(&client->dev, "read reg error: ret = %d\n", ret);
 	}
 
 	return ret;
@@ -111,15 +129,14 @@ static inline int adv7280_read_reg(struct adv7280_priv *adv7280, u8 reg)
  *  @param *reg     register in the device we wish to access.
  *  @return         0 if success, an error code otherwise.
  */
-static inline int adv7280_write_reg(struct adv7280_priv *adv7280,
+static inline int adv7280_write_reg(struct i2c_client *client,
 		u8 reg, u8 val)
 {
 	int ret;
 
-	ret = i2c_smbus_write_byte_data(adv7280->client, reg, val);
+	ret = i2c_smbus_write_byte_data(client, reg, val);
 	if (ret < 0) {
-		dev_dbg(&adv7280->client->dev, "%s:write reg error: reg=%2x\n",
-				__func__, reg);
+		dev_dbg(&client->dev, "write reg error: ret = %d", ret);
 	}
 
 	return ret;
@@ -127,14 +144,14 @@ static inline int adv7280_write_reg(struct adv7280_priv *adv7280,
 
 /*! Write ADV7280 config paramater array
  */
-static int adv7280_config(struct adv7280_priv *adv7280,
+static int adv7280_config(struct i2c_client *client,
 		struct reg_value *config, int size) {
 	int i, ret;
 
 	for (i = 0; i < size; i++) {
 		pr_debug("%s[%d]: reg = 0x%02x, value = 0x%02x\n", __func__,
 				i, config[i].reg,  config[i].value);
-		ret = adv7280_write_reg(adv7280, config[i].reg,
+		ret = adv7280_write_reg(client, config[i].reg,
 				config[i].value | config[i].mask);
 		if (ret < 0) {
 			pr_err("%s: write error %x\n", __func__, ret);
@@ -148,6 +165,162 @@ static int adv7280_config(struct adv7280_priv *adv7280,
 	return 0;
 }
 
+/*! Initial ADV7280 chipset configuration load recommended settings
+ */
+static int adv7280_default_config(struct adv7280_chipset *adv7280)
+{
+	int ret;
+	/* select main register map */
+	ret = adv7280_write_reg(adv7280->client, ADV7280_ADI_CONTROL1, 0x00);
+	if (ret < 0) {
+		pr_err("%s: write error, select memory map %x\n",
+				__func__, ret);
+		goto err;
+	}
+
+	/* perform a device reset */
+	ret = adv7280_write_reg(adv7280->client, ADV7280_PM_REG,
+			ADV7280_PM_RESET_BIT);
+	if (ret < 0) {
+		pr_err("%s: write error, reset %x\n", __func__, ret);
+		goto err;
+	}
+	/* Wait 5ms reset time spec */
+	msleep(5);
+
+	/* Initial device configuration */
+	ret = adv7280_config(adv7280->client, adv7280_init_params,
+			ARRAY_SIZE(adv7280_init_params));
+	if (ret < 0) {
+		pr_err("%s: config device error %x\n", __func__, ret);
+		goto err;
+	}
+
+	/* configure csi-tx slave address */
+	if (adv7280->pdata->csi_tx_addr) {
+		/* shit left to pass 8bit address instead of 7bit address*/
+		ret = adv7280_write_reg(adv7280->client,
+				ADV7280_CSI_TX_SLAVE_ADDR,
+				adv7280->pdata->csi_tx_addr << 1);
+		if (ret < 0)
+			goto err;
+	}
+
+	/* select csi top reg address space*/
+	ret = adv7280_write_reg(adv7280->client, ADV7280_ADI_CONTROL1, 0x40);
+	if (ret < 0)
+		goto err;
+
+	ret = adv7280_config(adv7280->client_csi_tx, adv7280_init_mipi_csi_top,
+			ARRAY_SIZE(adv7280_init_mipi_csi_top));
+	if (ret < 0) {
+		pr_err("%s: config device error csi_top %x\n", __func__, ret);
+		goto err;
+	}
+
+	return 0;
+err:
+	return ret;
+}
+
+static int adv7280_regulators_config(struct adv7280_chipset *adv7280)
+{
+	struct fsl_mxc_tvin_platform_data *pdata = adv7280->pdata;
+	int ret;
+
+	if (pdata->dvddio_reg) {
+		dvddio_regulator =
+			regulator_get(adv7280->dev, pdata->dvddio_reg);
+		if (!IS_ERR(dvddio_regulator)) {
+			ret = regulator_set_voltage(dvddio_regulator,
+					ADV7280_VOLTAGE_DIGITAL_CORE,
+					ADV7280_VOLTAGE_DIGITAL_CORE);
+			if (ret < 0)
+				goto dvddio_err;
+			ret = regulator_enable(dvddio_regulator);
+			if (ret != 0) {
+				pr_err("%s: dvddio_reg set voltage error\n",
+						__func__);
+				goto dvddio_err;
+			}
+		} else
+			dvddio_regulator = NULL;
+	}
+
+	if (pdata->dvdd_reg) {
+		dvdd_regulator = regulator_get(adv7280->dev, pdata->dvdd_reg);
+		if (!IS_ERR(dvdd_regulator)) {
+			ret = regulator_set_voltage(dvdd_regulator,
+					ADV7280_VOLTAGE_DIGITAL_IO,
+					ADV7280_VOLTAGE_DIGITAL_IO);
+			if (ret < 0)
+				goto dvdd_err;
+			ret = regulator_enable(dvdd_regulator);
+			if (ret != 0) {
+				pr_err("%s: dvdd_reg set voltage error\n",
+						__func__);
+				goto dvdd_err;
+			}
+		} else
+			dvdd_regulator = NULL;
+	}
+
+	if (pdata->avdd_reg) {
+		avdd_regulator = regulator_get(adv7280->dev, pdata->avdd_reg);
+		if (!IS_ERR(avdd_regulator)) {
+			ret = regulator_set_voltage(avdd_regulator,
+					ADV7280_VOLTAGE_ANALOG,
+					ADV7280_VOLTAGE_ANALOG);
+			if (ret < 0)
+				goto avdd_err;
+			ret = regulator_enable(avdd_regulator);
+			if (ret != 0) {
+				pr_err("%s: avdd_reg set voltage error\n",
+						__func__);
+				goto avdd_err;
+			}
+		} else
+			avdd_regulator = NULL;
+	}
+
+	if (pdata->pvdd_reg) {
+		pvdd_regulator = regulator_get(adv7280->dev, pdata->pvdd_reg);
+		if (!IS_ERR(pvdd_regulator)) {
+			ret = regulator_set_voltage(pvdd_regulator,
+					ADV7280_VOLTAGE_DIGITAL_IO,
+					ADV7280_VOLTAGE_DIGITAL_IO);
+			if (ret < 0)
+				goto pvdd_err;
+			ret = regulator_enable(pvdd_regulator);
+			if (ret != 0) {
+				pr_err("%s: pvdd_reg set voltage error\n",
+						__func__);
+				goto pvdd_err;
+			}
+		} else
+			pvdd_regulator = NULL;
+	}
+
+	return 0;
+
+pvdd_err:
+	if (avdd_regulator) {
+		regulator_disable(avdd_regulator);
+		regulator_put(avdd_regulator);
+	}
+avdd_err:
+	if (dvdd_regulator) {
+		regulator_disable(dvdd_regulator);
+		regulator_put(dvdd_regulator);
+	}
+dvdd_err:
+	if (dvddio_regulator) {
+		regulator_disable(dvddio_regulator);
+		regulator_put(dvddio_regulator);
+	}
+dvddio_err:
+	return ret;
+}
 /*!
  * ADV7280 I2C probe function.
  * Function set in i2c_driver struct.
@@ -160,17 +333,47 @@ static int adv7280_i2c_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	int ret;
-	struct adv7280_priv *adv7280;
+	u8 csi_addr;
+	struct adv7280_chipset *adv7280;
 
-	adv7280 = kzalloc(sizeof(struct adv7280_priv), GFP_KERNEL);
+	adv7280 = kzalloc(sizeof(struct adv7280_chipset), GFP_KERNEL);
 	if (!adv7280)
 		return -ENOMEM;
 
+	i2c_set_clientdata(client, adv7280);
+
+	adv7280->dev = &client->dev;
 	adv7280->client = client;
 	adv7280->pdata = client->dev.platform_data;
-	i2c_set_clientdata(client, adv7280);
 
-	ret = adv7280_read_reg(adv7280, ADV7280_IDENT);
+	if (adv7280->pdata->csi_tx_addr) {
+		csi_addr = adv7280->pdata->csi_tx_addr;
+		pr_debug("%s: csi_tx_addr = 0x%02x\n", __func__, csi_addr);
+	} else
+		csi_addr = ADV7280_CSI_TX_ADDR;
+	/* Attach a second dummy i2c_client for csi-top register access */
+	adv7280->client_csi_tx = i2c_new_dummy(client->adapter,
+								csi_addr);
+	if (!adv7280->client_csi_tx) {
+		ret = -ENOMEM;
+		goto client_csi_tx_err;
+	}
+
+	/* custom platform reset, powerup callbacks */
+	if (adv7280->pdata->io_init)
+		adv7280->pdata->io_init();
+
+	if (adv7280->pdata->reset)
+		adv7280->pdata->reset();
+
+	if (adv7280->pdata->pwdn)
+		adv7280->pdata->pwdn(0);
+	/* set regulators */
+	ret = adv7280_regulators_config(adv7280);
+	if (ret < 0)
+		goto err;
+
+	ret = adv7280_read_reg(adv7280->client, ADV7280_IDENT);
 	if (ret < 0) {
 		pr_err("%s: read id error %x\n", __func__, ret);
 		goto err;
@@ -183,42 +386,44 @@ static int adv7280_i2c_probe(struct i2c_client *client,
 	}
 
 	pr_info("%s: device found, rev_id 0x%02x\n", __func__, ret);
-	/* select main register map */
-	ret = adv7280_write_reg(adv7280, ADV7280_ADI_CONTROL1, 0x00);
-	if (ret < 0) {
-		pr_err("%s: write error, select memory map %x\n",
-				__func__, ret);
+	/* default configuration */
+	ret = adv7280_default_config(adv7280);
+	if (ret < 0)
 		goto err;
-	}
-
-	/* perform a device reset */
-	ret = adv7280_write_reg(adv7280, ADV7280_PM_REG,
-			ADV7280_PM_RESET_BIT);
-	if (ret < 0) {
-		pr_err("%s: write error, reset %x\n", __func__, ret);
-		goto err;
-	}
-	/* Wait 5ms reset time spec */
-	msleep(5);
-
-	/* Initial device configuration */
-	ret = adv7280_config(adv7280, adv7280_init_params,
-			ARRAY_SIZE(adv7280_init_params));
-	if (ret < 0) {
-		pr_err("%s: config device error %x\n", __func__, ret);
-		goto err;
-	}
 
 	return 0;
 err:
+	i2c_unregister_device(adv7280->client_csi_tx);
+client_csi_tx_err:
 	kfree(adv7280);
 	return ret;
 }
 
 static int adv7280_i2c_remove(struct i2c_client *i2c_client)
 {
-	struct adv7280_priv *adv7280 = i2c_get_clientdata(i2c_client);
+	struct adv7280_chipset *adv7280 = i2c_get_clientdata(i2c_client);
+
+	if (dvddio_regulator) {
+		regulator_disable(dvddio_regulator);
+		regulator_put(dvddio_regulator);
+	}
+
+	if (dvdd_regulator) {
+		regulator_disable(dvdd_regulator);
+		regulator_put(dvdd_regulator);
+	}
+
+	if (avdd_regulator) {
+		regulator_disable(avdd_regulator);
+		regulator_put(avdd_regulator);
+	}
+
+	if (pvdd_regulator) {
+		regulator_disable(pvdd_regulator);
+		regulator_put(pvdd_regulator);
+	}
 
+	i2c_unregister_device(adv7280->client_csi_tx);
 	kfree(adv7280);
 	return 0;
 }
diff --git a/drivers/media/video/mxc/capture/csi_v4l2_capture.c b/drivers/media/video/mxc/capture/csi_v4l2_capture.c
index 3756b00..68dda9b 100644
--- a/drivers/media/video/mxc/capture/csi_v4l2_capture.c
+++ b/drivers/media/video/mxc/capture/csi_v4l2_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -35,16 +35,20 @@
 #include <linux/dma-mapping.h>
 #include <media/v4l2-ioctl.h>
 #include <media/v4l2-int-device.h>
+#include <media/v4l2-chip-ident.h>
 #include <linux/mxcfb.h>
 #include "mxc_v4l2_capture.h"
 #include "fsl_csi.h"
 
 static int video_nr = -1;
 static cam_data *g_cam;
+static int req_buf_number;
 
 static int csi_v4l2_master_attach(struct v4l2_int_device *slave);
 static void csi_v4l2_master_detach(struct v4l2_int_device *slave);
 static u8 camera_power(cam_data *cam, bool cameraOn);
+struct v4l2_crop crop_current;
+struct v4l2_window win_current;
 
 /*! Information about this driver. */
 static struct v4l2_int_master csi_v4l2_master = {
@@ -61,6 +65,37 @@ static struct v4l2_int_device csi_v4l2_int_device = {
 	      },
 };
 
+static struct v4l2_queryctrl pxp_controls[] = {
+	{
+		.id 		= V4L2_CID_HFLIP,
+		.type 		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name 		= "Horizontal Flip",
+		.minimum 	= 0,
+		.maximum 	= 1,
+		.step 		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_VFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Vertical Flip",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_PRIVATE_BASE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotation",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags		= 0,
+	},
+};
+
 /* Callback function triggered after PxP receives an EOF interrupt */
 static void pxp_dma_done(void *arg)
 {
@@ -107,7 +142,7 @@ static int pxp_chan_init(cam_data *cam)
 
 /*
  * Function to call PxP DMA driver and send our new V4L2 buffer
- * through the PxP and PxP will process this buffer in place.
+ * through the PxP.
  * Note: This is a blocking call, so upon return the PxP tx should be complete.
  */
 static int pxp_process_update(cam_data *cam)
@@ -176,21 +211,41 @@ static int pxp_process_update(cam_data *cam)
 	proc_data->srect.width = pxp_conf->s0_param.width;
 	proc_data->srect.height = pxp_conf->s0_param.height;
 
-	proc_data->drect.top = 0;
+	if (crop_current.c.top != 0)
+		proc_data->srect.top = crop_current.c.top;
+	if (crop_current.c.left != 0)
+		proc_data->srect.left = crop_current.c.left;
+	if (crop_current.c.width != 0)
+		proc_data->srect.width = crop_current.c.width;
+	if (crop_current.c.height != 0)
+		proc_data->srect.height = crop_current.c.height;
+
 	proc_data->drect.left = 0;
+	proc_data->drect.top = 0;
 	proc_data->drect.width = proc_data->srect.width;
 	proc_data->drect.height = proc_data->srect.height;
-	proc_data->scaling = 0;
-	proc_data->hflip = 0;
-	proc_data->vflip = 0;
-	proc_data->rotate = 0;
-	proc_data->bgcolor = 0;
+
+	if (win_current.w.left != 0)
+		proc_data->drect.left = win_current.w.left;
+	if (win_current.w.top != 0)
+		proc_data->drect.top = win_current.w.top;
+	if (win_current.w.width != 0)
+		proc_data->drect.width = win_current.w.width;
+	if (win_current.w.height != 0)
+		proc_data->drect.height = win_current.w.height;
+
+	pr_debug("srect l: %d, t: %d, w: %d, h: %d; "
+		"drect l: %d, t: %d, w: %d, h: %d\n",
+		proc_data->srect.left, proc_data->srect.top,
+		proc_data->srect.width, proc_data->srect.height,
+		proc_data->drect.left, proc_data->drect.top,
+		proc_data->drect.width, proc_data->drect.height);
 
 	pxp_conf->out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
 	pxp_conf->out_param.width = proc_data->drect.width;
 	pxp_conf->out_param.height = proc_data->drect.height;
 
-	if (cam->rotation >= IPU_ROTATE_90_RIGHT)
+	if (cam->rotation % 180)
 		pxp_conf->out_param.stride = pxp_conf->out_param.height;
 	else
 		pxp_conf->out_param.stride = pxp_conf->out_param.width;
@@ -271,43 +326,48 @@ static void camera_callback(u32 mask, void *dev)
 	if (cam == NULL)
 		return;
 
-	if (list_empty(&cam->working_q)) {
-		pr_err("ERROR: v4l2 capture: %s: "
-				"working queue empty\n", __func__);
-		return;
-	}
+	spin_lock(&cam->queue_int_lock);
+	spin_lock(&cam->dqueue_int_lock);
+	if (!list_empty(&cam->working_q)) {
+		done_frame = list_entry(cam->working_q.next,
+				struct mxc_v4l_frame, queue);
+
+		if (done_frame->csi_buf_num != cam->ping_pong_csi)
+			goto next;
+
+		if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+			done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
+			done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
 
-	done_frame =
-		list_entry(cam->working_q.next, struct mxc_v4l_frame, queue);
-	if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
-		done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
-		done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
-		if (list_empty(&cam->ready_q)) {
-			cam->skip_frame++;
+			/* Added to the done queue */
+			list_del(cam->working_q.next);
+			list_add_tail(&done_frame->queue, &cam->done_q);
+			cam->enc_counter++;
+			wake_up_interruptible(&cam->enc_queue);
 		} else {
-			ready_frame = list_entry(cam->ready_q.next,
-						 struct mxc_v4l_frame, queue);
-			list_del(cam->ready_q.next);
-			list_add_tail(&ready_frame->queue, &cam->working_q);
-
-			if (cam->ping_pong_csi == 1) {
-				__raw_writel(cam->frame[ready_frame->index].
-					     paddress, CSI_CSIDMASA_FB1);
-			} else {
-				__raw_writel(cam->frame[ready_frame->index].
-					     paddress, CSI_CSIDMASA_FB2);
-			}
+			pr_err("ERROR: v4l2 capture: %s: "
+					"buffer not queued\n", __func__);
 		}
+	}
 
-		/* Added to the done queue */
-		list_del(cam->working_q.next);
-		list_add_tail(&done_frame->queue, &cam->done_q);
-		cam->enc_counter++;
-		wake_up_interruptible(&cam->enc_queue);
+next:
+	if (!list_empty(&cam->ready_q)) {
+		ready_frame = list_entry(cam->ready_q.next,
+					 struct mxc_v4l_frame, queue);
+		list_del(cam->ready_q.next);
+		list_add_tail(&ready_frame->queue, &cam->working_q);
+
+		__raw_writel(ready_frame->paddress,
+			cam->ping_pong_csi == 1 ? CSI_CSIDMASA_FB1 :
+						  CSI_CSIDMASA_FB2);
+		ready_frame->csi_buf_num = cam->ping_pong_csi;
 	} else {
-		pr_err("ERROR: v4l2 capture: %s: "
-				"buffer not queued\n", __func__);
+		__raw_writel(cam->dummy_frame.paddress,
+			cam->ping_pong_csi == 1 ? CSI_CSIDMASA_FB1 :
+						  CSI_CSIDMASA_FB2);
 	}
+	spin_unlock(&cam->dqueue_int_lock);
+	spin_unlock(&cam->queue_int_lock);
 
 	return;
 }
@@ -324,7 +384,7 @@ static int csi_cap_image(cam_data *cam)
 	unsigned int value;
 
 	value = __raw_readl(CSI_CSICR3);
-	__raw_writel(value | BIT_DMA_REFLASH_RFF | BIT_FRMCNT_RST, CSI_CSICR3);
+	__raw_writel(value | BIT_FRMCNT_RST, CSI_CSICR3);
 	value = __raw_readl(CSI_CSISR);
 	__raw_writel(value, CSI_CSISR);
 
@@ -357,6 +417,13 @@ static int csi_free_frame_buf(cam_data *cam)
 		}
 	}
 
+	if (cam->dummy_frame.vaddress != 0) {
+		dma_free_coherent(0, cam->dummy_frame.buffer.length,
+				  cam->dummy_frame.vaddress,
+				  cam->dummy_frame.paddress);
+		cam->dummy_frame.vaddress = 0;
+	}
+
 	return 0;
 }
 
@@ -391,11 +458,11 @@ static int csi_allocate_frame_buf(cam_data *cam, int count)
 		cam->frame[i].buffer.index = i;
 		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
 		cam->frame[i].buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cam->frame[i].buffer.length = PAGE_ALIGN(cam->v2f.fmt.
-							 pix.sizeimage);
+		cam->frame[i].buffer.length = cam->v2f.fmt.pix.sizeimage;
 		cam->frame[i].buffer.memory = V4L2_MEMORY_MMAP;
 		cam->frame[i].buffer.m.offset = cam->frame[i].paddress;
 		cam->frame[i].index = i;
+		cam->frame[i].csi_buf_num = 0;
 	}
 
 	return 0;
@@ -417,7 +484,7 @@ static void csi_free_frames(cam_data *cam)
 	for (i = 0; i < FRAME_NUM; i++)
 		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
 
-	cam->skip_frame = 0;
+	cam->enc_counter = 0;
 	INIT_LIST_HEAD(&cam->ready_q);
 	INIT_LIST_HEAD(&cam->working_q);
 	INIT_LIST_HEAD(&cam->done_q);
@@ -448,6 +515,36 @@ static int csi_v4l2_buffer_status(cam_data *cam, struct v4l2_buffer *buf)
 	return 0;
 }
 
+static int csi_v4l2_release_bufs(cam_data *cam)
+{
+	pr_debug("In MVC:csi_v4l2_release_bufs\n");
+	return 0;
+}
+
+static int csi_v4l2_prepare_bufs(cam_data *cam, struct v4l2_buffer *buf)
+{
+	pr_debug("In MVC:csi_v4l2_prepare_bufs\n");
+
+	if (buf->index < 0 || buf->index >= FRAME_NUM || buf->length <
+			cam->v2f.fmt.pix.sizeimage) {
+		pr_err("ERROR: v4l2 capture: csi_v4l2_prepare_bufs buffers "
+			"not allocated,index=%d, length=%d\n", buf->index,
+			buf->length);
+		return -EINVAL;
+	}
+
+	cam->frame[buf->index].buffer.index = buf->index;
+	cam->frame[buf->index].buffer.flags = V4L2_BUF_FLAG_MAPPED;
+	cam->frame[buf->index].buffer.length = buf->length;
+	cam->frame[buf->index].buffer.m.offset = cam->frame[buf->index].paddress
+		= buf->m.offset;
+	cam->frame[buf->index].buffer.type = buf->type;
+	cam->frame[buf->index].buffer.memory = V4L2_MEMORY_USERPTR;
+	cam->frame[buf->index].index = buf->index;
+
+	return 0;
+}
+
 /*!
  * Indicates whether the palette is supported.
  *
@@ -471,6 +568,9 @@ static inline int valid_mode(u32 palette)
 static int csi_streamon(cam_data *cam)
 {
 	struct mxc_v4l_frame *frame;
+	unsigned long flags;
+	unsigned long val;
+	int timeout, timeout2;
 
 	pr_debug("In MVC: %s\n", __func__);
 
@@ -479,32 +579,80 @@ static int csi_streamon(cam_data *cam)
 				__func__);
 		return -1;
 	}
+	cam->dummy_frame.vaddress = dma_alloc_coherent(0,
+			       PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage),
+			       &cam->dummy_frame.paddress,
+			       GFP_DMA | GFP_KERNEL);
+	if (cam->dummy_frame.vaddress == 0) {
+		pr_err("ERROR: v4l2 capture: Allocate dummy frame "
+		       "failed.\n");
+		return -ENOBUFS;
+	}
+	cam->dummy_frame.buffer.type = V4L2_BUF_TYPE_PRIVATE;
+	cam->dummy_frame.buffer.length = cam->v2f.fmt.pix.sizeimage;
+	cam->dummy_frame.buffer.m.offset = cam->dummy_frame.paddress;
 
+	spin_lock_irqsave(&cam->queue_int_lock, flags);
 	/* move the frame from readyq to workingq */
 	if (list_empty(&cam->ready_q)) {
 		pr_err("ERROR: v4l2 capture: %s: "
 				"ready_q queue empty\n", __func__);
+		spin_unlock_irqrestore(&cam->queue_int_lock, flags);
 		return -1;
 	}
 	frame = list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
 	list_del(cam->ready_q.next);
 	list_add_tail(&frame->queue, &cam->working_q);
-	__raw_writel(cam->frame[frame->index].paddress, CSI_CSIDMASA_FB1);
+	__raw_writel(frame->paddress, CSI_CSIDMASA_FB1);
+	frame->csi_buf_num = 1;
 
 	if (list_empty(&cam->ready_q)) {
 		pr_err("ERROR: v4l2 capture: %s: "
 				"ready_q queue empty\n", __func__);
+		spin_unlock_irqrestore(&cam->queue_int_lock, flags);
 		return -1;
 	}
 	frame = list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
 	list_del(cam->ready_q.next);
 	list_add_tail(&frame->queue, &cam->working_q);
-	__raw_writel(cam->frame[frame->index].paddress, CSI_CSIDMASA_FB2);
+	__raw_writel(frame->paddress, CSI_CSIDMASA_FB2);
+	frame->csi_buf_num = 2;
+	spin_unlock_irqrestore(&cam->queue_int_lock, flags);
 
 	cam->capture_pid = current->pid;
 	cam->capture_on = true;
 	csi_cap_image(cam);
-	csi_enable_int(1);
+
+	local_irq_save(flags);
+	for (timeout = 1000000; timeout > 0; timeout--) {
+		if (__raw_readl(CSI_CSISR) & BIT_SOF_INT) {
+			val = __raw_readl(CSI_CSICR3);
+			__raw_writel(val | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+			for (timeout2 = 1000000; timeout2 > 0; timeout2--) {
+				if (__raw_readl(CSI_CSICR3) &
+					BIT_DMA_REFLASH_RFF)
+					cpu_relax();
+				else
+					break;
+			}
+			if (timeout2 <= 0) {
+				pr_err("timeout when wait for reflash done.\n");
+				local_irq_restore(flags);
+				return -ETIME;
+			}
+
+			csi_dmareq_rff_enable();
+			csi_enable_int(1);
+			break;
+		} else
+			cpu_relax();
+	}
+	if (timeout <= 0) {
+		pr_err("timeout when wait for SOF\n");
+		local_irq_restore(flags);
+		return -ETIME;
+	}
+	local_irq_restore(flags);
 
 	return 0;
 }
@@ -518,21 +666,18 @@ static int csi_streamon(cam_data *cam)
  */
 static int csi_streamoff(cam_data *cam)
 {
-	unsigned int cr3;
-
 	pr_debug("In MVC: %s\n", __func__);
 
 	if (cam->capture_on == false)
 		return 0;
 
+	csi_dmareq_rff_disable();
 	csi_disable_int();
 	cam->capture_on = false;
 
 	/* set CSI_CSIDMASA_FB1 and CSI_CSIDMASA_FB2 to default value */
 	__raw_writel(0, CSI_CSIDMASA_FB1);
 	__raw_writel(0, CSI_CSIDMASA_FB2);
-	cr3 = __raw_readl(CSI_CSICR3);
-	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
 
 	csi_free_frames(cam);
 	csi_free_frame_buf(cam);
@@ -650,7 +795,7 @@ static int csi_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 			 * camera can change. */
 			pr_debug("csi_v4l2_s_fmt size changed\n");
 		}
-		if (cam->rotation >= IPU_ROTATE_90_RIGHT) {
+		if (cam->rotation % 180) {
 			height = &f->fmt.pix.width;
 			width = &f->fmt.pix.height;
 		} else {
@@ -732,6 +877,11 @@ static int csi_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 		pr_debug("   type=V4L2_BUF_TYPE_VIDEO_OVERLAY\n");
 		cam->win = f->fmt.win;
+		win_current = f->fmt.win;
+		size = win_current.w.width * win_current.w.height * 2;
+		if (cam->v2f.fmt.pix.sizeimage < size)
+			cam->v2f.fmt.pix.sizeimage = size;
+
 		break;
 	default:
 		retval = -EINVAL;
@@ -798,13 +948,53 @@ static int csi_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 
 	vidioc_int_g_ifparm(cam->sensor, &ifparm);
 	cam_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vidioc_int_g_fmt_cap(cam->sensor, &cam_fmt);
 	pr_debug("   g_fmt_cap returns widthxheight of input as %d x %d\n",
 		 cam_fmt.fmt.pix.width, cam_fmt.fmt.pix.height);
 
+	cam->crop_bounds.top = cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = cam_fmt.fmt.pix.width;
+	cam->crop_bounds.height = cam_fmt.fmt.pix.height;
+	cam->crop_current.width = cam->crop_bounds.width;
+	cam->crop_current.height = cam->crop_bounds.height;
+
 exit:
 	return err;
 }
 
+static int pxp_set_cstate(cam_data *cam, struct v4l2_control *vc)
+{
+	struct pxp_proc_data *proc_data = &cam->pxp_conf.proc_data;
+
+	if (vc->id == V4L2_CID_HFLIP) {
+		proc_data->hflip = vc->value;
+	} else if (vc->id == V4L2_CID_VFLIP) {
+		proc_data->vflip = vc->value;
+	} else if (vc->id == V4L2_CID_PRIVATE_BASE) {
+		if (vc->value % 90)
+			return -ERANGE;
+		proc_data->rotate = vc->value;
+		cam->rotation = vc->value;
+	}
+
+	return 0;
+}
+
+static int pxp_get_cstate(cam_data *cam, struct v4l2_control *vc)
+{
+	struct pxp_proc_data *proc_data = &cam->pxp_conf.proc_data;
+
+	if (vc->id == V4L2_CID_HFLIP)
+		vc->value = proc_data->hflip;
+	else if (vc->id == V4L2_CID_VFLIP)
+		vc->value = proc_data->vflip;
+	else if (vc->id == V4L2_CID_PRIVATE_BASE)
+		vc->value = proc_data->rotate;
+
+	return 0;
+}
+
+
 /*!
  * Dequeue one V4L capture buffer
  *
@@ -831,8 +1021,17 @@ static int csi_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 		return -ERESTARTSYS;
 	}
 
+	if (down_interruptible(&cam->busy_lock))
+		return -EBUSY;
+
 	spin_lock_irqsave(&cam->dqueue_int_lock, lock_flags);
 
+	if (list_empty(&cam->done_q)) {
+		spin_unlock_irqrestore(&cam->dqueue_int_lock, lock_flags);
+		up(&cam->busy_lock);
+		return -EINVAL;
+	}
+
 	cam->enc_counter--;
 
 	frame = list_entry(cam->done_q.next, struct mxc_v4l_frame, queue);
@@ -864,16 +1063,21 @@ static int csi_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 	 * to RGB565; but for encoding, usually we don't use RGB format.
 	 */
 	if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_RGB565) {
-		/* PxP processes it in place */
 		sg_dma_address(&cam->sg[0]) = buf->m.offset;
-		sg_dma_address(&cam->sg[1]) = buf->m.offset;
+		sg_dma_address(&cam->sg[1]) =
+			cam->frame[req_buf_number].paddress;
 		retval = pxp_process_update(cam);
 		if (retval) {
 			pr_err("Unable to submit PxP update task.\n");
 			return retval;
 		}
 		pxp_complete_update(cam);
+		if (cam->frame[buf->index].vaddress)
+			memcpy(cam->frame[buf->index].vaddress,
+			cam->frame[req_buf_number].vaddress,
+			cam->v2f.fmt.pix.sizeimage);
 	}
+	up(&cam->busy_lock);
 
 	return retval;
 }
@@ -912,7 +1116,6 @@ static int csi_v4l_open(struct file *file)
 					 cam->low_power == false);
 
 		cam->enc_counter = 0;
-		cam->skip_frame = 0;
 		INIT_LIST_HEAD(&cam->ready_q);
 		INIT_LIST_HEAD(&cam->working_q);
 		INIT_LIST_HEAD(&cam->done_q);
@@ -1060,8 +1263,9 @@ static long csi_v4l_do_ioctl(struct file *file,
 	pr_debug("In MVC: %s, %x\n", __func__, ioctlnr);
 	wait_event_interruptible(cam->power_queue, cam->low_power == false);
 	/* make this _really_ smp-safe */
-	if (down_interruptible(&cam->busy_lock))
-		return -EBUSY;
+	if (ioctlnr != VIDIOC_DQBUF)
+		if (down_interruptible(&cam->busy_lock))
+			return -EBUSY;
 
 	switch (ioctlnr) {
 		/*!
@@ -1149,10 +1353,65 @@ static long csi_v4l_do_ioctl(struct file *file,
 			break;
 		}
 
+	case VIDIOC_CROPCAP:
+	{
+		struct v4l2_cropcap *cap = arg;
+
+		if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		    cap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+			retval = -EINVAL;
+			break;
+		}
+		cap->bounds = cam->crop_bounds;
+		cap->defrect = cam->crop_defrect;
+		break;
+	}
 	case VIDIOC_S_CROP:
-		pr_debug("   case not supported\n");
+	{
+		struct v4l2_crop *crop = arg;
+		struct v4l2_rect *b = &cam->crop_bounds;
+
+		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+			retval = -EINVAL;
+			break;
+		}
+
+		crop->c.top = (crop->c.top < b->top) ? b->top
+			      : crop->c.top;
+		if (crop->c.top > b->top + b->height)
+			crop->c.top = b->top + b->height - 1;
+		if (crop->c.height > b->top + b->height - crop->c.top)
+			crop->c.height =
+				b->top + b->height - crop->c.top;
+
+		crop->c.left = (crop->c.left < b->left) ? b->left
+		    : crop->c.left;
+		if (crop->c.left > b->left + b->width)
+			crop->c.left = b->left + b->width - 1;
+		if (crop->c.width > b->left - crop->c.left + b->width)
+			crop->c.width =
+				b->left - crop->c.left + b->width;
+
+		crop->c.width -= crop->c.width % 8;
+		crop->c.height -= crop->c.height % 8;
+
+		crop_current.c = crop->c;
+
+		break;
+	}
+	case VIDIOC_G_CROP:
+	{
+		struct v4l2_crop *crop = arg;
+
+		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+			retval = -EINVAL;
+			break;
+		}
+		crop->c = crop_current.c;
+
 		break;
 
+	}
 	case VIDIOC_REQBUFS: {
 		struct v4l2_requestbuffers *req = arg;
 		pr_debug("   case VIDIOC_REQBUFS\n");
@@ -1163,8 +1422,7 @@ static long csi_v4l_do_ioctl(struct file *file,
 			req->count = FRAME_NUM;
 		}
 
-		if ((req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ||
-				(req->memory != V4L2_MEMORY_MMAP)) {
+		if (req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 			pr_err("ERROR: v4l2 capture: VIDIOC_REQBUFS: "
 					"wrong buffer type\n");
 			retval = -EINVAL;
@@ -1172,12 +1430,11 @@ static long csi_v4l_do_ioctl(struct file *file,
 		}
 
 		csi_streamoff(cam);
-		csi_free_frame_buf(cam);
-		cam->skip_frame = 0;
-		INIT_LIST_HEAD(&cam->ready_q);
-		INIT_LIST_HEAD(&cam->working_q);
-		INIT_LIST_HEAD(&cam->done_q);
-		retval = csi_allocate_frame_buf(cam, req->count);
+		if (req->memory & V4L2_MEMORY_MMAP) {
+			csi_free_frame_buf(cam);
+			retval = csi_allocate_frame_buf(cam, req->count + 1);
+			req_buf_number = req->count;
+		}
 		break;
 	}
 
@@ -1191,9 +1448,19 @@ static long csi_v4l_do_ioctl(struct file *file,
 			break;
 		}
 
-		memset(buf, 0, sizeof(buf));
-		buf->index = index;
-		retval = csi_v4l2_buffer_status(cam, buf);
+		if (buf->memory & V4L2_MEMORY_MMAP) {
+			memset(buf, 0, sizeof(buf));
+			buf->index = index;
+		}
+
+		down(&cam->param_lock);
+		if (buf->memory & V4L2_MEMORY_USERPTR) {
+			csi_v4l2_release_bufs(cam);
+			retval = csi_v4l2_prepare_bufs(cam, buf);
+		}
+		if (buf->memory & V4L2_MEMORY_MMAP)
+			retval = csi_v4l2_buffer_status(cam, buf);
+		up(&cam->param_lock);
 		break;
 	}
 
@@ -1207,22 +1474,7 @@ static long csi_v4l_do_ioctl(struct file *file,
 		if ((cam->frame[index].buffer.flags & 0x7) ==
 				V4L2_BUF_FLAG_MAPPED) {
 			cam->frame[index].buffer.flags |= V4L2_BUF_FLAG_QUEUED;
-			if (cam->skip_frame > 0) {
-				list_add_tail(&cam->frame[index].queue,
-					      &cam->working_q);
-				cam->skip_frame = 0;
-
-				if (cam->ping_pong_csi == 1) {
-					__raw_writel(cam->frame[index].paddress,
-						     CSI_CSIDMASA_FB1);
-				} else {
-					__raw_writel(cam->frame[index].paddress,
-						     CSI_CSIDMASA_FB2);
-				}
-			} else {
-				list_add_tail(&cam->frame[index].queue,
-					      &cam->ready_q);
-			}
+			list_add_tail(&cam->frame[index].queue, &cam->ready_q);
 		} else if (cam->frame[index].buffer.flags &
 				V4L2_BUF_FLAG_QUEUED) {
 			pr_err("ERROR: v4l2 capture: VIDIOC_QBUF: "
@@ -1264,19 +1516,107 @@ static long csi_v4l_do_ioctl(struct file *file,
 		retval = csi_streamoff(cam);
 		break;
 	}
+	case VIDIOC_ENUM_FMT: {
+		struct v4l2_fmtdesc *fmt = arg;
+		if (cam->sensor)
+			retval = vidioc_int_enum_fmt_cap(cam->sensor, fmt);
+		else {
+			pr_err("ERROR: v4l2 capture: slave not found!\n");
+			retval = -ENODEV;
+		}
+		break;
+	}
+	case VIDIOC_ENUM_FRAMESIZES: {
+		struct v4l2_frmsizeenum *fsize = arg;
+		if (cam->sensor)
+			retval = vidioc_int_enum_framesizes(cam->sensor, fsize);
+		else {
+			pr_err("ERROR: v4l2 capture: slave not found!\n");
+			retval = -ENODEV;
+		}
+		break;
+	}
+	case VIDIOC_ENUM_FRAMEINTERVALS: {
+		struct v4l2_frmivalenum *fival = arg;
+		if (cam->sensor)
+			retval = vidioc_int_enum_frameintervals(cam->sensor,
+								fival);
+		else {
+			pr_err("ERROR: v4l2 capture: slave not found!\n");
+			retval = -ENODEV;
+		}
+		break;
+	}
+	case VIDIOC_DBG_G_CHIP_IDENT: {
+		struct v4l2_dbg_chip_ident *p = arg;
+		p->ident = V4L2_IDENT_NONE;
+		p->revision = 0;
+		if (cam->sensor)
+			retval = vidioc_int_g_chip_ident(cam->sensor, (int *)p);
+		else {
+			pr_err("ERROR: v4l2 capture: slave not found!\n");
+			retval = -ENODEV;
+		}
+		break;
+	}
 
 	case VIDIOC_S_CTRL:
+	{
+		struct v4l2_control *vc = arg;
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+			if (vc->id == pxp_controls[i].id) {
+				if (vc->value < pxp_controls[i].minimum ||
+				    vc->value > pxp_controls[i].maximum) {
+					retval = -ERANGE;
+					break;
+				}
+				retval = pxp_set_cstate(cam, vc);
+				break;
+			}
+
+		if (i >= ARRAY_SIZE(pxp_controls))
+			retval = -EINVAL;
+		break;
+
+	}
+	case VIDIOC_G_CTRL:
+	{
+		struct v4l2_control *vc = arg;
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+			if (vc->id == pxp_controls[i].id) {
+				retval = pxp_get_cstate(cam, vc);
+				break;
+			}
+
+		if (i >= ARRAY_SIZE(pxp_controls))
+			retval = -EINVAL;
+		break;
+	}
+	case VIDIOC_QUERYCTRL:
+	{
+		struct v4l2_queryctrl *qc = arg;
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+			if (qc->id && qc->id == pxp_controls[i].id) {
+				memcpy(qc, &(pxp_controls[i]), sizeof(*qc));
+				break;
+			}
+
+		if (i >= ARRAY_SIZE(pxp_controls))
+			retval = -EINVAL;
+		break;
+	}
 	case VIDIOC_G_STD:
 	case VIDIOC_G_OUTPUT:
 	case VIDIOC_S_OUTPUT:
 	case VIDIOC_ENUMSTD:
-	case VIDIOC_G_CROP:
-	case VIDIOC_CROPCAP:
 	case VIDIOC_S_STD:
-	case VIDIOC_G_CTRL:
-	case VIDIOC_ENUM_FMT:
 	case VIDIOC_TRY_FMT:
-	case VIDIOC_QUERYCTRL:
 	case VIDIOC_ENUMINPUT:
 	case VIDIOC_G_INPUT:
 	case VIDIOC_S_INPUT:
@@ -1291,7 +1631,8 @@ static long csi_v4l_do_ioctl(struct file *file,
 		break;
 	}
 
-	up(&cam->busy_lock);
+	if (ioctlnr != VIDIOC_DQBUF)
+		up(&cam->busy_lock);
 	return retval;
 }
 
@@ -1331,7 +1672,7 @@ static int csi_mmap(struct file *file, struct vm_area_struct *vma)
 		return -EINTR;
 
 	size = vma->vm_end - vma->vm_start;
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 
 	if (remap_pfn_range(vma, vma->vm_start,
 			    vma->vm_pgoff, size, vma->vm_page_prot)) {
@@ -1375,8 +1716,14 @@ static struct video_device csi_v4l_template = {
  */
 static void init_camera_struct(cam_data *cam)
 {
+	struct pxp_proc_data *proc_data = &cam->pxp_conf.proc_data;
 	pr_debug("In MVC: %s\n", __func__);
 
+	proc_data->hflip = 0;
+	proc_data->vflip = 0;
+	proc_data->rotate = 0;
+	proc_data->bgcolor = 0;
+
 	/* Default everything to 0 */
 	memset(cam, 0, sizeof(cam_data));
 
@@ -1408,7 +1755,6 @@ static void init_camera_struct(cam_data *cam)
 	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
 	cam->overlay_on = false;
 	cam->capture_on = false;
-	cam->skip_frame = 0;
 	cam->v4l2_fb.flags = V4L2_FBUF_FLAG_OVERLAY;
 
 	cam->v2f.fmt.pix.sizeimage = 480 * 640 * 2;
@@ -1421,6 +1767,12 @@ static void init_camera_struct(cam_data *cam)
 	cam->win.w.left = 0;
 	cam->win.w.top = 0;
 	cam->still_counter = 0;
+	/* setup cropping */
+	cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = 640;
+	cam->crop_bounds.top = 0;
+	cam->crop_bounds.height = 480;
+	cam->crop_current = cam->crop_defrect = cam->crop_bounds;
 
 	cam->enc_callback = camera_callback;
 	csi_start_callback(cam);
@@ -1464,6 +1816,8 @@ static int __devinit csi_v4l2_probe(struct platform_device *pdev)
 		err = -ENOMEM;
 		goto out;
 	}
+	memset(&crop_current, 0, sizeof(crop_current));
+	memset(&win_current, 0, sizeof(win_current));
 	init_camera_struct(g_cam);
 	platform_set_drvdata(pdev, (void *)g_cam);
 
@@ -1607,13 +1961,30 @@ static int csi_v4l2_master_attach(struct v4l2_int_device *slave)
 	}
 
 	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+	vidioc_int_s_power(cam->sensor, 1);
 	vidioc_int_dev_init(slave);
+	vidioc_int_s_power(cam->sensor, 0);
 	csi_enable_mclk(CSI_MCLK_I2C, false, false);
 	cam_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vidioc_int_g_fmt_cap(cam->sensor, &cam_fmt);
 
 	/* Used to detect TV in (type 1) vs. camera (type 0) */
 	cam->device_type = cam_fmt.fmt.pix.priv;
 
+	cam->crop_bounds.top = cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = cam_fmt.fmt.pix.width;
+	cam->crop_bounds.height = cam_fmt.fmt.pix.height;
+
+	/* This also is the max crop size for this device. */
+	cam->crop_defrect.top = cam->crop_defrect.left = 0;
+	cam->crop_defrect.width = cam_fmt.fmt.pix.width;
+	cam->crop_defrect.height = cam_fmt.fmt.pix.height;
+
+	/* At this point, this is also the current image size. */
+	cam->crop_current.top = cam->crop_current.left = 0;
+	cam->crop_current.width = cam_fmt.fmt.pix.width;
+	cam->crop_current.height = cam_fmt.fmt.pix.height;
+
 	pr_debug("End of %s: v2f pix widthxheight %d x %d\n",
 		 __func__, cam->v2f.fmt.pix.width, cam->v2f.fmt.pix.height);
 
diff --git a/drivers/media/video/mxc/capture/fsl_csi.c b/drivers/media/video/mxc/capture/fsl_csi.c
index f5677e4..5368b57 100644
--- a/drivers/media/video/mxc/capture/fsl_csi.c
+++ b/drivers/media/video/mxc/capture/fsl_csi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -45,20 +45,17 @@ static irqreturn_t csi_irq_handler(int irq, void *data)
 {
 	cam_data *cam = (cam_data *) data;
 	unsigned long status = __raw_readl(CSI_CSISR);
-	unsigned long cr3 = __raw_readl(CSI_CSICR3);
-	unsigned int frame_count = (cr3 >> 16) & 0xFFFF;
 
 	__raw_writel(status, CSI_CSISR);
 
-	if (status & BIT_SOF_INT) {
-		/* reflash the embeded DMA controller */
-		if (frame_count % 2 == 1)
-			__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
-	}
+	if (status & BIT_HRESP_ERR_INT)
+		pr_warning("Hresponse error is detected.\n");
 
 	if (status & BIT_DMA_TSF_DONE_FB1) {
 		if (cam->capture_on) {
+			spin_lock(&cam->queue_int_lock);
 			cam->ping_pong_csi = 1;
+			spin_unlock(&cam->queue_int_lock);
 			cam->enc_callback(0, cam);
 		} else {
 			cam->still_counter++;
@@ -68,7 +65,9 @@ static irqreturn_t csi_irq_handler(int irq, void *data)
 
 	if (status & BIT_DMA_TSF_DONE_FB2) {
 		if (cam->capture_on) {
+			spin_lock(&cam->queue_int_lock);
 			cam->ping_pong_csi = 2;
+			spin_unlock(&cam->queue_int_lock);
 			cam->enc_callback(0, cam);
 		} else {
 			cam->still_counter++;
@@ -260,6 +259,24 @@ void csi_mclk_disable(void)
 	clk_disable(&csi_mclk);
 }
 
+void csi_dmareq_rff_enable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 |= BIT_DMA_REQ_EN_RFF;
+	cr3 |= BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
+void csi_dmareq_rff_disable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 &= ~BIT_DMA_REQ_EN_RFF;
+	cr3 &= ~BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
 static int __devinit csi_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -289,6 +306,7 @@ static int __devinit csi_probe(struct platform_device *pdev)
 
 	csihw_reset();
 	csi_init_interface();
+	csi_dmareq_rff_disable();
 
 	per_clk = clk_get(NULL, "csi_clk");
 	if (IS_ERR(per_clk))
diff --git a/drivers/media/video/mxc/capture/fsl_csi.h b/drivers/media/video/mxc/capture/fsl_csi.h
index 8dfce28..d8096cc 100644
--- a/drivers/media/video/mxc/capture/fsl_csi.h
+++ b/drivers/media/video/mxc/capture/fsl_csi.h
@@ -195,3 +195,5 @@ void csi_enable_int(int arg);
 void csi_disable_int(void);
 void csi_mclk_enable(void);
 void csi_mclk_disable(void);
+void csi_dmareq_rff_enable(void);
+void csi_dmareq_rff_disable(void);
diff --git a/drivers/media/video/mxc/capture/ipu_csi_enc.c b/drivers/media/video/mxc/capture/ipu_csi_enc.c
index 872598b..ff90e2b 100644
--- a/drivers/media/video/mxc/capture/ipu_csi_enc.c
+++ b/drivers/media/video/mxc/capture/ipu_csi_enc.c
@@ -104,6 +104,8 @@ static int csi_enc_setup(cam_data *cam)
 
 	if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420)
 		pixel_fmt = IPU_PIX_FMT_YUV420P;
+	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YVU420)
+		pixel_fmt = IPU_PIX_FMT_YVU420P;
 	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YUV422P)
 		pixel_fmt = IPU_PIX_FMT_YUV422P;
 	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_UYVY)
@@ -169,7 +171,8 @@ static int csi_enc_setup(cam_data *cam)
 	err = ipu_init_channel_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER,
 				      pixel_fmt, cam->v2f.fmt.pix.width,
 				      cam->v2f.fmt.pix.height,
-				      cam->v2f.fmt.pix.width, IPU_ROTATE_NONE,
+				      cam->v2f.fmt.pix.bytesperline,
+				      IPU_ROTATE_NONE,
 				      dummy, dummy, 0,
 				      cam->offset.u_offset,
 				      cam->offset.v_offset);
diff --git a/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c b/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c
index f324f4e..856078a 100644
--- a/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c
+++ b/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 /* * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -55,7 +55,7 @@ static void csi_buf_work_func(struct work_struct *work)
 		task.input.paddr = cam->vf_bufs[1];
 	task.input.width = cam->crop_current.width;
 	task.input.height = cam->crop_current.height;
-	task.input.format = IPU_PIX_FMT_UYVY;
+	task.input.format = IPU_PIX_FMT_NV12;
 
 	if (buffer_num == 0)
 		task.output.paddr = fbi->fix.smem_start +
@@ -124,7 +124,7 @@ static irqreturn_t csi_enc_callback(int irq, void *dev_id)
 	ipu_select_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER, csi_buffer_num);
 	if ((cam->crop_current.width != cam->win.w.width) ||
 		(cam->crop_current.height != cam->win.w.height) ||
-		(vf_out_format != IPU_PIX_FMT_UYVY) ||
+		(vf_out_format != IPU_PIX_FMT_NV12) ||
 		(cam->rotation >= IPU_ROTATE_VERT_FLIP))
 		schedule_work(&cam->csi_work_struct);
 	csi_buffer_num = (csi_buffer_num == 0) ? 1 : 0;
@@ -134,7 +134,6 @@ static irqreturn_t csi_enc_callback(int irq, void *dev_id)
 static int csi_enc_setup(cam_data *cam)
 {
 	ipu_channel_params_t params;
-	u32 pixel_fmt;
 	int err = 0, sensor_protocol = 0;
 #ifdef CONFIG_MXC_MIPI_CSI2
 	void *mipi_csi2_info;
@@ -213,7 +212,8 @@ static int csi_enc_setup(cam_data *cam)
 				  cam->vf_bufs_vaddr[1],
 				  (dma_addr_t) cam->vf_bufs[1]);
 	}
-	csi_mem_bufsize = cam->crop_current.width * cam->crop_current.height * 2;
+	csi_mem_bufsize = cam->crop_current.width *
+			  cam->crop_current.height * 3/2;
 	cam->vf_bufs_size[0] = PAGE_ALIGN(csi_mem_bufsize);
 	cam->vf_bufs_vaddr[0] = (void *)dma_alloc_coherent(0,
 							   cam->vf_bufs_size[0],
@@ -246,13 +246,13 @@ static int csi_enc_setup(cam_data *cam)
 		goto out_1;
 	}
 
-	pixel_fmt = IPU_PIX_FMT_UYVY;
 	if ((cam->crop_current.width == cam->win.w.width) &&
 		(cam->crop_current.height == cam->win.w.height) &&
-		(vf_out_format == IPU_PIX_FMT_UYVY) &&
+		(vf_out_format == IPU_PIX_FMT_NV12) &&
 		(cam->rotation < IPU_ROTATE_VERT_FLIP)) {
 		err = ipu_init_channel_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER,
-					      pixel_fmt, cam->crop_current.width,
+					      IPU_PIX_FMT_NV12,
+					      cam->crop_current.width,
 					      cam->crop_current.height,
 					      cam->crop_current.width, IPU_ROTATE_NONE,
 					      fbi->fix.smem_start + (fbi->fix.line_length * fbvar.yres),
@@ -260,7 +260,8 @@ static int csi_enc_setup(cam_data *cam)
 					      cam->offset.u_offset, cam->offset.u_offset);
 	} else {
 		err = ipu_init_channel_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER,
-					      pixel_fmt, cam->crop_current.width,
+					      IPU_PIX_FMT_NV12,
+					      cam->crop_current.width,
 					      cam->crop_current.height,
 					      cam->crop_current.width, IPU_ROTATE_NONE,
 					      cam->vf_bufs[0], cam->vf_bufs[1], 0,
@@ -347,8 +348,8 @@ out1:
 static int foreground_start(void *private)
 {
 	cam_data *cam = (cam_data *) private;
-	int err = 0, i = 0;
-	short *tmp, color;
+	int err = 0, i = 0, screen_size;
+	char *base;
 
 	if (!cam) {
 		printk(KERN_ERR "private is NULL\n");
@@ -383,13 +384,11 @@ static int foreground_start(void *private)
 
 	if (OVERLAY_FB_SUPPORT_NONSTD) {
 		/* Use DP to do CSC so that we can get better performance */
-		vf_out_format = IPU_PIX_FMT_UYVY;
+		vf_out_format = IPU_PIX_FMT_NV12;
 		fbvar.nonstd = vf_out_format;
-		color = 0x80;
 	} else {
 		vf_out_format = IPU_PIX_FMT_RGB565;
 		fbvar.nonstd = 0;
-		color = 0x0;
 	}
 
 	fbvar.bits_per_pixel = 16;
@@ -397,6 +396,7 @@ static int foreground_start(void *private)
 	fbvar.yres = cam->win.w.height;
 	fbvar.yres_virtual = cam->win.w.height * 2;
 	fbvar.yoffset = 0;
+	fbvar.vmode &= ~FB_VMODE_YWRAP;
 	fbvar.accel_flags = FB_ACCEL_DOUBLE_FLAG;
 	fbvar.activate |= FB_ACTIVATE_FORCE;
 	fb_set_var(fbi, &fbvar);
@@ -405,10 +405,17 @@ static int foreground_start(void *private)
 			cam->win.w.top);
 
 	/* Fill black color for framebuffer */
-	tmp = (short *) fbi->screen_base;
-	for (i = 0; i < (fbi->fix.line_length * fbi->var.yres)/2;
-			i++, tmp++)
-		*tmp = color;
+	base = (char *) fbi->screen_base;
+	screen_size = fbi->var.xres * fbi->var.yres;
+	if (OVERLAY_FB_SUPPORT_NONSTD) {
+		memset(base, 0, screen_size);
+		base += screen_size;
+		for (i = 0; i < screen_size / 2; i++, base++)
+			*base = 0x80;
+	} else {
+		for (i = 0; i < screen_size * 2; i++, base++)
+			*base = 0x00;
+	}
 
 	console_lock();
 	fb_blank(fbi, FB_BLANK_UNBLANK);
diff --git a/drivers/media/video/mxc/capture/ipu_prp_enc.c b/drivers/media/video/mxc/capture/ipu_prp_enc.c
index a3c90d5..e24b1b0 100644
--- a/drivers/media/video/mxc/capture/ipu_prp_enc.c
+++ b/drivers/media/video/mxc/capture/ipu_prp_enc.c
@@ -99,6 +99,9 @@ static int prp_enc_setup(cam_data *cam)
 	if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420) {
 		enc.csi_prp_enc_mem.out_pixel_fmt = IPU_PIX_FMT_YUV420P;
 		pr_info("YUV420\n");
+	} else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YVU420) {
+		enc.csi_prp_enc_mem.out_pixel_fmt = IPU_PIX_FMT_YVU420P;
+		pr_info("YVU420\n");
 	} else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YUV422P) {
 		enc.csi_prp_enc_mem.out_pixel_fmt = IPU_PIX_FMT_YUV422P;
 		pr_info("YUV422P\n");
diff --git a/drivers/media/video/mxc/capture/mxc_v4l2_capture.c b/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
index 4fd89b0..9130388 100644
--- a/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
+++ b/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -366,6 +366,7 @@ static inline int valid_mode(u32 palette)
 		(palette == V4L2_PIX_FMT_UYVY) ||
 		(palette == V4L2_PIX_FMT_YUYV) ||
 		(palette == V4L2_PIX_FMT_YUV420) ||
+		(palette == V4L2_PIX_FMT_YVU420) ||
 		(palette == V4L2_PIX_FMT_NV12));
 }
 
@@ -881,6 +882,7 @@ static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 			bytesperline = f->fmt.pix.width * 2;
 			break;
 		case V4L2_PIX_FMT_YUV420:
+		case V4L2_PIX_FMT_YVU420:
 			size = f->fmt.pix.width * f->fmt.pix.height * 3 / 2;
 			bytesperline = f->fmt.pix.width;
 			break;
@@ -1329,19 +1331,11 @@ static int mxc_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 	csi_param.csi = cam->csi;
 	csi_param.mclk = 0;
 
-	/*This may not work on other platforms. Check when adding a new one.*/
-	/*The mclk clock was never set correclty in the ipu register*/
-	/*for now we are going to use this mclk as pixel clock*/
-	/*to set csi0_data_dest register.*/
-	/*This is a workaround which should be fixed*/
 	pr_debug("   clock_curr=mclk=%d\n", ifparm.u.bt656.clock_curr);
-	if (ifparm.u.bt656.clock_curr == 0) {
+	if (ifparm.u.bt656.clock_curr == 0)
 		csi_param.clk_mode = IPU_CSI_CLK_MODE_CCIR656_INTERLACED;
-		/*protocol bt656 use 27Mhz pixel clock */
-		csi_param.mclk = 27000000;
-	} else {
+	else
 		csi_param.clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;
-	}
 
 	csi_param.pixclk_pol = ifparm.u.bt656.latch_clk_inv;
 
@@ -1411,7 +1405,8 @@ exit:
  */
 static int mxc_v4l2_s_std(cam_data *cam, v4l2_std_id e)
 {
-	printk(KERN_ERR "In mxc_v4l2_s_std %Lx\n", e);
+	pr_debug("In mxc_v4l2_s_std %Lx\n", e);
+
 	if (e == V4L2_STD_PAL) {
 		pr_debug("   Setting standard to PAL %Lx\n", V4L2_STD_PAL);
 		cam->standard.id = V4L2_STD_PAL;
@@ -2641,6 +2636,7 @@ static void init_camera_struct(cam_data *cam, struct platform_device *pdev)
 	cam->win.w.left = 0;
 	cam->win.w.top = 0;
 
+	cam->ipu_id = pdata->ipu;
 	cam->csi = pdata->csi;
 	cam->mclk_source = pdata->mclk_source;
 	cam->mclk_on[cam->mclk_source] = false;
@@ -2652,7 +2648,7 @@ static void init_camera_struct(cam_data *cam, struct platform_device *pdev)
 
 	cam->self = kmalloc(sizeof(struct v4l2_int_device), GFP_KERNEL);
 	cam->self->module = THIS_MODULE;
-	sprintf(cam->self->name, "mxc_v4l2_cap%d", cam->csi);
+	sprintf(cam->self->name, "mxc_v4l2_cap%d", pdev->id);
 	cam->self->type = v4l2_int_type_master;
 	cam->self->u.master = &mxc_v4l2_master;
 }
@@ -2685,6 +2681,17 @@ static ssize_t show_overlay(struct device *dev,
 }
 static DEVICE_ATTR(fsl_v4l2_overlay_property, S_IRUGO, show_overlay, NULL);
 
+static ssize_t show_csi(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct video_device *video_dev = container_of(dev,
+						struct video_device, dev);
+	cam_data *cam = video_get_drvdata(video_dev);
+
+	return sprintf(buf, "ipu%d_csi%d\n", cam->ipu_id, cam->csi);
+}
+static DEVICE_ATTR(fsl_csi_property, S_IRUGO, show_csi, NULL);
+
 /*!
  * This function is called to probe the devices if registered.
  *
@@ -2730,6 +2737,11 @@ static int mxc_v4l2_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Error on creating sysfs file"
 			" for overlay\n");
 
+	if (device_create_file(&cam->video_dev->dev,
+			&dev_attr_fsl_csi_property))
+		dev_err(&pdev->dev, "Error on creating sysfs file"
+			" for csi number\n");
+
 	return 0;
 }
 
@@ -2753,6 +2765,8 @@ static int mxc_v4l2_remove(struct platform_device *pdev)
 			&dev_attr_fsl_v4l2_capture_property);
 		device_remove_file(&cam->video_dev->dev,
 			&dev_attr_fsl_v4l2_overlay_property);
+		device_remove_file(&cam->video_dev->dev,
+			&dev_attr_fsl_csi_property);
 
 		pr_info("V4L2 freeing image input device\n");
 		v4l2_int_device_unregister(cam->self);
diff --git a/drivers/media/video/mxc/capture/mxc_v4l2_capture.h b/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
index d2efbe8..7edb8d6 100644
--- a/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
+++ b/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -56,7 +56,10 @@ struct mxc_v4l_frame {
 	struct v4l2_buffer buffer;
 	struct list_head queue;
 	int index;
-	int ipu_buf_num;
+	union {
+		int ipu_buf_num;
+		int csi_buf_num;
+	};
 };
 
 /* Only for old version.  Will go away soon. */
@@ -119,7 +122,6 @@ typedef struct _cam_data {
 	spinlock_t dqueue_int_lock;
 	struct mxc_v4l_frame frame[FRAME_NUM];
 	struct mxc_v4l_frame dummy_frame;
-	int skip_frame;
 	wait_queue_head_t enc_queue;
 	int enc_counter;
 	dma_addr_t rot_enc_bufs[2];
@@ -196,6 +198,7 @@ typedef struct _cam_data {
 	int capture_pid;
 	bool low_power;
 	wait_queue_head_t power_queue;
+	unsigned int ipu_id;
 	unsigned int csi;
 	u8 mclk_source;
 	bool mclk_on[2];	/* two mclk sources at most now */
diff --git a/drivers/media/video/mxc/capture/ov5640.c b/drivers/media/video/mxc/capture/ov5640.c
index f73e4f1..4ef5c42 100644
--- a/drivers/media/video/mxc/capture/ov5640.c
+++ b/drivers/media/video/mxc/capture/ov5640.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,6 +31,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-int-device.h>
 #include "mxc_v4l2_capture.h"
+#include "fsl_csi.h"
 
 #define OV5640_VOLTAGE_ANALOG               2800000
 #define OV5640_VOLTAGE_DIGITAL_CORE         1500000
@@ -43,6 +44,9 @@
 #define OV5640_XCLK_MIN 6000000
 #define OV5640_XCLK_MAX 24000000
 
+#define OV5640_CHIP_ID_HIGH_BYTE        0x300A
+#define OV5640_CHIP_ID_LOW_BYTE         0x300B
+
 enum ov5640_mode {
 	ov5640_mode_MIN = 0,
 	ov5640_mode_VGA_640_480 = 0,
@@ -52,7 +56,9 @@ enum ov5640_mode {
 	ov5640_mode_720P_1280_720 = 4,
 	ov5640_mode_1080P_1920_1080 = 5,
 	ov5640_mode_QSXGA_2592_1944 = 6,
-	ov5640_mode_MAX = 6
+	ov5640_mode_QCIF_176_144 = 7,
+	ov5640_mode_XGA_1024_768 = 8,
+	ov5640_mode_MAX = 8
 };
 
 enum ov5640_frame_rate {
@@ -60,6 +66,11 @@ enum ov5640_frame_rate {
 	ov5640_30_fps
 };
 
+static int ov5640_framerates[] = {
+	[ov5640_15_fps] = 15,
+	[ov5640_30_fps] = 30,
+};
+
 struct reg_value {
 	u16 u16RegAddr;
 	u8 u8Val;
@@ -79,9 +90,37 @@ struct ov5640_mode_info {
  * Maintains the information on the current state of the sesor.
  */
 static struct sensor_data ov5640_data;
+static int prev_sysclk;
+static int AE_Target = 52, night_mode;
+static int prev_HTS;
+static int AE_high, AE_low;
 
-static struct reg_value ov5640_setting_15fps_QSXGA_2592_1944[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
+static struct reg_value ov5640_global_init_setting[] = {
+	{0x3008, 0x42, 0, 0},
+	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
+	{0x3034, 0x1a, 0, 0}, {0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0},
+	{0x3630, 0x36, 0, 0}, {0x3631, 0x0e, 0, 0}, {0x3632, 0xe2, 0, 0},
+	{0x3633, 0x12, 0, 0}, {0x3621, 0xe0, 0, 0}, {0x3704, 0xa0, 0, 0},
+	{0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0}, {0x3717, 0x01, 0, 0},
+	{0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0}, {0x3905, 0x02, 0, 0},
+	{0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0}, {0x3731, 0x12, 0, 0},
+	{0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0}, {0x302d, 0x60, 0, 0},
+	{0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0}, {0x471c, 0x50, 0, 0},
+	{0x3a13, 0x43, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0x7c, 0, 0},
+	{0x3635, 0x13, 0, 0}, {0x3636, 0x03, 0, 0}, {0x3634, 0x40, 0, 0},
+	{0x3622, 0x01, 0, 0}, {0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0},
+	{0x3c05, 0x98, 0, 0}, {0x3c06, 0x00, 0, 0}, {0x3c07, 0x07, 0, 0},
+	{0x3c08, 0x00, 0, 0}, {0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0},
+	{0x3c0b, 0x40, 0, 0}, {0x3810, 0x00, 0, 0}, {0x3811, 0x10, 0, 0},
+	{0x3812, 0x00, 0, 0}, {0x3708, 0x64, 0, 0}, {0x4001, 0x02, 0, 0},
+	{0x4005, 0x1a, 0, 0}, {0x3000, 0x00, 0, 0}, {0x3004, 0xff, 0, 0},
+	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
+	{0x501f, 0x00, 0, 0}, {0x440e, 0x00, 0, 0}, {0x5000, 0xa7, 0, 0},
+	{0x3008, 0x02, 0, 0},
+};
+
+static struct reg_value ov5640_init_setting_30fps_VGA[] = {
+	{0x3008, 0x42, 0, 0},
 	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
 	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
 	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x36, 0, 0},
@@ -115,668 +154,403 @@ static struct reg_value ov5640_setting_15fps_QSXGA_2592_1944[] = {
 	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
 	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
 	{0x440e, 0x00, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0},
-	{0x5180, 0xff, 0, 0}, {0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0},
-	{0x5183, 0x14, 0, 0}, {0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0},
-	{0x5186, 0x09, 0, 0}, {0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0},
-	{0x5189, 0x75, 0, 0}, {0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0},
-	{0x518c, 0xb2, 0, 0}, {0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0},
-	{0x518f, 0x56, 0, 0}, {0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0},
-	{0x5192, 0x04, 0, 0}, {0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0},
-	{0x5195, 0xf0, 0, 0}, {0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0},
-	{0x5198, 0x04, 0, 0}, {0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0},
-	{0x519b, 0x00, 0, 0}, {0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0},
-	{0x519e, 0x38, 0, 0}, {0x5381, 0x1e, 0, 0}, {0x5382, 0x5b, 0, 0},
-	{0x5383, 0x08, 0, 0}, {0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0},
-	{0x5386, 0x88, 0, 0}, {0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0},
-	{0x5389, 0x10, 0, 0}, {0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0},
-	{0x5300, 0x08, 0, 0}, {0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0},
-	{0x5303, 0x00, 0, 0}, {0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0},
-	{0x5306, 0x08, 0, 0}, {0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0},
-	{0x530a, 0x30, 0, 0}, {0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0},
-	{0x5480, 0x01, 0, 0}, {0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0},
-	{0x5483, 0x28, 0, 0}, {0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0},
-	{0x5486, 0x71, 0, 0}, {0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0},
-	{0x5489, 0x91, 0, 0}, {0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0},
-	{0x548c, 0xb8, 0, 0}, {0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0},
-	{0x548f, 0xea, 0, 0}, {0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0},
-	{0x5583, 0x40, 0, 0}, {0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0},
-	{0x558a, 0x00, 0, 0}, {0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0},
-	{0x5801, 0x14, 0, 0}, {0x5802, 0x0f, 0, 0}, {0x5803, 0x0f, 0, 0},
-	{0x5804, 0x12, 0, 0}, {0x5805, 0x26, 0, 0}, {0x5806, 0x0c, 0, 0},
-	{0x5807, 0x08, 0, 0}, {0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0},
-	{0x580a, 0x08, 0, 0}, {0x580b, 0x0d, 0, 0}, {0x580c, 0x08, 0, 0},
-	{0x580d, 0x03, 0, 0}, {0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0},
-	{0x5810, 0x03, 0, 0}, {0x5811, 0x09, 0, 0}, {0x5812, 0x07, 0, 0},
-	{0x5813, 0x03, 0, 0}, {0x5814, 0x00, 0, 0}, {0x5815, 0x01, 0, 0},
-	{0x5816, 0x03, 0, 0}, {0x5817, 0x08, 0, 0}, {0x5818, 0x0d, 0, 0},
-	{0x5819, 0x08, 0, 0}, {0x581a, 0x05, 0, 0}, {0x581b, 0x06, 0, 0},
-	{0x581c, 0x08, 0, 0}, {0x581d, 0x0e, 0, 0}, {0x581e, 0x29, 0, 0},
-	{0x581f, 0x17, 0, 0}, {0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0},
-	{0x5822, 0x15, 0, 0}, {0x5823, 0x28, 0, 0}, {0x5824, 0x46, 0, 0},
-	{0x5825, 0x26, 0, 0}, {0x5826, 0x08, 0, 0}, {0x5827, 0x26, 0, 0},
-	{0x5828, 0x64, 0, 0}, {0x5829, 0x26, 0, 0}, {0x582a, 0x24, 0, 0},
-	{0x582b, 0x22, 0, 0}, {0x582c, 0x24, 0, 0}, {0x582d, 0x24, 0, 0},
-	{0x582e, 0x06, 0, 0}, {0x582f, 0x22, 0, 0}, {0x5830, 0x40, 0, 0},
-	{0x5831, 0x42, 0, 0}, {0x5832, 0x24, 0, 0}, {0x5833, 0x26, 0, 0},
-	{0x5834, 0x24, 0, 0}, {0x5835, 0x22, 0, 0}, {0x5836, 0x22, 0, 0},
-	{0x5837, 0x26, 0, 0}, {0x5838, 0x44, 0, 0}, {0x5839, 0x24, 0, 0},
-	{0x583a, 0x26, 0, 0}, {0x583b, 0x28, 0, 0}, {0x583c, 0x42, 0, 0},
-	{0x583d, 0xce, 0, 0}, {0x5025, 0x00, 0, 0}, {0x3a0f, 0x30, 0, 0},
-	{0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0}, {0x3a1e, 0x26, 0, 0},
-	{0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0}, {0x3008, 0x02, 0, 0},
-	{0x3035, 0x21, 0, 0}, {0x3c01, 0xb4, 0, 0}, {0x3c00, 0x04, 0, 0},
-	{0x3a19, 0x7c, 0, 0}, {0x5800, 0x2c, 0, 0}, {0x5801, 0x17, 0, 0},
-	{0x5802, 0x11, 0, 0}, {0x5803, 0x11, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x29, 0, 0}, {0x5806, 0x08, 0, 0}, {0x5807, 0x06, 0, 0},
-	{0x5808, 0x04, 0, 0}, {0x5809, 0x04, 0, 0}, {0x580a, 0x05, 0, 0},
-	{0x580b, 0x07, 0, 0}, {0x580c, 0x06, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x01, 0, 0}, {0x580f, 0x01, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x06, 0, 0}, {0x5812, 0x06, 0, 0}, {0x5813, 0x02, 0, 0},
-	{0x5814, 0x01, 0, 0}, {0x5815, 0x01, 0, 0}, {0x5816, 0x04, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x06, 0, 0}, {0x5819, 0x07, 0, 0},
-	{0x581a, 0x06, 0, 0}, {0x581b, 0x06, 0, 0}, {0x581c, 0x06, 0, 0},
-	{0x581d, 0x0e, 0, 0}, {0x581e, 0x31, 0, 0}, {0x581f, 0x12, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x11, 0, 0},
-	{0x5823, 0x2f, 0, 0}, {0x5824, 0x12, 0, 0}, {0x5825, 0x25, 0, 0},
-	{0x5826, 0x39, 0, 0}, {0x5827, 0x29, 0, 0}, {0x5828, 0x27, 0, 0},
-	{0x5829, 0x39, 0, 0}, {0x582a, 0x26, 0, 0}, {0x582b, 0x33, 0, 0},
-	{0x582c, 0x24, 0, 0}, {0x582d, 0x39, 0, 0}, {0x582e, 0x28, 0, 0},
-	{0x582f, 0x21, 0, 0}, {0x5830, 0x40, 0, 0}, {0x5831, 0x21, 0, 0},
-	{0x5832, 0x17, 0, 0}, {0x5833, 0x17, 0, 0}, {0x5834, 0x15, 0, 0},
-	{0x5835, 0x11, 0, 0}, {0x5836, 0x24, 0, 0}, {0x5837, 0x27, 0, 0},
-	{0x5838, 0x26, 0, 0}, {0x5839, 0x26, 0, 0}, {0x583a, 0x26, 0, 0},
-	{0x583b, 0x28, 0, 0}, {0x583c, 0x14, 0, 0}, {0x583d, 0xee, 0, 0},
-	{0x4005, 0x1a, 0, 0}, {0x5381, 0x26, 0, 0}, {0x5382, 0x50, 0, 0},
-	{0x5383, 0x0c, 0, 0}, {0x5384, 0x09, 0, 0}, {0x5385, 0x74, 0, 0},
-	{0x5386, 0x7d, 0, 0}, {0x5387, 0x7e, 0, 0}, {0x5388, 0x75, 0, 0},
-	{0x5389, 0x09, 0, 0}, {0x538b, 0x98, 0, 0}, {0x538a, 0x01, 0, 0},
-	{0x5580, 0x02, 0, 0}, {0x5588, 0x01, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x0f, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0x3f, 0, 0}, {0x5308, 0x25, 0, 0}, {0x5304, 0x08, 0, 0},
-	{0x5305, 0x30, 0, 0}, {0x5306, 0x10, 0, 0}, {0x5307, 0x20, 0, 0},
-	{0x5180, 0xff, 0, 0}, {0x5181, 0xf2, 0, 0}, {0x5182, 0x11, 0, 0},
-	{0x5183, 0x14, 0, 0}, {0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0},
-	{0x5186, 0x10, 0, 0}, {0x5187, 0x12, 0, 0}, {0x5188, 0x10, 0, 0},
-	{0x5189, 0x80, 0, 0}, {0x518a, 0x54, 0, 0}, {0x518b, 0xb8, 0, 0},
-	{0x518c, 0xb2, 0, 0}, {0x518d, 0x42, 0, 0}, {0x518e, 0x3a, 0, 0},
-	{0x518f, 0x56, 0, 0}, {0x5190, 0x46, 0, 0}, {0x5191, 0xf0, 0, 0},
-	{0x5192, 0x0f, 0, 0}, {0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0},
-	{0x5195, 0xf0, 0, 0}, {0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0},
-	{0x5198, 0x06, 0, 0}, {0x5199, 0x62, 0, 0}, {0x519a, 0x04, 0, 0},
-	{0x519b, 0x00, 0, 0}, {0x519c, 0x04, 0, 0}, {0x519d, 0xe7, 0, 0},
-	{0x519e, 0x38, 0, 0}, {0x3820, 0x40, 0, 0}, {0x3821, 0x06, 0, 0},
-	{0x3814, 0x11, 0, 0}, {0x3815, 0x11, 0, 0}, {0x3803, 0x00, 0, 0},
-	{0x3807, 0x9f, 0, 0}, {0x3808, 0x0a, 0, 0}, {0x3809, 0x20, 0, 0},
-	{0x380a, 0x07, 0, 0}, {0x380b, 0x98, 0, 0}, {0x380c, 0x0b, 0, 0},
-	{0x380d, 0x1c, 0, 0}, {0x380e, 0x07, 0, 0}, {0x380f, 0xb0, 0, 0},
-	{0x3813, 0x04, 0, 0}, {0x3618, 0x04, 0, 0}, {0x3612, 0x4b, 0, 0},
-	{0x3708, 0x21, 0, 0}, {0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0},
-	{0x3a02, 0x07, 0, 0}, {0x3a03, 0xb0, 0, 0}, {0x3a0e, 0x06, 0, 0},
-	{0x3a0d, 0x08, 0, 0}, {0x3a14, 0x07, 0, 0}, {0x3a15, 0xb0, 0, 0},
-	{0x4004, 0x06, 0, 0}, {0x5000, 0x07, 0, 0}, {0x5181, 0x52, 0, 0},
-	{0x5182, 0x00, 0, 0}, {0x5197, 0x01, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x3035, 0x21, 0, 0}, {0x5000, 0x27, 0, 0}, {0x5001, 0x83, 0, 0},
-	{0x3035, 0x71, 0, 0}, {0x4713, 0x02, 0, 0}, {0x3036, 0x69, 0, 0},
-	{0x4407, 0x0c, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
-	{0x3824, 0x01, 0, 0}, {0x4005, 0x1A, 0, 0},
+	{0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0}, {0x5000, 0xa7, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0}, {0x5181, 0xf2, 0, 0},
+	{0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0}, {0x5184, 0x25, 0, 0},
+	{0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0}, {0x5187, 0x09, 0, 0},
+	{0x5188, 0x09, 0, 0}, {0x5189, 0x88, 0, 0}, {0x518a, 0x54, 0, 0},
+	{0x518b, 0xee, 0, 0}, {0x518c, 0xb2, 0, 0}, {0x518d, 0x50, 0, 0},
+	{0x518e, 0x34, 0, 0}, {0x518f, 0x6b, 0, 0}, {0x5190, 0x46, 0, 0},
+	{0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0}, {0x5193, 0x70, 0, 0},
+	{0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0}, {0x5196, 0x03, 0, 0},
+	{0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0}, {0x5199, 0x6c, 0, 0},
+	{0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0}, {0x519c, 0x09, 0, 0},
+	{0x519d, 0x2b, 0, 0}, {0x519e, 0x38, 0, 0}, {0x5381, 0x1e, 0, 0},
+	{0x5382, 0x5b, 0, 0}, {0x5383, 0x08, 0, 0}, {0x5384, 0x0a, 0, 0},
+	{0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0}, {0x5387, 0x7c, 0, 0},
+	{0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0}, {0x538a, 0x01, 0, 0},
+	{0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0}, {0x5301, 0x30, 0, 0},
+	{0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0}, {0x5304, 0x08, 0, 0},
+	{0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0}, {0x5307, 0x16, 0, 0},
+	{0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0}, {0x530b, 0x04, 0, 0},
+	{0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0}, {0x5481, 0x08, 0, 0},
+	{0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0}, {0x5484, 0x51, 0, 0},
+	{0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0}, {0x5487, 0x7d, 0, 0},
+	{0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0}, {0x548a, 0x9a, 0, 0},
+	{0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0}, {0x548d, 0xcd, 0, 0},
+	{0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0}, {0x5490, 0x1d, 0, 0},
+	{0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0}, {0x5584, 0x10, 0, 0},
+	{0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0}, {0x558b, 0xf8, 0, 0},
+	{0x5800, 0x23, 0, 0}, {0x5801, 0x14, 0, 0}, {0x5802, 0x0f, 0, 0},
+	{0x5803, 0x0f, 0, 0}, {0x5804, 0x12, 0, 0}, {0x5805, 0x26, 0, 0},
+	{0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0}, {0x5808, 0x05, 0, 0},
+	{0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0}, {0x580b, 0x0d, 0, 0},
+	{0x580c, 0x08, 0, 0}, {0x580d, 0x03, 0, 0}, {0x580e, 0x00, 0, 0},
+	{0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0}, {0x5811, 0x09, 0, 0},
+	{0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0}, {0x5814, 0x00, 0, 0},
+	{0x5815, 0x01, 0, 0}, {0x5816, 0x03, 0, 0}, {0x5817, 0x08, 0, 0},
+	{0x5818, 0x0d, 0, 0}, {0x5819, 0x08, 0, 0}, {0x581a, 0x05, 0, 0},
+	{0x581b, 0x06, 0, 0}, {0x581c, 0x08, 0, 0}, {0x581d, 0x0e, 0, 0},
+	{0x581e, 0x29, 0, 0}, {0x581f, 0x17, 0, 0}, {0x5820, 0x11, 0, 0},
+	{0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0}, {0x5823, 0x28, 0, 0},
+	{0x5824, 0x46, 0, 0}, {0x5825, 0x26, 0, 0}, {0x5826, 0x08, 0, 0},
+	{0x5827, 0x26, 0, 0}, {0x5828, 0x64, 0, 0}, {0x5829, 0x26, 0, 0},
+	{0x582a, 0x24, 0, 0}, {0x582b, 0x22, 0, 0}, {0x582c, 0x24, 0, 0},
+	{0x582d, 0x24, 0, 0}, {0x582e, 0x06, 0, 0}, {0x582f, 0x22, 0, 0},
+	{0x5830, 0x40, 0, 0}, {0x5831, 0x42, 0, 0}, {0x5832, 0x24, 0, 0},
+	{0x5833, 0x26, 0, 0}, {0x5834, 0x24, 0, 0}, {0x5835, 0x22, 0, 0},
+	{0x5836, 0x22, 0, 0}, {0x5837, 0x26, 0, 0}, {0x5838, 0x44, 0, 0},
+	{0x5839, 0x24, 0, 0}, {0x583a, 0x26, 0, 0}, {0x583b, 0x28, 0, 0},
+	{0x583c, 0x42, 0, 0}, {0x583d, 0xce, 0, 0}, {0x5025, 0x00, 0, 0},
+	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
+	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
+	{0x3008, 0x02, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_VGA_640_480[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0}, {0x380a, 0x01, 0, 0},
-	{0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0}, {0x3503, 0x00, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_VGA_640_480[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0}, {0x3503, 0x00, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_QVGA_320_240[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0}, {0x380a, 0x01, 0, 0},
-	{0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3808, 0x01, 0, 0},
-	{0x3809, 0x40, 0, 0}, {0x380a, 0x00, 0, 0}, {0x380b, 0xf0, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x01, 0, 0}, {0x3809, 0x40, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0xf0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_QVGA_320_240[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x01, 0, 0}, {0x3809, 0x40, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0xf0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_NTSC_720_480[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0}, {0x380a, 0x01, 0, 0},
-	{0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x60, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0},
+	{0x3807, 0xd4, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_NTSC_720_480[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0},
+	{0x3807, 0xd4, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_PAL_720_576[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x60, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x09, 0, 0}, {0x3805, 0x7e, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x02, 0, 0}, {0x380b, 0x40, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_PAL_720_576[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x60, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x09, 0, 0}, {0x3805, 0x7e, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x02, 0, 0}, {0x380b, 0x40, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
+	{0x3035, 0x21, 0, 0}, {0x3036, 0x69, 0, 0}, {0x3c07, 0x07, 0, 0},
 	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
 	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0}, {0x380a, 0x02, 0, 0},
-	{0x380b, 0x40, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x62, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0xfa, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0}, {0x3807, 0xa9, 0, 0},
+	{0x3808, 0x05, 0, 0}, {0x3809, 0x00, 0, 0}, {0x380a, 0x02, 0, 0},
+	{0x380b, 0xd0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x64, 0, 0},
+	{0x380e, 0x02, 0, 0}, {0x380f, 0xe4, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3709, 0x52, 0, 0},
+	{0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0}, {0x3a03, 0xe0, 0, 0},
+	{0x3a14, 0x02, 0, 0}, {0x3a15, 0xe0, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0}, {0x4713, 0x03, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
+	{0x4837, 0x16, 0, 0}, {0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x3503, 0x00, 0, 0},
 };
 
-static struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x69, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x27, 0, 0}, {0x3814, 0x31, 0, 0},
+static struct reg_value ov5640_setting_15fps_720P_1280_720[] = {
+	{0x3035, 0x41, 0, 0}, {0x3036, 0x69, 0, 0}, {0x3c07, 0x07, 0, 0},
+	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
 	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
 	{0x3802, 0x00, 0, 0}, {0x3803, 0xfa, 0, 0}, {0x3804, 0x0a, 0, 0},
 	{0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0}, {0x3807, 0xa9, 0, 0},
 	{0x3808, 0x05, 0, 0}, {0x3809, 0x00, 0, 0}, {0x380a, 0x02, 0, 0},
 	{0x380b, 0xd0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x64, 0, 0},
-	{0x380e, 0x02, 0, 0}, {0x380f, 0xe4, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0},
-	{0x3a03, 0xe4, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0xbc, 0, 0},
-	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x72, 0, 0}, {0x3a0e, 0x01, 0, 0},
-	{0x3a0d, 0x02, 0, 0}, {0x3a14, 0x02, 0, 0}, {0x3a15, 0xe4, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x00, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xff, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x02, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0x83, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x21, 0, 0}, {0x3002, 0x1c, 0, 0},
-	{0x3006, 0xc3, 0, 0}, {0x3821, 0x07, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x460b, 0x37, 0, 0},
+	{0x380e, 0x02, 0, 0}, {0x380f, 0xe4, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3709, 0x52, 0, 0},
+	{0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0}, {0x3a03, 0xe0, 0, 0},
+	{0x3a14, 0x02, 0, 0}, {0x3a15, 0xe0, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0}, {0x4713, 0x03, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
+	{0x4837, 0x16, 0, 0}, {0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x3503, 0x00, 0, 0},
 };
 
-static struct reg_value ov5640_setting_30fps_1080P_1920_1080[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x69, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x26, 0, 0}, {0x3814, 0x11, 0, 0},
-	{0x3815, 0x11, 0, 0}, {0x3800, 0x01, 0, 0}, {0x3801, 0x50, 0, 0},
-	{0x3802, 0x01, 0, 0}, {0x3803, 0xb2, 0, 0}, {0x3804, 0x08, 0, 0},
-	{0x3805, 0xef, 0, 0}, {0x3806, 0x05, 0, 0}, {0x3807, 0xf2, 0, 0},
-	{0x3808, 0x07, 0, 0}, {0x3809, 0x80, 0, 0}, {0x380a, 0x04, 0, 0},
-	{0x380b, 0x38, 0, 0}, {0x380c, 0x09, 0, 0}, {0x380d, 0xc4, 0, 0},
-	{0x380e, 0x04, 0, 0}, {0x380f, 0x60, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
-	{0x3618, 0x04, 0, 0}, {0x3612, 0x2b, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x04, 0, 0},
-	{0x3a03, 0x60, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x50, 0, 0},
-	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x18, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x04, 0, 0}, {0x3a15, 0x60, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x00, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xff, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x02, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0x83, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x21, 0, 0}, {0x3002, 0x1c, 0, 0},
-	{0x3006, 0xc3, 0, 0}, {0x3821, 0x06, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x460b, 0x37, 0, 0},
+static struct reg_value ov5640_setting_30fps_QCIF_176_144[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x00, 0, 0}, {0x3809, 0xb0, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0x90, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_QCIF_176_144[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x00, 0, 0}, {0x3809, 0xb0, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0x90, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_30fps_XGA_1024_768[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x04, 0, 0}, {0x3809, 0x00, 0, 0},
+	{0x380a, 0x03, 0, 0}, {0x380b, 0x00, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x69, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_XGA_1024_768[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x04, 0, 0}, {0x3809, 0x00, 0, 0},
+	{0x380a, 0x03, 0, 0}, {0x380b, 0x00, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+
+static struct reg_value ov5640_setting_15fps_1080P_1920_1080[] = {
+	{0x3c07, 0x07, 0, 0}, {0x3820, 0x40, 0, 0}, {0x3821, 0x06, 0, 0},
+	{0x3814, 0x11, 0, 0}, {0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0xee, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x05, 0, 0},
+	{0x3807, 0xc3, 0, 0}, {0x3808, 0x07, 0, 0}, {0x3809, 0x80, 0, 0},
+	{0x380a, 0x04, 0, 0}, {0x380b, 0x38, 0, 0}, {0x380c, 0x0b, 0, 0},
+	{0x380d, 0x1c, 0, 0}, {0x380e, 0x07, 0, 0}, {0x380f, 0xb0, 0, 0},
+	{0x3813, 0x04, 0, 0}, {0x3618, 0x04, 0, 0}, {0x3612, 0x2b, 0, 0},
+	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x07, 0, 0},
+	{0x3a03, 0xae, 0, 0}, {0x3a14, 0x07, 0, 0}, {0x3a15, 0xae, 0, 0},
+	{0x4004, 0x06, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x02, 0, 0}, {0x4407, 0x0c, 0, 0}, {0x460b, 0x37, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x2c, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0x83, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x69, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_QSXGA_2592_1944[] = {
+	{0x3c07, 0x07, 0, 0}, {0x3820, 0x40, 0, 0}, {0x3821, 0x06, 0, 0},
+	{0x3814, 0x11, 0, 0}, {0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x00, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9f, 0, 0}, {0x3808, 0x0a, 0, 0}, {0x3809, 0x20, 0, 0},
+	{0x380a, 0x07, 0, 0}, {0x380b, 0x98, 0, 0}, {0x380c, 0x0b, 0, 0},
+	{0x380d, 0x1c, 0, 0}, {0x380e, 0x07, 0, 0}, {0x380f, 0xb0, 0, 0},
+	{0x3813, 0x04, 0, 0}, {0x3618, 0x04, 0, 0}, {0x3612, 0x2b, 0, 0},
+	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x07, 0, 0},
+	{0x3a03, 0xae, 0, 0}, {0x3a14, 0x07, 0, 0}, {0x3a15, 0xae, 0, 0},
+	{0x4004, 0x06, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x02, 0, 0}, {0x4407, 0x0c, 0, 0}, {0x460b, 0x37, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x2c, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0x83, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x69, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct ov5640_mode_info ov5640_mode_info_data[2][ov5640_mode_MAX + 1] = {
 	{
-		{ov5640_mode_VGA_640_480, 0, 0, NULL, 0},
-		{ov5640_mode_QVGA_320_240, 0, 0, NULL, 0},
-		{ov5640_mode_NTSC_720_480, 0, 0, NULL, 0},
-		{ov5640_mode_PAL_720_576, 0, 0, NULL, 0},
-		{ov5640_mode_720P_1280_720, 0, 0, NULL, 0},
-		{ov5640_mode_1080P_1920_1080, 0, 0, NULL, 0},
+		{ov5640_mode_VGA_640_480,      640,  480,
+		ov5640_setting_15fps_VGA_640_480,
+		ARRAY_SIZE(ov5640_setting_15fps_VGA_640_480)},
+		{ov5640_mode_QVGA_320_240,     320,  240,
+		ov5640_setting_15fps_QVGA_320_240,
+		ARRAY_SIZE(ov5640_setting_15fps_QVGA_320_240)},
+		{ov5640_mode_NTSC_720_480,     720,  480,
+		ov5640_setting_15fps_NTSC_720_480,
+		ARRAY_SIZE(ov5640_setting_15fps_NTSC_720_480)},
+		{ov5640_mode_PAL_720_576,      720,  576,
+		ov5640_setting_15fps_PAL_720_576,
+		ARRAY_SIZE(ov5640_setting_15fps_PAL_720_576)},
+		{ov5640_mode_720P_1280_720,   1280,  720,
+		ov5640_setting_15fps_720P_1280_720,
+		ARRAY_SIZE(ov5640_setting_15fps_720P_1280_720)},
+		{ov5640_mode_1080P_1920_1080, 1920, 1080,
+		ov5640_setting_15fps_1080P_1920_1080,
+		ARRAY_SIZE(ov5640_setting_15fps_1080P_1920_1080)},
 		{ov5640_mode_QSXGA_2592_1944, 2592, 1944,
 		ov5640_setting_15fps_QSXGA_2592_1944,
 		ARRAY_SIZE(ov5640_setting_15fps_QSXGA_2592_1944)},
+		{ov5640_mode_QCIF_176_144,     176,  144,
+		ov5640_setting_15fps_QCIF_176_144,
+		ARRAY_SIZE(ov5640_setting_15fps_QCIF_176_144)},
+		{ov5640_mode_XGA_1024_768,    1024,  768,
+		ov5640_setting_15fps_XGA_1024_768,
+		ARRAY_SIZE(ov5640_setting_15fps_XGA_1024_768)},
 	},
 	{
-		{ov5640_mode_VGA_640_480,    640,  480,
+		{ov5640_mode_VGA_640_480,      640,  480,
 		ov5640_setting_30fps_VGA_640_480,
 		ARRAY_SIZE(ov5640_setting_30fps_VGA_640_480)},
-		{ov5640_mode_QVGA_320_240,   320,  240,
+		{ov5640_mode_QVGA_320_240,     320,  240,
 		ov5640_setting_30fps_QVGA_320_240,
 		ARRAY_SIZE(ov5640_setting_30fps_QVGA_320_240)},
-		{ov5640_mode_NTSC_720_480,   720, 480,
+		{ov5640_mode_NTSC_720_480,     720,  480,
 		ov5640_setting_30fps_NTSC_720_480,
 		ARRAY_SIZE(ov5640_setting_30fps_NTSC_720_480)},
-		{ov5640_mode_PAL_720_576,    720, 576,
+		{ov5640_mode_PAL_720_576,      720,  576,
 		ov5640_setting_30fps_PAL_720_576,
 		ARRAY_SIZE(ov5640_setting_30fps_PAL_720_576)},
-		{ov5640_mode_720P_1280_720,  1280, 720,
+		{ov5640_mode_720P_1280_720,   1280,  720,
 		ov5640_setting_30fps_720P_1280_720,
 		ARRAY_SIZE(ov5640_setting_30fps_720P_1280_720)},
-		{ov5640_mode_1080P_1920_1080,  1920, 1080,
-		ov5640_setting_30fps_1080P_1920_1080,
-		ARRAY_SIZE(ov5640_setting_30fps_1080P_1920_1080)},
+		{ov5640_mode_1080P_1920_1080, 0, 0, NULL, 0},
 		{ov5640_mode_QSXGA_2592_1944, 0, 0, NULL, 0},
+		{ov5640_mode_QCIF_176_144,     176,  144,
+		ov5640_setting_30fps_QCIF_176_144,
+		ARRAY_SIZE(ov5640_setting_30fps_QCIF_176_144)},
+		{ov5640_mode_XGA_1024_768,    1024,  768,
+		ov5640_setting_30fps_XGA_1024_768,
+		ARRAY_SIZE(ov5640_setting_30fps_XGA_1024_768)},
 	},
 };
 
@@ -795,6 +569,7 @@ static s32 ov5640_write_reg(u16 reg, u8 val);
 
 static const struct i2c_device_id ov5640_id[] = {
 	{"ov5640", 0},
+	{"ov564x", 0},
 	{},
 };
 
@@ -853,36 +628,317 @@ static s32 ov5640_read_reg(u16 reg, u8 *val)
 	return u8RdVal;
 }
 
-static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,
-			    enum ov5640_mode mode)
+static void ov5640_soft_reset(void)
 {
-	struct reg_value *pModeSetting = NULL;
-	s32 i = 0;
-	s32 iModeSettingArySize = 0;
-	register u32 Delay_ms = 0;
-	register u16 RegAddr = 0;
-	register u8 Mask = 0;
-	register u8 Val = 0;
-	u8 RegVal = 0;
-	int retval = 0;
+	/* sysclk from pad */
+	ov5640_write_reg(0x3103, 0x11);
 
-	if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
-		pr_err("Wrong ov5640 mode detected!\n");
+	/* software reset */
+	ov5640_write_reg(0x3008, 0x82);
+
+	/* delay at least 5ms */
+	msleep(10);
+}
+
+/* set sensor driver capability
+ * 0x302c[7:6] - strength
+	00     - 1x
+	01     - 2x
+	10     - 3x
+	11     - 4x
+ */
+static int ov5640_driver_capability(int strength)
+{
+	u8 temp = 0;
+
+	if (strength > 4 || strength < 1) {
+		pr_err("The valid driver capability of ov5640 is 1x~4x\n");
+		return -EINVAL;
+	}
+
+	ov5640_read_reg(0x302c, &temp);
+
+	temp &= ~0xc0;	/* clear [7:6] */
+	temp |= ((strength - 1) << 6);	/* set [7:6] */
+
+	ov5640_write_reg(0x302c, temp);
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_get_sysclk(void)
+{
+	int xvclk = ov5640_data.mclk / 10000;
+	int sysclk;
+	int temp1, temp2;
+	int Multiplier, PreDiv, VCO, SysDiv, Pll_rdiv, Bit_div2x, sclk_rdiv;
+	int sclk_rdiv_map[] = {1, 2, 4, 8};
+	u8 regval = 0;
+
+	temp1 = ov5640_read_reg(0x3034, &regval);
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10) {
+		Bit_div2x = temp2 / 2;
+	} else {
+		pr_err("ov5640: unsupported bit mode %d\n", temp2);
 		return -1;
 	}
 
-	pModeSetting = ov5640_mode_info_data[frame_rate][mode].init_data_ptr;
-	iModeSettingArySize =
-		ov5640_mode_info_data[frame_rate][mode].init_data_size;
+	temp1 = ov5640_read_reg(0x3035, &regval);
+	SysDiv = temp1 >> 4;
+	if (SysDiv == 0)
+		SysDiv = 16;
 
-	ov5640_data.pix.width = ov5640_mode_info_data[frame_rate][mode].width;
-	ov5640_data.pix.height = ov5640_mode_info_data[frame_rate][mode].height;
+	temp1 = ov5640_read_reg(0x3036, &regval);
+	Multiplier = temp1;
+	temp1 = ov5640_read_reg(0x3037, &regval);
+	PreDiv = temp1 & 0x0f;
+	Pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
 
-	if (ov5640_data.pix.width == 0 || ov5640_data.pix.height == 0 ||
-	    pModeSetting == NULL || iModeSettingArySize == 0)
-		return -EINVAL;
+	temp1 = ov5640_read_reg(0x3108, &regval);
+	temp2 = temp1 & 0x03;
+
+	sclk_rdiv = sclk_rdiv_map[temp2];
+	VCO = xvclk * Multiplier / PreDiv;
+	sysclk = VCO / SysDiv / Pll_rdiv * 2 / Bit_div2x / sclk_rdiv;
 
-	for (i = 0; i < iModeSettingArySize; ++i, ++pModeSetting) {
+	return sysclk;
+}
+
+/* read HTS from register settings */
+static int ov5640_get_HTS(void)
+{
+	int HTS;
+	u8 temp = 0;
+
+	HTS = ov5640_read_reg(0x380c, &temp);
+	HTS = (HTS<<8) + ov5640_read_reg(0x380d, &temp);
+	return HTS;
+}
+
+/* read VTS from register settings */
+static int ov5640_get_VTS(void)
+{
+	int VTS;
+	u8 temp = 0;
+
+	VTS = ov5640_read_reg(0x380e, &temp);
+	VTS = (VTS<<8) + ov5640_read_reg(0x380f, &temp);
+
+	return VTS;
+}
+
+/* write VTS to registers */
+static int ov5640_set_VTS(int VTS)
+{
+	int temp;
+
+	temp = VTS & 0xff;
+	ov5640_write_reg(0x380f, temp);
+
+	temp = VTS>>8;
+	ov5640_write_reg(0x380e, temp);
+	return 0;
+}
+
+/* read shutter, in number of line period */
+static int ov5640_get_shutter(void)
+{
+	int shutter;
+	u8 regval;
+
+	shutter = (ov5640_read_reg(0x03500, &regval) & 0x0f);
+
+	shutter = (shutter<<8) + ov5640_read_reg(0x3501, &regval);
+	shutter = (shutter<<4) + (ov5640_read_reg(0x3502, &regval)>>4);
+
+	return shutter;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_set_shutter(int shutter)
+{
+	int temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp<<4;
+	ov5640_write_reg(0x3502, temp);
+
+	temp = shutter & 0xfff;
+	temp = temp>>4;
+	ov5640_write_reg(0x3501, temp);
+
+	temp = shutter>>12;
+	ov5640_write_reg(0x3500, temp);
+
+	return 0;
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_get_gain16(void)
+{
+	int gain16;
+	u8 regval;
+
+	gain16 = ov5640_read_reg(0x350a, &regval) & 0x03;
+	gain16 = (gain16<<8) + ov5640_read_reg(0x350b, &regval);
+
+	return gain16;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_set_gain16(int gain16)
+{
+	int temp;
+
+	gain16 = gain16 & 0x3ff;
+	temp = gain16 & 0xff;
+
+	ov5640_write_reg(0x350b, temp);
+	temp = gain16>>8;
+
+	ov5640_write_reg(0x350a, temp);
+	return 0;
+}
+
+/* get banding filter value */
+static int ov5640_get_light_freq(void)
+{
+	int temp, temp1, light_frequency;
+	u8 regval;
+
+	temp = ov5640_read_reg(0x3c01, &regval);
+	if (temp & 0x80) {
+		/* manual */
+		temp1 = ov5640_read_reg(0x3c00, &regval);
+		if (temp1 & 0x04) {
+			/* 50Hz */
+			light_frequency = 50;
+		} else {
+			/* 60Hz */
+			light_frequency = 60;
+		}
+	} else {
+		/* auto */
+		temp1 = ov5640_read_reg(0x3c0c, &regval);
+		if (temp1 & 0x01) {
+			/* 50Hz */
+			light_frequency = 50;
+		} else {
+			/* 60Hz */
+			light_frequency = 60;
+		}
+	}
+
+	return light_frequency;
+}
+
+static void ov5640_set_bandingfilter(void)
+{
+	int prev_VTS;
+	int band_step60, max_band60, band_step50, max_band50;
+
+	/* read preview PCLK */
+	prev_sysclk = ov5640_get_sysclk();
+
+	/* read preview HTS */
+	prev_HTS = ov5640_get_HTS();
+
+	/* read preview VTS */
+	prev_VTS = ov5640_get_VTS();
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = prev_sysclk * 100/prev_HTS * 100/120;
+	ov5640_write_reg(0x3a0a, (band_step60 >> 8));
+	ov5640_write_reg(0x3a0b, (band_step60 & 0xff));
+
+	max_band60 = (int)((prev_VTS-4)/band_step60);
+	ov5640_write_reg(0x3a0d, max_band60);
+
+	/* 50Hz */
+	band_step50 = prev_sysclk * 100/prev_HTS;
+	ov5640_write_reg(0x3a08, (band_step50 >> 8));
+	ov5640_write_reg(0x3a09, (band_step50 & 0xff));
+
+	max_band50 = (int)((prev_VTS-4)/band_step50);
+	ov5640_write_reg(0x3a0e, max_band50);
+}
+
+/* stable in high */
+static int ov5640_set_AE_target(int target)
+{
+	int fast_high, fast_low;
+
+	AE_low = target * 23 / 25; /* 0.92 */
+	AE_high = target * 27 / 25; /* 1.08 */
+	fast_high = AE_high << 1;
+
+	if (fast_high > 255)
+		fast_high = 255;
+	fast_low = AE_low >> 1;
+
+	ov5640_write_reg(0x3a0f, AE_high);
+	ov5640_write_reg(0x3a10, AE_low);
+	ov5640_write_reg(0x3a1b, AE_high);
+	ov5640_write_reg(0x3a1e, AE_low);
+	ov5640_write_reg(0x3a11, fast_high);
+	ov5640_write_reg(0x3a1f, fast_low);
+
+	return 0;
+}
+
+/* enable = 0 to turn off night mode
+   enable = 1 to turn on night mode */
+static int ov5640_set_night_mode(int enable)
+{
+	u8 mode;
+
+	ov5640_read_reg(0x3a00, &mode);
+
+	if (enable) {
+		/* night mode on */
+		mode |= 0x04;
+		ov5640_write_reg(0x3a00, mode);
+	} else {
+		/* night mode off */
+		mode &= 0xfb;
+		ov5640_write_reg(0x3a00, mode);
+	}
+
+	return 0;
+}
+
+/* enable = 0 to turn off AEC/AGC
+   enable = 1 to turn on AEC/AGC */
+void ov5640_turn_on_AE_AG(int enable)
+{
+	u8 ae_ag_ctrl;
+
+	ov5640_read_reg(0x3503, &ae_ag_ctrl);
+	if (enable) {
+		/* turn on auto AE/AG */
+		ae_ag_ctrl = ae_ag_ctrl & ~(0x03);
+	} else {
+		/* turn off AE/AG */
+		ae_ag_ctrl = ae_ag_ctrl | 0x03;
+	}
+	ov5640_write_reg(0x3503, ae_ag_ctrl);
+}
+
+/* download ov5640 settings to sensor through i2c */
+static int ov5640_download_firmware(struct reg_value *pModeSetting, s32 ArySize)
+{
+	register u32 Delay_ms = 0;
+	register u16 RegAddr = 0;
+	register u8 Mask = 0;
+	register u8 Val = 0;
+	u8 RegVal = 0;
+	int i, retval = 0;
+
+	for (i = 0; i < ArySize; ++i, ++pModeSetting) {
 		Delay_ms = pModeSetting->u32Delay_ms;
 		RegAddr = pModeSetting->u16RegAddr;
 		Val = pModeSetting->u8Val;
@@ -909,6 +965,251 @@ err:
 	return retval;
 }
 
+static int ov5640_init_mode(void)
+{
+	struct reg_value *pModeSetting = NULL;
+	int ArySize = 0, retval = 0;
+
+	ov5640_soft_reset();
+
+	pModeSetting = ov5640_global_init_setting;
+	ArySize = ARRAY_SIZE(ov5640_global_init_setting);
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+	if (retval < 0)
+		goto err;
+
+	pModeSetting = ov5640_init_setting_30fps_VGA;
+	ArySize = ARRAY_SIZE(ov5640_init_setting_30fps_VGA);
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+	if (retval < 0)
+		goto err;
+
+	/* change driver capability to 2x according to validation board.
+	 * if the image is not stable, please increase the driver strength.
+	 */
+	ov5640_driver_capability(2);
+	ov5640_set_bandingfilter();
+	ov5640_set_AE_target(AE_Target);
+	ov5640_set_night_mode(night_mode);
+
+	/* skip 9 vysnc: start capture at 10th vsync */
+	msleep(300);
+
+	/* turn off night mode */
+	night_mode = 0;
+	ov5640_data.pix.width = 640;
+	ov5640_data.pix.height = 480;
+err:
+	return retval;
+}
+
+/* change to or back to subsampling mode set the mode directly
+ * image size below 1280 * 960 is subsampling mode */
+static int ov5640_change_mode_direct(enum ov5640_frame_rate frame_rate,
+			    enum ov5640_mode mode)
+{
+	struct reg_value *pModeSetting = NULL;
+	s32 ArySize = 0;
+	int retval = 0;
+
+	if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
+		pr_err("Wrong ov5640 mode detected!\n");
+		return -1;
+	}
+
+	pModeSetting = ov5640_mode_info_data[frame_rate][mode].init_data_ptr;
+	ArySize =
+		ov5640_mode_info_data[frame_rate][mode].init_data_size;
+
+	ov5640_data.pix.width = ov5640_mode_info_data[frame_rate][mode].width;
+	ov5640_data.pix.height = ov5640_mode_info_data[frame_rate][mode].height;
+
+	if (ov5640_data.pix.width == 0 || ov5640_data.pix.height == 0 ||
+	    pModeSetting == NULL || ArySize == 0)
+		return -EINVAL;
+
+	/* set ov5640 to subsampling mode */
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+
+	/* turn on AE AG for subsampling mode, in case the firmware didn't */
+	ov5640_turn_on_AE_AG(1);
+
+	/* calculate banding filter */
+	ov5640_set_bandingfilter();
+
+	/* set AE target */
+	ov5640_set_AE_target(AE_Target);
+
+	/* update night mode setting */
+	ov5640_set_night_mode(night_mode);
+
+	/* skip 9 vysnc: start capture at 10th vsync */
+	if (mode == ov5640_mode_XGA_1024_768 && frame_rate == ov5640_30_fps) {
+		pr_warning("ov5640: actual frame rate of XGA is 22.5fps\n");
+		/* 1/22.5 * 9*/
+		msleep(400);
+		return retval;
+	}
+
+	if (frame_rate == ov5640_15_fps) {
+		/* 1/15 * 9*/
+		msleep(600);
+	} else if (frame_rate == ov5640_30_fps) {
+		/* 1/30 * 9*/
+		msleep(300);
+	}
+
+	return retval;
+}
+
+/* change to scaling mode go through exposure calucation
+ * image size above 1280 * 960 is scaling mode */
+static int ov5640_change_mode_exposure_calc(enum ov5640_frame_rate frame_rate,
+			    enum ov5640_mode mode)
+{
+	int prev_shutter, prev_gain16, average;
+	int cap_shutter, cap_gain16;
+	int cap_sysclk, cap_HTS, cap_VTS;
+	int light_freq, cap_bandfilt, cap_maxband;
+	long cap_gain16_shutter;
+	u8 temp;
+	struct reg_value *pModeSetting = NULL;
+	s32 ArySize = 0;
+	int retval = 0;
+
+	/* check if the input mode and frame rate is valid */
+	pModeSetting =
+		ov5640_mode_info_data[frame_rate][mode].init_data_ptr;
+	ArySize =
+		ov5640_mode_info_data[frame_rate][mode].init_data_size;
+
+	ov5640_data.pix.width =
+		ov5640_mode_info_data[frame_rate][mode].width;
+	ov5640_data.pix.height =
+		ov5640_mode_info_data[frame_rate][mode].height;
+
+	if (ov5640_data.pix.width == 0 || ov5640_data.pix.height == 0 ||
+		pModeSetting == NULL || ArySize == 0)
+		return -EINVAL;
+
+	/* read preview shutter */
+	prev_shutter = ov5640_get_shutter();
+
+	/* read preview gain */
+	prev_gain16 = ov5640_get_gain16();
+
+	/* get average */
+	average = ov5640_read_reg(0x56a1, &temp);
+
+	/* turn off night mode for capture */
+	ov5640_set_night_mode(0);
+
+	/* turn off overlay */
+	ov5640_write_reg(0x3022, 0x06);
+
+	/* Write capture setting */
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+	if (retval < 0)
+		goto err;
+
+	/* turn off AE AG when capture image. */
+	ov5640_turn_on_AE_AG(0);
+
+	/* read capture VTS */
+	cap_VTS = ov5640_get_VTS();
+	cap_HTS = ov5640_get_HTS();
+	cap_sysclk = ov5640_get_sysclk();
+
+	/* calculate capture banding filter */
+	light_freq = ov5640_get_light_freq();
+	if (light_freq == 60) {
+		/* 60Hz */
+		cap_bandfilt = cap_sysclk * 100 / cap_HTS * 100 / 120;
+	} else {
+		/* 50Hz */
+		cap_bandfilt = cap_sysclk * 100 / cap_HTS;
+	}
+	cap_maxband = (int)((cap_VTS - 4)/cap_bandfilt);
+	/* calculate capture shutter/gain16 */
+	if (average > AE_low && average < AE_high) {
+		/* in stable range */
+		cap_gain16_shutter =
+			prev_gain16 * prev_shutter * cap_sysclk/prev_sysclk *
+			prev_HTS/cap_HTS * AE_Target / average;
+	} else {
+		cap_gain16_shutter =
+			prev_gain16 * prev_shutter * cap_sysclk/prev_sysclk *
+			prev_HTS/cap_HTS;
+	}
+
+	/* gain to shutter */
+	if (cap_gain16_shutter < (cap_bandfilt * 16)) {
+		/* shutter < 1/100 */
+		cap_shutter = cap_gain16_shutter/16;
+		if (cap_shutter < 1)
+			cap_shutter = 1;
+		cap_gain16 = cap_gain16_shutter/cap_shutter;
+		if (cap_gain16 < 16)
+			cap_gain16 = 16;
+	} else {
+		if (cap_gain16_shutter > (cap_bandfilt*cap_maxband*16)) {
+			/* exposure reach max */
+			cap_shutter = cap_bandfilt*cap_maxband;
+			cap_gain16 = cap_gain16_shutter / cap_shutter;
+		} else {
+			/* 1/100 < cap_shutter =< max, cap_shutter = n/100 */
+			cap_shutter =
+				((int)(cap_gain16_shutter/16/cap_bandfilt))
+				* cap_bandfilt;
+			cap_gain16 = cap_gain16_shutter / cap_shutter;
+		}
+	}
+
+	/* write capture gain */
+	ov5640_set_gain16(cap_gain16);
+
+	/* write capture shutter */
+	if (cap_shutter > (cap_VTS - 4)) {
+		cap_VTS = cap_shutter + 4;
+		ov5640_set_VTS(cap_VTS);
+	}
+
+	ov5640_set_shutter(cap_shutter);
+
+	/* skip 2 vysnc: start capture at 3rd vsync
+	 * frame rate of QSXGA and 1080P is 7.5fps: 1/7.5 * 2
+	 */
+	pr_warning("ov5640: the actual frame rate of %s is 7.5fps\n",
+		mode == ov5640_mode_1080P_1920_1080 ? "1080P" : "QSXGA");
+	msleep(267);
+err:
+	return retval;
+}
+
+static int ov5640_change_mode(enum ov5640_frame_rate frame_rate,
+			    enum ov5640_mode mode)
+{
+	int retval = 0;
+
+	if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
+		pr_err("Wrong ov5640 mode detected!\n");
+		return -1;
+	}
+
+	if (mode == ov5640_mode_1080P_1920_1080 ||
+			mode == ov5640_mode_QSXGA_2592_1944) {
+		/* change to scaling mode go through exposure calucation
+		 * image size above 1280 * 960 is scaling mode */
+		retval = ov5640_change_mode_exposure_calc(frame_rate, mode);
+	} else {
+		/* change back to subsampling modem download firmware directly
+		 * image size below 1280 * 960 is subsampling mode */
+		retval = ov5640_change_mode_direct(frame_rate, mode);
+	}
+
+	return retval;
+}
+
 /* --------------- IOCTL functions from v4l2_int_ioctl_desc --------------- */
 
 static int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)
@@ -1076,12 +1377,14 @@ static int ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
 			return -EINVAL;
 		}
 
+		ret = ov5640_change_mode(frame_rate,
+				a->parm.capture.capturemode);
+		if (ret < 0)
+			return ret;
+
 		sensor->streamcap.timeperframe = *timeperframe;
-		sensor->streamcap.capturemode =
-				(u32)a->parm.capture.capturemode;
+		sensor->streamcap.capturemode = a->parm.capture.capturemode;
 
-		ret = ov5640_init_mode(frame_rate,
-				       sensor->streamcap.capturemode);
 		break;
 
 	/* These are all the possible cases. */
@@ -1243,6 +1546,50 @@ static int ioctl_enum_framesizes(struct v4l2_int_device *s,
 }
 
 /*!
+ * ioctl_enum_frameintervals - V4L2 sensor interface handler for
+ *			       VIDIOC_ENUM_FRAMEINTERVALS ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fival: standard V4L2 VIDIOC_ENUM_FRAMEINTERVALS ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+					 struct v4l2_frmivalenum *fival)
+{
+	int i, j, count;
+
+	if (fival->index < 0 || fival->index > ov5640_mode_MAX)
+		return -EINVAL;
+
+	if (fival->pixel_format == 0 || fival->width == 0 || fival->height == 0) {
+		pr_warning("Please assign pixelformat, width and height.\n");
+		return -EINVAL;
+	}
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+
+	count = 0;
+	for (i = 0; i < ARRAY_SIZE(ov5640_mode_info_data); i++) {
+		for (j = 0; j < (ov5640_mode_MAX + 1); j++) {
+			if (fival->pixel_format == ov5640_data.pix.pixelformat
+			 && fival->width == ov5640_mode_info_data[i][j].width
+			 && fival->height == ov5640_mode_info_data[i][j].height
+			 && ov5640_mode_info_data[i][j].init_data_ptr != NULL) {
+				count++;
+			}
+			if (fival->index == (count - 1)) {
+				fival->discrete.denominator =
+						ov5640_framerates[i];
+				return 0;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+/*!
  * ioctl_g_chip_ident - V4L2 sensor interface handler for
  *			VIDIOC_DBG_G_CHIP_IDENT ioctl
  * @s: pointer to standard V4L2 device structure
@@ -1299,6 +1646,7 @@ static int ioctl_dev_init(struct v4l2_int_device *s)
 	u32 tgt_xclk;	/* target xclk */
 	u32 tgt_fps;	/* target frames per secound */
 	enum ov5640_frame_rate frame_rate;
+	int ret;
 
 	ov5640_data.on = true;
 
@@ -1322,8 +1670,8 @@ static int ioctl_dev_init(struct v4l2_int_device *s)
 	else
 		return -EINVAL; /* Only support 15fps or 30fps now. */
 
-	return ov5640_init_mode(frame_rate,
-				sensor->streamcap.capturemode);
+	ret = ov5640_init_mode();
+	return ret;
 }
 
 /*!
@@ -1363,6 +1711,8 @@ static struct v4l2_int_ioctl_desc ov5640_ioctl_desc[] = {
 	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func *)ioctl_s_ctrl},
 	{vidioc_int_enum_framesizes_num,
 				(v4l2_int_ioctl_func *)ioctl_enum_framesizes},
+	{vidioc_int_enum_frameintervals_num,
+				(v4l2_int_ioctl_func *)ioctl_enum_frameintervals},
 	{vidioc_int_g_chip_ident_num,
 				(v4l2_int_ioctl_func *)ioctl_g_chip_ident},
 };
@@ -1392,6 +1742,7 @@ static int ov5640_probe(struct i2c_client *client,
 {
 	int retval;
 	struct fsl_mxc_camera_platform_data *plat_data = client->dev.platform_data;
+	u8 chip_id_high, chip_id_low;
 
 	/* Set initial values for the sensor struct. */
 	memset(&ov5640_data, 0, sizeof(ov5640_data));
@@ -1469,13 +1820,45 @@ static int ov5640_probe(struct i2c_client *client,
 	if (plat_data->io_init)
 		plat_data->io_init();
 
+	if (plat_data->pwdn)
+		plat_data->pwdn(0);
+
+#ifdef CONFIG_SOC_IMX6SL
+	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+#endif
+	retval = ov5640_read_reg(OV5640_CHIP_ID_HIGH_BYTE, &chip_id_high);
+	if (retval < 0 || chip_id_high != 0x56) {
+		pr_warning("camera ov5640 is not found\n");
+		retval = -ENODEV;
+		goto err4;
+	}
+	retval = ov5640_read_reg(OV5640_CHIP_ID_LOW_BYTE, &chip_id_low);
+	if (retval < 0 || chip_id_low != 0x40) {
+		pr_warning("camera ov5640 is not found\n");
+		retval = -ENODEV;
+		goto err4;
+	}
+
+	if (plat_data->pwdn)
+		plat_data->pwdn(1);
+
+#ifdef CONFIG_SOC_IMX6SL
+	csi_enable_mclk(CSI_MCLK_I2C, false, false);
+#endif
+
 	camera_plat = plat_data;
 
 	ov5640_int_device.priv = &ov5640_data;
 	retval = v4l2_int_device_register(&ov5640_int_device);
 
+	pr_info("camera ov5640 is found\n");
 	return retval;
 
+err4:
+	if (analog_regulator) {
+		regulator_disable(analog_regulator);
+		regulator_put(analog_regulator);
+	}
 err3:
 	if (core_regulator) {
 		regulator_disable(core_regulator);
@@ -1487,7 +1870,7 @@ err2:
 		regulator_put(io_regulator);
 	}
 err1:
-	return -1;
+	return retval;
 }
 
 /*!
diff --git a/drivers/media/video/mxc/capture/ov5640_mipi.c b/drivers/media/video/mxc/capture/ov5640_mipi.c
index bde39a5..a373e5b 100644
--- a/drivers/media/video/mxc/capture/ov5640_mipi.c
+++ b/drivers/media/video/mxc/capture/ov5640_mipi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -904,6 +904,7 @@ int OV5640_get_light_freq(void)
 			light_freq = 50;
 		} else {
 			/* 60Hz */
+			light_freq = 60;
 		}
 	}
 	return light_freq;
@@ -1216,7 +1217,7 @@ static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,
 	s32 ArySize = 0;
 	int retval = 0;
 	void *mipi_csi2_info;
-	u32 mipi_reg;
+	u32 mipi_reg, msec_wait4stable = 0;
 	enum ov5640_downsize_mode dn_mode, orig_dn_mode;
 
 	if ((mode > ov5640_mode_MAX || mode < ov5640_mode_MIN)
@@ -1288,6 +1289,20 @@ static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,
 	OV5640_set_bandingfilter();
 	ov5640_set_virtual_channel(ov5640_data.csi);
 
+	/* add delay to wait for sensor stable */
+	if (mode == ov5640_mode_QSXGA_2592_1944) {
+		/* dump the first two frames: 1/7.5*2
+		 * the frame rate of QSXGA is 7.5fps */
+		msec_wait4stable = 267;
+	} else if (frame_rate == ov5640_15_fps) {
+		/* dump the first nine frames: 1/15*9 */
+		msec_wait4stable = 600;
+	} else if (frame_rate == ov5640_30_fps) {
+		/* dump the first nine frames: 1/30*9 */
+		msec_wait4stable = 300;
+	}
+	msleep(msec_wait4stable);
+
 	if (mipi_csi2_info) {
 		unsigned int i;
 
@@ -1922,13 +1937,13 @@ static int ov5640_probe(struct i2c_client *client,
 
 	retval = ov5640_read_reg(OV5640_CHIP_ID_HIGH_BYTE, &chip_id_high);
 	if (retval < 0 || chip_id_high != 0x56) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5640_mipi is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
 	retval = ov5640_read_reg(OV5640_CHIP_ID_LOW_BYTE, &chip_id_low);
 	if (retval < 0 || chip_id_low != 0x40) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5640_mipi is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
@@ -1941,6 +1956,7 @@ static int ov5640_probe(struct i2c_client *client,
 	ov5640_int_device.priv = &ov5640_data;
 	retval = v4l2_int_device_register(&ov5640_int_device);
 
+	pr_info("camera ov5640_mipi is found\n");
 	return retval;
 
 err4:
diff --git a/drivers/media/video/mxc/capture/ov5642.c b/drivers/media/video/mxc/capture/ov5642.c
index 4264382..6cf5af9 100644
--- a/drivers/media/video/mxc/capture/ov5642.c
+++ b/drivers/media/video/mxc/capture/ov5642.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -65,6 +65,11 @@ enum ov5642_frame_rate {
 	ov5642_30_fps
 };
 
+static int ov5642_framerates[] = {
+	[ov5642_15_fps] = 15,
+	[ov5642_30_fps] = 30,
+};
+
 struct reg_value {
 	u16 u16RegAddr;
 	u8 u8Val;
@@ -2994,6 +2999,7 @@ static s32 ov5642_write_reg(u16 reg, u8 val);
 
 static const struct i2c_device_id ov5642_id[] = {
 	{"ov5642", 0},
+	{"ov564x", 0},
 	{},
 };
 
@@ -3739,6 +3745,50 @@ static int ioctl_enum_framesizes(struct v4l2_int_device *s,
 }
 
 /*!
+ * ioctl_enum_frameintervals - V4L2 sensor interface handler for
+ *			       VIDIOC_ENUM_FRAMEINTERVALS ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fival: standard V4L2 VIDIOC_ENUM_FRAMEINTERVALS ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+					 struct v4l2_frmivalenum *fival)
+{
+	int i, j, count;
+
+	if (fival->index < 0 || fival->index > ov5642_mode_MAX)
+		return -EINVAL;
+
+	if (fival->pixel_format == 0 || fival->width == 0 || fival->height == 0) {
+		pr_warning("Please assign pixelformat, width and height.\n");
+		return -EINVAL;
+	}
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+
+	count = 0;
+	for (i = 0; i < ARRAY_SIZE(ov5642_mode_info_data); i++) {
+		for (j = 0; j < (ov5642_mode_MAX + 1); j++) {
+			if (fival->pixel_format == ov5642_data.pix.pixelformat
+			 && fival->width == ov5642_mode_info_data[i][j].width
+			 && fival->height == ov5642_mode_info_data[i][j].height
+			 && ov5642_mode_info_data[i][j].init_data_ptr != NULL) {
+				count++;
+			}
+			if (fival->index == (count - 1)) {
+				fival->discrete.denominator =
+						ov5642_framerates[i];
+				return 0;
+			}
+		}
+	}
+
+	return -EINVAL;
+}
+
+/*!
  * ioctl_g_chip_ident - V4L2 sensor interface handler for
  *			VIDIOC_DBG_G_CHIP_IDENT ioctl
  * @s: pointer to standard V4L2 device structure
@@ -3775,7 +3825,7 @@ static int ioctl_init(struct v4l2_int_device *s)
 static int ioctl_enum_fmt_cap(struct v4l2_int_device *s,
 			      struct v4l2_fmtdesc *fmt)
 {
-	if (fmt->index > ov5642_mode_MAX)
+	if (fmt->index > 0)	/* only 1 pixelformat support so far */
 		return -EINVAL;
 
 	fmt->pixelformat = ov5642_data.pix.pixelformat;
@@ -3894,6 +3944,8 @@ static struct v4l2_int_ioctl_desc ov5642_ioctl_desc[] = {
 	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func *)ioctl_s_ctrl},
 	{vidioc_int_enum_framesizes_num,
 				(v4l2_int_ioctl_func *)ioctl_enum_framesizes},
+	{vidioc_int_enum_frameintervals_num,
+				(v4l2_int_ioctl_func *)ioctl_enum_frameintervals},
 	{vidioc_int_g_chip_ident_num,
 				(v4l2_int_ioctl_func *)ioctl_g_chip_ident},
 };
@@ -4009,13 +4061,13 @@ static int ov5642_probe(struct i2c_client *client,
 
 	retval = ov5642_read_reg(OV5642_CHIP_ID_HIGH_BYTE, &chip_id_high);
 	if (retval < 0 || chip_id_high != 0x56) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5642 is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
 	retval = ov5642_read_reg(OV5642_CHIP_ID_LOW_BYTE, &chip_id_low);
 	if (retval < 0 || chip_id_low != 0x42) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5642 is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
@@ -4028,6 +4080,7 @@ static int ov5642_probe(struct i2c_client *client,
 	ov5642_int_device.priv = &ov5642_data;
 	retval = v4l2_int_device_register(&ov5642_int_device);
 
+	pr_info("camera ov5642 is found\n");
 	return retval;
 
 err4:
diff --git a/drivers/media/video/mxc/output/mxc_vout.c b/drivers/media/video/mxc/output/mxc_vout.c
index 388c4b3..452c573 100644
--- a/drivers/media/video/mxc/output/mxc_vout.c
+++ b/drivers/media/video/mxc/output/mxc_vout.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,8 +30,8 @@
 
 #define UYVY_BLACK	(0x00800080)
 #define RGB_BLACK	(0x0)
-#define NV12_UV_BLACK	(0x80)
-#define NV12_Y_BLACK	(0x0)
+#define UV_BLACK	(0x80)
+#define Y_BLACK		(0x0)
 
 #define MAX_FB_NUM	6
 #define FB_BUFS		3
@@ -58,6 +58,16 @@
 	       ((vout)->task.input.crop.w == FRAME_WIDTH_1080P) &&	\
 	       ((vout)->task.input.height == FRAME_HEIGHT_1080P) &&	\
 	       ((vout)->task.input.crop.h == FRAME_HEIGHT_1080P))
+#define IS_PLANAR_PIXEL_FORMAT(format) \
+	(format == IPU_PIX_FMT_NV12 ||		\
+	    format == IPU_PIX_FMT_YUV420P2 ||	\
+	    format == IPU_PIX_FMT_YUV420P ||	\
+	    format == IPU_PIX_FMT_YVU420P ||	\
+	    format == IPU_PIX_FMT_YUV422P ||	\
+	    format == IPU_PIX_FMT_YVU422P ||	\
+	    format == IPU_PIX_FMT_YUV444P)
+
+#define NSEC_PER_FRAME_30FPS		(33333333)
 
 struct mxc_vout_fb {
 	char *name;
@@ -108,11 +118,12 @@ struct mxc_vout_output {
 	struct dma_mem vdoa_output[VDOA_FB_BUFS];
 
 	bool timer_stop;
-	struct timer_list timer;
+	struct hrtimer timer;
 	struct workqueue_struct *v4l_wq;
 	struct work_struct disp_work;
 	unsigned long frame_count;
-	unsigned long start_jiffies;
+	unsigned long vdi_frame_cnt;
+	ktime_t start_ktime;
 
 	int ctrl_rotate;
 	int ctrl_vflip;
@@ -120,7 +131,8 @@ struct mxc_vout_output {
 
 	dma_addr_t disp_bufs[FB_BUFS];
 
-	struct videobuf_buffer *pre_vb;
+	struct videobuf_buffer *pre1_vb;
+	struct videobuf_buffer *pre2_vb;
 };
 
 struct mxc_vout_dev {
@@ -135,6 +147,7 @@ struct mxc_vout_dev {
 
 /* Variables configurable through module params*/
 static int debug;
+static int vdi_rate_double;
 static int video_nr = 16;
 
 /* Module parameters */
@@ -142,8 +155,10 @@ module_param(video_nr, int, S_IRUGO);
 MODULE_PARM_DESC(video_nr, "video device numbers");
 module_param(debug, int, 0600);
 MODULE_PARM_DESC(debug, "Debug level (0-1)");
+module_param(vdi_rate_double, int, 0600);
+MODULE_PARM_DESC(vdi_rate_double, "vdi frame rate double on/off");
 
-const static struct v4l2_fmtdesc mxc_formats[] = {
+static const struct v4l2_fmtdesc mxc_formats[] = {
 	{
 		.description = "RGB565",
 		.pixelformat = V4L2_PIX_FMT_RGB565,
@@ -189,6 +204,10 @@ const static struct v4l2_fmtdesc mxc_formats[] = {
 		.pixelformat = V4L2_PIX_FMT_YUV420,
 	},
 	{
+		.description = "YVU420",
+		.pixelformat = V4L2_PIX_FMT_YVU420,
+	},
+	{
 		.description = "TILED NV12P",
 		.pixelformat = IPU_PIX_FMT_TILED_NV12,
 	},
@@ -207,7 +226,8 @@ const static struct v4l2_fmtdesc mxc_formats[] = {
 #define DEF_INPUT_WIDTH		320
 #define DEF_INPUT_HEIGHT	240
 
-static int mxc_vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i);
+static int mxc_vidioc_streamoff(struct file *file, void *fh,
+					enum v4l2_buf_type i);
 
 static struct mxc_vout_fb g_fb_setting[MAX_FB_NUM];
 static int config_disp_output(struct mxc_vout_output *vout);
@@ -341,7 +361,8 @@ static int update_setting_from_fbi(struct mxc_vout_output *vout,
 			if (!strcmp(fbi->fix.id, g_fb_setting[i].name)) {
 				vout->crop_bounds = g_fb_setting[i].crop_bounds;
 				vout->disp_fmt = g_fb_setting[i].disp_fmt;
-				vout->disp_support_csc = g_fb_setting[i].disp_support_csc;
+				vout->disp_support_csc =
+					g_fb_setting[i].disp_support_csc;
 				vout->disp_support_windows =
 					g_fb_setting[i].disp_support_windows;
 				found = true;
@@ -410,6 +431,48 @@ static bool deinterlace_3_field(struct mxc_vout_output *vout)
 		(vout->task.input.deinterlace.motion != HIGH_MOTION));
 }
 
+static int set_field_fmt(struct mxc_vout_output *vout, enum v4l2_field field)
+{
+	struct ipu_deinterlace *deinterlace = &vout->task.input.deinterlace;
+
+	switch (field) {
+	/* Images are in progressive format, not interlaced */
+	case V4L2_FIELD_NONE:
+	case V4L2_FIELD_ANY:
+		deinterlace->enable = false;
+		deinterlace->field_fmt = 0;
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "Progressive frame.\n");
+		break;
+	case V4L2_FIELD_INTERLACED_TB:
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"Enable deinterlace TB.\n");
+		deinterlace->enable = true;
+		deinterlace->field_fmt = IPU_DEINTERLACE_FIELD_TOP;
+		break;
+	case V4L2_FIELD_INTERLACED_BT:
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"Enable deinterlace BT.\n");
+		deinterlace->enable = true;
+		deinterlace->field_fmt = IPU_DEINTERLACE_FIELD_BOTTOM;
+		break;
+	default:
+		v4l2_err(vout->vfd->v4l2_dev,
+			"field format:%d not supported yet!\n", field);
+		return -EINVAL;
+	}
+
+	if (IPU_PIX_FMT_TILED_NV12F == vout->task.input.format) {
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"tiled fmt enable deinterlace.\n");
+		deinterlace->enable = true;
+	}
+
+	if (deinterlace->enable && vdi_rate_double)
+		deinterlace->field_fmt |= IPU_DEINTERLACE_RATE_EN;
+
+	return 0;
+}
+
 static bool is_pp_bypass(struct mxc_vout_output *vout)
 {
 	if ((IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
@@ -425,11 +488,15 @@ static bool is_pp_bypass(struct mxc_vout_output *vout)
 			return true;
 		else if (!need_csc(vout->task.input.format, vout->disp_fmt))
 			return true;
-	/* input crop show to full output which can show based on xres_virtual/yres_virtual */
+	/*
+	 * input crop show to full output which can show based on
+	 * xres_virtual/yres_virtual
+	 */
 	} else if ((vout->task.input.crop.w == vout->task.output.crop.w) &&
 			(vout->task.output.crop.w == vout->task.output.width) &&
 			(vout->task.input.crop.h == vout->task.output.crop.h) &&
-			(vout->task.output.crop.h == vout->task.output.height) &&
+			(vout->task.output.crop.h ==
+				vout->task.output.height) &&
 			(vout->task.output.rotate < IPU_ROTATE_HORIZ_FLIP) &&
 			!vout->task.input.deinterlace.enable) {
 		if (vout->disp_support_csc)
@@ -443,29 +510,26 @@ static bool is_pp_bypass(struct mxc_vout_output *vout)
 static void setup_buf_timer(struct mxc_vout_output *vout,
 			struct videobuf_buffer *vb)
 {
-	unsigned long timeout;
+	ktime_t expiry_time, now;
 
 	/* if timestamp is 0, then default to 30fps */
-	if ((vb->ts.tv_sec == 0)
-			&& (vb->ts.tv_usec == 0)
-			&& vout->start_jiffies)
-		timeout =
-			vout->start_jiffies + vout->frame_count * HZ / 30;
+	if ((vb->ts.tv_sec == 0) && (vb->ts.tv_usec == 0))
+		expiry_time = ktime_add_ns(vout->start_ktime,
+				NSEC_PER_FRAME_30FPS * vout->frame_count);
 	else
-		timeout = get_jiffies(&vb->ts);
+		expiry_time = timeval_to_ktime(vb->ts);
 
-	if (jiffies >= timeout) {
+	now = hrtimer_cb_get_time(&vout->timer);
+	if ((now.tv64 > expiry_time.tv64)) {
 		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
 				"warning: timer timeout already expired.\n");
+		expiry_time = now;
 	}
 
-	if (mod_timer(&vout->timer, timeout)) {
-		v4l2_warn(vout->vfd->v4l2_dev,
-				"warning: timer was already set\n");
-	}
+	hrtimer_start(&vout->timer, expiry_time, HRTIMER_MODE_ABS);
 
-	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
-			"timer handler next schedule: %lu\n", timeout);
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "timer handler next "
+		"schedule: %lldnsecs\n", expiry_time.tv64);
 }
 
 static int show_buf(struct mxc_vout_output *vout, int idx,
@@ -489,12 +553,14 @@ static int show_buf(struct mxc_vout_output *vout, int idx,
 		fbi->var.yoffset = ipos->y + 1;
 		var.xoffset = ipos->x;
 		var.yoffset = ipos->y;
+		var.vmode |= FB_VMODE_YWRAP;
 		ret = fb_pan_display(fbi, &var);
 		fbi->fix.smem_start = fb_base;
 		console_unlock();
 	} else {
 		console_lock();
 		var.yoffset = idx * fbi->var.yres;
+		var.vmode &= ~FB_VMODE_YWRAP;
 		ret = fb_pan_display(fbi, &var);
 		console_unlock();
 	}
@@ -512,6 +578,9 @@ static void disp_work_func(struct work_struct *work)
 	struct ipu_pos ipos;
 	int ret = 0;
 	u32 in_fmt = 0;
+	u32 vdi_cnt = 0;
+	u32 vdi_frame;
+	u32 index = 0;
 	u32 ocrop_h = 0;
 	u32 o_height = 0;
 	u32 tiled_interlaced = 0;
@@ -521,37 +590,67 @@ static void disp_work_func(struct work_struct *work)
 
 	spin_lock_irqsave(q->irqlock, flags);
 
-	if (deinterlace_3_field(vout)) {
-		if (list_is_singular(&vout->active_list)) {
-			v4l2_warn(vout->vfd->v4l2_dev,
-					"deinterlacing: no enough entry in active_list\n");
-			spin_unlock_irqrestore(q->irqlock, flags);
-			return;
-		}
-	} else {
-		if (list_empty(&vout->active_list)) {
-			v4l2_warn(vout->vfd->v4l2_dev,
-					"no entry in active_list, should not be here\n");
-			spin_unlock_irqrestore(q->irqlock, flags);
-			return;
-		}
+	if (list_empty(&vout->active_list)) {
+		v4l2_warn(vout->vfd->v4l2_dev,
+			"no entry in active_list, should not be here\n");
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return;
 	}
+
 	vb = list_first_entry(&vout->active_list,
 			struct videobuf_buffer, queue);
+	ret = set_field_fmt(vout, vb->field);
+	if (ret < 0) {
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return;
+	}
+	if (deinterlace_3_field(vout)) {
+		if (list_is_singular(&vout->active_list)) {
+			if (list_empty(&vout->queue_list)) {
+				vout->timer_stop = true;
+				spin_unlock_irqrestore(q->irqlock, flags);
+				v4l2_warn(vout->vfd->v4l2_dev,
+					"no enough entry for 3 fields "
+					"deinterlacer\n");
+				return;
+			}
 
-	if (deinterlace_3_field(vout))
-		vb_next = list_first_entry(vout->active_list.next,
-				struct videobuf_buffer, queue);
+			/*
+			 * We need to use the next vb even if it is
+			 * not on the active list.
+			 */
+			vb_next = list_first_entry(&vout->queue_list,
+					struct videobuf_buffer, queue);
+		} else
+			vb_next = list_first_entry(vout->active_list.next,
+						struct videobuf_buffer, queue);
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"cur field_fmt:%d, next field_fmt:%d.\n",
+			vb->field, vb_next->field);
+		/* repeat the last field during field format changing */
+		if ((vb->field != vb_next->field) &&
+			(vb_next->field != V4L2_FIELD_NONE))
+			vb_next = vb;
+	}
 
 	spin_unlock_irqrestore(q->irqlock, flags);
 
+vdi_frame_rate_double:
 	mutex_lock(&vout->task_lock);
 
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+		"v4l2 frame_cnt:%ld, vb_field:%d, fmt:%d\n",
+		vout->frame_count, vb->field,
+		vout->task.input.deinterlace.field_fmt);
 	if (vb->memory == V4L2_MEMORY_USERPTR)
 		vout->task.input.paddr = vb->baddr;
 	else
 		vout->task.input.paddr = videobuf_to_dma_contig(vb);
 
+	if (vout->task.input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN)
+		index = vout->vdi_frame_cnt % FB_BUFS;
+	else
+		index = vout->frame_count % FB_BUFS;
 	if (vout->linear_bypass_pp) {
 		vout->task.output.paddr = vout->task.input.paddr;
 		ipos.x = vout->task.input.crop.pos.x;
@@ -564,15 +663,15 @@ static void disp_work_func(struct work_struct *work)
 				vout->task.input.paddr_n =
 					videobuf_to_dma_contig(vb_next);
 		}
-		vout->task.output.paddr =
-			vout->disp_bufs[vout->frame_count % FB_BUFS];
+		vout->task.output.paddr = vout->disp_bufs[index];
 		if (vout->vdoa_1080p) {
 			o_height =  vout->task.output.height;
 			ocrop_h = vout->task.output.crop.h;
 			vout->task.output.height = FRAME_HEIGHT_1080P;
 			vout->task.output.crop.h = FRAME_HEIGHT_1080P;
 		}
-		tiled_fmt = (IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
+		tiled_fmt =
+			(IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
 			(IPU_PIX_FMT_TILED_NV12F == vout->task.input.format);
 		if (vout->tiled_bypass_pp) {
 			ipos.x = vout->task.input.crop.pos.x;
@@ -615,30 +714,52 @@ static void disp_work_func(struct work_struct *work)
 
 	mutex_unlock(&vout->task_lock);
 
-	ret = show_buf(vout, vout->frame_count % FB_BUFS, &ipos);
+	ret = show_buf(vout, index, &ipos);
 	if (ret < 0)
-		v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "show buf with ret %d\n", ret);
-
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"show buf with ret %d\n", ret);
+
+	if (vout->task.input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN) {
+		vdi_frame = vout->task.input.deinterlace.field_fmt
+				& IPU_DEINTERLACE_RATE_FRAME1;
+		if (vdi_frame)
+			vout->task.input.deinterlace.field_fmt &=
+			~IPU_DEINTERLACE_RATE_FRAME1;
+		else
+			vout->task.input.deinterlace.field_fmt |=
+			IPU_DEINTERLACE_RATE_FRAME1;
+		vout->vdi_frame_cnt++;
+		vdi_cnt++;
+		if (vdi_cnt < IPU_DEINTERLACE_MAX_FRAME)
+			goto vdi_frame_rate_double;
+	}
 	spin_lock_irqsave(q->irqlock, flags);
 
 	list_del(&vb->queue);
 
 	/*
-	 * previous videobuf finish show, set VIDEOBUF_DONE state here
-	 * to avoid tearing issue in pp bypass case, which make sure
-	 * showing buffer will not be dequeue to write new data. It also
-	 * bring side-effect that the last buffer can not be dequeue
-	 * correctly, app need take care about it.
+	 * The videobuf before the last one has been shown. Set
+	 * VIDEOBUF_DONE state here to avoid tearing issue in ic bypass
+	 * case, which makes sure a buffer being shown will not be
+	 * dequeued to be overwritten. It also brings side-effect that
+	 * the last 2 buffers can not be dequeued correctly, apps need
+	 * to take care of it.
 	 */
-	if (vout->pre_vb) {
-		vout->pre_vb->state = VIDEOBUF_DONE;
-		wake_up_interruptible(&vout->pre_vb->done);
+	if (vout->pre2_vb) {
+		vout->pre2_vb->state = VIDEOBUF_DONE;
+		wake_up_interruptible(&vout->pre2_vb->done);
+		vout->pre2_vb = NULL;
 	}
 
-	if (vout->linear_bypass_pp)
-		vout->pre_vb = vb;
-	else {
-		vout->pre_vb = NULL;
+	if (vout->linear_bypass_pp) {
+		vout->pre2_vb = vout->pre1_vb;
+		vout->pre1_vb = vb;
+	} else {
+		if (vout->pre1_vb) {
+			vout->pre1_vb->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->pre1_vb->done);
+			vout->pre1_vb = NULL;
+		}
 		vb->state = VIDEOBUF_DONE;
 		wake_up_interruptible(&vb->done);
 	}
@@ -666,10 +787,11 @@ err:
 	return;
 }
 
-static void mxc_vout_timer_handler(unsigned long arg)
+static enum hrtimer_restart mxc_vout_timer_handler(struct hrtimer *timer)
 {
-	struct mxc_vout_output *vout =
-			(struct mxc_vout_output *) arg;
+	struct mxc_vout_output *vout = container_of(timer,
+						    struct mxc_vout_output,
+						    timer);
 	struct videobuf_queue *q = &vout->vbq;
 	struct videobuf_buffer *vb;
 	unsigned long flags = 0;
@@ -682,7 +804,7 @@ static void mxc_vout_timer_handler(unsigned long arg)
 	 */
 	if (list_empty(&vout->queue_list)) {
 		spin_unlock_irqrestore(q->irqlock, flags);
-		return;
+		return HRTIMER_NORESTART;
 	}
 
 	/* move videobuf from queued list to active list */
@@ -693,16 +815,18 @@ static void mxc_vout_timer_handler(unsigned long arg)
 
 	if (queue_work(vout->v4l_wq, &vout->disp_work) == 0) {
 		v4l2_warn(vout->vfd->v4l2_dev,
-			"disp work was in queue already, queue buf again next time\n");
+		"disp work was in queue already, queue buf again next time\n");
 		list_del(&vb->queue);
 		list_add(&vb->queue, &vout->queue_list);
 		spin_unlock_irqrestore(q->irqlock, flags);
-		return;
+		return HRTIMER_NORESTART;
 	}
 
 	vb->state = VIDEOBUF_ACTIVE;
 
 	spin_unlock_irqrestore(q->irqlock, flags);
+
+	return HRTIMER_NORESTART;
 }
 
 /* Video buffer call backs */
@@ -755,21 +879,21 @@ static void mxc_vout_buffer_queue(struct videobuf_queue *q,
 			  struct videobuf_buffer *vb)
 {
 	struct mxc_vout_output *vout = q->priv_data;
+	struct videobuf_buffer *active_vb;
 
 	list_add_tail(&vb->queue, &vout->queue_list);
 	vb->state = VIDEOBUF_QUEUED;
 
 	if (vout->timer_stop) {
 		if (deinterlace_3_field(vout) &&
-			list_empty(&vout->active_list)) {
-			vb = list_first_entry(&vout->queue_list,
+			!list_empty(&vout->active_list)) {
+			active_vb = list_first_entry(&vout->active_list,
 					struct videobuf_buffer, queue);
-			list_del(&vb->queue);
-			list_add_tail(&vb->queue, &vout->active_list);
+			setup_buf_timer(vout, active_vb);
 		} else {
 			setup_buf_timer(vout, vb);
-			vout->timer_stop = false;
 		}
+		vout->timer_stop = false;
 	}
 }
 
@@ -858,6 +982,7 @@ static int mxc_vout_open(struct file *file)
 
 		vout->fmt_init = false;
 		vout->frame_count = 0;
+		vout->vdi_frame_cnt = 0;
 
 		vout->win_pos.x = 0;
 		vout->win_pos.y = 0;
@@ -947,7 +1072,8 @@ again:
 			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER) {
 				if (vout->disp_support_windows) {
 					task->output.width -= 8;
-					task->output.crop.w = task->output.width;
+					task->output.crop.w =
+						task->output.width;
 				} else
 					task->output.crop.w -= 8;
 				goto again;
@@ -955,7 +1081,8 @@ again:
 			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER) {
 				if (vout->disp_support_windows) {
 					task->output.height -= 8;
-					task->output.crop.h = task->output.height;
+					task->output.crop.h =
+						task->output.height;
 				} else
 					task->output.crop.h -= 8;
 				goto again;
@@ -1127,7 +1254,8 @@ static int mxc_vout_try_task(struct mxc_vout_output *vout)
 	return ret;
 }
 
-static int mxc_vout_try_format(struct mxc_vout_output *vout, struct v4l2_format *f)
+static int mxc_vout_try_format(struct mxc_vout_output *vout,
+				struct v4l2_format *f)
 {
 	int ret = 0;
 	struct v4l2_rect rect;
@@ -1147,38 +1275,9 @@ static int mxc_vout_try_format(struct mxc_vout_output *vout, struct v4l2_format
 	vout->task.input.height = f->fmt.pix.height;
 	vout->task.input.format = f->fmt.pix.pixelformat;
 
-	if (IPU_PIX_FMT_TILED_NV12F == vout->task.input.format) {
-		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
-				"tiled fmt enable deinterlace.\n");
-		vout->task.input.deinterlace.enable = true;
-		vout->task.input.deinterlace.field_fmt =
-				IPU_DEINTERLACE_FIELD_TOP;
-	}
-	switch (f->fmt.pix.field) {
-	/* Images are in progressive format, not interlaced */
-	case V4L2_FIELD_NONE:
-		break;
-	/* The two fields of a frame are passed in separate buffers,
-	   in temporal order, i. e. the older one first. */
-	case V4L2_FIELD_ALTERNATE:
-		v4l2_err(vout->vfd->v4l2_dev,
-			"V4L2_FIELD_ALTERNATE field format not supported yet!\n");
-		break;
-	case V4L2_FIELD_INTERLACED_TB:
-		v4l2_info(vout->vfd->v4l2_dev, "Enable deinterlace TB.\n");
-		vout->task.input.deinterlace.enable = true;
-		vout->task.input.deinterlace.field_fmt =
-				IPU_DEINTERLACE_FIELD_TOP;
-		break;
-	case V4L2_FIELD_INTERLACED_BT:
-		v4l2_info(vout->vfd->v4l2_dev, "Enable deinterlace BT.\n");
-		vout->task.input.deinterlace.enable = true;
-		vout->task.input.deinterlace.field_fmt =
-				IPU_DEINTERLACE_FIELD_BOTTOM;
-		break;
-	default:
-		break;
-	}
+	ret = set_field_fmt(vout, f->fmt.pix.field);
+	if (ret < 0)
+		return ret;
 
 	if (f->fmt.pix.priv) {
 		vout->task.input.crop.pos.x = rect.left;
@@ -1242,7 +1341,8 @@ static int mxc_vidioc_cropcap(struct file *file, void *fh,
 	return 0;
 }
 
-static int mxc_vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *crop)
+static int mxc_vidioc_g_crop(struct file *file, void *fh,
+				struct v4l2_crop *crop)
 {
 	struct mxc_vout_output *vout = fh;
 
@@ -1271,7 +1371,8 @@ static int mxc_vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *crop
 	return 0;
 }
 
-static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop)
+static int mxc_vidioc_s_crop(struct file *file, void *fh,
+				struct v4l2_crop *crop)
 {
 	struct mxc_vout_output *vout = fh;
 	struct v4l2_rect *b = &vout->crop_bounds;
@@ -1307,6 +1408,14 @@ static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop
 	/* stride line limitation */
 	crop->c.height -= crop->c.height % 8;
 	crop->c.width -= crop->c.width % 8;
+	if ((crop->c.width <= 0) || (crop->c.height <= 0) ||
+		((crop->c.left + crop->c.width) > (b->left + b->width)) ||
+		((crop->c.top + crop->c.height) > (b->top + b->height))) {
+		v4l2_err(vout->vfd->v4l2_dev, "s_crop err: %d, %d, %d, %d",
+			crop->c.left, crop->c.top,
+			crop->c.width, crop->c.height);
+		return -EINVAL;
+	}
 
 	/* the same setting, return */
 	if (vout->disp_support_windows) {
@@ -1325,7 +1434,7 @@ static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop
 
 	/* wait current work finish */
 	if (vout->vbq.streaming)
-		cancel_work_sync(&vout->disp_work);
+		flush_workqueue(vout->v4l_wq);
 
 	mutex_lock(&vout->task_lock);
 
@@ -1365,7 +1474,7 @@ static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop
 			ret = config_disp_output(vout);
 			if (ret < 0) {
 				v4l2_err(vout->vfd->v4l2_dev,
-						"Config display output failed\n");
+					"Config display output failed\n");
 				goto done;
 			}
 		}
@@ -1402,7 +1511,8 @@ static int mxc_vidioc_queryctrl(struct file *file, void *fh,
 	return ret;
 }
 
-static int mxc_vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)
+static int mxc_vidioc_g_ctrl(struct file *file, void *fh,
+				struct v4l2_control *ctrl)
 {
 	int ret = 0;
 	struct mxc_vout_output *vout = fh;
@@ -1470,14 +1580,15 @@ static void setup_task_rotation(struct mxc_vout_output *vout)
 	}
 }
 
-static int mxc_vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)
+static int mxc_vidioc_s_ctrl(struct file *file, void *fh,
+				struct v4l2_control *ctrl)
 {
 	int ret = 0;
 	struct mxc_vout_output *vout = fh;
 
 	/* wait current work finish */
 	if (vout->vbq.streaming)
-		cancel_work_sync(&vout->disp_work);
+		flush_workqueue(vout->v4l_wq);
 
 	mutex_lock(&vout->task_lock);
 	switch (ctrl->id) {
@@ -1527,7 +1638,7 @@ static int mxc_vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c
 			ret = config_disp_output(vout);
 			if (ret < 0) {
 				v4l2_err(vout->vfd->v4l2_dev,
-						"Config display output failed\n");
+					"Config display output failed\n");
 				goto done;
 			}
 		}
@@ -1596,7 +1707,8 @@ static int mxc_vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
 		return videobuf_dqbuf(&vout->vbq, (struct v4l2_buffer *)b, 0);
 }
 
-static int set_window_position(struct mxc_vout_output *vout, struct mxcfb_pos *pos)
+static int set_window_position(struct mxc_vout_output *vout,
+				struct mxcfb_pos *pos)
 {
 	struct fb_info *fbi = vout->fbi;
 	mm_segment_t old_fs;
@@ -1676,7 +1788,10 @@ static int config_disp_output(struct mxc_vout_output *vout)
 				"ERR:%s fb_set_var ret:%d\n", __func__, ret);
 		return ret;
 	}
-	display_buf_size = fbi->fix.line_length * fbi->var.yres;
+	if (vout->linear_bypass_pp || vout->tiled_bypass_pp)
+		display_buf_size = fbi->fix.line_length * fbi->var.yres_virtual;
+	else
+		display_buf_size = fbi->fix.line_length * fbi->var.yres;
 	for (i = 0; i < fb_num; i++)
 		vout->disp_bufs[i] = fbi->fix.smem_start + i * display_buf_size;
 	if (vout->tiled_bypass_pp) {
@@ -1709,11 +1824,11 @@ static int config_disp_output(struct mxc_vout_output *vout)
 	/* fill black when video config changed */
 	color = colorspaceofpixel(vout->task.output.format) == YUV_CS ?
 			UYVY_BLACK : RGB_BLACK;
-	if (vout->task.output.format == IPU_PIX_FMT_NV12) {
+	if (IS_PLANAR_PIXEL_FORMAT(vout->task.output.format)) {
 		size = display_buf_size * 8 /
 			fmt_to_bpp(vout->task.output.format);
-		memset(fbi->screen_base, NV12_Y_BLACK, size);
-		memset(fbi->screen_base + size, NV12_UV_BLACK,
+		memset(fbi->screen_base, Y_BLACK, size);
+		memset(fbi->screen_base + size, UV_BLACK,
 				display_buf_size - size);
 	} else {
 		pixel = (u32 *)fbi->screen_base;
@@ -1737,6 +1852,22 @@ err:
 	return ret;
 }
 
+static inline void wait_for_vsync(struct mxc_vout_output *vout)
+{
+	struct fb_info *fbi = vout->fbi;
+	mm_segment_t old_fs;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi, MXCFB_WAIT_FOR_VSYNC,
+				(unsigned long)NULL);
+		set_fs(old_fs);
+	}
+
+	return;
+}
+
 static void release_disp_output(struct mxc_vout_output *vout)
 {
 	struct fb_info *fbi = vout->fbi;
@@ -1768,7 +1899,8 @@ static void release_disp_output(struct mxc_vout_output *vout)
 	vout->release = true;
 }
 
-static int mxc_vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
+static int mxc_vidioc_streamon(struct file *file, void *fh,
+				enum v4l2_buf_type i)
 {
 	struct mxc_vout_output *vout = fh;
 	struct videobuf_queue *q = &vout->vbq;
@@ -1783,7 +1915,7 @@ static int mxc_vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i
 
 	if (deinterlace_3_field(vout) && list_is_singular(&q->stream)) {
 		v4l2_err(vout->vfd->v4l2_dev,
-				"deinterlacing: need queue 2 frame before streamon\n");
+			"deinterlacing: need queue 2 frame before streamon\n");
 		ret = -EINVAL;
 		goto done;
 	}
@@ -1795,31 +1927,39 @@ static int mxc_vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i
 		goto done;
 	}
 
-	init_timer(&vout->timer);
+	hrtimer_init(&vout->timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);
 	vout->timer.function = mxc_vout_timer_handler;
-	vout->timer.data = (unsigned long)vout;
 	vout->timer_stop = true;
 
-	vout->start_jiffies = jiffies;
+	vout->start_ktime = hrtimer_cb_get_time(&vout->timer);
 
-	vout->pre_vb = NULL;
+	vout->pre1_vb = NULL;
+	vout->pre2_vb = NULL;
 
 	ret = videobuf_streamon(q);
 done:
 	return ret;
 }
 
-static int mxc_vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
+static int mxc_vidioc_streamoff(struct file *file, void *fh,
+				enum v4l2_buf_type i)
 {
 	struct mxc_vout_output *vout = fh;
 	struct videobuf_queue *q = &vout->vbq;
 	int ret = 0;
 
 	if (q->streaming) {
-		cancel_work_sync(&vout->disp_work);
 		flush_workqueue(vout->v4l_wq);
 
-		del_timer_sync(&vout->timer);
+		hrtimer_cancel(&vout->timer);
+
+		/*
+		 * Wait for 2 vsyncs to make sure
+		 * frames are drained on triple
+		 * buffer.
+		 */
+		wait_for_vsync(vout);
+		wait_for_vsync(vout);
 
 		release_disp_output(vout);
 
@@ -1832,16 +1972,16 @@ static int mxc_vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type
 }
 
 static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
-	.vidioc_querycap      			= mxc_vidioc_querycap,
-	.vidioc_enum_fmt_vid_out 		= mxc_vidioc_enum_fmt_vid_out,
+	.vidioc_querycap			= mxc_vidioc_querycap,
+	.vidioc_enum_fmt_vid_out		= mxc_vidioc_enum_fmt_vid_out,
 	.vidioc_g_fmt_vid_out			= mxc_vidioc_g_fmt_vid_out,
 	.vidioc_s_fmt_vid_out			= mxc_vidioc_s_fmt_vid_out,
 	.vidioc_cropcap				= mxc_vidioc_cropcap,
 	.vidioc_g_crop				= mxc_vidioc_g_crop,
 	.vidioc_s_crop				= mxc_vidioc_s_crop,
-	.vidioc_queryctrl    			= mxc_vidioc_queryctrl,
-	.vidioc_g_ctrl       			= mxc_vidioc_g_ctrl,
-	.vidioc_s_ctrl       			= mxc_vidioc_s_ctrl,
+	.vidioc_queryctrl			= mxc_vidioc_queryctrl,
+	.vidioc_g_ctrl				= mxc_vidioc_g_ctrl,
+	.vidioc_s_ctrl				= mxc_vidioc_s_ctrl,
 	.vidioc_reqbufs				= mxc_vidioc_reqbufs,
 	.vidioc_querybuf			= mxc_vidioc_querybuf,
 	.vidioc_qbuf				= mxc_vidioc_qbuf,
@@ -1851,17 +1991,17 @@ static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
 };
 
 static const struct v4l2_file_operations mxc_vout_fops = {
-	.owner 		= THIS_MODULE,
+	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= video_ioctl2,
-	.mmap 		= mxc_vout_mmap,
-	.open 		= mxc_vout_open,
-	.release 	= mxc_vout_release,
+	.mmap		= mxc_vout_mmap,
+	.open		= mxc_vout_open,
+	.release	= mxc_vout_release,
 };
 
 static struct video_device mxc_vout_template = {
-	.name 		= "MXC Video Output",
+	.name		= "MXC Video Output",
 	.fops           = &mxc_vout_fops,
-	.ioctl_ops 	= &mxc_vout_ioctl_ops,
+	.ioctl_ops	= &mxc_vout_ioctl_ops,
 	.release	= video_device_release,
 };
 
@@ -1971,9 +2111,13 @@ static int mxc_vout_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	dev->dev = &pdev->dev;
-	dev->dev->dma_mask = kmalloc(sizeof(*dev->dev->dma_mask), GFP_KERNEL);
-	*dev->dev->dma_mask = DMA_BIT_MASK(32);
-	dev->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	if (!dev->dev->dma_mask) {
+		dev->dev->dma_mask = kmalloc(sizeof(*dev->dev->dma_mask),
+					     GFP_KERNEL);
+		if (dev->dev->dma_mask)
+			*dev->dev->dma_mask = DMA_BIT_MASK(32);
+		dev->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	}
 
 	ret = v4l2_device_register(dev->dev, &dev->v4l2_dev);
 	if (ret) {
diff --git a/drivers/media/video/videobuf-dma-contig.c b/drivers/media/video/videobuf-dma-contig.c
index af7ff78..92cf704 100644
--- a/drivers/media/video/videobuf-dma-contig.c
+++ b/drivers/media/video/videobuf-dma-contig.c
@@ -284,7 +284,8 @@ static int __videobuf_mmap_mapper(struct videobuf_queue *q,
 
 	mem->size = PAGE_ALIGN(buf->bsize);
 	mem->vaddr = dma_alloc_coherent(q->dev, mem->size,
-					&mem->dma_handle, GFP_DMA);
+					&mem->dma_handle,
+					GFP_DMA | GFP_KERNEL);
 	if (!mem->vaddr) {
 		dev_err(q->dev, "dma_alloc_coherent size %ld failed\n",
 			mem->size);
diff --git a/drivers/mfd/wm831x-i2c.c b/drivers/mfd/wm831x-i2c.c
old mode 100644
new mode 100755
index a06cbc7..7a4f998
--- a/drivers/mfd/wm831x-i2c.c
+++ b/drivers/mfd/wm831x-i2c.c
@@ -53,23 +53,21 @@ static int wm831x_i2c_write_device(struct wm831x *wm831x, unsigned short reg,
 	struct i2c_client *i2c = wm831x->control_data;
 	struct i2c_msg xfer[2];
 	int ret;
+    char buf_to_write[4];
 
 	reg = cpu_to_be16(reg);
+    memcpy( buf_to_write, &reg, 2);
+    memcpy( buf_to_write + 2, src, 2);
 
 	xfer[0].addr = i2c->addr;
 	xfer[0].flags = 0;
-	xfer[0].len = 2;
-	xfer[0].buf = (char *)&reg;
+	xfer[0].len = 4;
+	xfer[0].buf = buf_to_write;
 
-	xfer[1].addr = i2c->addr;
-	xfer[1].flags = I2C_M_NOSTART;
-	xfer[1].len = bytes;
-	xfer[1].buf = (char *)src;
-
-	ret = i2c_transfer(i2c->adapter, xfer, 2);
+	ret = i2c_transfer(i2c->adapter, xfer, 1);
 	if (ret < 0)
 		return ret;
-	if (ret != 2)
+	if (ret != 1)
 		return -EIO;
 
 	return 0;
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index f8ffabd..2bd67d5 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -259,7 +259,8 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if (card->ext_csd.rev > 5) {
+	/* workaround: support emmc 4.5 cards to work at emmc 4.4 mode */
+	if (card->ext_csd.rev > 6) {
 		printk(KERN_ERR "%s: unrecognised EXT_CSD revision %d\n",
 			mmc_hostname(card->host), card->ext_csd.rev);
 		err = -EINVAL;
@@ -495,7 +496,7 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	int err, busy = 0;
-	u32 part, new_part;
+	u32 part;
 	u8 *ext_csd, boot_config;
 	struct mmc_command cmd;
 	struct mmc_card *card = container_of(dev, struct mmc_card, dev);
@@ -513,12 +514,28 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 
 	/* it's a normal SD/MMC but user request to configure boot partition */
 	if (card->ext_csd.boot_size <= 0) {
-		printk(KERN_ERR "%s: this is a normal SD/MMC card"
-			" but you request to access boot partition!\n",
+		pr_err("%s: fail to send SWITCH command to card " \
+				"to update boot_config of the EXT_CSD!\n",
 			mmc_hostname(card->host));
 		return -EINVAL;
 	}
 
+	/*
+	 * partition must be -
+	 * 0 - user area
+	 * 1 - boot partition 1
+	 * 2 - boot partition 2
+	 * DO NOT switch the partitions that used to be accessed
+	 * in OS layer HERE
+	 */
+	if (part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK) {
+		pr_err("%s: DO NOT switch the partitions that used to be\n" \
+			" accessed in OS layer HERE. please following the\n" \
+			" guidance of Documentation/mmc/mmc-dev-parts.txt.\n",
+			mmc_hostname(card->host));
+		return -EINVAL;
+       }
+
 	ext_csd = kmalloc(512, GFP_KERNEL);
 	if (!ext_csd) {
 		printk(KERN_ERR "%s: could not allocate a buffer to "
@@ -573,29 +590,11 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 		goto err_rtn;
 	}
 
-	/* switch the partitions that used to be accessed in OS layer */
-	/* partition must be -
-	 * 0 - user area
-	 * 1 - boot partition 1
-	 * 2 - boot partition 2
-	 */
-	if ((part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK) > 2) {
-		printk(KERN_ERR "%s: wrong partition id"
-			" 0 (user area), 1 (boot1), 2 (boot2)\n",
-			mmc_hostname(card->host));
-		err = -EINVAL;
-		goto err_rtn;
-	}
-
-
-	/* Send SWITCH command to change partition for access */
-	boot_config &= ~EXT_CSD_BOOT_PARTITION_ACCESS_MASK;
-	boot_config |= (part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK);
 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 		EXT_CSD_PART_CONFIG, boot_config, card->ext_csd.part_time);
 	if (err) {
-		printk(KERN_ERR "%s: fail to send SWITCH command"
-				" to card to swich partition for access!\n",
+		pr_err("%s: fail to send SWITCH command to card " \
+				"to update boot_config of the EXT_CSD!\n",
 			mmc_hostname(card->host));
 		goto err_rtn;
 	}
@@ -633,14 +632,6 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 		goto err_rtn;
 	}
 
-	new_part = ext_csd[EXT_CSD_PART_CONFIG] &
-		EXT_CSD_BOOT_PARTITION_ACCESS_MASK;
-	if ((part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK) != new_part) {
-		printk(KERN_ERR "%s: after SWITCH, current part id %d is not"
-				" same as requested partition %d!\n",
-			mmc_hostname(card->host), new_part, part);
-		goto err_rtn;
-	}
 	card->ext_csd.boot_config = ext_csd[EXT_CSD_PART_CONFIG];
 
 err_rtn:
@@ -668,8 +659,8 @@ setup_boot_bus(struct device *dev, struct device_attribute *attr,
 	sscanf(buf, "%d\n", &boot_bus);
 
 	if (card->csd.mmca_vsn < CSD_SPEC_VER_4) {
-		printk(KERN_ERR "%s: invalid mmc version"
-			" mmc version is below version 4!)\n",
+		pr_err("%s: fail to send SWITCH command to card " \
+				"to update boot_config of the EXT_CSD!\n",
 			mmc_hostname(card->host));
 		return -EINVAL;
 	}
@@ -793,16 +784,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 		"Reserved",
 		"User area enabled for boot"};
 
-	char *boot_partition_access[8] = {
-		"No access to boot partition",
-		"R/W boot partition 1",
-		"R/W boot partition 2",
-		"R/W Replay Protected Memory Block (RPMB)",
-		"Access to General Purpose partition 1",
-		"Access to General Purpose partition 2",
-		"Access to General Purpose partition 3",
-		"Access to General Purpose partition 4"};
-
 	char *bus_width[4] = {
 		"x1 (sdr) or x4 (ddr) bus width in boot operation mode",
 		"x4 (sdr/ddr) bus width in boot operation mode",
@@ -816,7 +797,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 	"Reserved"};
 
 	int partition;
-	int access;
 	int width;
 	int mode;
 	u8 *ext_csd = NULL;
@@ -829,7 +809,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 	mmc_read_ext_csd(card, ext_csd);
 
 	partition = (card->ext_csd.boot_config >> 3) & 0x7;
-	access = card->ext_csd.boot_config & 0x7;
 	width =  card->ext_csd.boot_bus_width & 0x3;
 	mode = (card->ext_csd.boot_bus_width >> 3) & 0x3;
 
@@ -842,7 +821,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 		"boot_partition:0x%02x;\n"
 		"  BOOT_ACK:%x - %s\n"
 		"  BOOT_PARTITION-ENABLE: %x - %s\n"
-		"  PARTITION_ACCESS:%x - %s\n"
 		"boot_bus:0x%02x\n"
 		"  BOOT_MODE:%x - %s\n"
 		"  RESET_BOOT_BUS_WIDTH:%x - %s\n"
@@ -862,7 +840,7 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 			"Supports high speed timing during boot" :
 			"Does not support high speed timing during boot",
 
-		card->ext_csd.boot_size * 128,
+		card->ext_csd.boot_size >> 10,
 
 		card->ext_csd.boot_config,
 		!!(card->ext_csd.boot_config & 0x40),
@@ -871,8 +849,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 			"No boot acknowledge sent",
 		partition,
 		boot_partition[partition],
-		access,
-		boot_partition_access[access],
 
 		card->ext_csd.boot_bus_width,
 		mode,
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index 59cc92c..35fd825 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -881,6 +881,8 @@ static int esdhc_pltfm_init(struct sdhci_host *host, struct sdhci_pltfm_data *pd
 		if (boarddata->always_present) {
 			/* remove BROKEN_CD to disable card polling */
 			host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
+			/* if it is always present, invalid cd_gpio */
+			boarddata->cd_gpio = ARCH_NR_GPIOS + 1;
 			if (host->clk_mgr_en)
 				clk_disable(pltfm_host->clk);
 			return 0;
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index dbab040..61f3aaf 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -140,12 +140,18 @@ err:
 
 static int __devexit sdhci_pltfm_remove(struct platform_device *pdev)
 {
-	struct sdhci_pltfm_data *pdata = pdev->dev.platform_data;
+	const struct platform_device_id *platid = platform_get_device_id(pdev);
+	struct sdhci_pltfm_data *pdata;
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	int dead;
 	u32 scratch;
 
+	if (platid && platid->driver_data)
+		pdata = (void *)platid->driver_data;
+	else
+		pdata = pdev->dev.platform_data;
+
 	dead = 0;
 	scratch = readl(host->ioaddr + SDHCI_INT_STATUS);
 	if (scratch == (u32)-1)
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index e8f78ae..d34486e 100755
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1312,6 +1312,7 @@ void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
 }
+EXPORT_SYMBOL_GPL(sdhci_request);
 
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 23175ed..f3626b0 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -59,6 +59,9 @@ static void cfi_amdstd_resume (struct mtd_info *);
 static int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);
 static int cfi_amdstd_secsi_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 
+static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf);
+
 static void cfi_amdstd_destroy(struct mtd_info *);
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *, int);
@@ -145,8 +148,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 	if (((major << 8) | minor) < 0x3131) {
 		/* CFI version 1.0 => don't trust bootloc */
 
-		DEBUG(MTD_DEBUG_LEVEL1,
-			"%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",
+		pr_debug("%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",
 			map->name, cfi->mfr, cfi->id);
 
 		/* AFAICS all 29LV400 with a bottom boot block have a device ID
@@ -166,8 +168,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 			 * the 8-bit device ID.
 			 */
 			(cfi->mfr == CFI_MFR_MACRONIX)) {
-			DEBUG(MTD_DEBUG_LEVEL1,
-				"%s: Macronix MX29LV400C with bottom boot block"
+			pr_debug("%s: Macronix MX29LV400C with bottom boot block"
 				" detected\n", map->name);
 			extp->TopBottom = 2;	/* bottom boot */
 		} else
@@ -178,8 +179,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 			extp->TopBottom = 2;	/* bottom boot */
 		}
 
-		DEBUG(MTD_DEBUG_LEVEL1,
-			"%s: AMD CFI PRI V%c.%c has no boot block field;"
+		pr_debug("%s: AMD CFI PRI V%c.%c has no boot block field;"
 			" deduced %s from Device ID\n", map->name, major, minor,
 			extp->TopBottom == 2 ? "bottom" : "top");
 	}
@@ -191,7 +191,7 @@ static void fixup_use_write_buffers(struct mtd_info *mtd)
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	if (cfi->cfiq->BufWriteTimeoutTyp) {
-		DEBUG(MTD_DEBUG_LEVEL1, "Using buffer write method\n" );
+		pr_debug("Using buffer write method\n" );
 		mtd->write = cfi_amdstd_write_buffers;
 	}
 }
@@ -317,7 +317,7 @@ static void fixup_s29gl064n_sectors(struct mtd_info *mtd)
 
 	if ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0x003f) {
 		cfi->cfiq->EraseRegionInfo[0] |= 0x0040;
-		pr_warning("%s: Bad S29GL064N CFI data, adjust from 64 to 128 sectors\n", mtd->name);
+		pr_warning("%s: Bad S29GL064N CFI data; adjust from 64 to 128 sectors\n", mtd->name);
 	}
 }
 
@@ -328,10 +328,23 @@ static void fixup_s29gl032n_sectors(struct mtd_info *mtd)
 
 	if ((cfi->cfiq->EraseRegionInfo[1] & 0xffff) == 0x007e) {
 		cfi->cfiq->EraseRegionInfo[1] &= ~0x0040;
-		pr_warning("%s: Bad S29GL032N CFI data, adjust from 127 to 63 sectors\n", mtd->name);
+		pr_warning("%s: Bad S29GL032N CFI data; adjust from 127 to 63 sectors\n", mtd->name);
 	}
 }
 
+static void fixup_s29ns512p_sectors(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	/*
+	 *  S29NS512P flash uses more than 8bits to report number of sectors,
+	 * which is not permitted by CFI.
+	 */
+	cfi->cfiq->EraseRegionInfo[0] = 0x020001ff;
+	pr_warning("%s: Bad S29NS512P CFI data; adjust to 512 sectors\n", mtd->name);
+}
+
 /* Used to fix CFI-Tables of chips without Extended Query Tables */
 static struct cfi_fixup cfi_nopri_fixup_table[] = {
 	{ CFI_MFR_SST, 0x234a, fixup_sst39vf }, /* SST39VF1602 */
@@ -362,6 +375,7 @@ static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors },
 	{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors },
 	{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors },
+	{ CFI_MFR_AMD, 0x3f00, fixup_s29ns512p_sectors },
 	{ CFI_MFR_SST, 0x536a, fixup_sst38vf640x_sectorsize }, /* SST38VF6402 */
 	{ CFI_MFR_SST, 0x536b, fixup_sst38vf640x_sectorsize }, /* SST38VF6401 */
 	{ CFI_MFR_SST, 0x536c, fixup_sst38vf640x_sectorsize }, /* SST38VF6404 */
@@ -417,6 +431,68 @@ static void cfi_fixup_major_minor(struct cfi_private *cfi,
 	}
 }
 
+static int is_m29ew(struct cfi_private *cfi)
+{
+	if (cfi->mfr == CFI_MFR_INTEL &&
+	    ((cfi->device_type == CFI_DEVICETYPE_X8 && (cfi->id & 0xff) == 0x7e) ||
+	     (cfi->device_type == CFI_DEVICETYPE_X16 && cfi->id == 0x227e)))
+		return 1;
+	return 0;
+}
+
+/*
+ * From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 20:
+ * Some revisions of the M29EW suffer from erase suspend hang ups. In
+ * particular, it can occur when the sequence
+ * Erase Confirm -> Suspend -> Program -> Resume
+ * causes a lockup due to internal timing issues. The consequence is that the
+ * erase cannot be resumed without inserting a dummy command after programming
+ * and prior to resuming. [...] The work-around is to issue a dummy write cycle
+ * that writes an F0 command code before the RESUME command.
+ */
+static void cfi_fixup_m29ew_erase_suspend(struct map_info *map,
+					  unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	/* before resume, insert a dummy 0xF0 cycle for Micron M29EW devices */
+	if (is_m29ew(cfi))
+		map_write(map, CMD(0xF0), adr);
+}
+
+/*
+ * From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 22:
+ *
+ * Some revisions of the M29EW (for example, A1 and A2 step revisions)
+ * are affected by a problem that could cause a hang up when an ERASE SUSPEND
+ * command is issued after an ERASE RESUME operation without waiting for a
+ * minimum delay.  The result is that once the ERASE seems to be completed
+ * (no bits are toggling), the contents of the Flash memory block on which
+ * the erase was ongoing could be inconsistent with the expected values
+ * (typically, the array value is stuck to the 0xC0, 0xC4, 0x80, or 0x84
+ * values), causing a consequent failure of the ERASE operation.
+ * The occurrence of this issue could be high, especially when file system
+ * operations on the Flash are intensive.  As a result, it is recommended
+ * that a patch be applied.  Intensive file system operations can cause many
+ * calls to the garbage routine to free Flash space (also by erasing physical
+ * Flash blocks) and as a result, many consecutive SUSPEND and RESUME
+ * commands can occur.  The problem disappears when a delay is inserted after
+ * the RESUME command by using the udelay() function available in Linux.
+ * The DELAY value must be tuned based on the customer's platform.
+ * The maximum value that fixes the problem in all cases is 500us.
+ * But, in our experience, a delay of 30 µs to 50 µs is sufficient
+ * in most cases.
+ * We have chosen 500µs because this latency is acceptable.
+ */
+static void cfi_fixup_m29ew_delay_after_resume(struct cfi_private *cfi)
+{
+	/*
+	 * Resolving the Delay After Resume Issue see Micron TN-13-07
+	 * Worst case delay must be 500µs but 30-50µs should be ok as well
+	 */
+	if (is_m29ew(cfi))
+		cfi_udelay(500);
+}
+
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -443,9 +519,10 @@ struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 	mtd->writesize = 1;
 	mtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): write buffer size %d\n",
-		__func__, mtd->writebufsize);
+	pr_debug("MTD %s(): write buffer size %d\n", __func__,
+			mtd->writebufsize);
 
+	mtd->panic_write = cfi_amdstd_panic_write;
 	mtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;
 
 	if (cfi->cfi_mode==CFI_MODE_CFI){
@@ -761,7 +838,10 @@ static void put_chip(struct map_info *map, struct flchip *chip, unsigned long ad
 
 	switch(chip->oldstate) {
 	case FL_ERASING:
+		cfi_fixup_m29ew_erase_suspend(map,
+			chip->in_progress_block_addr);
 		map_write(map, cfi->sector_erase_cmd, chip->in_progress_block_addr);
+		cfi_fixup_m29ew_delay_after_resume(cfi);
 		chip->oldstate = FL_READY;
 		chip->state = FL_ERASING;
 		break;
@@ -773,8 +853,6 @@ static void put_chip(struct map_info *map, struct flchip *chip, unsigned long ad
 
 	case FL_READY:
 	case FL_STATUS:
-		/* We should really make set_vpp() count, rather than doing this */
-		DISABLE_VPP(map);
 		break;
 	default:
 		printk(KERN_ERR "MTD: put_chip() called with oldstate %d!!\n", chip->oldstate);
@@ -903,6 +981,8 @@ static void __xipram xip_udelay(struct map_info *map, struct flchip *chip,
 			/* Disallow XIP again */
 			local_irq_disable();
 
+			/* Correct Erase Suspend Hangups for M29EW */
+			cfi_fixup_m29ew_erase_suspend(map, adr);
 			/* Resume the write or erase operation */
 			map_write(map, cfi->sector_erase_cmd, adr);
 			chip->state = oldstate;
@@ -960,17 +1040,13 @@ static void __xipram xip_udelay(struct map_info *map, struct flchip *chip,
 
 #define UDELAY(map, chip, adr, usec)  \
 do {  \
-	mutex_unlock(&chip->mutex);  \
 	cfi_udelay(usec);  \
-	mutex_lock(&chip->mutex);  \
 } while (0)
 
 #define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \
 do {  \
-	mutex_unlock(&chip->mutex);  \
 	INVALIDATE_CACHED_RANGE(map, adr, len);  \
 	cfi_udelay(usec);  \
-	mutex_lock(&chip->mutex);  \
 } while (0)
 
 #endif
@@ -1163,7 +1239,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 		return ret;
 	}
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
+	pr_debug("MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
 	       __func__, adr, datum.x[0] );
 
 	/*
@@ -1174,7 +1250,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	 */
 	oldd = map_read(map, adr);
 	if (map_word_equal(map, oldd, datum)) {
-		DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): NOP\n",
+		pr_debug("MTD %s(): NOP\n",
 		       __func__);
 		goto op_done;
 	}
@@ -1237,6 +1313,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	xip_enable(map, chip, adr);
  op_done:
 	chip->state = FL_READY;
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 
@@ -1400,7 +1477,7 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 
 	datum = map_word_load(map, buf);
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
+	pr_debug("MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
 	       __func__, adr, datum.x[0] );
 
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
@@ -1468,17 +1545,30 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 		UDELAY(map, chip, adr, 1);
 	}
 
-	/* reset on all failures. */
-	map_write( map, CMD(0xF0), chip->start );
+	/*
+	 * Recovery from write-buffer programming failures requires
+	 * the write-to-buffer-reset sequence.  Since the last part
+	 * of the sequence also works as a normal reset, we can run
+	 * the same commands regardless of why we are here.
+	 * See e.g.
+	 * http://www.spansion.com/Support/Application%20Notes/MirrorBit_Write_Buffer_Prog_Page_Buffer_Read_AN.pdf
+	 */
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
+			 cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
+			 cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, chip->start, map, cfi,
+			 cfi->device_type, NULL);
 	xip_enable(map, chip, adr);
 	/* FIXME - should have reset delay before continuing */
 
-	printk(KERN_WARNING "MTD %s(): software timeout\n",
-	       __func__ );
+	printk(KERN_WARNING "MTD %s(): software timeout, address:0x%.8lx.\n",
+	       __func__, adr);
 
 	ret = -EIO;
  op_done:
 	chip->state = FL_READY;
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 
@@ -1565,6 +1655,242 @@ static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 	return 0;
 }
 
+/*
+ * Wait for the flash chip to become ready to write data
+ *
+ * This is only called during the panic_write() path. When panic_write()
+ * is called, the kernel is in the process of a panic, and will soon be
+ * dead. Therefore we don't take any locks, and attempt to get access
+ * to the chip as soon as possible.
+ */
+static int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,
+				 unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	int retries = 10;
+	int i;
+
+	/*
+	 * If the driver thinks the chip is idle, and no toggle bits
+	 * are changing, then the chip is actually idle for sure.
+	 */
+	if (chip->state == FL_READY && chip_ready(map, adr))
+		return 0;
+
+	/*
+	 * Try several times to reset the chip and then wait for it
+	 * to become idle. The upper limit of a few milliseconds of
+	 * delay isn't a big problem: the kernel is dying anyway. It
+	 * is more important to save the messages.
+	 */
+	while (retries > 0) {
+		const unsigned long timeo = (HZ / 1000) + 1;
+
+		/* send the reset command */
+		map_write(map, CMD(0xF0), chip->start);
+
+		/* wait for the chip to become ready */
+		for (i = 0; i < jiffies_to_usecs(timeo); i++) {
+			if (chip_ready(map, adr))
+				return 0;
+
+			udelay(1);
+		}
+	}
+
+	/* the chip never became ready */
+	return -EBUSY;
+}
+
+/*
+ * Write out one word of data to a single flash chip during a kernel panic
+ *
+ * This is only called during the panic_write() path. When panic_write()
+ * is called, the kernel is in the process of a panic, and will soon be
+ * dead. Therefore we don't take any locks, and attempt to get access
+ * to the chip as soon as possible.
+ *
+ * The implementation of this routine is intentionally similar to
+ * do_write_oneword(), in order to ease code maintenance.
+ */
+static int do_panic_write_oneword(struct map_info *map, struct flchip *chip,
+				  unsigned long adr, map_word datum)
+{
+	const unsigned long uWriteTimeout = (HZ / 1000) + 1;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int retry_cnt = 0;
+	map_word oldd;
+	int ret = 0;
+	int i;
+
+	adr += chip->start;
+
+	ret = cfi_amdstd_panic_wait(map, chip, adr);
+	if (ret)
+		return ret;
+
+	pr_debug("MTD %s(): PANIC WRITE 0x%.8lx(0x%.8lx)\n",
+			__func__, adr, datum.x[0]);
+
+	/*
+	 * Check for a NOP for the case when the datum to write is already
+	 * present - it saves time and works around buggy chips that corrupt
+	 * data at other locations when 0xff is written to a location that
+	 * already contains 0xff.
+	 */
+	oldd = map_read(map, adr);
+	if (map_word_equal(map, oldd, datum)) {
+		pr_debug("MTD %s(): NOP\n", __func__);
+		goto op_done;
+	}
+
+	ENABLE_VPP(map);
+
+retry:
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	map_write(map, datum, adr);
+
+	for (i = 0; i < jiffies_to_usecs(uWriteTimeout); i++) {
+		if (chip_ready(map, adr))
+			break;
+
+		udelay(1);
+	}
+
+	if (!chip_good(map, adr, datum)) {
+		/* reset on all failures. */
+		map_write(map, CMD(0xF0), chip->start);
+		/* FIXME - should have reset delay before continuing */
+
+		if (++retry_cnt <= MAX_WORD_RETRIES)
+			goto retry;
+
+		ret = -EIO;
+	}
+
+op_done:
+	DISABLE_VPP(map);
+	return ret;
+}
+
+/*
+ * Write out some data during a kernel panic
+ *
+ * This is used by the mtdoops driver to save the dying messages from a
+ * kernel which has panic'd.
+ *
+ * This routine ignores all of the locking used throughout the rest of the
+ * driver, in order to ensure that the data gets written out no matter what
+ * state this driver (and the flash chip itself) was in when the kernel crashed.
+ *
+ * The implementation of this routine is intentionally similar to
+ * cfi_amdstd_write_words(), in order to ease code maintenance.
+ */
+static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long ofs, chipstart;
+	int ret = 0;
+	int chipnum;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to >> cfi->chipshift;
+	ofs = to - (chipnum << cfi->chipshift);
+	chipstart = cfi->chips[chipnum].start;
+
+	/* If it's not bus aligned, do the first byte write */
+	if (ofs & (map_bankwidth(map) - 1)) {
+		unsigned long bus_ofs = ofs & ~(map_bankwidth(map) - 1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		map_word tmp_buf;
+
+		ret = cfi_amdstd_panic_wait(map, &cfi->chips[chipnum], bus_ofs);
+		if (ret)
+			return ret;
+
+		/* Load 'tmp_buf' with old contents of flash */
+		tmp_buf = map_read(map, bus_ofs + chipstart);
+
+		/* Number of bytes to copy from buffer */
+		n = min_t(int, len, map_bankwidth(map) - i);
+
+		tmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);
+
+		ret = do_panic_write_oneword(map, &cfi->chips[chipnum],
+					     bus_ofs, tmp_buf);
+		if (ret)
+			return ret;
+
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+		len -= n;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	/* We are now aligned, write as much as possible */
+	while (len >= map_bankwidth(map)) {
+		map_word datum;
+
+		datum = map_word_load(map, buf);
+
+		ret = do_panic_write_oneword(map, &cfi->chips[chipnum],
+					     ofs, datum);
+		if (ret)
+			return ret;
+
+		ofs += map_bankwidth(map);
+		buf += map_bankwidth(map);
+		(*retlen) += map_bankwidth(map);
+		len -= map_bankwidth(map);
+
+		if (ofs >> cfi->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+
+			chipstart = cfi->chips[chipnum].start;
+		}
+	}
+
+	/* Write the trailing bytes if any */
+	if (len & (map_bankwidth(map) - 1)) {
+		map_word tmp_buf;
+
+		ret = cfi_amdstd_panic_wait(map, &cfi->chips[chipnum], ofs);
+		if (ret)
+			return ret;
+
+		tmp_buf = map_read(map, ofs + chipstart);
+
+		tmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);
+
+		ret = do_panic_write_oneword(map, &cfi->chips[chipnum],
+					     ofs, tmp_buf);
+		if (ret)
+			return ret;
+
+		(*retlen) += len;
+	}
+
+	return 0;
+}
+
 
 /*
  * Handle devices with one erase region, that only implement
@@ -1587,7 +1913,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 		return ret;
 	}
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",
+	pr_debug("MTD %s(): ERASE 0x%.8lx\n",
 	       __func__, chip->start );
 
 	XIP_INVAL_CACHED_RANGE(map, adr, map->size);
@@ -1652,6 +1978,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 
 	chip->state = FL_READY;
 	xip_enable(map, chip, adr);
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 
@@ -1675,7 +2002,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 		return ret;
 	}
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",
+	pr_debug("MTD %s(): ERASE 0x%.8lx\n",
 	       __func__, adr );
 
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
@@ -1742,6 +2069,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 	}
 
 	chip->state = FL_READY;
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 	return ret;
@@ -1801,8 +2129,7 @@ static int do_atmel_lock(struct map_info *map, struct flchip *chip,
 		goto out_unlock;
 	chip->state = FL_LOCKING;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): LOCK 0x%08lx len %d\n",
-	      __func__, adr, len);
+	pr_debug("MTD %s(): LOCK 0x%08lx len %d\n", __func__, adr, len);
 
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
 			 cfi->device_type, NULL);
@@ -1837,8 +2164,7 @@ static int do_atmel_unlock(struct map_info *map, struct flchip *chip,
 		goto out_unlock;
 	chip->state = FL_UNLOCKING;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): LOCK 0x%08lx len %d\n",
-	      __func__, adr, len);
+	pr_debug("MTD %s(): LOCK 0x%08lx len %d\n", __func__, adr, len);
 
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
 			 cfi->device_type, NULL);
diff --git a/drivers/mtd/nand/gpmi-nand/gpmi-lib.c b/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
index 2138dcb..5c8f3bc 100644
--- a/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
+++ b/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
@@ -1,7 +1,7 @@
 /*
  * Freescale GPMI NAND Flash Driver
  *
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Embedded Alley Solutions, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -1160,7 +1160,7 @@ void gpmi_begin(struct gpmi_nand_data *this)
 	unsigned int   clock_period_in_ns;
 	uint32_t       reg;
 	unsigned int   dll_wait_time_in_us;
-	struct gpmi_nfc_hardware_timing  hw;
+	struct gpmi_nfc_hardware_timing  hw = {};
 	int ret;
 
 	/* Enable the clock. */
diff --git a/drivers/mxc/asrc/mxc_asrc.c b/drivers/mxc/asrc/mxc_asrc.c
index 62d7ceb..ea65738 100644
--- a/drivers/mxc/asrc/mxc_asrc.c
+++ b/drivers/mxc/asrc/mxc_asrc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -17,7 +17,7 @@
  * @brief MXC Asynchronous Sample Rate Converter
  *
  * @ingroup SOUND
- */
+*/
 
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -41,27 +41,30 @@
 #include <asm/memory.h>
 #include <mach/dma.h>
 #include <mach/mxc_asrc.h>
+#include <linux/delay.h>
+
 
 #define ASRC_PROC_PATH        "driver/asrc"
 
 #define ASRC_RATIO_DECIMAL_DEPTH 26
 
 DEFINE_SPINLOCK(data_lock);
+DEFINE_SPINLOCK(pair_lock);
 DEFINE_SPINLOCK(input_int_lock);
 DEFINE_SPINLOCK(output_int_lock);
 
-#define AICPA		0	/* Input Clock Divider A Offset */
-#define AICDA		3	/* Input Clock Prescaler A Offset */
-#define AICPB           6	/* Input Clock Divider B Offset */
-#define AICDB           9	/* Input Clock Prescaler B Offset */
-#define AOCPA           12	/* Output Clock Divider A Offset */
-#define AOCDA           15	/* Output Clock Prescaler A Offset */
-#define AOCPB           18	/* Output Clock Divider B Offset */
-#define AOCDB           21	/* Output Clock Prescaler B Offset */
-#define AICPC           0	/* Input Clock Divider C Offset */
-#define AICDC           3	/* Input Clock Prescaler C Offset */
-#define AOCDC           6	/* Output Clock Prescaler C Offset */
-#define AOCPC           9	/* Output Clock Divider C Offset */
+#define AICPA		0	/* Input Clock Prescaler A Offset */
+#define AICDA		3	/* Input Clock Divider A Offset */
+#define AICPB           6	/* Input Clock Prescaler B Offset */
+#define AICDB           9	/* Input Clock Divider B Offset */
+#define AOCPA           12	/* Output Clock Prescaler A Offset */
+#define AOCDA           15	/* Output Clock Divider A Offset */
+#define AOCPB           18	/* Output Clock Prescaler B Offset */
+#define AOCDB           21	/* Output Clock Divider B Offset */
+#define AICPC           0	/* Input Clock Prescaler C Offset */
+#define AICDC           3	/* Input Clock Divider C Offset */
+#define AOCPC           6	/* Output Clock Prescaler C Offset */
+#define AOCDC           9	/* Output Clock Divider C Offset */
 
 char *asrc_pair_id[] = {
 	[0] = "ASRC RX PAIR A",
@@ -141,21 +144,26 @@ static unsigned char output_clk_map_v1[] = {
 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
 };
 
+/* V2 uses the same map for input and output */
 static unsigned char input_clk_map_v2[] = {
-	0, 1, 2, 3, 4, 5, 0xf, 0xf, 0xf, 8, 9, 0xa, 0xb, 0xc, 0xf, 0xd,
+/*	0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xa  0xb  0xc  0xd  0xe  0xf*/
+	0x0, 0x1, 0x2, 0x7, 0x4, 0x5, 0x6, 0x3, 0x8, 0x9, 0xa, 0xb, 0xc, 0xf, 0xe, 0xd,
 };
 
 static unsigned char output_clk_map_v2[] = {
-	8, 9, 0xa, 0, 0xc, 0x5, 0xf, 0xf, 0, 1, 2, 0xf, 0xf, 4, 0xf, 0xd,
+/*	0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xa  0xb  0xc  0xd  0xe  0xf*/
+	0x8, 0x9, 0xa, 0x7, 0xc, 0x5, 0x6, 0xb, 0x0, 0x1, 0x2, 0x3, 0x4, 0xf, 0xe, 0xd,
 };
 
 static unsigned char *input_clk_map, *output_clk_map;
 
+struct asrc_p2p_ops asrc_pcm_p2p_ops_asrc;
+
 static struct dma_chan *imx_asrc_dma_alloc(u32 dma_req);
-struct dma_async_tx_descriptor *imx_asrc_dma_config(
+static int imx_asrc_dma_config(
 					struct asrc_pair_params *params,
 					struct dma_chan *chan,
-					u32 dma_addr, dma_addr_t buf_addr,
+					u32 dma_addr, void *buf_addr,
 					u32 buf_len, bool in,
 					enum asrc_word_width word_width);
 
@@ -313,34 +321,42 @@ int asrc_req_pair(int chn_num, enum asrc_pair_index *index)
 	int err = 0;
 	unsigned long lock_flags;
 	struct asrc_pair *pair;
+	int imax = 0, busy = 0, i;
+
 	spin_lock_irqsave(&data_lock, lock_flags);
 
-	if (chn_num > 2) {
-		pair = &g_asrc->asrc_pair[ASRC_PAIR_B];
-		if (pair->active || (chn_num > pair->chn_max))
-			err = -EBUSY;
-		else {
-			*index = ASRC_PAIR_B;
-			pair->chn_num = chn_num;
-			pair->active = 1;
+	for (i = ASRC_PAIR_A; i < ASRC_PAIR_MAX_NUM; i++) {
+		pair = &g_asrc->asrc_pair[i];
+		if (chn_num > pair->chn_max) {
+			imax++;
+			continue;
+		} else if (pair->active) {
+			busy++;
+			continue;
 		}
+		/* Save the current qualified pair */
+		*index = i;
+
+		/* Check if this pair is a perfect one */
+		if (chn_num == pair->chn_max)
+			break;
+	}
+
+	if (imax >= ASRC_PAIR_MAX_NUM) {
+		pr_err("No pair could afford requested channel number.\n");
+		err = -EINVAL;
+	} else if (busy >= ASRC_PAIR_MAX_NUM) {
+		pr_err("All pairs are busy now.\n");
+		err = -EBUSY;
+	} else if (busy + imax >= ASRC_PAIR_MAX_NUM) {
+		pr_err("All affordable pairs are busy now.\n");
+		err = -EBUSY;
 	} else {
-		pair = &g_asrc->asrc_pair[ASRC_PAIR_A];
-		if (pair->active || (pair->chn_max == 0)) {
-			pair = &g_asrc->asrc_pair[ASRC_PAIR_C];
-			if (pair->active || (pair->chn_max == 0))
-				err = -EBUSY;
-			else {
-				*index = ASRC_PAIR_C;
-				pair->chn_num = 2;
-				pair->active = 1;
-			}
-		} else {
-			*index = ASRC_PAIR_A;
-			pair->chn_num = 2;
-			pair->active = 1;
-		}
+		pair = &g_asrc->asrc_pair[*index];
+		pair->chn_num = chn_num;
+		pair->active = 1;
 	}
+
 	spin_unlock_irqrestore(&data_lock, lock_flags);
 
 	if (!err) {
@@ -376,6 +392,9 @@ int asrc_config_pair(struct asrc_config *config)
 	int err = 0;
 	int reg, tmp, channel_num;
 	unsigned long lock_flags;
+	unsigned long aicp_shift, aocp_shift;
+	unsigned long asrc_asrcdr_reg, dp_clear_mask;
+
 	/* Set the channel number */
 	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCNCR_REG);
 	spin_lock_irqsave(&data_lock, lock_flags);
@@ -421,133 +440,68 @@ int asrc_config_pair(struct asrc_config *config)
 	__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCTR_REG);
 
 	/* Default Clock Divider Setting */
-	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR1_REG);
-	if (config->pair == ASRC_PAIR_A) {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR1_REG);
-		reg &= 0xfc0fc0;
-		/* Input Part */
-		if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
-			reg |= 7 << AICPA;
-		else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
-			reg |= 6 << AICPA;
-		else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 input_sample_rate);
-			reg |= tmp << AICPA;
-		} else {
-			if (config->input_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AICPA;
-			else if (config->input_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AICPA;
-			else
-				err = -EFAULT;
-		}
-		/* Output Part */
-		if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
-			reg |= 7 << AOCPA;
-		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
-			reg |= 6 << AOCPA;
-		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 output_sample_rate);
-			reg |= tmp << AOCPA;
-		} else {
-			if (config->output_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AOCPA;
-			else if (config->output_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AOCPA;
-			else
-				err = -EFAULT;
-		}
-
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCDR1_REG);
-
-	} else if (config->pair == ASRC_PAIR_B) {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR1_REG);
-		reg &= 0x03f03f;
-		/* Input Part */
-		if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
-			reg |= 7 << AICPB;
-		else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
-			reg |= 6 << AICPB;
-		else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 input_sample_rate);
-			reg |= tmp << AICPB;
-		} else {
-			if (config->input_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AICPB;
-			else if (config->input_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AICPB;
-			else
-				err = -EFAULT;
-		}
-		/* Output Part */
-		if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
-			reg |= 7 << AOCPB;
-		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
-			reg |= 6 << AOCPB;
-		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 output_sample_rate);
-			reg |= tmp << AOCPB;
-		} else {
-			if (config->output_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AOCPB;
-			else if (config->output_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AOCPB;
-			else
-				err = -EFAULT;
-		}
-
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCDR1_REG);
+	switch (config->pair) {
+	case ASRC_PAIR_A:
+		asrc_asrcdr_reg = ASRC_ASRCDR1_REG;
+		dp_clear_mask = 0xfc0fc0;
+		aicp_shift = AICPA;
+		aocp_shift = AOCPA;
+		break;
+	case ASRC_PAIR_B:
+		asrc_asrcdr_reg = ASRC_ASRCDR1_REG;
+		dp_clear_mask = 0x03f03f;
+		aicp_shift = AICPB;
+		aocp_shift = AOCPB;
+		break;
+	case ASRC_PAIR_C:
+		asrc_asrcdr_reg = ASRC_ASRCDR2_REG;
+		dp_clear_mask = 0x00;
+		aicp_shift = AICPC;
+		aocp_shift = AOCPC;
+		break;
+	default:
+		pr_err("Invalid Pair number %d\n", config->pair);
+		return -EFAULT;
+	}
 
+	reg = __raw_readl(g_asrc->vaddr + asrc_asrcdr_reg);
+	reg &= dp_clear_mask;
+	/* Input Part */
+	if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
+		reg |= 7 << aicp_shift;
+	else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
+		reg |= 6 << aicp_shift;
+	else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
+		tmp = asrc_get_asrck_clock_divider(config->input_sample_rate);
+		reg |= tmp << aicp_shift;
 	} else {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR2_REG);
-		reg &= 0;
-		/* Input Part */
-		if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
-			reg |= 7 << AICPC;
-		else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
-			reg |= 6 << AICPC;
-		else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 input_sample_rate);
-			reg |= tmp << AICPC;
-		} else {
-			if (config->input_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AICPC;
-			else if (config->input_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AICPC;
-			else
-				err = -EFAULT;
-		}
-		/* Output Part */
-		if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
-			reg |= 7 << AOCPC;
-		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
-			reg |= 6 << AOCPC;
-		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 output_sample_rate);
-			reg |= tmp << AOCPC;
-		} else {
-			if (config->output_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AOCPC;
-			else if (config->output_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AOCPC;
-			else
-				err = -EFAULT;
-		}
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCDR2_REG);
-
+		if (config->input_word_width == ASRC_WIDTH_16_BIT)
+			reg |= 5 << aicp_shift;
+		else if (config->input_word_width == ASRC_WIDTH_24_BIT)
+			reg |= 6 << aicp_shift;
+		else
+			err = -EFAULT;
 	}
+	/* Output Part */
+	if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
+		reg |= 7 << aocp_shift;
+	else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
+		reg |= 6 << aocp_shift;
+	else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK)
+			&& ((config->inclk & 0x0f) == INCLK_NONE))
+		reg |= 5 << aocp_shift;
+	else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
+		tmp = asrc_get_asrck_clock_divider(config->output_sample_rate);
+		reg |= tmp << aocp_shift;
+	} else {
+		if (config->output_word_width == ASRC_WIDTH_16_BIT)
+			reg |= 5 << aocp_shift;
+		else if (config->output_word_width == ASRC_WIDTH_24_BIT)
+			reg |= 6 << aocp_shift;
+		else
+			err = -EFAULT;
+	}
+	__raw_writel(reg, g_asrc->vaddr + asrc_asrcdr_reg);
 
 	/* check whether ideal ratio is a must */
 	if ((config->inclk & 0x0f) == INCLK_NONE) {
@@ -583,25 +537,6 @@ int asrc_config_pair(struct asrc_config *config)
 		}
 	}
 
-	if ((config->inclk == INCLK_NONE) &&
-			(config->outclk == OUTCLK_ESAI_TX)) {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCTR_REG);
-		reg &= ~(1 << (20 + config->pair));
-		reg |= (0x03 << (13 + (config->pair << 1)));
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCTR_REG);
-		err = asrc_set_clock_ratio(config->pair,
-					   config->input_sample_rate,
-					   config->output_sample_rate);
-		if (err < 0)
-			return err;
-		err = asrc_set_process_configuration(config->pair,
-						     config->input_sample_rate,
-						     config->
-						     output_sample_rate);
-		if (err < 0)
-			return err;
-	}
-
 	/* Config input and output wordwidth */
 	reg = __raw_readl(
 		g_asrc->vaddr + ASRC_ASRMCR1A_REG + (config->pair << 2));
@@ -632,11 +567,46 @@ int asrc_config_pair(struct asrc_config *config)
 	__raw_writel(reg,
 		 g_asrc->vaddr + ASRC_ASRMCR1A_REG + (config->pair << 2));
 
+
+	/* Enable BUFFER STALL*/
+	reg = __raw_readl(
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (config->pair << 3));
+	reg |= 1 << 21;
+	reg |= 1 << 22;
+	reg &= ~0x3f;
+	reg += ASRC_INPUTFIFO_THRESHOLD;
+	reg &= ~(0x3f << 12);
+	reg += ASRC_OUTPUTFIFO_THRESHOLD << 12;
+	__raw_writel(reg,
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (config->pair << 3));
+
 	return err;
 }
 
 EXPORT_SYMBOL(asrc_config_pair);
 
+int asrc_set_watermark(enum asrc_pair_index index, u32 in_wm, u32 out_wm)
+{
+	u32 reg;
+
+	if ((in_wm > 63) || (out_wm > 63)) {
+		pr_err("error watermark!\n");
+		return -EINVAL;
+	}
+
+	reg = __raw_readl(
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (index << 3));
+	reg |= 1 << 22;
+	reg &= ~0x3f;
+	reg += in_wm;
+	reg &= ~(0x3f << 12);
+	reg += out_wm << 12;
+	__raw_writel(reg,
+		g_asrc->vaddr + ASRC_ASRMCRA_REG + (index << 3));
+	return 0;
+}
+EXPORT_SYMBOL(asrc_set_watermark);
+
 void asrc_start_conv(enum asrc_pair_index index)
 {
 	int reg, reg_1;
@@ -828,10 +798,10 @@ static int mxc_init_asrc(void)
 	__raw_writel(0x001f00, g_asrc->vaddr + ASRC_ASRTFR1);
 
 	/* Set the processing clock for 76KHz, 133M  */
-	__raw_writel(0x30E, g_asrc->vaddr + ASRC_ASR76K_REG);
+	__raw_writel(0x06D6, g_asrc->vaddr + ASRC_ASR76K_REG);
 
 	/* Set the processing clock for 56KHz, 133M */
-	__raw_writel(0x0426, g_asrc->vaddr + ASRC_ASR56K_REG);
+	__raw_writel(0x0947, g_asrc->vaddr + ASRC_ASR56K_REG);
 
 	return 0;
 }
@@ -842,88 +812,192 @@ static void asrc_input_dma_callback(void *data)
 	unsigned long lock_flags;
 
 	params = data;
+	dma_unmap_sg(NULL, params->input_sg,
+		params->input_sg_nodes, DMA_MEM_TO_DEV);
 	spin_lock_irqsave(&input_int_lock, lock_flags);
-	params->input_queue_empty--;
 	params->input_counter++;
 	wake_up_interruptible(&params->input_wait_queue);
 	spin_unlock_irqrestore(&input_int_lock, lock_flags);
+	schedule_work(&params->task_output_work);
 	return;
 }
 
 static void asrc_output_dma_callback(void *data)
 {
 	struct asrc_pair_params *params;
-	unsigned long lock_flags;
 
 	params = data;
+	dma_unmap_sg(NULL, params->output_sg,
+		params->output_sg_nodes, DMA_MEM_TO_DEV);
+	return;
+}
 
+static unsigned int asrc_get_output_FIFO_size(enum asrc_pair_index index)
+{
+	u32 reg;
+
+	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRFSTA_REG + (index << 3));
+	return (reg & ASRC_ASRFSTX_OUTPUT_FIFO_MASK)
+			>> ASRC_ASRFSTX_OUTPUT_FIFO_OFFSET;
+}
+
+static unsigned int asrc_get_input_FIFO_size(enum asrc_pair_index index)
+{
+	u32 reg;
+
+	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRFSTA_REG + (index << 3));
+	return (reg & ASRC_ASRFSTX_INPUT_FIFO_MASK) >>
+				ASRC_ASRFSTX_INPUT_FIFO_OFFSET;
+}
+
+
+static u32 asrc_read_one_from_output_FIFO(enum asrc_pair_index index)
+{
+	return __raw_readl(g_asrc->vaddr + ASRC_ASRDOA_REG + (index << 3));
+}
+
+static void asrc_write_one_to_output_FIFO(enum asrc_pair_index index, u32 value)
+{
+	__raw_writel(value, g_asrc->vaddr + ASRC_ASRDIA_REG + (index << 3));
+}
+
+static void asrc_read_output_FIFO_S16(struct asrc_pair_params *params)
+{
+	u32 size, i, j, reg, t_size;
+	u16 *index = params->output_last_period.dma_vaddr;
+
+	t_size = 0;
+	udelay(100);
+	size = asrc_get_output_FIFO_size(params->index);
+	while (size) {
+		for (i = 0; i < size; i++) {
+			for (j = 0; j < params->channel_nums; j++) {
+				reg = asrc_read_one_from_output_FIFO(
+							params->index);
+				*(index) = (u16)reg;
+				index++;
+			}
+		}
+		t_size += size;
+		mdelay(1);
+		size = asrc_get_output_FIFO_size(params->index);
+	}
+
+	if (t_size > ASRC_OUTPUT_LAST_SAMPLE)
+		t_size = ASRC_OUTPUT_LAST_SAMPLE;
+	params->output_last_period.length = t_size * params->channel_nums * 2;
+}
+
+static void asrc_read_output_FIFO_S24(struct asrc_pair_params *params)
+{
+	u32 size, i, j, reg, t_size;
+	u32 *index = params->output_last_period.dma_vaddr;
+
+	t_size = 0;
+	udelay(100);
+	size = asrc_get_output_FIFO_size(params->index);
+	while (size) {
+		for (i = 0; i < size; i++) {
+			for (j = 0; j < params->channel_nums; j++) {
+				reg = asrc_read_one_from_output_FIFO(
+							params->index);
+				*(index) = reg;
+				index++;
+			}
+		}
+		t_size += size;
+		mdelay(1);
+		size = asrc_get_output_FIFO_size(params->index);
+	}
+
+	if (t_size > ASRC_OUTPUT_LAST_SAMPLE)
+		t_size = ASRC_OUTPUT_LAST_SAMPLE;
+	params->output_last_period.length = t_size * params->channel_nums * 4;
+}
+
+
+static void asrc_output_task_worker(struct work_struct *w)
+{
+	struct asrc_pair_params *params =
+		container_of(w, struct asrc_pair_params, task_output_work);
+	unsigned long lock_flags;
+
+	/* asrc output work struct */
+	spin_lock_irqsave(&pair_lock, lock_flags);
+	if (!params->pair_hold) {
+		spin_unlock_irqrestore(&pair_lock, lock_flags);
+		return;
+	}
+	switch (params->output_word_width) {
+	case ASRC_WIDTH_24_BIT:
+		asrc_read_output_FIFO_S24(params);
+		break;
+	case ASRC_WIDTH_16_BIT:
+	case ASRC_WIDTH_8_BIT:
+		asrc_read_output_FIFO_S16(params);
+		break;
+	default:
+		pr_err("%s: error word width\n", __func__);
+	}
+	spin_unlock_irqrestore(&pair_lock, lock_flags);
+
+	/* finish receiving all output data */
 	spin_lock_irqsave(&output_int_lock, lock_flags);
-	params->output_queue_empty--;
 	params->output_counter++;
 	wake_up_interruptible(&params->output_wait_queue);
 	spin_unlock_irqrestore(&output_int_lock, lock_flags);
-	return;
 }
 
 static void mxc_free_dma_buf(struct asrc_pair_params *params)
 {
 	if (params->input_dma_total.dma_vaddr != NULL) {
-		dma_free_coherent(g_asrc->dev,
-			params->input_dma_total.length,
-			params->input_dma_total.dma_vaddr,
-			params->input_dma_total.dma_paddr);
+		kfree(params->input_dma_total.dma_vaddr);
 		params->input_dma_total.dma_vaddr = NULL;
 	}
 
 	if (params->output_dma_total.dma_vaddr != NULL) {
-		dma_free_coherent(g_asrc->dev,
-			params->output_dma_total.length,
-			params->output_dma_total.dma_vaddr,
-			params->output_dma_total.dma_paddr);
+		kfree(params->output_dma_total.dma_vaddr);
 		params->output_dma_total.dma_vaddr = NULL;
 	}
 
+	if (params->output_last_period.dma_vaddr) {
+		dma_free_coherent(
+			g_asrc->dev, 4096,
+			params->output_last_period.dma_vaddr,
+			params->output_last_period.dma_paddr);
+		params->output_last_period.dma_vaddr = NULL;
+	}
+
 	return;
 }
 
 static int mxc_allocate_dma_buf(struct asrc_pair_params *params)
 {
-	int i;
-	struct dma_block *input_a, *output_a;
-
+	struct dma_block *input_a, *output_a, *last_period;
 	input_a = &params->input_dma_total;
 	output_a = &params->output_dma_total;
+	last_period = &params->output_last_period;
 
-	input_a->dma_vaddr =
-		dma_alloc_coherent(g_asrc->dev,
-			input_a->length, &input_a->dma_paddr,
-			GFP_KERNEL | GFP_DMA);
-	if (!input_a->dma_vaddr)
+	input_a->dma_vaddr = kzalloc(input_a->length, GFP_KERNEL);
+	if (!input_a->dma_vaddr) {
+		pr_err("fail to allocate input dma buffer!\n");
 		goto exit;
-
-	for (i = 0; i < params->buffer_num; i++) {
-		params->input_dma[i].dma_vaddr =
-			input_a->dma_vaddr + i * params->input_buffer_size;
-		params->input_dma[i].dma_paddr =
-			input_a->dma_paddr + i * params->input_buffer_size;
-		if (params->input_dma[i].dma_vaddr == NULL)
-			goto exit;
 	}
+	input_a->dma_paddr = virt_to_dma(NULL, input_a->dma_vaddr);
 
-	output_a->dma_vaddr =
-		dma_alloc_coherent(g_asrc->dev,
-			output_a->length, &output_a->dma_paddr,
-			GFP_KERNEL | GFP_DMA);
-	if (!output_a->dma_vaddr)
+	output_a->dma_vaddr = kzalloc(output_a->length, GFP_KERNEL);
+	if (!output_a->dma_vaddr) {
+		pr_err("fail to allocate output dma buffer!\n");
 		goto exit;
-	for (i = 0; i < params->buffer_num; i++) {
-		params->output_dma[i].dma_vaddr =
-			output_a->dma_vaddr + i * params->output_buffer_size;
-		params->output_dma[i].dma_paddr =
-			output_a->dma_paddr + i * params->output_buffer_size;
-		if (params->output_dma[i].dma_vaddr == NULL)
-			goto exit;
 	}
+	output_a->dma_paddr = virt_to_dma(NULL, output_a->dma_vaddr);
+
+	last_period->dma_vaddr =
+		dma_alloc_coherent(NULL,
+			4096,
+			&last_period->dma_paddr,
+			GFP_KERNEL);
+
 	return 0;
 
 exit:
@@ -957,18 +1031,30 @@ static struct dma_chan *imx_asrc_dma_alloc(u32 dma_req)
 	return dma_request_channel(mask, filter, &dma_data);
 }
 
-
-struct dma_async_tx_descriptor *imx_asrc_dma_config(
+static int imx_asrc_dma_config(
 				struct asrc_pair_params *params,
 				struct dma_chan *chan,
-				u32 dma_addr, dma_addr_t buf_addr,
+				u32 dma_addr, void *buf_addr,
 				u32 buf_len, bool in,
 				enum asrc_word_width word_width)
 {
 	struct dma_slave_config slave_config;
 	enum dma_slave_buswidth buswidth;
+	struct scatterlist *sg;
+	unsigned int sg_nent, sg_index;
+	struct dma_async_tx_descriptor *desc;
 	int ret;
 
+	if (in) {
+		sg = params->input_sg;
+		sg_nent = params->input_sg_nodes;
+		desc = params->desc_in;
+	} else {
+		sg = params->output_sg;
+		sg_nent = params->output_sg_nodes;
+		desc = params->desc_out;
+	}
+
 	switch (word_width) {
 	case ASRC_WIDTH_16_BIT:
 		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
@@ -978,7 +1064,7 @@ struct dma_async_tx_descriptor *imx_asrc_dma_config(
 		break;
 	default:
 		pr_err("Error word_width\n");
-		return NULL;
+		return -EINVAL;
 	}
 
 	if (in) {
@@ -986,25 +1072,252 @@ struct dma_async_tx_descriptor *imx_asrc_dma_config(
 		slave_config.dst_addr = dma_addr;
 		slave_config.dst_addr_width = buswidth;
 		slave_config.dst_maxburst =
-			ASRC_INPUTFIFO_THRESHOLD * params->channel_nums;
+			params->input_wm * params->channel_nums;
 	} else {
 		slave_config.direction = DMA_DEV_TO_MEM;
 		slave_config.src_addr = dma_addr;
 		slave_config.src_addr_width = buswidth;
 		slave_config.src_maxburst =
-			ASRC_OUTPUTFIFO_THRESHOLD * params->channel_nums;
+			params->output_wm * params->channel_nums;
 	}
 	ret = dmaengine_slave_config(chan, &slave_config);
 	if (ret) {
 		pr_err("imx_asrc_dma_config(%d) failed\r\n", in);
-		return NULL;
+		return -EINVAL;
 	}
 
-	return chan->device->device_prep_dma_cyclic(chan, buf_addr,
-			buf_len * params->buffer_num,
-			buf_len,
-			in == true ?
-			DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	sg_init_table(sg, sg_nent);
+	switch (sg_nent) {
+	case 1:
+		sg_init_one(sg, buf_addr, buf_len);
+		break;
+	case 2:
+	case 3:
+	case 4:
+		for (sg_index = 0; sg_index < (sg_nent - 1); sg_index++) {
+			sg_set_buf(&sg[sg_index],
+				buf_addr + sg_index * ASRC_MAX_BUFFER_SIZE,
+				ASRC_MAX_BUFFER_SIZE);
+		}
+		sg_set_buf(&sg[sg_index],
+			buf_addr + sg_index * ASRC_MAX_BUFFER_SIZE,
+			buf_len - ASRC_MAX_BUFFER_SIZE * sg_index);
+		break;
+	default:
+		pr_err("Error Input DMA nodes number[%d]!", sg_nent);
+		return -EINVAL;
+	}
+
+	ret = dma_map_sg(NULL, sg, sg_nent, slave_config.direction);
+	if (ret != sg_nent) {
+		pr_err("DMA mapping error!!\n");
+		return -EINVAL;
+	}
+
+	desc = chan->device->device_prep_slave_sg(chan,
+					sg, sg_nent, slave_config.direction, 1);
+
+	if (in) {
+		params->desc_in = desc;
+		params->desc_in->callback = asrc_input_dma_callback;
+	} else {
+		params->desc_out = desc;
+		params->desc_out->callback = asrc_output_dma_callback;
+	}
+	if (desc) {
+		desc->callback = in ?
+			asrc_input_dma_callback : asrc_output_dma_callback;
+		desc->callback_param = params;
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int mxc_asrc_prepare_input_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	u32 word_size;
+
+	switch (params->input_word_width) {
+	case ASRC_WIDTH_24_BIT:
+		word_size = 4;
+		break;
+	case ASRC_WIDTH_16_BIT:
+	case ASRC_WIDTH_8_BIT:
+		word_size = 2;
+		break;
+	default:
+		pr_err("error input word size!\n");
+		return -EINVAL;
+	}
+
+	if (pbuf->input_buffer_length <
+		word_size * params->channel_nums * params->input_wm) {
+		pr_err("input buffer size[%d] is too small!\n",
+					pbuf->input_buffer_length);
+		return -EINVAL;
+	}
+
+	/* copy origin data into input buffer */
+	if (copy_from_user(
+		params->input_dma_total.dma_vaddr,
+		(void __user *)pbuf->input_buffer_vaddr,
+		pbuf->input_buffer_length)) {
+		return -EFAULT;
+	}
+
+	params->input_dma_total.length = pbuf->input_buffer_length;
+	params->input_sg_nodes =
+		params->input_dma_total.length / ASRC_MAX_BUFFER_SIZE + 1;
+
+	return imx_asrc_dma_config(
+			params,
+			params->input_dma_channel,
+			asrc_get_per_addr(params->index, 1),
+			params->input_dma_total.dma_vaddr,
+			params->input_dma_total.length, 1,
+			params->input_word_width);
+
+}
+
+static int mxc_asrc_prepare_output_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	u32 word_size;
+
+	switch (params->output_word_width) {
+	case ASRC_WIDTH_24_BIT:
+		word_size = 4;
+		break;
+	case ASRC_WIDTH_16_BIT:
+	case ASRC_WIDTH_8_BIT:
+		word_size = 2;
+		break;
+	default:
+		pr_err("error word size!\n");
+		return -EINVAL;
+	}
+
+	if (pbuf->output_buffer_length <
+		ASRC_OUTPUT_LAST_SAMPLE * word_size * params->channel_nums) {
+		pr_err("output buffer size[%d] is wrong.\n",
+				pbuf->output_buffer_length);
+		return -EINVAL;
+	}
+
+	params->output_dma_total.length =
+		pbuf->output_buffer_length -
+		ASRC_OUTPUT_LAST_SAMPLE * word_size * params->channel_nums ;
+
+	params->output_sg_nodes =
+		params->output_dma_total.length / ASRC_MAX_BUFFER_SIZE + 1;
+
+	return imx_asrc_dma_config(
+			params,
+			params->output_dma_channel,
+			asrc_get_per_addr(params->index, 0),
+			params->output_dma_total.dma_vaddr,
+			params->output_dma_total.length, 0,
+			params->output_word_width);
+}
+
+int mxc_asrc_process_output_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	unsigned long lock_flags;
+
+	if (!wait_event_interruptible_timeout
+	    (params->output_wait_queue,
+	     params->output_counter != 0, 10 * HZ)) {
+		pr_info
+		    ("ASRC_DQ_OUTBUF timeout counter %x\n",
+		     params->output_counter);
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		pr_info("ASRC_DQ_INBUF interrupt received\n");
+		return -ERESTARTSYS;
+	}
+	spin_lock_irqsave(&output_int_lock, lock_flags);
+	params->output_counter--;
+	spin_unlock_irqrestore(&output_int_lock, lock_flags);
+
+	pbuf->output_buffer_length = params->output_dma_total.length;
+
+	if (copy_to_user((void __user *)pbuf->output_buffer_vaddr,
+				params->output_dma_total.dma_vaddr,
+				params->output_dma_total.length))
+		return -EFAULT;
+
+	pbuf->output_buffer_length += params->output_last_period.length;
+
+	if (copy_to_user((void __user *)(pbuf->output_buffer_vaddr +
+				params->output_dma_total.length),
+				params->output_last_period.dma_vaddr,
+				params->output_last_period.length))
+		return -EFAULT;
+
+	return 0;
+
+}
+
+int mxc_asrc_process_input_buffer(struct asrc_pair_params *params,
+					struct asrc_convert_buffer *pbuf)
+{
+	unsigned long lock_flags;
+
+	if (!wait_event_interruptible_timeout
+	    (params->input_wait_queue,
+	     params->input_counter != 0, 10 * HZ)) {
+		pr_info
+		    ("ASRC_DQ_INBUF timeout counter %x\n",
+		     params->input_counter);
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		pr_info("ASRC_DQ_INBUF interrupt received\n");
+		return -ERESTARTSYS;
+	}
+	spin_lock_irqsave(&input_int_lock, lock_flags);
+	params->input_counter--;
+	spin_unlock_irqrestore(&input_int_lock, lock_flags);
+
+	pbuf->input_buffer_length = params->input_dma_total.length;
+
+	return 0;
+}
+
+static void mxc_asrc_submit_dma(struct asrc_pair_params *params)
+{
+	enum asrc_pair_index index;
+	u32 size, i, j;
+	index = params->index;
+
+	/*  read all data in OUTPUT FIFO*/
+	size = asrc_get_output_FIFO_size(params->index);
+	while (size) {
+		for (j = 0; j < size; j++) {
+			for (i = 0; i < params->channel_nums; i++)
+				asrc_read_one_from_output_FIFO(params->index);
+		}
+		mdelay(1);
+		size = asrc_get_output_FIFO_size(params->index);
+	}
+
+	/* Fill the input FIFO until reach the stall level */
+	size = asrc_get_input_FIFO_size(params->index);
+	while (size < 3) {
+		for (i = 0; i < params->channel_nums; i++)
+			asrc_write_one_to_output_FIFO(params->index, 0);
+		size = asrc_get_input_FIFO_size(params->index);
+	}
+
+	/* submit dma request */
+	dmaengine_submit(params->desc_in);
+	dmaengine_submit(params->desc_out);
+	sdma_set_event_pending(params->input_dma_channel);
+
 }
 
 /*!
@@ -1063,6 +1376,13 @@ static long asrc_ioctl(struct file *file,
 			err = asrc_config_pair(&config);
 			if (err < 0)
 				break;
+
+			params->input_wm = 4;
+			params->output_wm = 2;
+			err = asrc_set_watermark(config.pair,
+					params->input_wm, params->output_wm);
+			if (err < 0)
+				break;
 			params->output_buffer_size = config.dma_buffer_size;
 			params->input_buffer_size = config.dma_buffer_size;
 			if (config.buffer_num > ASRC_DMA_BUFFER_NUM)
@@ -1070,10 +1390,14 @@ static long asrc_ioctl(struct file *file,
 			else
 				params->buffer_num = config.buffer_num;
 
-			params->input_dma_total.length =
-				params->input_buffer_size * params->buffer_num;
-			params->output_dma_total.length =
-				params->output_buffer_size * params->buffer_num;
+			params->input_dma_total.length = ASRC_DMA_BUFFER_SIZE;
+			params->output_dma_total.length = ASRC_DMA_BUFFER_SIZE;
+
+			params->input_word_width = config.input_word_width;
+			params->output_word_width = config.output_word_width;
+
+			params->input_sample_rate = config.input_sample_rate;
+			params->output_sample_rate = config.output_sample_rate;
 
 			err = mxc_allocate_dma_buf(params);
 			if (err < 0)
@@ -1103,51 +1427,18 @@ static long asrc_ioctl(struct file *file,
 				err = -EBUSY;
 			}
 
-			params->desc_in = imx_asrc_dma_config(params,
-					params->input_dma_channel,
-					asrc_get_per_addr(params->index, 1),
-					params->input_dma[0].dma_paddr,
-					params->input_buffer_size, 1,
-					config.input_word_width);
-			if (params->desc_in) {
-				params->desc_in->callback =
-						asrc_input_dma_callback;
-				params->desc_in->callback_param = params;
-			} else {
-				pr_err("unable to get desc_in\r\n");
-				err = -EINVAL;
-				break;
-			}
-
 			params->output_dma_channel = imx_asrc_dma_alloc(tx_id);
 			if (params->output_dma_channel == NULL) {
 				pr_err("unable to get tx channel %d\n", tx_id);
 				err = -EBUSY;
 			}
-			params->desc_out = imx_asrc_dma_config(params,
-					params->output_dma_channel,
-					asrc_get_per_addr(params->index, 0),
-					params->output_dma[0].dma_paddr,
-					params->output_buffer_size, 0,
-					config.output_word_width);
-			if (params->desc_out) {
-				params->desc_out->callback =
-						asrc_output_dma_callback;
-				params->desc_out->callback_param = params;
-			} else {
-				pr_err("unable to get desc_out\r\n");
-				err = -EINVAL;
-				break;
-			}
 
-			params->input_queue_empty = 0;
-			params->output_queue_empty = 0;
-			INIT_LIST_HEAD(&params->input_queue);
-			INIT_LIST_HEAD(&params->input_done_queue);
-			INIT_LIST_HEAD(&params->output_queue);
-			INIT_LIST_HEAD(&params->output_done_queue);
 			init_waitqueue_head(&params->input_wait_queue);
 			init_waitqueue_head(&params->output_wait_queue);
+			/* Add work struct to cover the task of
+			 * receive last period of output data.*/
+			INIT_WORK(&params->task_output_work,
+						asrc_output_task_worker);
 
 			if (copy_to_user
 			    ((void __user *)arg, &config,
@@ -1155,35 +1446,10 @@ static long asrc_ioctl(struct file *file,
 				err = -EFAULT;
 			break;
 		}
-	case ASRC_QUERYBUF:
-		{
-			struct asrc_querybuf buffer;
-			unsigned int index_n;
-			if (copy_from_user
-			    (&buffer, (void __user *)arg,
-			     sizeof(struct asrc_querybuf))) {
-				err = -EFAULT;
-				break;
-			}
-			index_n = buffer.buffer_index;
-
-			buffer.input_offset = (unsigned long)
-				params->input_dma[index_n].dma_paddr;
-			buffer.input_length = params->input_buffer_size;
-
-			buffer.output_offset = (unsigned long)
-				params->output_dma[index_n].dma_paddr;
-			buffer.output_length = params->output_buffer_size;
-
-			if (copy_to_user
-			    ((void __user *)arg, &buffer,
-			     sizeof(struct asrc_querybuf)))
-				err = -EFAULT;
-			break;
-		}
 	case ASRC_RELEASE_PAIR:
 		{
 			enum asrc_pair_index index;
+			unsigned long lock_flags;
 			if (copy_from_user
 			    (&index, (void __user *)arg,
 			     sizeof(enum asrc_pair_index))) {
@@ -1191,6 +1457,17 @@ static long asrc_ioctl(struct file *file,
 				break;
 			}
 
+			if (index < 0) {
+				pr_err("unvalid index: %d!\n", index);
+				err = -EFAULT;
+				break;
+			}
+
+			params->asrc_active = 0;
+
+			spin_lock_irqsave(&pair_lock, lock_flags);
+			params->pair_hold = 0;
+			spin_unlock_irqrestore(&pair_lock, lock_flags);
 			if (params->input_dma_channel)
 				dma_release_channel(params->input_dma_channel);
 			if (params->output_dma_channel)
@@ -1199,191 +1476,53 @@ static long asrc_ioctl(struct file *file,
 			mxc_free_dma_buf(params);
 			asrc_release_pair(index);
 			asrc_finish_conv(index);
-			params->pair_hold = 0;
 			break;
 		}
-	case ASRC_Q_INBUF:
+	case ASRC_CONVERT:
 		{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
+			struct asrc_convert_buffer buf;
 			if (copy_from_user
 			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
+			     sizeof(struct asrc_convert_buffer))) {
 				err = -EFAULT;
 				break;
 			}
 
-			spin_lock_irqsave(&input_int_lock, lock_flags);
-			params->input_dma[buf.index].index = buf.index;
-			params->input_dma[buf.index].length = buf.length;
-			list_add_tail(&params->input_dma[buf.index].
-				      queue, &params->input_queue);
-			if (!list_empty(&params->input_queue)) {
-				block =
-				    list_entry(params->input_queue.next,
-					       struct dma_block, queue);
-
-				params->input_queue_empty++;
-				list_del(params->input_queue.next);
-				list_add_tail(&block->queue,
-					      &params->input_done_queue);
-			}
-			spin_unlock_irqrestore(&input_int_lock, lock_flags);
-			break;
-		}
-	case ASRC_DQ_INBUF:{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
-			if (copy_from_user
-			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
-				err = -EFAULT;
+			err = mxc_asrc_prepare_input_buffer(params, &buf);
+			if (err)
 				break;
-			}
-			/* if ASRC is inactive, nonsense to DQ buffer */
-			if (params->asrc_active == 0) {
-				err = -EFAULT;
-				buf.buf_valid = ASRC_BUF_NA;
-				if (copy_to_user
-				    ((void __user *)arg, &buf,
-				     sizeof(struct asrc_buffer)))
-					err = -EFAULT;
-				break;
-			}
 
-			if (!wait_event_interruptible_timeout
-			    (params->input_wait_queue,
-			     params->input_counter != 0, 10 * HZ)) {
-				pr_info
-				    ("ASRC_DQ_INBUF timeout counter %x\n",
-				     params->input_counter);
-				err = -ETIME;
-				break;
-			} else if (signal_pending(current)) {
-				pr_info("ASRC_DQ_INBUF interrupt received\n");
-				err = -ERESTARTSYS;
-				break;
-			}
-			spin_lock_irqsave(&input_int_lock, lock_flags);
-			params->input_counter--;
-			block =
-			    list_entry(params->input_done_queue.next,
-				       struct dma_block, queue);
-			list_del(params->input_done_queue.next);
-			spin_unlock_irqrestore(&input_int_lock, lock_flags);
-			buf.index = block->index;
-			buf.length = block->length;
-			buf.buf_valid = ASRC_BUF_AV;
-			if (copy_to_user
-			    ((void __user *)arg, &buf,
-			     sizeof(struct asrc_buffer)))
-				err = -EFAULT;
-
-			break;
-		}
-	case ASRC_Q_OUTBUF:{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
-			if (copy_from_user
-			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
-				err = -EFAULT;
+			err = mxc_asrc_prepare_output_buffer(params, &buf);
+			if (err)
 				break;
-			}
 
-			spin_lock_irqsave(&output_int_lock, lock_flags);
-			params->output_dma[buf.index].index = buf.index;
-			params->output_dma[buf.index].length = buf.length;
-			list_add_tail(&params->output_dma[buf.index].
-				      queue, &params->output_queue);
-			if (!list_empty(&params->output_queue)) {
-				block =
-				    list_entry(params->output_queue.
-					       next, struct dma_block, queue);
-				list_del(params->output_queue.next);
-				list_add_tail(&block->queue,
-					      &params->output_done_queue);
-				params->output_queue_empty++;
-			}
+			mxc_asrc_submit_dma(params);
 
-			spin_unlock_irqrestore(&output_int_lock, lock_flags);
-			break;
-		}
-	case ASRC_DQ_OUTBUF:{
-			struct asrc_buffer buf;
-			struct dma_block *block;
-			unsigned long lock_flags;
-			if (copy_from_user
-			    (&buf, (void __user *)arg,
-			     sizeof(struct asrc_buffer))) {
-				err = -EFAULT;
-				break;
-			}
-			/* if ASRC is inactive, nonsense to DQ buffer */
-			if (params->asrc_active == 0) {
-				buf.buf_valid = ASRC_BUF_NA;
-				err = -EFAULT;
-				if (copy_to_user
-				    ((void __user *)arg, &buf,
-				     sizeof(struct asrc_buffer)))
-					err = -EFAULT;
+			err = mxc_asrc_process_output_buffer(params, &buf);
+			if (err)
 				break;
-			}
 
-			if (!wait_event_interruptible_timeout
-			    (params->output_wait_queue,
-			     params->output_counter != 0, 10 * HZ)) {
-				pr_info
-				    ("ASRC_DQ_OUTBUF timeout counter %x\n",
-				     params->output_counter);
-				err = -ETIME;
-				break;
-			} else if (signal_pending(current)) {
-				pr_info("ASRC_DQ_INBUF interrupt received\n");
-				err = -ERESTARTSYS;
+			err = mxc_asrc_process_input_buffer(params, &buf);
+			if (err)
 				break;
-			}
-			spin_lock_irqsave(&output_int_lock, lock_flags);
-			params->output_counter--;
-			block =
-			    list_entry(params->output_done_queue.next,
-				       struct dma_block, queue);
-			list_del(params->output_done_queue.next);
-			spin_unlock_irqrestore(&output_int_lock, lock_flags);
-			buf.index = block->index;
-			buf.length = block->length;
-			buf.buf_valid = ASRC_BUF_AV;
+
 			if (copy_to_user
 			    ((void __user *)arg, &buf,
-			     sizeof(struct asrc_buffer)))
+			     sizeof(struct asrc_convert_buffer)))
 				err = -EFAULT;
 
 			break;
 		}
 	case ASRC_START_CONV:{
 			enum asrc_pair_index index;
-			unsigned long lock_flags;
 			if (copy_from_user
 			    (&index, (void __user *)arg,
 			     sizeof(enum asrc_pair_index))) {
 				err = -EFAULT;
 				break;
 			}
-			spin_lock_irqsave(&input_int_lock, lock_flags);
-			if (params->input_queue_empty == 0) {
-				err = -EFAULT;
-				pr_info
-				    ("ASRC_START_CONV - no block available\n");
-				break;
-			}
-			spin_unlock_irqrestore(&input_int_lock, lock_flags);
-			params->asrc_active = 1;
-			dmaengine_submit(params->desc_in);
-			dmaengine_submit(params->desc_out);
 
+			params->asrc_active = 1;
 			asrc_start_conv(index);
 
 			break;
@@ -1423,22 +1562,14 @@ static long asrc_ioctl(struct file *file,
 			u32 rx_id, tx_id;
 			char *rx_name, *tx_name;
 			spin_lock_irqsave(&input_int_lock, lock_flags);
-			while (!list_empty(&params->input_queue))
-				list_del(params->input_queue.next);
-			while (!list_empty(&params->input_done_queue))
-				list_del(params->input_done_queue.next);
+
 			params->input_counter = 0;
-			params->input_queue_empty = 0;
 			spin_unlock_irqrestore(&input_int_lock, lock_flags);
 
 			/* flush output dma buffer */
 			spin_lock_irqsave(&output_int_lock, lock_flags);
-			while (!list_empty(&params->output_queue))
-				list_del(params->output_queue.next);
-			while (!list_empty(&params->output_done_queue))
-				list_del(params->output_done_queue.next);
+
 			params->output_counter = 0;
-			params->output_queue_empty = 0;
 			spin_unlock_irqrestore(&output_int_lock, lock_flags);
 
 			/* release DMA and request again */
@@ -1519,9 +1650,11 @@ static int mxc_asrc_open(struct inode *inode, struct file *file)
 static int mxc_asrc_close(struct inode *inode, struct file *file)
 {
 	struct asrc_pair_params *pair_params;
+	unsigned long lock_flags;
 	pair_params = file->private_data;
 	if (pair_params) {
 		if (pair_params->asrc_active) {
+			pair_params->asrc_active = 0;
 			dmaengine_terminate_all(
 					pair_params->input_dma_channel);
 			dmaengine_terminate_all(
@@ -1531,6 +1664,9 @@ static int mxc_asrc_close(struct inode *inode, struct file *file)
 			wake_up_interruptible(&pair_params->output_wait_queue);
 		}
 		if (pair_params->pair_hold) {
+			spin_lock_irqsave(&pair_lock, lock_flags);
+			pair_params->pair_hold = 0;
+			spin_unlock_irqrestore(&pair_lock, lock_flags);
 			if (pair_params->input_dma_channel)
 				dma_release_channel(
 					pair_params->input_dma_channel);
@@ -1632,13 +1768,26 @@ static int asrc_write_proc_attr(struct file *file, const char *buffer,
 		total = 10;
 	else
 		total = 5;
-	if ((na + nb + nc) != total) {
-		pr_info("Wrong ASRCNR settings\n");
-		return -EFAULT;
+
+	if ((na + nb + nc) > total) {
+		pr_err("Don't surpass %d for total.\n", total);
+		return -EINVAL;
+	} else if (na % 2 != 0 || nb % 2 != 0 || nc % 2 != 0) {
+		pr_err("Please set an even number for each pair.\n");
+		return -EINVAL;
+	} else if (na < 0 || nb < 0 || nc < 0) {
+		pr_err("Please set an positive number for each pair.\n");
+		return -EINVAL;
 	}
+
 	reg = na | (nb << g_asrc->mxc_asrc_data->channel_bits) |
 		(nc << (g_asrc->mxc_asrc_data->channel_bits * 2));
 
+	/* Update chn_max */
+	g_asrc->asrc_pair[ASRC_PAIR_A].chn_max = na;
+	g_asrc->asrc_pair[ASRC_PAIR_B].chn_max = nb;
+	g_asrc->asrc_pair[ASRC_PAIR_C].chn_max = nc;
+
 	clk_enable(g_asrc->mxc_asrc_data->asrc_core_clk);
 	__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCNCR_REG);
 	clk_disable(g_asrc->mxc_asrc_data->asrc_core_clk);
@@ -1831,6 +1980,18 @@ static struct platform_driver mxc_asrc_driver = {
 static __init int asrc_init(void)
 {
 	int ret;
+
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_start_conv = asrc_start_conv;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_stop_conv = asrc_stop_conv;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_get_dma_request = asrc_get_dma_request;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_per_addr = asrc_get_per_addr;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_req_pair = asrc_req_pair;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_config_pair = asrc_config_pair;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_release_pair = asrc_release_pair;
+	asrc_pcm_p2p_ops_asrc.asrc_p2p_finish_conv = asrc_finish_conv;
+
+	asrc_p2p_hook(&asrc_pcm_p2p_ops_asrc);
+
 	ret = platform_driver_register(&mxc_asrc_driver);
 	return ret;
 }
@@ -1840,6 +2001,8 @@ static __init int asrc_init(void)
  *
  */ static void __exit asrc_exit(void)
 {
+	asrc_p2p_hook(NULL);
+
 	platform_driver_unregister(&mxc_asrc_driver);
 	return;
 }
diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index bc5ec02..93b1259 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
@@ -54,7 +54,8 @@ OBJS += $(HAL_KERNEL_DIR)/gc_hal_kernel.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_event.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_heap.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_mmu.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o
+        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o \
+        $(HAL_KERNEL_DIR)/gc_hal_kernel_power.o
 
 OBJS += $(ARCH_KERNEL_DIR)/gc_hal_kernel_context.o \
         $(ARCH_KERNEL_DIR)/gc_hal_kernel_hardware.o
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
index a8b9922..cf40e3f 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
index e2a9f8e..aa767ee 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_kernel_hardware_command_vg_h_
 #define __gc_hal_kernel_hardware_command_vg_h_
 
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
index ec5d858..70c2cd6 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_hardware_command_vg.h"
@@ -219,7 +217,6 @@ _IdentifyHardware(
     return status;
 }
 
-#if gcdPOWER_MANAGEMENT
 static gctTHREADFUNCRESULT gctTHREADFUNCTYPE
 _TimeIdleThread(
     gctTHREADFUNCPARAMETER ThreadParameter
@@ -264,8 +261,6 @@ _TimeIdleThread(
     }
     return 0;
 }
-#endif
-
 
 /******************************************************************************\
 ****************************** gckVGHARDWARE API code *****************************
@@ -310,6 +305,8 @@ gckVGHARDWARE_Construct(
 
     do
     {
+        gcmkERR_BREAK(gckOS_SetGPUPower(Os, gcvCORE_VG, gcvTRUE, gcvTRUE));
+
         status = _ResetGPU(Os);
 
         if (status != gcvSTATUS_OK)
@@ -342,10 +339,10 @@ gckVGHARDWARE_Construct(
 
         hardware->powerMutex            = gcvNULL;
         hardware->idleSignal            = gcvNULL;
-        hardware->chipPowerState        = gcvPOWER_OFF;
+        hardware->chipPowerState        = gcvPOWER_ON;
         hardware->chipPowerStateGlobal  = gcvPOWER_ON;
-        hardware->clockState            = gcvFALSE;
-        hardware->powerState            = gcvFALSE;
+        hardware->clockState            = gcvTRUE;
+        hardware->powerState            = gcvTRUE;
         hardware->powerOffTimeout       = gcdPOWEROFF_TIMEOUT;
         hardware->powerOffTime          = 0;
         hardware->timeIdleThread        = gcvNULL;
@@ -369,14 +366,17 @@ gckVGHARDWARE_Construct(
 
         gcmkERR_BREAK(gckOS_CreateMutex(Os, &hardware->powerMutex));
         gcmkERR_BREAK(gckOS_CreateSignal(Os, gcvFALSE, &hardware->idleSignal));
-#if gcdPOWER_MANAGEMENT
+
+        /* Enable power management by default. */
+        hardware->powerManagement = gcvTRUE;
+
         gcmkERR_BREAK(gckOS_StartThread(
             hardware->os,
             _TimeIdleThread,
             hardware,
             &hardware->timeIdleThread
             ));
-#endif
+
         /* Return pointer to the gckVGHARDWARE object. */
         *Hardware = hardware;
 
@@ -396,6 +396,8 @@ gckVGHARDWARE_Construct(
         gcmkVERIFY_OK(gckOS_Free(Os, hardware));
     }
 
+    gcmkVERIFY_OK(gckOS_SetGPUPower(Os, gcvCORE_VG, gcvFALSE, gcvFALSE));
+
     gcmkFOOTER();
     /* Return the status. */
     return status;
@@ -426,11 +428,10 @@ gckVGHARDWARE_Destroy(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-#if gcdPOWER_MANAGEMENT
     Hardware->killThread  = gcvTRUE;
     gcmkVERIFY_OK(gckOS_Signal(Hardware->os, Hardware->idleSignal, gcvTRUE));
     gcmkVERIFY_OK(gckOS_StopThread(Hardware->os, Hardware->timeIdleThread));
-#endif
+
     /* Mark the object as unknown. */
     Hardware->object.type = gcvOBJ_UNKNOWN;
 
@@ -1433,7 +1434,6 @@ gckVGHARDWARE_ReadInterrupt(
     return status;
 }
 
-#if gcdPOWER_MANAGEMENT
 static gceSTATUS _CommandStall(
     gckVGHARDWARE Hardware)
 {
@@ -1478,7 +1478,6 @@ static gceSTATUS _CommandStall(
     /* Return the status. */
     return status;
 }
-#endif
 
 /*******************************************************************************
 **
@@ -1501,7 +1500,6 @@ gckVGHARDWARE_SetPowerManagementState(
     IN gceCHIPPOWERSTATE State
     )
 {
-#if gcdPOWER_MANAGEMENT
     gceSTATUS status;
     gckVGCOMMAND command = gcvNULL;
     gckOS os;
@@ -1601,6 +1599,12 @@ gckVGHARDWARE_SetPowerManagementState(
     command = Hardware->kernel->command;
     gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
 
+    if (Hardware->powerManagement == gcvFALSE)
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
     /* Start profiler. */
     gcmkPROFILE_INIT(freq, time);
 
@@ -1801,6 +1805,8 @@ gckVGHARDWARE_SetPowerManagementState(
 
     if (flag & gcvPOWER_FLAG_INITIALIZE)
     {
+        gcmkONERROR(gckVGHARDWARE_SetMMU(Hardware, Hardware->kernel->mmu->pageTableLogical));
+
         /* Force the command queue to reload the next context. */
         command->currentContext = 0;
     }
@@ -1913,10 +1919,6 @@ OnError:
     /* Return the status. */
     gcmkFOOTER();
     return status;
-#else /* gcdPOWER_MANAGEMENT */
-    /* Do nothing */
-    return gcvSTATUS_OK;
-#endif
 }
 
 /*******************************************************************************
@@ -1954,6 +1956,40 @@ gckVGHARDWARE_QueryPowerManagementState(
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckVGHARDWARE_SetPowerManagement
+**
+**  Configure GPU power management function.
+**  Only used in driver initialization stage.
+**
+**  INPUT:
+**
+**      gckVGHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**      gctBOOL PowerManagement
+**          Power Mangement State.
+**
+*/
+gceSTATUS
+gckVGHARDWARE_SetPowerManagement(
+    IN gckVGHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    )
+{
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    Hardware->powerManagement = PowerManagement;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 gceSTATUS
 gckVGHARDWARE_SetPowerOffTimeout(
     IN gckVGHARDWARE  Hardware,
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
index e3714b7..16b81ae 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_kernel_hardware_vg_h_
 #define __gc_hal_kernel_hardware_vg_h_
 
@@ -69,6 +66,8 @@ struct _gckVGHARDWARE
     gctTHREAD                   timeIdleThread;
     gctBOOL                     killThread;
     gctPOINTER                  pageTableDirty;
+
+    gctBOOL                     powerManagement;
 };
 
 #endif /* __gc_hal_kernel_hardware_h_ */
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
index d8898a3..24003e7 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_context.h"
@@ -474,7 +471,7 @@ _InitializeContextBuffer(
     index += _SwitchPipe(Context, index, gcvPIPE_3D);
 
     /* Current context pointer. */
-#if gcdDEBUG && 1
+#if gcdDEBUG
     index += _State(Context, index, 0x03850 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 #endif
 
@@ -623,6 +620,7 @@ _InitializeContextBuffer(
         index += _State(Context, index, 0x10180 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10200 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10280 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
+        index += _State(Context, index, 0x02C00 >> 2, 0x00000000, 256, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10300 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10380 >> 2, 0x00321000, 32, gcvFALSE, gcvFALSE);
         index += _State(Context, index, 0x10400 >> 2, 0x00000000, 32, gcvFALSE, gcvFALSE);
@@ -905,6 +903,16 @@ _DestroyContext(
             /* Free state delta map. */
             if (buffer->logical != gcvNULL)
             {
+#if gcdVIRTUAL_COMMAND_BUFFER
+                gcmkONERROR(gckEVENT_DestroyVirtualCommandBuffer(
+                    Context->hardware->kernel->eventObj,
+                    Context->totalSize,
+                    buffer->physical,
+                    buffer->logical,
+                    gcvKERNEL_PIXEL
+                    ));
+
+#else
                 gcmkONERROR(gckEVENT_FreeContiguousMemory(
                     Context->hardware->kernel->eventObj,
                     Context->totalSize,
@@ -912,6 +920,7 @@ _DestroyContext(
                     buffer->logical,
                     gcvKERNEL_PIXEL
                     ));
+#endif
 
                 buffer->logical = gcvNULL;
             }
@@ -1149,6 +1158,16 @@ gckCONTEXT_Construct(
             ));
 
         /* Create a new physical context buffer. */
+#if gcdVIRTUAL_COMMAND_BUFFER
+        gcmkONERROR(gckKERNEL_AllocateVirtualCommandBuffer(
+            context->hardware->kernel,
+            gcvFALSE,
+            &context->totalSize,
+            &buffer->physical,
+            &pointer
+            ));
+
+#else
         gcmkONERROR(gckOS_AllocateContiguous(
             Os,
             gcvFALSE,
@@ -1156,6 +1175,7 @@ gckCONTEXT_Construct(
             &buffer->physical,
             &pointer
             ));
+#endif
 
         buffer->logical = pointer;
 
@@ -1234,11 +1254,11 @@ gckCONTEXT_Construct(
             }
 
             /* Copy the current context. */
-            gcmkONERROR(gckOS_MemCopy(
+            gckOS_MemCopy(
                 tempContext->logical,
                 currContext->logical,
                 context->totalSize
-                ));
+                );
 
             /* Get the next context buffer. */
             tempContext = tempContext->next;
@@ -1419,7 +1439,7 @@ gckCONTEXT_Update(
             gcmkONERROR(gckKERNEL_OpenUserData(
                 kernel, needCopy,
                 Context->recordArray,
-                kDelta->recordArray, Context->recordArraySize,
+                gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
 
@@ -1528,13 +1548,13 @@ gckCONTEXT_Update(
             gcmkASSERT(kDelta->refCount >= 0);
 
             /* Get the next state delta. */
-            nDelta = kDelta->next;
+            nDelta = gcmUINT64_TO_PTR(kDelta->next);
 
             /* Get access to the state records. */
             gcmkONERROR(gckKERNEL_CloseUserData(
                 kernel, needCopy,
                 gcvFALSE,
-                kDelta->recordArray, Context->recordArraySize,
+                gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
 
@@ -1681,7 +1701,7 @@ OnError:
         gcmkVERIFY_OK(gckKERNEL_CloseUserData(
             kernel, needCopy,
             gcvFALSE,
-            kDelta->recordArray, Context->recordArraySize,
+            gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
             (gctPOINTER *) &recordArray
             ));
 	}
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
index a5030de..7554045 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_context_h_
 #define __gc_hal_kernel_context_h_
 
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
index 377ce32..00f3839 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,13 +19,24 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_HARDWARE
 
+typedef struct _gcsiDEBUG_REGISTERS * gcsiDEBUG_REGISTERS_PTR;
+typedef struct _gcsiDEBUG_REGISTERS
+{
+    gctSTRING       module;
+    gctUINT         index;
+    gctUINT         shift;
+    gctUINT         data;
+    gctUINT         count;
+    gctUINT32       signature;
+}
+gcsiDEBUG_REGISTERS;
+
+extern int gpu3DMinClock;
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
@@ -165,6 +176,7 @@ _IdentifyHardware(
         Identity->chipMinorFeatures1 = 0;
         Identity->chipMinorFeatures2 = 0;
         Identity->chipMinorFeatures3 = 0;
+        Identity->chipMinorFeatures4 = 0;
     }
     else
     {
@@ -196,13 +208,20 @@ _IdentifyHardware(
                 gckOS_ReadRegisterEx(Os, Core,
                                      0x00088,
                                      &Identity->chipMinorFeatures3));
+
+            /* Read chip minor featuress register #4. */
+            gcmkONERROR(
+                gckOS_ReadRegisterEx(Os, Core,
+                                     0x00094,
+                                     &Identity->chipMinorFeatures4));
         }
         else
         {
-            /* Chip doesn't has minor features register #1 or 2 or 3. */
+            /* Chip doesn't has minor features register #1 or 2 or 3 or 4. */
             Identity->chipMinorFeatures1 = 0;
             Identity->chipMinorFeatures2 = 0;
             Identity->chipMinorFeatures3 = 0;
+            Identity->chipMinorFeatures4 = 0;
         }
     }
 
@@ -221,17 +240,18 @@ _IdentifyHardware(
         Identity->superTileMode = 0;
     }
 
-    /* If new HZ is available, disable other early z modes. */
-    if (((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 26:26) & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))))
-     || ((((gctUINT32) (Identity->chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))))
+    /* Exception for GC1000, revision 5035 &  GC800, revision 4612 */
+    if (((Identity->chipModel == gcv1000) && ((Identity->chipRevision == 0x5035)
+                                           || (Identity->chipRevision == 0x5036)
+                                           || (Identity->chipRevision == 0x5037)))
+	 || ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4612)))
     {
-        /* Disable EZ. */
-        Identity->chipFeatures
-            = ((((gctUINT32) (Identity->chipFeatures)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
+        Identity->superTileMode = 1;
     }
 
+
 	/* Disable HZ when EZ is present for older chips. */
-    else if (!((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))))
+	if (!((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))))
     {
         /* Disable HIERARCHICAL_Z. */
         Identity->chipMinorFeatures
@@ -246,6 +266,13 @@ _IdentifyHardware(
             = ((((gctUINT32) (Identity->chipMinorFeatures2)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
     }
 
+    if ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4605))
+    {
+        /* Correct feature bit: RTL does not have such feature. */
+        Identity->chipFeatures
+            = ((((gctUINT32) (Identity->chipFeatures)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)));
+    }
+
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                    "Identity: chipFeatures=0x%08X",
                    Identity->chipFeatures);
@@ -266,6 +293,10 @@ _IdentifyHardware(
                    "Identity: chipMinorFeatures3=0x%08X",
                    Identity->chipMinorFeatures3);
 
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
+                   "Identity: chipMinorFeatures4=0x%08X",
+                   Identity->chipMinorFeatures4);
+
     /***************************************************************************
     ** Get chip specs.
     */
@@ -408,7 +439,7 @@ _IdentifyHardware(
                    (instructionCount == 0) ? " (default)" : "");
 
     /* Get the number of constants. */
-    Identity->numConstants = numConstants;
+    Identity->numConstants = (numConstants == 0) ? 168 : numConstants;
 
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                    "Specs: numConstants=%u%s",
@@ -461,6 +492,157 @@ _PowerTimerFunction(
 }
 #endif
 
+static gceSTATUS
+_VerifyDMA(
+    IN gckOS Os,
+    IN gceCORE Core,
+    gctUINT32_PTR Address1,
+    gctUINT32_PTR Address2,
+    gctUINT32_PTR State1,
+    gctUINT32_PTR State2
+    )
+{
+    gceSTATUS status;
+    gctUINT32 i;
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State1));
+    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address1));
+
+    for (i = 0; i < 500; i += 1)
+    {
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State2));
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address2));
+
+        if (*Address1 != *Address2)
+        {
+            break;
+        }
+
+        if (*State1 != *State2)
+        {
+            break;
+        }
+    }
+
+OnError:
+    return status;
+}
+
+static gceSTATUS
+_DumpDebugRegisters(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gcsiDEBUG_REGISTERS_PTR Descriptor
+    )
+{
+    gceSTATUS status;
+    gctUINT32 select;
+    gctUINT32 data;
+    gctUINT i;
+
+    gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
+
+    gcmkPRINT_N(4, "    %s debug registers:\n", Descriptor->module);
+
+    for (i = 0; i < Descriptor->count; i += 1)
+    {
+        select = i << Descriptor->shift;
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, Descriptor->index, select));
+#if gcdFPGA_BUILD
+        gcmkONERROR(gckOS_Delay(Os, 1000));
+#endif
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, Descriptor->data, &data));
+
+        gcmkPRINT_N(12, "      [0x%02X] 0x%08X\n", i, data);
+    }
+
+    select = 0xF << Descriptor->shift;
+
+    for (i = 0; i < 500; i += 1)
+    {
+        gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, Descriptor->index, select));
+#if gcdFPGA_BUILD
+        gcmkONERROR(gckOS_Delay(Os, 1000));
+#endif
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, Descriptor->data, &data));
+
+        if (data == Descriptor->signature)
+        {
+            break;
+        }
+    }
+
+    if (i == 500)
+    {
+        gcmkPRINT_N(4, "      failed to obtain the signature (read 0x%08X).\n", data);
+    }
+    else
+    {
+        gcmkPRINT_N(8, "      signature = 0x%08X (%d read attempt(s))\n", data, i + 1);
+    }
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
+static gceSTATUS
+_IsGPUPresent(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gcsHAL_QUERY_CHIP_IDENTITY identity;
+    gctUINT32 control;
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &control));
+
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)));
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      control));
+
+    /* Identify the hardware. */
+    gcmkONERROR(_IdentifyHardware(Hardware->os,
+                                  Hardware->core,
+                                  &identity));
+
+    /* Check if these are the same values as saved before. */
+    if ((Hardware->identity.chipModel          != identity.chipModel)
+    ||  (Hardware->identity.chipRevision       != identity.chipRevision)
+    ||  (Hardware->identity.chipFeatures       != identity.chipFeatures)
+    ||  (Hardware->identity.chipMinorFeatures  != identity.chipMinorFeatures)
+    ||  (Hardware->identity.chipMinorFeatures1 != identity.chipMinorFeatures1)
+    ||  (Hardware->identity.chipMinorFeatures2 != identity.chipMinorFeatures2)
+    )
+    {
+        gcmkPRINT("[galcore]: GPU is not present.");
+        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
+    }
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
 /******************************************************************************\
 ****************************** gckHARDWARE API code *****************************
 \******************************************************************************/
@@ -536,6 +718,7 @@ gckHARDWARE_Construct(
 
     case gcv300:
     case gcv320:
+    case gcv420:
         hardware->type = gcvHARDWARE_2D;
         /*set outstanding limit*/
         gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x00414, &axi_ot));
@@ -581,7 +764,7 @@ gckHARDWARE_Construct(
     /* Initialize the fast clear. */
     gcmkONERROR(gckHARDWARE_SetFastClear(hardware, -1, -1));
 
-#if !gcdENABLE_128B_MERGE && 1 && 1
+#if !gcdENABLE_128B_MERGE
 
     if (((((gctUINT32) (hardware->identity.chipMinorFeatures2)) >> (0 ? 21:21) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))))
     {
@@ -617,6 +800,15 @@ gckHARDWARE_Construct(
 
     gcmkONERROR(gckOS_AtomConstruct(Os, &hardware->pageTableDirty));
 
+#if gcdLINK_QUEUE_SIZE
+    hardware->linkQueue.front = 0;
+    hardware->linkQueue.rear = 0;
+    hardware->linkQueue.count = 0;
+#endif
+
+    /* Enable power management by default. */
+    hardware->powerManagement = gcvTRUE;
+
     /* Return pointer to the gckHARDWARE object. */
     *Hardware = hardware;
 
@@ -648,7 +840,7 @@ OnError:
         if (hardware->powerOffTimer != gcvNULL)
         {
             gcmkVERIFY_OK(gckOS_StopTimer(Os, hardware->powerOffTimer));
-            gcmkVERIFY_OK(gckOS_DestoryTimer(Os, hardware->powerOffTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, hardware->powerOffTimer));
         }
 #endif
 
@@ -701,7 +893,7 @@ gckHARDWARE_Destroy(
 
 #if gcdPOWEROFF_TIMEOUT
     gcmkVERIFY_OK(gckOS_StopTimer(Hardware->os, Hardware->powerOffTimer));
-    gcmkVERIFY_OK(gckOS_DestoryTimer(Hardware->os, Hardware->powerOffTimer));
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Hardware->os, Hardware->powerOffTimer));
 #endif
 
     gcmkVERIFY_OK(gckOS_AtomDestroy(Hardware->os, Hardware->pageTableDirty));
@@ -851,7 +1043,7 @@ gckHARDWARE_InitializeHardware(
                                       0x00424,
                                       baseAddress));
 
-#if !VIVANTE_PROFILER && 1
+#if !VIVANTE_PROFILER
     {
         gctUINT32 data;
 
@@ -982,6 +1174,29 @@ gckHARDWARE_InitializeHardware(
                                   data));
     }
 
+#if gcdHZ_L2_DISALBE
+    /* Disable HZ-L2. */
+    if (((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 26:26) & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1))))))) == gcvTRUE ||
+            ((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))) == gcvTRUE)
+    {
+		gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 0x00414,
+                                 &data));
+
+        data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)));
+
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  0x00414,
+                                  data));
+    }
+#endif
+
     /* Limit 2D outstanding request. */
     if ((Hardware->identity.chipModel == gcv320)
         && ((Hardware->identity.chipRevision == 0x5007)
@@ -1203,6 +1418,7 @@ gckHARDWARE_QueryChipIdentity(
     Identity->chipMinorFeatures1 = Hardware->identity.chipMinorFeatures1;
     Identity->chipMinorFeatures2 = Hardware->identity.chipMinorFeatures2;
     Identity->chipMinorFeatures3 = Hardware->identity.chipMinorFeatures3;
+    Identity->chipMinorFeatures4 = Hardware->identity.chipMinorFeatures4;
 
     /* Return chip specs. */
     Identity->streamCount            = Hardware->identity.streamCount;
@@ -2226,6 +2442,13 @@ gckHARDWARE_Link(
         /* Memory barrier. */
         gcmkONERROR(
             gckOS_MemoryBarrier(Hardware->os, logical));
+
+#if gcdLINK_QUEUE_SIZE && gcdVIRTUAL_COMMAND_BUFFER
+        if (address >= 0x80000000)
+        {
+            gckLINKQUEUE_Enqueue(&Hardware->linkQueue, address, address + bytes);
+        }
+#endif
     }
 
     if (Bytes != gcvNULL)
@@ -2344,25 +2567,32 @@ gckHARDWARE_ConvertLogical(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
-    /* Convert logical address into a physical address. */
-    gcmkONERROR(
-        gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
+#if gcdVIRTUAL_COMMAND_BUFFER
+    status = gckKERNEL_GetGPUAddress(Hardware->kernel, Logical, Address);
 
-    /* For old MMU, get GPU address according to baseAddress. */
-    if (Hardware->mmuVersion == 0)
+    if (status == gcvSTATUS_INVALID_ADDRESS)
+#endif
     {
-        gcmkONERROR(gckOS_GetBaseAddress(Hardware->os, &baseAddress));
+        /* Convert logical address into a physical address. */
+        gcmkONERROR(
+            gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
 
-        /* Subtract base address to get a GPU address. */
-        gcmkASSERT(address >= baseAddress);
-        address -= baseAddress;
-    }
+        /* For old MMU, get GPU address according to baseAddress. */
+        if (Hardware->mmuVersion == 0)
+        {
+            gcmkONERROR(gckOS_GetBaseAddress(Hardware->os, &baseAddress));
 
-    /* Return hardware specific address. */
-    *Address = (Hardware->mmuVersion == 0)
-             ? ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
-               | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0))) | (((gctUINT32) ((gctUINT32) (address) & ((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0)))
-             : address;
+            /* Subtract base address to get a GPU address. */
+            gcmkASSERT(address >= baseAddress);
+            address -= baseAddress;
+        }
+
+        /* Return hardware specific address. */
+        *Address = (Hardware->mmuVersion == 0)
+                 ? ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
+                   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0))) | (((gctUINT32) ((gctUINT32) (address) & ((gctUINT32) ((((1 ? 30:0) - (0 ? 30:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 30:0) - (0 ? 30:0) + 1))))))) << (0 ? 30:0)))
+                 : address;
+    }
 
     /* Success. */
     gcmkFOOTER_ARG("*Address=0x%08x", *Address);
@@ -2621,7 +2851,7 @@ gckHARDWARE_QuerySystemMemory(
     return gcvSTATUS_OK;
 }
 
-#if !defined(VIVANTE_NO_3D)
+#ifndef VIVANTE_NO_3D
 /*******************************************************************************
 **
 **  gckHARDWARE_QueryShaderCaps
@@ -2914,7 +3144,7 @@ gckHARDWARE_FlushMMU(
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
         buffer[9]
-            = (((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) &  ((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) );
+            = (((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) &  ((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))));
 
         /* Arm the PE-FE Semaphore. */
         buffer[10]
@@ -3393,8 +3623,13 @@ gckHARDWARE_SetFastClear(
         /* Set fast clear bypass. */
         debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (Enable == 0) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
 
-        /* Set compression bypass. */
-        debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21))) | (((gctUINT32) ((gctUINT32) (Compression == 0) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)));
+        if (
+            ((((gctUINT32) (Hardware->identity.chipMinorFeatures2)) >> (0 ? 27:27) & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1))))))) ||
+            (Hardware->identity.chipModel >= gcv4000))
+        {
+            /* Set compression bypass. */
+            debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21))) | (((gctUINT32) ((gctUINT32) (Compression == 0) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)));
+        }
 
         /* Write back AQMemoryDebug register. */
         gcmkONERROR(
@@ -3440,7 +3675,7 @@ typedef enum
 }
 gcePOWER_FLAGS;
 
-#if gcmIS_DEBUG(gcdDEBUG_TRACE) && gcdPOWER_MANAGEMENT
+#if gcmIS_DEBUG(gcdDEBUG_TRACE)
 static gctCONST_STRING
 _PowerEnum(gceCHIPPOWERSTATE State)
 {
@@ -3489,7 +3724,6 @@ gckHARDWARE_SetPowerManagementState(
     IN gceCHIPPOWERSTATE State
     )
 {
-#if gcdPOWER_MANAGEMENT
     gceSTATUS status;
     gckCOMMAND command = gcvNULL;
     gckOS os;
@@ -3621,6 +3855,12 @@ gckHARDWARE_SetPowerManagementState(
     command = Hardware->kernel->command;
     gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
 
+    if (Hardware->powerManagement == gcvFALSE)
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
     /* Start profiler. */
     gcmkPROFILE_INIT(freq, time);
 
@@ -3913,6 +4153,43 @@ gckHARDWARE_SetPowerManagementState(
         /* Mark clock and power as enabled. */
         Hardware->clockState = gcvTRUE;
         Hardware->powerState = gcvTRUE;
+
+        for (;;)
+        {
+            /* Check if GPU is present and awake. */
+            status = _IsGPUPresent(Hardware);
+
+            /* Check if the GPU is not responding. */
+            if (status == gcvSTATUS_GPU_NOT_RESPONDING)
+            {
+                /* Turn off the power and clock. */
+                gcmkONERROR(gckOS_SetGPUPower(os, Hardware->core, gcvFALSE, gcvFALSE));
+
+                Hardware->clockState = gcvFALSE;
+                Hardware->powerState = gcvFALSE;
+
+                /* Wait a little. */
+                gckOS_Delay(os, 1);
+
+                /* Turn on the power and clock. */
+                gcmkONERROR(gckOS_SetGPUPower(os, Hardware->core, gcvTRUE, gcvTRUE));
+
+                Hardware->clockState = gcvTRUE;
+                Hardware->powerState = gcvTRUE;
+
+                /* We need to initialize the hardware and start the command
+                 * processor. */
+                flag |= gcvPOWER_FLAG_INITIALIZE | gcvPOWER_FLAG_START;
+            }
+            else
+            {
+                /* Test for error. */
+                gcmkONERROR(status);
+
+                /* Break out of loop. */
+                break;
+            }
+        }
     }
 
     /* Get time until powered on. */
@@ -4012,7 +4289,10 @@ gckHARDWARE_SetPowerManagementState(
     gcmkPROFILE_QUERY(time, stopTime);
 
     /* Only process this when hardware is enabled. */
-    if (Hardware->clockState && Hardware->powerState)
+    if (Hardware->clockState && Hardware->powerState
+    /* Don't touch clock control if dynamic frequency scaling is available. */
+    && gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_DYNAMIC_FREQUENCY_SCALING) != gcvTRUE
+    )
     {
         if (flag & (gcvPOWER_FLAG_POWER_OFF | gcvPOWER_FLAG_CLOCK_OFF))
         {
@@ -4146,6 +4426,13 @@ gckHARDWARE_SetPowerManagementState(
     /* Save the new power state. */
     Hardware->chipPowerState = State;
 
+#if gcdDVFS
+    if (State == gcvPOWER_ON && Hardware->kernel->dvfs)
+    {
+        gckDVFS_Start(Hardware->kernel->dvfs);
+    }
+#endif
+
 #if gcdPOWEROFF_TIMEOUT
     /* Reset power off time */
     gcmkONERROR(gckOS_GetTicks(&currentTime));
@@ -4224,10 +4511,6 @@ OnError:
     /* Return the status. */
     gcmkFOOTER();
     return status;
-#else /* gcdPOWER_MANAGEMENT */
-    /* Do nothing */
-    return gcvSTATUS_OK;
-#endif
 }
 
 /*******************************************************************************
@@ -4265,6 +4548,40 @@ gckHARDWARE_QueryPowerManagementState(
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_SetPowerManagement
+**
+**  Configure GPU power management function.
+**  Only used in driver initialization stage.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**      gctBOOL PowerManagement
+**          Power Mangement State.
+**
+*/
+gceSTATUS
+gckHARDWARE_SetPowerManagement(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    )
+{
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    Hardware->powerManagement = PowerManagement;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 #if gcdENABLE_FSCALE_VAL_ADJUST
 gceSTATUS
 gckHARDWARE_SetFscaleValue(
@@ -4364,7 +4681,10 @@ gckHARDWARE_GetFscaleValue(
     )
 {
     *FscaleValue = Hardware->powerOnFscaleVal;
-    *MinFscaleValue = 1;
+    if ((gpu3DMinClock > 0) && (gpu3DMinClock <= 64) && (Hardware->core == gcvCORE_MAJOR))
+        *MinFscaleValue = gpu3DMinClock;
+    else
+        *MinFscaleValue = 1;
     *MaxFscaleValue = 64;
 
     return gcvSTATUS_OK;
@@ -4497,6 +4817,21 @@ OnError:
                              GC_DEBUG_SIGNALS_##block##_Address, \
                              &profiler->data))
 
+#define gcmkREAD_DEBUG_REGISTER_N(control, block, index, data) \
+    gcmkONERROR(\
+        gckOS_WriteRegisterEx(Hardware->os, \
+                              Hardware->core, \
+                              GC_DEBUG_CONTROL##control##_Address, \
+                              gcmSETFIELD(0, \
+                                          GC_DEBUG_CONTROL##control, \
+                                          block, \
+                                          index))); \
+    gcmkONERROR(\
+        gckOS_ReadRegisterEx(Hardware->os, \
+                             Hardware->core, \
+                             GC_DEBUG_SIGNALS_##block##_Address, \
+                             &data))
+
 #define gcmkRESET_DEBUG_REGISTER(control, block) \
     gcmkONERROR(\
         gckOS_WriteRegisterEx(Hardware->os, \
@@ -4581,11 +4916,15 @@ OnError:
 gceSTATUS
 gckHARDWARE_QueryProfileRegisters(
     IN gckHARDWARE Hardware,
+    IN gctBOOL   Reset,
     OUT gcsPROFILER_COUNTERS * Counters
     )
 {
     gceSTATUS status;
     gcsPROFILER_COUNTERS * profiler = Counters;
+    gctUINT i, clock;
+    gctUINT32 colorKilled, colorDrawn, depthKilled, depthDrawn;
+    gctUINT32 totalRead, totalWrite;
 
     gcmkHEADER_ARG("Hardware=0x%x Counters=0x%x", Hardware, Counters);
 
@@ -4596,16 +4935,6 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(
         gckOS_ReadRegisterEx(Hardware->os,
                              Hardware->core,
-                             0x00040,
-                             &profiler->gpuTotalRead64BytesPerFrame));
-    gcmkONERROR(
-        gckOS_ReadRegisterEx(Hardware->os,
-                             Hardware->core,
-                             0x00044,
-                             &profiler->gpuTotalWrite64BytesPerFrame));
-    gcmkONERROR(
-        gckOS_ReadRegisterEx(Hardware->os,
-                             Hardware->core,
                              0x00438,
                              &profiler->gpuCyclesCounter));
 
@@ -4621,28 +4950,76 @@ gckHARDWARE_QueryProfileRegisters(
                              0x0007C,
                              &profiler->gpuIdleCyclesCounter));
 
-    /* Reset counters. */
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
-
-    /* PE */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_killed_by_color_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_killed_by_depth_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_drawn_by_color_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_drawn_by_depth_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+
+    /* Read clock control register. */
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &clock));
+
+    profiler->gpuTotalRead64BytesPerFrame = 0;
+    profiler->gpuTotalWrite64BytesPerFrame = 0;
+    profiler->pe_pixel_count_killed_by_color_pipe = 0;
+    profiler->pe_pixel_count_killed_by_depth_pipe = 0;
+    profiler->pe_pixel_count_drawn_by_color_pipe = 0;
+    profiler->pe_pixel_count_drawn_by_depth_pipe = 0;
+
+     /* Walk through all avaiable pixel pipes. */
+    for (i = 0; i < Hardware->identity.pixelPipes; ++i)
+    {
+        /* Select proper pipe. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                           Hardware->core,
+                                           0x00000,
+                                           ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:20) - (0 ? 23:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:20) - (0 ? 23:20) + 1))))))) << (0 ? 23:20))) | (((gctUINT32) ((gctUINT32) (i) & ((gctUINT32) ((((1 ? 23:20) - (0 ? 23:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:20) - (0 ? 23:20) + 1))))))) << (0 ? 23:20)))));
+
+        /* BW */
+        gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00040,
+                             &totalRead));
+        gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00044,
+                             &totalWrite));
+
+        profiler->gpuTotalRead64BytesPerFrame += totalRead;
+        profiler->gpuTotalWrite64BytesPerFrame += totalWrite;
+
+        /* PE */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorKilled));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &depthKilled));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorDrawn));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &depthDrawn));
+
+        profiler->pe_pixel_count_killed_by_color_pipe += colorKilled;
+        profiler->pe_pixel_count_killed_by_depth_pipe += depthKilled;
+        profiler->pe_pixel_count_drawn_by_color_pipe += colorDrawn;
+        profiler->pe_pixel_count_drawn_by_depth_pipe += depthDrawn;
+    }
+
+    /* Reset clock control register. */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      clock));
+
+    if(Reset){
+            /* Reset counters. */
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
+            gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
+    }
 
     /* SH */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
@@ -4661,9 +5038,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_branch_inst_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_texld_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    if(Reset){  gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
-));
+));}
 
     /* PA */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
@@ -4678,18 +5055,18 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_trivial_rejected_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_culled_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
-));
+));}
 
     /* SE */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_triangle_count));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_lines_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
-));
+));}
 
     /* RA */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
@@ -4704,9 +5081,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_pipe_cache_miss_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
-));
+));}
 
     /* TX */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
@@ -4727,9 +5104,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_hit_texel_count));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_texel_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
-));
+));}
 
     /* MC */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
@@ -4738,9 +5115,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_IP));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
-));
+));}
 
     /* HI */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
@@ -4749,9 +5126,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_request_stalled));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
-));
+));}
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -5219,6 +5596,11 @@ gckHARDWARE_IsFeatureAvailable(
     case gcvFEATURE_MC20:
         available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures)) >> (0 ? 22:22) & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1)))))));
         break;
+    case gcvFEATURE_DYNAMIC_FREQUENCY_SCALING:
+        /* This feature doesn't apply for 2D cores. */
+        available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures2)) >> (0 ? 14:14) & ((gctUINT32) ((((1 ? 14:14) - (0 ? 14:14) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 14:14) - (0 ? 14:14) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 14:14) - (0 ? 14:14) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 14:14) - (0 ? 14:14) + 1)))))))
+            &&      ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 2:2) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))));
+        break;
 
     default:
         gcmkFATAL("Invalid feature has been requested.");
@@ -5250,6 +5632,7 @@ gckHARDWARE_DumpMMUException(
     IN gckHARDWARE Hardware
     )
 {
+#if !gcdPOWER_SUSNPEND_WHEN_IDLE && !gcdPOWEROFF_TIMEOUT
     gctUINT32 mmu, mmuStatus, address, i;
 #if gcdDEBUG
     gctUINT32 mtlb, stlb, offset;
@@ -5260,8 +5643,14 @@ gckHARDWARE_DumpMMUException(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-    gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                   "  *** MMU ERROR ***\n");
+    gcmkPRINT("GPU[%d](ChipModel=0x%x ChipRevision=0x%x):\n",
+              Hardware->core,
+              Hardware->identity.chipModel,
+              Hardware->identity.chipRevision);
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("***   MMU ERROR DUMP   ***\n");
+    gcmkPRINT("**************************\n");
 
     gcmkVERIFY_OK(
         gckOS_ReadRegisterEx(Hardware->os,
@@ -5269,9 +5658,7 @@ gckHARDWARE_DumpMMUException(
                              0x00188,
                              &mmuStatus));
 
-    gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                   "  MMU status = 0x%08X\n",
-                   mmuStatus);
+    gcmkPRINT("  MMU status = 0x%08X\n", mmuStatus);
 
     for (i = 0; i < 4; i += 1)
     {
@@ -5286,62 +5673,288 @@ gckHARDWARE_DumpMMUException(
         switch (mmu)
         {
         case 1:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: slave not present\n",
-                            i);
+              gcmkPRINT("  MMU%d: slave not present\n", i);
               break;
 
         case 2:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: page not present\n",
-                            i);
+              gcmkPRINT("  MMU%d: page not present\n", i);
               break;
 
         case 3:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: write violation\n",
-                            i);
+              gcmkPRINT("  MMU%d: write violation\n", i);
               break;
 
         default:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: unknown state\n",
-                            i);
+              gcmkPRINT("  MMU%d: unknown state\n", i);
         }
 
         gcmkVERIFY_OK(
             gckOS_ReadRegisterEx(Hardware->os,
                                  Hardware->core,
-                                 0x00190 + i,
+                                 0x00190 + i * 4,
                                  &address));
 
-#if gcdDEBUG
         mtlb   = (address & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT;
         stlb   = (address & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
         offset =  address & gcdMMU_OFFSET_4K_MASK;
-#endif
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "  MMU%d: exception address = 0x%08X\n",
-                     i, address);
+        gcmkPRINT("  MMU%d: exception address = 0x%08X\n", i, address);
+
+        gcmkPRINT("    MTLB entry = %d\n", mtlb);
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "    MTLB entry = %d\n",
-                     mtlb);
+        gcmkPRINT("    STLB entry = %d\n", stlb);
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "    STLB entry = %d\n",
-                     stlb);
+        gcmkPRINT("    Offset = 0x%08X (%d)\n", offset, offset);
+
+        gckMMU_DumpPageTableEntry(Hardware->kernel->mmu, address);
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "    Offset = 0x%08X (%d)\n",
-                     offset, offset);
     }
 
 	gcmkFOOTER_NO();
+#else
+    /* If clock could be off automatically, we can't read mmu debug
+    ** register here; build driver with gcdPOWER_SUSPEND_WHEN_IDLE = 0
+    ** and gcdPOWEROFF_TIMEOUT = 0 to make it safe to read mmu register. */
+    gcmkPRINT("[galcore] %s(%d): MMU Exception!", __FUNCTION__, __LINE__);
+#endif
+
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_DumpGPUState
+**
+**  Dump the GPU debug registers.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckHARDWARE_DumpGPUState(
+    IN gckHARDWARE Hardware
+    )
+{
+    static gctCONST_STRING _cmdState[] =
+    {
+        "PAR_IDLE_ST", "PAR_DEC_ST", "PAR_ADR0_ST", "PAR_LOAD0_ST",
+        "PAR_ADR1_ST", "PAR_LOAD1_ST", "PAR_3DADR_ST", "PAR_3DCMD_ST",
+        "PAR_3DCNTL_ST", "PAR_3DIDXCNTL_ST", "PAR_INITREQDMA_ST",
+        "PAR_DRAWIDX_ST", "PAR_DRAW_ST", "PAR_2DRECT0_ST", "PAR_2DRECT1_ST",
+        "PAR_2DDATA0_ST", "PAR_2DDATA1_ST", "PAR_WAITFIFO_ST", "PAR_WAIT_ST",
+        "PAR_LINK_ST", "PAR_END_ST", "PAR_STALL_ST"
+    };
+
+    static gctCONST_STRING _cmdDmaState[] =
+    {
+        "CMD_IDLE_ST", "CMD_START_ST", "CMD_REQ_ST", "CMD_END_ST"
+    };
+
+    static gctCONST_STRING _cmdFetState[] =
+    {
+        "FET_IDLE_ST", "FET_RAMVALID_ST", "FET_VALID_ST"
+    };
+
+    static gctCONST_STRING _reqDmaState[] =
+    {
+        "REQ_IDLE_ST", "REQ_WAITIDX_ST", "REQ_CAL_ST"
+    };
+
+    static gctCONST_STRING _calState[] =
+    {
+        "CAL_IDLE_ST", "CAL_LDADR_ST", "CAL_IDXCALC_ST"
+    };
+
+    static gctCONST_STRING _veReqState[] =
+    {
+        "VER_IDLE_ST", "VER_CKCACHE_ST", "VER_MISS_ST"
+    };
+
+    static gcsiDEBUG_REGISTERS _dbgRegs[] =
+    {
+        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
+        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
+        { "FE", 0x470, 0, 0x450, 16, 0xBABEF00D },
+        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
+        { "DE", 0x470, 8, 0x458, 16, 0xBABEF00D },
+        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
+        { "PA", 0x474, 0, 0x460, 16, 0x0000AAAA },
+        { "SE", 0x474, 8, 0x464, 16, 0x5E5E5E5E },
+        { "MC", 0x478, 0, 0x468, 16, 0x12345678 },
+        { "HI", 0x478, 8, 0x46C, 16, 0xAAAAAAAA }
+    };
+
+    static gctUINT32 _otherRegs[] =
+    {
+        0x040, 0x044, 0x04C, 0x050, 0x054, 0x058, 0x05C, 0x060,
+        0x43c, 0x440, 0x444, 0x414,
+    };
+
+    gceSTATUS status;
+    gckKERNEL kernel;
+    gctUINT32 idle, axi;
+    gctUINT32 dmaAddress1, dmaAddress2;
+    gctUINT32 dmaState1, dmaState2;
+    gctUINT32 dmaLow, dmaHigh;
+    gctUINT32 cmdState, cmdDmaState, cmdFetState;
+    gctUINT32 dmaReqState, calState, veReqState;
+    gctUINT i;
+    gctUINT pipe, pixelPipes;
+    gctUINT32 control, oldControl;
+    gckOS os = Hardware->os;
+    gceCORE core = Hardware->core;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    kernel = Hardware->kernel;
+
+    gcmkPRINT_N(12, "GPU[%d](ChipModel=0x%x ChipRevision=0x%x):\n",
+                core,
+                Hardware->identity.chipModel,
+                Hardware->identity.chipRevision);
+
+    pixelPipes = Hardware->identity.pixelPipes
+               ? Hardware->identity.pixelPipes
+               : 1;
+
+    /* Reset register values. */
+    idle        = axi         =
+    dmaState1   = dmaState2   =
+    dmaAddress1 = dmaAddress2 =
+    dmaLow      = dmaHigh     = 0;
+
+    /* Verify whether DMA is running. */
+    gcmkONERROR(_VerifyDMA(
+        os, core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
+        ));
+
+    cmdState    =  dmaState2        & 0x1F;
+    cmdDmaState = (dmaState2 >>  8) & 0x03;
+    cmdFetState = (dmaState2 >> 10) & 0x03;
+    dmaReqState = (dmaState2 >> 12) & 0x03;
+    calState    = (dmaState2 >> 14) & 0x03;
+    veReqState  = (dmaState2 >> 16) & 0x03;
+
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x004, &idle));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00C, &axi));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x668, &dmaLow));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x66C, &dmaHigh));
+
+    gcmkPRINT_N(0, "**************************\n");
+    gcmkPRINT_N(0, "***   GPU STATE DUMP   ***\n");
+    gcmkPRINT_N(0, "**************************\n");
+
+    gcmkPRINT_N(4, "  axi      = 0x%08X\n", axi);
+
+    gcmkPRINT_N(4, "  idle     = 0x%08X\n", idle);
+    if ((idle & 0x00000001) == 0) gcmkPRINT_N(0, "    FE not idle\n");
+    if ((idle & 0x00000002) == 0) gcmkPRINT_N(0, "    DE not idle\n");
+    if ((idle & 0x00000004) == 0) gcmkPRINT_N(0, "    PE not idle\n");
+    if ((idle & 0x00000008) == 0) gcmkPRINT_N(0, "    SH not idle\n");
+    if ((idle & 0x00000010) == 0) gcmkPRINT_N(0, "    PA not idle\n");
+    if ((idle & 0x00000020) == 0) gcmkPRINT_N(0, "    SE not idle\n");
+    if ((idle & 0x00000040) == 0) gcmkPRINT_N(0, "    RA not idle\n");
+    if ((idle & 0x00000080) == 0) gcmkPRINT_N(0, "    TX not idle\n");
+    if ((idle & 0x00000100) == 0) gcmkPRINT_N(0, "    VG not idle\n");
+    if ((idle & 0x00000200) == 0) gcmkPRINT_N(0, "    IM not idle\n");
+    if ((idle & 0x00000400) == 0) gcmkPRINT_N(0, "    FP not idle\n");
+    if ((idle & 0x00000800) == 0) gcmkPRINT_N(0, "    TS not idle\n");
+    if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
+
+    if (
+        (dmaAddress1 == dmaAddress2)
+     && (dmaState1 == dmaState2)
+    )
+    {
+        gcmkPRINT_N(0, "  DMA appears to be stuck at this address:\n");
+        gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
+    }
+    else
+    {
+        if (dmaAddress1 == dmaAddress2)
+        {
+            gcmkPRINT_N(0, "  DMA address is constant, but state is changing:\n");
+            gcmkPRINT_N(4, "    0x%08X\n", dmaState1);
+            gcmkPRINT_N(4, "    0x%08X\n", dmaState2);
+        }
+        else
+        {
+            gcmkPRINT_N(0, "  DMA is running; known addresses are:\n");
+            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
+            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress2);
+        }
+    }
+    gcmkPRINT_N(4, "  dmaLow   = 0x%08X\n", dmaLow);
+    gcmkPRINT_N(4, "  dmaHigh  = 0x%08X\n", dmaHigh);
+    gcmkPRINT_N(4, "  dmaState = 0x%08X\n", dmaState2);
+    gcmkPRINT_N(8, "    command state       = %d (%s)\n", cmdState, _cmdState   [cmdState]);
+    gcmkPRINT_N(8, "    command DMA state   = %d (%s)\n", cmdDmaState, _cmdDmaState[cmdDmaState]);
+    gcmkPRINT_N(8, "    command fetch state = %d (%s)\n", cmdFetState, _cmdFetState[cmdFetState]);
+    gcmkPRINT_N(8, "    DMA request state   = %d (%s)\n", dmaReqState, _reqDmaState[dmaReqState]);
+    gcmkPRINT_N(8, "    cal state           = %d (%s)\n", calState, _calState   [calState]);
+    gcmkPRINT_N(8, "    VE request state    = %d (%s)\n", veReqState, _veReqState [veReqState]);
+
+    /* Record control. */
+    gckOS_ReadRegisterEx(os, core, 0x0, &oldControl);
+
+    for (pipe = 0; pipe < pixelPipes; pipe++)
+    {
+        gcmkPRINT_N(4, "  Debug registers of pipe[%d]:\n", pipe);
+
+        /* Switch pipe. */
+        gckOS_ReadRegisterEx(os, core, 0x0, &control);
+        control &= ~(0xF << 20);
+        control |= (pipe << 20);
+        gckOS_WriteRegisterEx(os, core, 0x0, control);
+
+        for (i = 0; i < gcmCOUNTOF(_dbgRegs); i += 1)
+        {
+            gcmkONERROR(_DumpDebugRegisters(os, core, &_dbgRegs[i]));
+        }
+
+        gcmkPRINT_N(0, "    Other Registers:\n");
+        for (i = 0; i < gcmCOUNTOF(_otherRegs); i += 1)
+        {
+            gctUINT32 read;
+            gcmkONERROR(gckOS_ReadRegisterEx(os, core, _otherRegs[i], &read));
+            gcmkPRINT_N(12, "      [0x%04X] 0x%08X\n", _otherRegs[i], read);
+        }
+    }
+
+    if (kernel->hardware->identity.chipFeatures & (1 << 4))
+    {
+        gctUINT32 read0, read1, write;
+
+        read0 = read1 = write = 0;
+
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x43C, &read0));
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x440, &read1));
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x444, &write));
+
+        gcmkPRINT_N(4, "  read0    = 0x%08X\n", read0);
+        gcmkPRINT_N(4, "  read1    = 0x%08X\n", read1);
+        gcmkPRINT_N(4, "  write    = 0x%08X\n", write);
+    }
+
+    /* Restore control. */
+    gckOS_WriteRegisterEx(os, core, 0x0, oldControl);
+
+    /* dump stack. */
+    gckOS_DumpCallStack(os);
+
+OnError:
+
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
 
 #if gcdFRAME_DB
 static gceSTATUS
@@ -5741,3 +6354,194 @@ OnError:
 }
 #endif
 
+#if gcdDVFS
+#define READ_FROM_EATER1 0
+
+gceSTATUS
+gckHARDWARE_QueryLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 * Load
+    )
+{
+    gctUINT32 debug1;
+    gceSTATUS status;
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Load != gcvNULL);
+
+    gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE);
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00110,
+                                         Load));
+#if READ_FROM_EATER1
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00134,
+                                         Load));
+#endif
+
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00114,
+                                         &debug1));
+
+        /* Patch result of 0x110 with result of 0x114. */
+        if ((debug1 & 0xFF) == 1)
+        {
+            *Load &= ~0xFF;
+            *Load |= 1;
+        }
+
+        if (((debug1 & 0xFF00) >> 8) == 1)
+        {
+            *Load &= ~(0xFF << 8);
+            *Load |= 1 << 8;
+        }
+
+        if (((debug1 & 0xFF0000) >> 16) == 1)
+        {
+            *Load &= ~(0xFF << 16);
+            *Load |= 1 << 16;
+        }
+
+        if (((debug1 & 0xFF000000) >> 24) == 1)
+        {
+            *Load &= ~(0xFF << 24);
+            *Load |= 1 << 24;
+        }
+    }
+    else
+    {
+        status = gcvSTATUS_INVALID_REQUEST;
+    }
+
+OnError:
+
+    gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_SetDVFSPeroid(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 Frequency
+    )
+{
+    gceSTATUS status;
+    gctUINT32 period;
+    gctUINT32 eater;
+
+#if READ_FROM_EATER1
+    gctUINT32 period1;
+    gctUINT32 eater1;
+#endif
+
+    gcmkHEADER_ARG("Hardware=0x%X Frequency=%d", Hardware, Frequency);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    period = 0;
+
+    while((64 << period) < (gcdDVFS_ANAYLSE_WINDOW * Frequency * 1000) )
+    {
+        period++;
+    }
+
+#if READ_FROM_EATER1
+    /*
+    *  Peroid = F * 1000 * 1000 / (60 * 16 * 1024);
+    */
+    period1 = Frequency * 6250 / 6114;
+#endif
+
+    gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE);
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        /* Get current configure. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x0010C,
+                                         &eater));
+
+        /* Change peroid. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x0010C,
+                                          ((((gctUINT32) (eater)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (period) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))));
+
+#if READ_FROM_EATER1
+        /* Config eater1. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00130,
+                                         &eater1));
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x00130,
+                                          ((((gctUINT32) (eater1)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16))) | (((gctUINT32) ((gctUINT32) (period1) & ((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16)))));
+#endif
+    }
+    else
+    {
+        status = gcvSTATUS_INVALID_REQUEST;
+    }
+
+OnError:
+    gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_InitDVFS(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gctUINT32 data;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x0010C,
+                                     &data));
+
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 18:18) - (0 ? 18:18) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 18:18) - (0 ? 18:18) + 1))))))) << (0 ? 18:18))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 18:18) - (0 ? 18:18) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 18:18) - (0 ? 18:18) + 1))))))) << (0 ? 18:18)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22)));
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
+                   "DVFS Configure=0x%X",
+                   data);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x0010C,
+                                      data));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+#endif
+
+
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
index 8a96d1f..37226b7 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_hardware_h_
 #define __gc_hal_kernel_hardware_h_
 
@@ -88,6 +86,12 @@ struct _gckHARDWARE
     /* FSCALE_VAL when gcvPOWER_ON. */
     gctUINT32                   powerOnFscaleVal;
 #endif
+
+#if gcdLINK_QUEUE_SIZE
+    struct _gckLINKQUEUE        linkQueue;
+#endif
+
+    gctBOOL                     powerManagement;
 };
 
 gceSTATUS
diff --git a/drivers/mxc/gpu-viv/config b/drivers/mxc/gpu-viv/config
index 7e6e867..cdd143e 100644
--- a/drivers/mxc/gpu-viv/config
+++ b/drivers/mxc/gpu-viv/config
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
@@ -22,7 +22,6 @@
 ARCH_TYPE                         ?= arm
 SDK_DIR                           ?= $(AQROOT)/build/sdk
 USE_3D_VG                         ?= 1
-USE_POWER_MANAGEMENT              ?= 1
 FORCE_ALL_VIDEO_MEMORY_CACHED     ?= 0
 NONPAGED_MEMORY_CACHEABLE         ?= 0
 NONPAGED_MEMORY_BUFFERABLE        ?= 1
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 15ed52c..b7b0d28 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
@@ -70,6 +68,9 @@ gctCONST_STRING _DispatchText[] =
     gcmDEFINE2TEXT(gcvHAL_GET_PROFILE_SETTING),
     gcmDEFINE2TEXT(gcvHAL_SET_PROFILE_SETTING),
     gcmDEFINE2TEXT(gcvHAL_READ_ALL_PROFILE_REGISTERS),
+#if VIVANTE_PROFILER_PERDRAW
+    gcmDEFINE2TEXT(gcvHAL_READ_PROFILER_REGISTER_SETTING),
+#endif
     gcmDEFINE2TEXT(gcvHAL_PROFILE_REGISTERS_2D),
     gcmDEFINE2TEXT(gcvHAL_SET_POWER_MANAGEMENT_STATE),
     gcmDEFINE2TEXT(gcvHAL_QUERY_POWER_MANAGEMENT_STATE),
@@ -173,6 +174,15 @@ gckKERNEL_Construct(
     kernel->command      = gcvNULL;
     kernel->eventObj     = gcvNULL;
     kernel->mmu          = gcvNULL;
+#if gcdDVFS
+    kernel->dvfs         = gcvNULL;
+#endif
+
+    /* Initialize the gckKERNEL object. */
+    kernel->object.type = gcvOBJ_KERNEL;
+    kernel->os          = Os;
+    kernel->core        = Core;
+
 
     if (SharedDB == gcvNULL)
     {
@@ -197,6 +207,12 @@ gckKERNEL_Construct(
 
         /* Construct a database mutex. */
         gcmkONERROR(gckOS_CreateMutex(Os, &kernel->db->dbMutex));
+
+        /* Construct a id-pointer database. */
+        gcmkONERROR(gckKERNEL_CreateIntegerDatabase(kernel, &kernel->db->pointerDatabase));
+
+        /* Construct a id-pointer database mutex. */
+        gcmkONERROR(gckOS_CreateMutex(Os, &kernel->db->pointerDatabaseMutex));
     }
     else
     {
@@ -212,14 +228,17 @@ gckKERNEL_Construct(
 
     kernel->timeOut      = gcdGPU_TIMEOUT;
 
-    /* Initialize the gckKERNEL object. */
-    kernel->object.type = gcvOBJ_KERNEL;
-    kernel->os          = Os;
-    kernel->core        = Core;
-
     /* Save context. */
     kernel->context = Context;
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+    kernel->virtualBufferHead =
+    kernel->virtualBufferTail = gcvNULL;
+
+    gcmkONERROR(
+        gckOS_CreateMutex(Os, (gctPOINTER)&kernel->virtualBufferLock));
+#endif
+
     /* Construct atom holding number of clients. */
     kernel->atomClients = gcvNULL;
     gcmkONERROR(gckOS_AtomConstruct(Os, &kernel->atomClients));
@@ -268,6 +287,16 @@ gckKERNEL_Construct(
                               (gctTIMERFUNCTION)_ResetFinishFunction,
                               (gctPOINTER)kernel,
                               &kernel->resetFlagClearTimer));
+        kernel->resetTimeStamp = 0;
+#endif
+
+#if gcdDVFS
+        if (gckHARDWARE_IsFeatureAvailable(kernel->hardware,
+                                           gcvFEATURE_DYNAMIC_FREQUENCY_SCALING))
+        {
+            gcmkONERROR(gckDVFS_Construct(kernel->hardware, &kernel->dvfs));
+            gcmkONERROR(gckDVFS_Start(kernel->dvfs));
+        }
 #endif
     }
 
@@ -278,6 +307,7 @@ gckKERNEL_Construct(
 #else
     kernel->profileEnable = gcvTRUE;
 #endif
+    kernel->profileCleanRegister = gcvTRUE;
 
     gcmkVERIFY_OK(
         gckOS_MemCopy(kernel->profileFileName,
@@ -334,7 +364,7 @@ OnError:
         if (kernel->resetFlagClearTimer)
         {
             gcmkVERIFY_OK(gckOS_StopTimer(Os, kernel->resetFlagClearTimer));
-            gcmkVERIFY_OK(gckOS_DestoryTimer(Os, kernel->resetFlagClearTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, kernel->resetFlagClearTimer));
         }
 #endif
 
@@ -349,6 +379,22 @@ OnError:
             gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel->db));
         }
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+        if (kernel->virtualBufferLock != gcvNULL)
+        {
+            /* Destroy the virtual command buffer mutex. */
+            gcmkVERIFY_OK(gckOS_DeleteMutex(Os, kernel->virtualBufferLock));
+        }
+#endif
+
+#if gcdDVFS
+        if (kernel->dvfs)
+        {
+            gcmkVERIFY_OK(gckDVFS_Stop(kernel->dvfs));
+            gcmkVERIFY_OK(gckDVFS_Destroy(kernel->dvfs));
+        }
+#endif
+
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel));
     }
 
@@ -424,6 +470,13 @@ gckKERNEL_Destroy(
 
         /* Destroy the database mutex. */
         gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->db->dbMutex));
+
+
+        /* Destroy id-pointer database. */
+        gcmkVERIFY_OK(gckKERNEL_DestroyIntegerDatabase(Kernel, Kernel->db->pointerDatabase));
+
+        /* Destroy id-pointer database mutex. */
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->db->pointerDatabaseMutex));
     }
 
 #if gcdENABLE_VG
@@ -452,7 +505,7 @@ gckKERNEL_Destroy(
         if (Kernel->resetFlagClearTimer)
         {
             gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->resetFlagClearTimer));
-            gcmkVERIFY_OK(gckOS_DestoryTimer(Kernel->os, Kernel->resetFlagClearTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->resetFlagClearTimer));
         }
 #endif
     }
@@ -460,6 +513,18 @@ gckKERNEL_Destroy(
     /* Detsroy the client atom. */
     gcmkVERIFY_OK(gckOS_AtomDestroy(Kernel->os, Kernel->atomClients));
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->virtualBufferLock));
+#endif
+
+#if gcdDVFS
+    if (Kernel->dvfs)
+    {
+        gcmkVERIFY_OK(gckDVFS_Stop(Kernel->dvfs));
+        gcmkVERIFY_OK(gckDVFS_Destroy(Kernel->dvfs));
+    }
+#endif
+
     /* Mark the gckKERNEL object as unknown. */
     Kernel->object.type = gcvOBJ_UNKNOWN;
 
@@ -471,6 +536,97 @@ gckKERNEL_Destroy(
     return gcvSTATUS_OK;
 }
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/oom.h>
+#include <linux/sched.h>
+#include <linux/notifier.h>
+
+extern struct task_struct *lowmem_deathpending;
+static unsigned long lowmem_deathpending_timeout;
+
+static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
+{
+	struct task_struct *p;
+	struct task_struct *selected = NULL;
+	int tasksize;
+        int ret = -1;
+	int min_adj = 0;
+	int selected_tasksize = 0;
+	int selected_oom_adj;
+	/*
+	 * If we already have a death outstanding, then
+	 * bail out right away; indicating to vmscan
+	 * that we have nothing further to offer on
+	 * this pass.
+	 *
+	 */
+	if (lowmem_deathpending &&
+	    time_before_eq(jiffies, lowmem_deathpending_timeout))
+		return 0;
+	selected_oom_adj = min_adj;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		struct mm_struct *mm;
+		struct signal_struct *sig;
+                gcuDATABASE_INFO info;
+		int oom_adj;
+
+		task_lock(p);
+		mm = p->mm;
+		sig = p->signal;
+		if (!mm || !sig) {
+			task_unlock(p);
+			continue;
+		}
+		oom_adj = sig->oom_adj;
+		if (oom_adj < min_adj) {
+			task_unlock(p);
+			continue;
+		}
+
+		tasksize = 0;
+		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_VIDEO_MEMORY, &info) == gcvSTATUS_OK){
+			tasksize += info.counters.bytes / PAGE_SIZE;
+		}
+		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_CONTIGUOUS, &info) == gcvSTATUS_OK){
+			tasksize += info.counters.bytes / PAGE_SIZE;
+		}
+
+		task_unlock(p);
+
+		if (tasksize <= 0)
+			continue;
+
+		gckOS_Print("<gpu> pid %d (%s), adj %d, size %d \n", p->pid, p->comm, oom_adj, tasksize);
+
+		if (selected) {
+			if (oom_adj < selected_oom_adj)
+				continue;
+			if (oom_adj == selected_oom_adj &&
+			    tasksize <= selected_tasksize)
+				continue;
+		}
+		selected = p;
+		selected_tasksize = tasksize;
+		selected_oom_adj = oom_adj;
+	}
+	if (selected) {
+		gckOS_Print("<gpu> send sigkill to %d (%s), adj %d, size %d\n",
+			     selected->pid, selected->comm,
+			     selected_oom_adj, selected_tasksize);
+		lowmem_deathpending = selected;
+		lowmem_deathpending_timeout = jiffies + HZ;
+		force_sig(SIGKILL, selected);
+		ret = 0;
+	}
+	read_unlock(&tasklist_lock);
+	return ret;
+}
+
+#endif
 
 /*******************************************************************************
 **
@@ -518,6 +674,9 @@ _AllocateMemory(
     gcmkVERIFY_ARGUMENT(Pool != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes != 0);
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+_AllocateMemory_Retry:
+#endif
     /* Get initial pool. */
     switch (pool = *Pool)
     {
@@ -663,11 +822,22 @@ _AllocateMemory(
 
     if (node == gcvNULL)
     {
+
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+        if(forceContiguous == gcvTRUE)
+        {
+            if(force_contiguous_lowmem_shrink(Kernel) == 0)
+            {
+                 /* Sleep 1 millisecond. */
+                 gckOS_Delay(gcvNULL, 1);
+                 goto _AllocateMemory_Retry;
+            }
+        }
+#endif
         /* Nothing allocated. */
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-
     /* Return node and pool used for allocation. */
     *Node = node;
     *Pool = pool;
@@ -719,11 +889,14 @@ gckKERNEL_Dispatch(
     gcuVIDMEM_NODE_PTR node;
     gctBOOL locked = gcvFALSE;
     gctPHYS_ADDR physical = gcvNULL;
+    gctPOINTER logical = gcvNULL;
+    gctPOINTER info = gcvNULL;
+    gckCONTEXT context = gcvNULL;
     gctUINT32 address;
     gctUINT32 processID;
+    gckKERNEL kernel = Kernel;
 #if gcdSECURE_USER
     gcskSECURE_CACHE_PTR cache;
-    gctPOINTER logical;
 #endif
     gctBOOL asynchronous;
     gctPOINTER paddr = gcvNULL;
@@ -731,9 +904,6 @@ gckKERNEL_Dispatch(
     gctSIGNAL   signal;
 #endif
 
-    gcsDATABASE_RECORD record;
-    gctPOINTER    data;
-
     gcmkHEADER_ARG("Kernel=0x%x FromUser=%d Interface=0x%x",
                    Kernel, FromUser, Interface);
 
@@ -781,135 +951,185 @@ gckKERNEL_Dispatch(
         break;
 
     case gcvHAL_MAP_MEMORY:
-        physical = Interface->u.MapMemory.physical;
+        physical = gcmINT2PTR(Interface->u.MapMemory.physical);
 
         /* Map memory. */
         gcmkONERROR(
             gckKERNEL_MapMemory(Kernel,
                                 physical,
-                                Interface->u.MapMemory.bytes,
-                                &Interface->u.MapMemory.logical));
+                                (gctSIZE_T) Interface->u.MapMemory.bytes,
+                                &logical));
+
+        Interface->u.MapMemory.logical = gcmPTR_TO_UINT64(logical);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_MAP_MEMORY,
-                                   Interface->u.MapMemory.logical,
+                                   logical,
                                    physical,
-                                   Interface->u.MapMemory.bytes));
+                                   (gctSIZE_T) Interface->u.MapMemory.bytes));
         break;
 
     case gcvHAL_UNMAP_MEMORY:
-        physical = Interface->u.UnmapMemory.physical;
+        physical = gcmINT2PTR(Interface->u.UnmapMemory.physical);
 
         /* Unmap memory. */
         gcmkONERROR(
             gckKERNEL_UnmapMemory(Kernel,
                                   physical,
-                                  Interface->u.UnmapMemory.bytes,
-                                  Interface->u.UnmapMemory.logical));
+                                  (gctSIZE_T) Interface->u.UnmapMemory.bytes,
+                                  gcmUINT64_TO_PTR(Interface->u.UnmapMemory.logical)));
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_MAP_MEMORY,
-                                      Interface->u.UnmapMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.UnmapMemory.logical)));
         break;
 
     case gcvHAL_ALLOCATE_NON_PAGED_MEMORY:
+        bytes = (gctSIZE_T) Interface->u.AllocateNonPagedMemory.bytes;
+
         /* Allocate non-paged memory. */
         gcmkONERROR(
             gckOS_AllocateNonPagedMemory(
                 Kernel->os,
                 FromUser,
-                &Interface->u.AllocateNonPagedMemory.bytes,
-                &Interface->u.AllocateNonPagedMemory.physical,
-                &Interface->u.AllocateNonPagedMemory.logical));
+                &bytes,
+                &physical,
+                &logical));
+
+        Interface->u.AllocateNonPagedMemory.bytes    = bytes;
+        Interface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
 
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_NON_PAGED,
-                                   Interface->u.AllocateNonPagedMemory.logical,
-                                   Interface->u.AllocateNonPagedMemory.physical,
-                                   Interface->u.AllocateNonPagedMemory.bytes));
+                                   logical,
+                                   gcmINT2PTR(Interface->u.AllocateNonPagedMemory.physical),
+                                   bytes));
+
+        break;
+
+    case gcvHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER:
+#if gcdVIRTUAL_COMMAND_BUFFER
+        bytes = (gctSIZE_T) Interface->u.AllocateVirtualCommandBuffer.bytes;
+
+        gcmkONERROR(
+            gckKERNEL_AllocateVirtualCommandBuffer(
+                Kernel,
+                FromUser,
+                &bytes,
+                &physical,
+                &logical));
+
+        Interface->u.AllocateVirtualCommandBuffer.bytes    = bytes;
+        Interface->u.AllocateVirtualCommandBuffer.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateVirtualCommandBuffer.physical = gcmPTR_TO_NAME(physical);
+
+        gcmkVERIFY_OK(
+            gckKERNEL_AddProcessDB(Kernel,
+                                   processID, gcvDB_COMMAND_BUFFER,
+                                   logical,
+                                   gcmINT2PTR(Interface->u.AllocateVirtualCommandBuffer.physical),
+                                   bytes));
+#else
+        status = gcvSTATUS_NOT_SUPPORTED;
+#endif
         break;
 
     case gcvHAL_FREE_NON_PAGED_MEMORY:
-        physical = Interface->u.FreeNonPagedMemory.physical;
+        physical = gcmNAME_TO_PTR(Interface->u.FreeNonPagedMemory.physical);
 
         /* Unmap user logical out of physical memory first. */
         gcmkONERROR(gckOS_UnmapUserLogical(Kernel->os,
                                            physical,
-                                           Interface->u.FreeNonPagedMemory.bytes,
-                                           Interface->u.FreeNonPagedMemory.logical));
+                                           (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
+                                           gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
         /* Free non-paged memory. */
         gcmkONERROR(
             gckOS_FreeNonPagedMemory(Kernel->os,
-                                     Interface->u.FreeNonPagedMemory.bytes,
+                                     (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
                                      physical,
-                                     Interface->u.FreeNonPagedMemory.logical));
+                                     gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_NON_PAGED,
-                                      Interface->u.FreeNonPagedMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.FreeNonPagedMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical),
             Interface->u.FreeNonPagedMemory.bytes));
 #endif
+
+        gcmRELEASE_NAME(Interface->u.FreeNonPagedMemory.physical);
+
         break;
 
     case gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY:
+        bytes = (gctSIZE_T) Interface->u.AllocateContiguousMemory.bytes;
+
         /* Allocate contiguous memory. */
         gcmkONERROR(gckOS_AllocateContiguous(
             Kernel->os,
             FromUser,
-            &Interface->u.AllocateContiguousMemory.bytes,
-            &Interface->u.AllocateContiguousMemory.physical,
-            &Interface->u.AllocateContiguousMemory.logical));
+            &bytes,
+            &physical,
+            &logical));
+
+        Interface->u.AllocateContiguousMemory.bytes    = bytes;
+        Interface->u.AllocateContiguousMemory.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateContiguousMemory.physical = gcmPTR_TO_NAME(physical);
 
         gcmkONERROR(gckHARDWARE_ConvertLogical(
             Kernel->hardware,
-            Interface->u.AllocateContiguousMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.AllocateContiguousMemory.logical),
             &Interface->u.AllocateContiguousMemory.address));
 
         gcmkVERIFY_OK(gckKERNEL_AddProcessDB(
             Kernel,
             processID, gcvDB_CONTIGUOUS,
-            Interface->u.AllocateContiguousMemory.logical,
-            Interface->u.AllocateContiguousMemory.physical,
-            Interface->u.AllocateContiguousMemory.bytes));
+            logical,
+            gcmINT2PTR(Interface->u.AllocateContiguousMemory.physical),
+            bytes));
+
         break;
 
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
-        physical = Interface->u.FreeContiguousMemory.physical;
+        physical = gcmNAME_TO_PTR(Interface->u.FreeContiguousMemory.physical);
 
         /* Unmap user logical out of physical memory first. */
         gcmkONERROR(gckOS_UnmapUserLogical(Kernel->os,
                                            physical,
-                                           Interface->u.FreeContiguousMemory.bytes,
-                                           Interface->u.FreeContiguousMemory.logical));
+                                           (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes,
+                                           gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical)));
 
         /* Free contiguous memory. */
         gcmkONERROR(
             gckOS_FreeContiguous(Kernel->os,
                                  physical,
-                                 Interface->u.FreeContiguousMemory.logical,
-                                 Interface->u.FreeContiguousMemory.bytes));
+                                 gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical),
+                                 (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_CONTIGUOUS,
-                                      Interface->u.FreeNonPagedMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.FreeContiguousMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical),
             Interface->u.FreeContiguousMemory.bytes));
 #endif
+
+        gcmRELEASE_NAME(Interface->u.FreeContiguousMemory.physical);
+
         break;
 
     case gcvHAL_ALLOCATE_VIDEO_MEMORY:
@@ -926,10 +1146,8 @@ gckKERNEL_Dispatch(
                             Interface->u.AllocateLinearVideoMemory.bytes,
                             Interface->u.AllocateLinearVideoMemory.alignment,
                             Interface->u.AllocateLinearVideoMemory.type,
-                            &Interface->u.AllocateLinearVideoMemory.node));
+                            &node));
 
-        /* Get actual size of node. */
-        node = Interface->u.AllocateLinearVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             bytes = node->VidMem.bytes;
@@ -942,14 +1160,17 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY,
-                                   Interface->u.AllocateLinearVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    bytes));
+
+        /* Get the node. */
+        Interface->u.AllocateLinearVideoMemory.node = gcmPTR_TO_UINT64(node);
         break;
 
     case gcvHAL_FREE_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.FreeVideoMemory.node);
 #ifdef __QNXNTO__
-        node = Interface->u.FreeVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM
          && node->VidMem.logical != gcvNULL)
         {
@@ -963,25 +1184,27 @@ gckKERNEL_Dispatch(
 #endif
         /* Free video memory. */
         gcmkONERROR(
-            gckVIDMEM_Free(Interface->u.FreeVideoMemory.node));
+            gckVIDMEM_Free(node));
 
         gcmkONERROR(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_VIDEO_MEMORY,
-                                      Interface->u.FreeVideoMemory.node));
+                                      node));
+
         break;
 
     case gcvHAL_LOCK_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node);
+
         /* Lock video memory. */
         gcmkONERROR(
             gckVIDMEM_Lock(Kernel,
-                           Interface->u.LockVideoMemory.node,
+                           node,
                            Interface->u.LockVideoMemory.cacheable,
                            &Interface->u.LockVideoMemory.address));
 
         locked = gcvTRUE;
 
-        node = Interface->u.LockVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Map video memory address into user space. */
@@ -998,18 +1221,20 @@ gckKERNEL_Dispatch(
         }
         gcmkASSERT(node->VidMem.logical != gcvNULL);
 
-        Interface->u.LockVideoMemory.memory = node->VidMem.logical;
+        Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->VidMem.logical);
 #else
             gcmkONERROR(
                 gckKERNEL_MapVideoMemory(Kernel,
                                          FromUser,
                                          Interface->u.LockVideoMemory.address,
-                                         &Interface->u.LockVideoMemory.memory));
+                                         &logical));
+
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(logical);
 #endif
         }
         else
         {
-            Interface->u.LockVideoMemory.memory = node->Virtual.logical;
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->Virtual.logical);
 
             /* Success. */
             status = gcvSTATUS_OK;
@@ -1018,12 +1243,12 @@ gckKERNEL_Dispatch(
 #if gcdSECURE_USER
         /* Return logical address as physical address. */
         Interface->u.LockVideoMemory.address =
-            gcmPTR2INT(Interface->u.LockVideoMemory.memory);
+            Interface->u.LockVideoMemory.memory;
 #endif
         gcmkONERROR(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                   Interface->u.LockVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    0));
 
@@ -1031,7 +1256,7 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         /* Unlock video memory. */
-        node = Interface->u.UnlockVideoMemory.node;
+        node = gcmUINT64_TO_PTR(Interface->u.UnlockVideoMemory.node);
 
 #if gcdSECURE_USER
         /* Save node information before it disappears. */
@@ -1070,26 +1295,25 @@ gckKERNEL_Dispatch(
             gcmkONERROR(
                 gckKERNEL_RemoveProcessDB(Kernel,
                                           processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                          Interface->u.UnlockVideoMemory.node));
+                                          node));
         }
-
         break;
 
     case gcvHAL_EVENT_COMMIT:
         /* Commit an event queue. */
         gcmkONERROR(
             gckEVENT_Commit(Kernel->eventObj,
-                            Interface->u.Event.queue));
+                            gcmUINT64_TO_PTR(Interface->u.Event.queue)));
         break;
 
     case gcvHAL_COMMIT:
         /* Commit a command and context buffer. */
         gcmkONERROR(
             gckCOMMAND_Commit(Kernel->command,
-                              Interface->u.Commit.context,
-                              Interface->u.Commit.commandBuffer,
-                              Interface->u.Commit.delta,
-                              Interface->u.Commit.queue,
+                              gcmNAME_TO_PTR(Interface->u.Commit.context),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.commandBuffer),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.delta),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.queue),
                               processID));
         break;
 
@@ -1103,42 +1327,49 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckOS_MapUserMemory(Kernel->os,
                                 Kernel->core,
-                                Interface->u.MapUserMemory.memory,
+                                gcmUINT64_TO_PTR(Interface->u.MapUserMemory.memory),
                                 Interface->u.MapUserMemory.physical,
-                                Interface->u.MapUserMemory.size,
-                                &Interface->u.MapUserMemory.info,
+                                (gctSIZE_T) Interface->u.MapUserMemory.size,
+                                &info,
                                 &Interface->u.MapUserMemory.address));
+
+        Interface->u.MapUserMemory.info = gcmPTR_TO_NAME(info);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_MAP_USER_MEMORY,
-                                   Interface->u.MapUserMemory.info,
-                                   Interface->u.MapUserMemory.memory,
-                                   Interface->u.MapUserMemory.size));
+                                   gcmINT2PTR(Interface->u.MapUserMemory.info),
+                                   gcmUINT64_TO_PTR(Interface->u.MapUserMemory.memory),
+                                   (gctSIZE_T) Interface->u.MapUserMemory.size));
         break;
 
     case gcvHAL_UNMAP_USER_MEMORY:
         address = Interface->u.UnmapUserMemory.address;
+        info = gcmNAME_TO_PTR(Interface->u.UnmapUserMemory.info);
 
         /* Unmap user memory. */
         gcmkONERROR(
             gckOS_UnmapUserMemory(Kernel->os,
                                   Kernel->core,
-                                  Interface->u.UnmapUserMemory.memory,
-                                  Interface->u.UnmapUserMemory.size,
-                                  Interface->u.UnmapUserMemory.info,
+                                  gcmUINT64_TO_PTR(Interface->u.UnmapUserMemory.memory),
+                                  (gctSIZE_T) Interface->u.UnmapUserMemory.size,
+                                  info,
                                   address));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.UnmapUserMemory.memory,
+            gcmUINT64_TO_PTR(Interface->u.UnmapUserMemory.memory),
             Interface->u.UnmapUserMemory.size));
 #endif
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_MAP_USER_MEMORY,
-                                      Interface->u.UnmapUserMemory.info));
+                                      gcmINT2PTR(Interface->u.UnmapUserMemory.info)));
+
+        gcmRELEASE_NAME(Interface->u.UnmapUserMemory.info);
+
         break;
 
 #if !USE_NEW_LINUX_SIGNAL
@@ -1199,7 +1430,7 @@ gckKERNEL_Dispatch(
                     {
                         gcmkONERROR(
                             gckOS_SignalQueryHardware(Kernel->os,
-                                                      (gctSIGNAL)Interface->u.UserSignal.id,
+                                                      (gctSIGNAL)(gctUINTPTR_T)Interface->u.UserSignal.id,
                                                       &hardware));
 
                         if (hardware)
@@ -1251,8 +1482,8 @@ gckKERNEL_Dispatch(
         case gcvUSER_SIGNAL_MAP:
             gcmkONERROR(
                 gckOS_MapSignal(Kernel->os,
-                               (gctSIGNAL)Interface->u.UserSignal.id,
-                               (gctHANDLE)processID,
+                               (gctSIGNAL)(gctUINTPTR_T)Interface->u.UserSignal.id,
+                               (gctHANDLE)(gctUINTPTR_T)processID,
                                &signal));
 
             gcmkVERIFY_OK(
@@ -1374,6 +1605,7 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckHARDWARE_QueryProfileRegisters(
                 Kernel->hardware,
+                Kernel->profileCleanRegister,
                 &Interface->u.RegisterProfileData.counters));
 #else
         status = gcvSTATUS_OK;
@@ -1386,7 +1618,7 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckHARDWARE_ProfileEngine2D(
                 Kernel->hardware,
-                Interface->u.RegisterProfileData2D.hwProfile2D));
+                gcmUINT64_TO_PTR(Interface->u.RegisterProfileData2D.hwProfile2D)));
 #else
         status = gcvSTATUS_OK;
 #endif
@@ -1405,7 +1637,6 @@ gckKERNEL_Dispatch(
 
         status = gcvSTATUS_OK;
         break;
-
     case gcvHAL_SET_PROFILE_SETTING:
 #if VIVANTE_PROFILER
         /* Set profile setting */
@@ -1420,6 +1651,15 @@ gckKERNEL_Dispatch(
         status = gcvSTATUS_OK;
         break;
 
+#if VIVANTE_PROFILER_PERDRAW
+    case gcvHAL_READ_PROFILER_REGISTER_SETTING:
+    #if VIVANTE_PROFILER
+        Kernel->profileCleanRegister = Interface->u.SetProfilerRegisterClear.bclear;
+    #endif
+        status = gcvSTATUS_OK;
+        break;
+#endif
+
     case gcvHAL_QUERY_KERNEL_SETTINGS:
         /* Get kernel settings. */
         gcmkONERROR(
@@ -1470,7 +1710,11 @@ gckKERNEL_Dispatch(
             {
                 Interface->u.ReadRegisterData.data = 1;
                 gcmkVERIFY_OK(
-                    gckOS_DumpGPUState(Kernel->os, Kernel->core));
+                    gckHARDWARE_DumpGPUState(Kernel->hardware));
+#if gcdVIRTUAL_COMMAND_BUFFER
+                gcmkVERIFY_OK(
+                    gckCOMMAND_DumpExecutingBuffer(Kernel->command));
+#endif
             }
             else
             {
@@ -1482,19 +1726,22 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_DUMP_EVENT:
         /* Dump GPU event */
-        gcmkVERIFY_OK(
-            gckEVENT_Dump(Kernel->eventObj));
+        gcmkVERIFY_OK(gckEVENT_Dump(Kernel->eventObj));
+
+        /* Dump Process DB. */
+        gcmkVERIFY_OK(gckKERNEL_DumpProcessDB(Kernel));
         break;
 
     case gcvHAL_CACHE:
-        if (Interface->u.Cache.node == gcvNULL)
+        node = gcmUINT64_TO_PTR(Interface->u.Cache.node);
+        if (node == gcvNULL)
         {
             /* FIXME Surface wrap some memory which is not allocated by us,
             ** So we don't have physical address to handle outer cache, ignore it*/
             status = gcvSTATUS_OK;
             break;
         }
-        else if (Interface->u.Cache.node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+        else if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Video memory has no physical handles. */
             physical = gcvNULL;
@@ -1502,9 +1749,11 @@ gckKERNEL_Dispatch(
         else
         {
             /* Grab physical handle. */
-            physical = Interface->u.Cache.node->Virtual.physical;
+            physical = node->Virtual.physical;
         }
 
+        logical = gcmUINT64_TO_PTR(Interface->u.Cache.logical);
+        bytes = (gctSIZE_T) Interface->u.Cache.bytes;
         switch(Interface->u.Cache.operation)
         {
         case gcvCACHE_FLUSH:
@@ -1513,8 +1762,8 @@ gckKERNEL_Dispatch(
                                       processID,
                                       physical,
                                       paddr,
-                                      Interface->u.Cache.logical,
-                                      Interface->u.Cache.bytes);
+                                      logical,
+                                      bytes);
             break;
         case gcvCACHE_CLEAN:
             /* Clean the cache. */
@@ -1522,8 +1771,8 @@ gckKERNEL_Dispatch(
                                       processID,
                                       physical,
                                       paddr,
-                                      Interface->u.Cache.logical,
-                                      Interface->u.Cache.bytes);
+                                      logical,
+                                      bytes);
             break;
         case gcvCACHE_INVALIDATE:
             /* Invalidate the cache. */
@@ -1531,13 +1780,13 @@ gckKERNEL_Dispatch(
                                            processID,
                                            physical,
                                            paddr,
-                                           Interface->u.Cache.logical,
-                                           Interface->u.Cache.bytes);
+                                           logical,
+                                           bytes);
             break;
 
 	case gcvCACHE_MEMORY_BARRIER:
 	   status = gckOS_MemoryBarrier(Kernel->os,
-                                        Interface->u.Cache.logical);
+                                        logical);
 	   break;
         default:
             status = gcvSTATUS_INVALID_ARGUMENT;
@@ -1637,14 +1886,17 @@ gckKERNEL_Dispatch(
         /* Attach user process. */
         gcmkONERROR(
             gckCOMMAND_Attach(Kernel->command,
-                              &Interface->u.Attach.context,
-                              &Interface->u.Attach.stateCount,
+                              &context,
+                              &bytes,
                               processID));
 
+        Interface->u.Attach.stateCount = bytes;
+        Interface->u.Attach.context = gcmPTR_TO_NAME(context);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_CONTEXT,
-                                   Interface->u.Attach.context,
+                                   gcmINT2PTR(Interface->u.Attach.context),
                                    gcvNULL,
                                    0));
         break;
@@ -1653,15 +1905,18 @@ gckKERNEL_Dispatch(
         /* Detach user process. */
         gcmkONERROR(
             gckCOMMAND_Detach(Kernel->command,
-                              Interface->u.Detach.context));
+                              gcmNAME_TO_PTR(Interface->u.Detach.context)));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                               processID, gcvDB_CONTEXT,
-                              Interface->u.Detach.context));
+                              gcmINT2PTR(Interface->u.Detach.context)));
+
+        gcmRELEASE_NAME(Interface->u.Detach.context);
         break;
 
     case gcvHAL_COMPOSE:
+        Interface->u.Compose.physical = gcmPTR_TO_UINT64(gcmNAME_TO_PTR(Interface->u.Compose.physical));
         /* Start composition. */
         gcmkONERROR(
             gckEVENT_Compose(Kernel->eventObj,
@@ -1677,250 +1932,138 @@ gckKERNEL_Dispatch(
     case gcvHAL_GET_FRAME_INFO:
         gcmkONERROR(gckHARDWARE_GetFrameInfo(
             Kernel->hardware,
-            Interface->u.GetFrameInfo.frameInfo));
+            gcmUINT64_TO_PTR(Interface->u.GetFrameInfo.frameInfo)));
         break;
 #endif
 
     case gcvHAL_GET_SHARED_INFO:
-        if (Interface->u.GetSharedInfo.dataId != 0)
+        if (Interface->u.GetSharedInfo.data == gcvNULL)
         {
-            gcmkONERROR(gckKERNEL_FindProcessDB(Kernel,
-                        Interface->u.GetSharedInfo.pid,
-                        0,
-                        gcvDB_SHARED_INFO,
-                        gcmINT2PTR(Interface->u.GetSharedInfo.dataId),
-                        &record));
-
-            /* find a record in db, check size */
-            if (record.bytes != Interface->u.GetSharedInfo.size)
-            {
-                /* Size change is not allowed */
-                gcmkONERROR(gcvSTATUS_INVALID_DATA);
-            }
-
-            /* fetch data */
-            gcmkONERROR(gckOS_CopyToUserData(
-                Kernel->os,
-                record.physical,
-                Interface->u.GetSharedInfo.data,
-                Interface->u.GetSharedInfo.size
-                ));
-
+            gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
         }
-
-        if ((node = Interface->u.GetSharedInfo.node) != gcvNULL)
+        else
         {
-            switch (Interface->u.GetSharedInfo.infoType)
-                {
-                case gcvVIDMEM_INFO_GENERIC:
-                    { /* Generic data stored */
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            data = &node->VidMem.sharedInfo;
-
-                        }
-                        else
-                        {
-                            data = &node->Virtual.sharedInfo;
-                        }
-
-                         gcmkONERROR(gckOS_CopyToUserData(
-                             Kernel->os,
-                             data,
-                             Interface->u.GetSharedInfo.nodeData,
-                             sizeof(gcsVIDMEM_NODE_SHARED_INFO)
-                             ));
-                    }
-                    break;
-
-                case gcvVIDMEM_INFO_DIRTY_RECTANGLE:
-                    { /* Dirty rectangle stored */
-                        gcsVIDMEM_NODE_SHARED_INFO *storedSharedInfo;
-                        gcsVIDMEM_NODE_SHARED_INFO alignedSharedInfo;
-
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            storedSharedInfo = &node->VidMem.sharedInfo;
-                        }
-                        else
-                        {
-                            storedSharedInfo = &node->Virtual.sharedInfo;
-                        }
-
-                        /* Stored shared info holds the unaligned dirty rectangle.
-                           Align it first.                                         */
-
-                        /* Hardware requires 64-byte aligned address, and 16x4 pixel aligned rectsize.
-                           We simply align to 32 pixels which covers both 16- and 32-bpp formats. */
-
-                        /* Make sure we have a legit rectangle. */
-                        gcmkASSERT((storedSharedInfo->RectSize.width != 0) && (storedSharedInfo->RectSize.height != 0));
-
-                        alignedSharedInfo.SrcOrigin.x = gcmALIGN_BASE(storedSharedInfo->SrcOrigin.x, 32);
-                        alignedSharedInfo.RectSize.width = gcmALIGN((storedSharedInfo->RectSize.width + (storedSharedInfo->SrcOrigin.x - alignedSharedInfo.SrcOrigin.x)), 16);
-
-                        alignedSharedInfo.SrcOrigin.y = gcmALIGN_BASE(storedSharedInfo->SrcOrigin.y, 4);
-                        alignedSharedInfo.RectSize.height = gcmALIGN((storedSharedInfo->RectSize.height + (storedSharedInfo->SrcOrigin.y - alignedSharedInfo.SrcOrigin.y)), 4);
-
-                        gcmkONERROR(gckOS_CopyToUserData(
-                            Kernel->os,
-                            &alignedSharedInfo,
-                            Interface->u.GetSharedInfo.nodeData,
-                            sizeof(gcsVIDMEM_NODE_SHARED_INFO)
-                            ));
+            gctUINT32 pid    = Interface->u.GetSharedInfo.pid;
+            gctUINT32 dataId = Interface->u.GetSharedInfo.dataId;
+            gctSIZE_T bytes  = Interface->u.GetSharedInfo.bytes;
+            gctPOINTER data  = Interface->u.GetSharedInfo.data;
+            gcsDATABASE_RECORD record;
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL,
-                                        "Node = %p, unaligned rectangle (l=%d, t=%d, w=%d, h=%d) aligned to (l=%d, t=%d, w=%d, h=%d)", node,
-                                        storedSharedInfo->SrcOrigin.x, storedSharedInfo->SrcOrigin.y,
-                                        storedSharedInfo->RectSize.width, storedSharedInfo->RectSize.height,
-                                        alignedSharedInfo.SrcOrigin.x, alignedSharedInfo.SrcOrigin.y,
-                                        alignedSharedInfo.RectSize.width, alignedSharedInfo.RectSize.height);
+            /* Find record. */
+            gcmkONERROR(
+                gckKERNEL_FindProcessDB(Kernel,
+                                        pid,
+                                        0,
+                                        gcvDB_SHARED_INFO,
+                                        gcmINT2PTR(dataId),
+                                        &record));
+
+            /* Check memory size. */
+            if (bytes < record.bytes)
+            {
+                /* Insufficient memory to hold shared data. */
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+            }
 
-                        /* Rectangle */
-                        storedSharedInfo->SrcOrigin.x =
-                        storedSharedInfo->SrcOrigin.y =
-                        storedSharedInfo->RectSize.width =
-                        storedSharedInfo->RectSize.height = 0;
-                    }
-                    break;
-                }
+            /* Copy to user. */
+            status = gckOS_CopyToUserData(Kernel->os,
+                                          record.physical,
+                                          data,
+                                          record.bytes);
+
+            /*
+             * Remove from process db.
+             * Every time when shared info is taken, the record is erased in
+             * kernel side.
+             */
+            gcmkVERIFY_OK(
+                gckKERNEL_RemoveProcessDB(Kernel,
+                                          pid,
+                                          gcvDB_SHARED_INFO,
+                                          gcmINT2PTR(dataId)));
+            /* Free existed data. */
+            gcmkVERIFY_OK(
+                gckOS_FreeMemory(Kernel->os, record.physical));
         }
         break;
 
     case gcvHAL_SET_SHARED_INFO:
-        if (Interface->u.SetSharedInfo.dataId != 0)
         {
-            status = gckKERNEL_FindProcessDB(Kernel, processID, 0,
-                        gcvDB_SHARED_INFO,
-                        gcmINT2PTR(Interface->u.SetSharedInfo.dataId),
-                        &record);
-
-            if (status == gcvSTATUS_INVALID_DATA)
-            {
-                /* private data has not been created yet */
-                /* Note: we count on DestoryProcessDB to free it */
-                gcmkONERROR(gckOS_AllocateMemory(
-                    Kernel->os,
-                    Interface->u.SetSharedInfo.size,
-                    &data
-                    ));
-
-                gcmkONERROR(
-                    gckKERNEL_AddProcessDB(Kernel, processID,
-                        gcvDB_SHARED_INFO,
-                        gcmINT2PTR(Interface->u.SetSharedInfo.dataId),
-                        data,
-                        Interface->u.SetSharedInfo.size
-                        ));
-            }
-            else
+            gctUINT32 dataId = Interface->u.SetSharedInfo.dataId;
+            gctPOINTER data  = Interface->u.SetSharedInfo.data;
+            gctUINT32 bytes  = Interface->u.SetSharedInfo.bytes;
+            gctPOINTER memory = gcvNULL;
+            gcsDATABASE_RECORD record;
+
+            if (gcmIS_SUCCESS(gckKERNEL_FindProcessDB(Kernel,
+                                                     processID,
+                                                     0,
+                                                     gcvDB_SHARED_INFO,
+                                                     gcmINT2PTR(dataId),
+                                                     &record)))
             {
-                /* bail on other errors */
-                gcmkONERROR(status);
-
-                /* find a record in db, check size */
-                if (record.bytes != Interface->u.SetSharedInfo.size)
+                /* Find a record with the same id. */
+                if (bytes != record.bytes)
                 {
-                    /* Size change is not allowed */
-                    gcmkONERROR(gcvSTATUS_INVALID_DATA);
+                    /* Remove from process db. */
+                    gcmkVERIFY_OK(
+                        gckKERNEL_RemoveProcessDB(Kernel,
+                                                  processID,
+                                                  gcvDB_SHARED_INFO,
+                                                  gcmINT2PTR(dataId)));
+
+                    /* Free existed data. */
+                    gcmkVERIFY_OK(
+                        gckOS_FreeMemory(Kernel->os, record.physical));
                 }
-
-                /* get storage address */
-                data = record.physical;
-            }
-
-            gcmkONERROR(gckOS_CopyFromUserData(
-                Kernel->os,
-                data,
-                Interface->u.SetSharedInfo.data,
-                Interface->u.SetSharedInfo.size
-                ));
-        }
-
-        if ((node = Interface->u.SetSharedInfo.node) != gcvNULL)
-        {
-            switch (Interface->u.SetSharedInfo.infoType)
+                else
                 {
-                case gcvVIDMEM_INFO_GENERIC:
-                    { /* Generic data stored */
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            data = &node->VidMem.sharedInfo;
-                        }
-                        else
-                        {
-                            data = &node->Virtual.sharedInfo;
-                        }
-
-                        gcmkONERROR(gckOS_CopyFromUserData(
-                            Kernel->os,
-                            data,
-                            Interface->u.SetSharedInfo.nodeData,
-                            sizeof(gcsVIDMEM_NODE_SHARED_INFO)
-                            ));
-                    }
-                    break;
+                    /* Re-use allocated memory. */
+                    memory = record.physical;
+                }
+            }
 
-                case gcvVIDMEM_INFO_DIRTY_RECTANGLE:
-                    { /* Dirty rectangle stored */
-                        gcsVIDMEM_NODE_SHARED_INFO newSharedInfo;
-                        gcsVIDMEM_NODE_SHARED_INFO *currentSharedInfo;
-                        gctINT dirtyX, dirtyY, right, bottom;
-
-                        /* Expand the dirty rectangle stored in the node to include the rectangle passed in. */
-                        gcmkONERROR(gckOS_CopyFromUserData(
-                            Kernel->os,
-                            &newSharedInfo,
-                            Interface->u.SetSharedInfo.nodeData,
-                            gcmSIZEOF(gcsVIDMEM_NODE_SHARED_INFO)
-                            ));
-
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            currentSharedInfo = &node->VidMem.sharedInfo;
-                        }
-                        else
-                        {
-                            currentSharedInfo = &node->Virtual.sharedInfo;
-                        }
+            if ((data == gcvNULL) || (bytes == 0))
+            {
+                /* Nothing to record. */
+                break;
+            }
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL, "Node = %p Stored rectangle (l=%d, t=%d, w=%d, h=%d)", node,
-                                        currentSharedInfo->SrcOrigin.x, currentSharedInfo->SrcOrigin.y,
-                                        currentSharedInfo->RectSize.width, currentSharedInfo->RectSize.height);
+            if (bytes > 1024)
+            {
+                /* Limite data size. */
+                gcmkONERROR(gcvSTATUS_TOO_COMPLEX);
+            }
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL, "To combine with (l=%d, t=%d, w=%d, h=%d)",
-                                        newSharedInfo.SrcOrigin.x, newSharedInfo.SrcOrigin.y,
-                                        newSharedInfo.RectSize.width, newSharedInfo.RectSize.height);
+            if (memory == gcvNULL)
+            {
+                /* Allocate memory for holding shared data. */
+                gcmkONERROR(
+                    gckOS_AllocateMemory(Kernel->os, bytes, &memory));
 
-                        if ((currentSharedInfo->RectSize.width == 0) || (currentSharedInfo->RectSize.height == 0))
-                        { /* Setting it for the first time */
-                            currentSharedInfo->SrcOrigin.x = newSharedInfo.SrcOrigin.x;
-                            currentSharedInfo->SrcOrigin.y = newSharedInfo.SrcOrigin.y;
-                            currentSharedInfo->RectSize.width = newSharedInfo.RectSize.width;
-                            currentSharedInfo->RectSize.height = newSharedInfo.RectSize.height;
-                        }
-                        else
-                        {
-                            /* Expand the stored rectangle to include newly locked rectangle */
-                            dirtyX = (newSharedInfo.SrcOrigin.x < currentSharedInfo->SrcOrigin.x) ? newSharedInfo.SrcOrigin.x : currentSharedInfo->SrcOrigin.x;
-                            right = gcmMAX((currentSharedInfo->SrcOrigin.x + currentSharedInfo->RectSize.width), (newSharedInfo.SrcOrigin.x + newSharedInfo.RectSize.width));
-                            currentSharedInfo->RectSize.width = right - dirtyX;
-                            currentSharedInfo->SrcOrigin.x = dirtyX;
-
-                            dirtyY = (newSharedInfo.SrcOrigin.y < currentSharedInfo->SrcOrigin.y) ? newSharedInfo.SrcOrigin.y : currentSharedInfo->SrcOrigin.y;
-                            bottom = gcmMAX((currentSharedInfo->SrcOrigin.y + currentSharedInfo->RectSize.height), (newSharedInfo.SrcOrigin.y + newSharedInfo.RectSize.height));
-                            currentSharedInfo->RectSize.height = bottom - dirtyY;
-                            currentSharedInfo->SrcOrigin.y = dirtyY;
-                        }
+                /* Add to process db. */
+                status = gckKERNEL_AddProcessDB(Kernel,
+                                                processID,
+                                                gcvDB_SHARED_INFO,
+                                                gcmINT2PTR(dataId),
+                                                memory,
+                                                bytes);
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL, "Combined rectangle (l=%d, t=%d, w=%d, h=%d)",
-                                       currentSharedInfo->SrcOrigin.x, currentSharedInfo->SrcOrigin.y,
-                                       currentSharedInfo->RectSize.width, currentSharedInfo->RectSize.height);
-                    }
+                if (gcmIS_ERROR(status))
+                {
+                    /* Failed to add process db. Free allocated memory. */
+                    gcmkVERIFY_OK(gckOS_FreeMemory(Kernel->os, memory));
                     break;
                 }
-        }
+            }
 
+            /* Copy shared data to kernel memory. */
+            gcmkONERROR(
+                gckOS_CopyFromUserData(Kernel->os,
+                                       memory,
+                                       data,
+                                       bytes));
+        }
         break;
 
     case gcvHAL_SET_FSCALE_VALUE:
@@ -1942,6 +2085,14 @@ gckKERNEL_Dispatch(
 #endif
         break;
 
+    case gcvHAL_QUERY_RESET_TIME_STAMP:
+#if gcdENABLE_RECOVERY
+        Interface->u.QueryResetTimeStamp.timeStamp = Kernel->resetTimeStamp;
+#else
+        Interface->u.QueryResetTimeStamp.timeStamp = 0;
+#endif
+        break;
+
     default:
         /* Invalid command. */
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -1958,7 +2109,7 @@ OnError:
             /* Roll back the lock. */
             gcmkVERIFY_OK(
                 gckVIDMEM_Unlock(Kernel,
-                                 Interface->u.LockVideoMemory.node,
+                                 gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node),
                                  gcvSURF_TYPE_UNKNOWN,
                                  &asynchronous));
 
@@ -1967,7 +2118,7 @@ OnError:
                 /* Bottom Half */
                 gcmkVERIFY_OK(
                     gckVIDMEM_Unlock(Kernel,
-                                     Interface->u.LockVideoMemory.node,
+                                     gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node),
                                      gcvSURF_TYPE_UNKNOWN,
                                      gcvNULL));
             }
@@ -2745,6 +2896,8 @@ gckKERNEL_Recovery(
 #endif
     gcmkONERROR(gckEVENT_Notify(eventObj, 2));
 
+    Kernel->resetTimeStamp++;
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -2943,8 +3096,691 @@ gckKERNEL_SetTimeOut(
     gcmkFOOTER_NO();
 }
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckKERNEL_AllocateVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    )
+{
+    gckOS os = Kernel->os;
+    gceSTATUS status;
+    gctPOINTER logical;
+    gctSIZE_T pageCount;
+    gctSIZE_T bytes = *Bytes;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+
+    gcmkHEADER_ARG("Os=0x%X InUserSpace=%d *Bytes=%lu",
+                   os, InUserSpace, gcmOPT_VALUE(Bytes));
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Bytes != gcvNULL);
+    gcmkVERIFY_ARGUMENT(*Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+
+    gcmkONERROR(gckOS_Allocate(os,
+                               sizeof(gckVIRTUAL_COMMAND_BUFFER),
+                               (gctPOINTER)&buffer));
+
+    gcmkONERROR(gckOS_ZeroMemory(buffer, sizeof(gckVIRTUAL_COMMAND_BUFFER)));
+
+    gcmkONERROR(gckOS_AllocatePagedMemoryEx(os,
+                                            gcvFALSE,
+                                            bytes,
+                                            &buffer->physical));
+
+    if (InUserSpace)
+    {
+        gcmkONERROR(gckOS_LockPages(os,
+                                    buffer->physical,
+                                    bytes,
+                                    gcvFALSE,
+                                    &logical,
+                                    &pageCount));
+
+        *Logical =
+        buffer->userLogical = logical;
+    }
+    else
+    {
+        gcmkONERROR(
+            gckOS_CreateKernelVirtualMapping(buffer->physical,
+                                             &pageCount,
+                                             &logical));
+        *Logical =
+        buffer->kernelLogical = logical;
+    }
+
+    buffer->pageCount = pageCount;
+    buffer->kernel = Kernel;
+
+    gcmkONERROR(gckOS_GetProcessID(&buffer->pid));
+
+    gcmkONERROR(gckMMU_AllocatePages(Kernel->mmu,
+                                     pageCount,
+                                     &buffer->pageTable,
+                                     &buffer->gpuAddress));
+
+    gcmkONERROR(gckOS_MapPagesEx(os,
+                                 Kernel->core,
+                                 buffer->physical,
+                                 pageCount,
+                                 buffer->pageTable));
+
+    gcmkONERROR(gckMMU_Flush(Kernel->mmu));
+
+    *Physical = buffer;
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_KERNEL,
+                   "gpuAddress = %x pageCount = %d kernelLogical = %x userLogical=%x",
+                   buffer->gpuAddress, buffer->pageCount,
+                   buffer->kernelLogical, buffer->userLogical);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    if (Kernel->virtualBufferHead == gcvNULL)
+    {
+        Kernel->virtualBufferHead =
+        Kernel->virtualBufferTail = buffer;
+    }
+    else
+    {
+        buffer->prev = Kernel->virtualBufferTail;
+        Kernel->virtualBufferTail->next = buffer;
+        Kernel->virtualBufferTail = buffer;
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Kernel->virtualBufferLock));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (buffer->gpuAddress)
+    {
+        gcmkVERIFY_OK(
+            gckMMU_FreePages(Kernel->mmu, buffer->pageTable, buffer->pageCount));
+    }
+
+    if (buffer->userLogical)
+    {
+        gcmkVERIFY_OK(
+            gckOS_UnlockPages(os, buffer->physical, bytes, buffer->userLogical));
+    }
+
+    if (buffer->kernelLogical)
+    {
+        gcmkVERIFY_OK(
+            gckOS_DestroyKernelVirtualMapping(buffer->kernelLogical));
+    }
+
+    if (buffer->physical)
+    {
+        gcmkVERIFY_OK(gckOS_FreePagedMemory(os, buffer->physical, bytes));
+    }
 
+    gcmkVERIFY_OK(gckOS_Free(os, buffer));
 
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_DestroyVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical
+    )
+{
+    gckOS os;
+    gckKERNEL kernel;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer = (gckVIRTUAL_COMMAND_BUFFER_PTR)Physical;
+
+    gcmkHEADER();
+    gcmkVERIFY_ARGUMENT(buffer != gcvNULL);
+
+    kernel = buffer->kernel;
+    os = kernel->os;
+
+    if (buffer->userLogical)
+    {
+        gcmkVERIFY_OK(gckOS_UnlockPages(os, buffer->physical, Bytes, Logical));
+    }
+    else
+    {
+        gcmkVERIFY_OK(gckOS_DestroyKernelVirtualMapping(Logical));
+    }
+
+    gcmkVERIFY_OK(
+        gckMMU_FreePages(kernel->mmu, buffer->pageTable, buffer->pageCount));
+
+    gcmkVERIFY_OK(gckOS_FreePagedMemory(os, buffer->physical, Bytes));
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, kernel->virtualBufferLock, gcvINFINITE));
+
+    if (buffer == kernel->virtualBufferHead)
+    {
+        if ((kernel->virtualBufferHead = buffer->next) == gcvNULL)
+        {
+            kernel->virtualBufferTail = gcvNULL;
+        }
+    }
+    else
+    {
+        buffer->prev->next = buffer->next;
+
+        if (buffer == kernel->virtualBufferTail)
+        {
+            kernel->virtualBufferTail = buffer->prev;
+        }
+        else
+        {
+            buffer->next->prev = buffer->prev;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, kernel->virtualBufferLock));
+
+    gcmkVERIFY_OK(gckOS_Free(os, buffer));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckKERNEL_GetGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    )
+{
+    gceSTATUS status;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctPOINTER start;
+    gctINT pid;
+
+    gcmkHEADER_ARG("Logical = %x", Logical);
+
+    gckOS_GetProcessID(&pid);
+
+    status = gcvSTATUS_INVALID_ADDRESS;
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    /* Walk all command buffer. */
+    for (buffer = Kernel->virtualBufferHead; buffer != gcvNULL; buffer = buffer->next)
+    {
+        if (buffer->userLogical)
+        {
+            start = buffer->userLogical;
+        }
+        else
+        {
+            start = buffer->kernelLogical;
+        }
+
+        if (Logical >= start
+        && (Logical < (start + buffer->pageCount * 4096))
+        && pid == buffer->pid
+        )
+        {
+            * Address = buffer->gpuAddress + (Logical - start);
+            status = gcvSTATUS_OK;
+            break;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->virtualBufferLock));
+
+    gcmkFOOTER_NO();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_QueryGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 GpuAddress,
+    OUT gckVIRTUAL_COMMAND_BUFFER_PTR * Buffer
+    )
+{
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctUINT32 start;
+    gceSTATUS status = gcvSTATUS_NOT_SUPPORTED;
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    /* Walk all command buffers. */
+    for (buffer = Kernel->virtualBufferHead; buffer != gcvNULL; buffer = buffer->next)
+    {
+        start = (gctUINT32)buffer->gpuAddress;
+
+        if (GpuAddress >= start && GpuAddress < (start + buffer->pageCount * 4096))
+        {
+            /* Find a range matched. */
+            *Buffer = buffer;
+            status = gcvSTATUS_OK;
+            break;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->virtualBufferLock));
+
+    return status;
+}
+#endif
+
+#if gcdLINK_QUEUE_SIZE
+static void
+gckLINKQUEUE_Dequeue(
+    IN gckLINKQUEUE LinkQueue
+    )
+{
+    gcmASSERT(LinkQueue->count == gcdLINK_QUEUE_SIZE);
+
+    LinkQueue->count--;
+    LinkQueue->front = (LinkQueue->front + 1) % gcdLINK_QUEUE_SIZE;
+}
+
+void
+gckLINKQUEUE_Enqueue(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 start,
+    IN gctUINT32 end
+    )
+{
+    if (LinkQueue->count == gcdLINK_QUEUE_SIZE)
+    {
+        gckLINKQUEUE_Dequeue(LinkQueue);
+    }
+
+    gcmkASSERT(LinkQueue->count < gcdLINK_QUEUE_SIZE);
+
+    LinkQueue->count++;
+
+    LinkQueue->data[LinkQueue->rear].start = start;
+    LinkQueue->data[LinkQueue->rear].end = end;
+
+    gcmkVERIFY_OK(
+        gckOS_GetProcessID(&LinkQueue->data[LinkQueue->rear].pid));
+
+    LinkQueue->rear = (LinkQueue->rear + 1) % gcdLINK_QUEUE_SIZE;
+}
+
+void
+gckLINKQUEUE_GetData(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 Index,
+    OUT gckLINKDATA * Data
+    )
+{
+    gcmkASSERT(Index >= 0 && Index < gcdLINK_QUEUE_SIZE);
+
+    *Data = &LinkQueue->data[(Index + LinkQueue->front) % gcdLINK_QUEUE_SIZE];
+}
+#endif
+
+/******************************************************************************\
+*************************** Pointer - ID translation ***************************
+\******************************************************************************/
+#define gcdID_TABLE_LENGTH 1024
+typedef struct _gcsINTEGERDB * gckINTEGERDB;
+typedef struct _gcsINTEGERDB
+{
+    gckOS                       os;
+    gctPOINTER*                 table;
+    gctPOINTER                  mutex;
+    gctUINT32                   tableLen;
+    gctUINT32                   currentID;
+    gctUINT32                   unused;
+}
+gcsINTEGERDB;
+
+gceSTATUS
+gckKERNEL_CreateIntegerDatabase(
+    IN gckKERNEL Kernel,
+    OUT gctPOINTER * Database
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = gcvNULL;
+
+    gcmkHEADER_ARG("Kernel=0x%08X Datbase=0x%08X", Kernel, Database);
+
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Database != gcvNULL);
+
+    /* Allocate a database. */
+    gcmkONERROR(gckOS_Allocate(
+        Kernel->os, gcmSIZEOF(gcsINTEGERDB), (gctPOINTER *)&database));
+
+    gckOS_ZeroMemory(database, gcmSIZEOF(gcsINTEGERDB));
+
+    /* Allocate a pointer table. */
+    gcmkONERROR(gckOS_Allocate(
+        Kernel->os, gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH, (gctPOINTER *)&database->table));
+
+    gckOS_ZeroMemory(database->table, gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH);
+
+    /* Allocate a database mutex. */
+    gcmkONERROR(gckOS_CreateMutex(Kernel->os, &database->mutex));
+
+    /* Initialize. */
+    database->currentID = 0;
+    database->unused = gcdID_TABLE_LENGTH;
+    database->os = Kernel->os;
+    database->tableLen = gcdID_TABLE_LENGTH;
+
+    *Database = database;
+
+    gcmkFOOTER_ARG("*Database=0x%08X", *Database);
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Rollback. */
+    if (database)
+    {
+        if (database->table)
+        {
+            gcmkOS_SAFE_FREE(Kernel->os, database->table);
+        }
+
+        gcmkOS_SAFE_FREE(Kernel->os, database);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_DestroyIntegerDatabase(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Database
+    )
+{
+    gckINTEGERDB database = Database;
+
+    gcmkHEADER_ARG("Kernel=0x%08X Datbase=0x%08X", Kernel, Database);
+
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Database != gcvNULL);
+
+    /* Destroy pointer table. */
+    gcmkOS_SAFE_FREE(Kernel->os, database->table);
+
+    /* Destroy database mutex. */
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, database->mutex));
+
+    /* Destroy database. */
+    gcmkOS_SAFE_FREE(Kernel->os, database);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckKERNEL_AllocateIntegerId(
+    IN gctPOINTER Database,
+    IN gctPOINTER Pointer,
+    OUT gctUINT32 * Id
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gctUINT32 i, unused, currentID, tableLen;
+    gctPOINTER * table;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Pointer=0x%08X", Database, Pointer);
+
+    gcmkVERIFY_ARGUMENT(Id != gcvNULL);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (database->unused < 1)
+    {
+        /* Extend table. */
+        gcmkONERROR(
+            gckOS_Allocate(os,
+                           gcmSIZEOF(gctPOINTER) * (database->tableLen + gcdID_TABLE_LENGTH),
+                           (gctPOINTER *)&table));
+
+        gckOS_ZeroMemory(table + database->tableLen,
+                         gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH);
+
+        /* Copy data from old table. */
+        gckOS_MemCopy(table,
+                      database->table,
+                      database->tableLen * gcmSIZEOF(gctPOINTER));
+
+        gcmkOS_SAFE_FREE(os, database->table);
+
+        /* Update databse with new allocated table. */
+        database->table = table;
+        database->currentID = database->tableLen;
+        database->tableLen += gcdID_TABLE_LENGTH;
+        database->unused += gcdID_TABLE_LENGTH;
+    }
+
+    table = database->table;
+    currentID = database->currentID;
+    tableLen = database->tableLen;
+    unused = database->unused;
+
+    /* Connect id with pointer. */
+    table[currentID] = Pointer;
+
+    *Id = currentID + 1;
+
+    /* Update the currentID. */
+    if (--unused > 0)
+    {
+        for (i = 0; i < tableLen; i++)
+        {
+            if (++currentID >= tableLen)
+            {
+                /* Wrap to the begin. */
+                currentID = 0;
+            }
+
+            if (table[currentID] == gcvNULL)
+            {
+                break;
+            }
+        }
+    }
+
+    database->table = table;
+    database->currentID = currentID;
+    database->tableLen = tableLen;
+    database->unused = unused;
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    gcmkFOOTER_ARG("*Id=%d", *Id);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_FreeIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Id=%d", Database, Id);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (!(Id > 0 && Id <= database->tableLen))
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    Id -= 1;
+
+    database->table[Id] = gcvNULL;
+
+    if (database->unused++ == 0)
+    {
+        database->currentID = Id;
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_QueryIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id,
+    OUT gctPOINTER * Pointer
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gctPOINTER pointer;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Id=%d", Database, Id);
+    gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (!(Id > 0 && Id <= database->tableLen))
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    Id -= 1;
+
+    pointer = database->table[Id];
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    if (pointer)
+    {
+        *Pointer = pointer;
+    }
+    else
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    gcmkFOOTER_ARG("*Pointer=0x%08X", *Pointer);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+
+gctUINT32
+gckKERNEL_AllocateNameFromPointer(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Pointer
+    )
+{
+    gceSTATUS status;
+    gctUINT32 name;
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Pointer=0x%X", Kernel, Pointer);
+
+    gcmkONERROR(
+        gckKERNEL_AllocateIntegerId(database, Pointer, &name));
+
+    gcmkFOOTER_ARG("name=%d", name);
+    return name;
+
+OnError:
+    gcmkFOOTER();
+    return 0;
+}
+
+gctPOINTER
+gckKERNEL_QueryPointerFromName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    )
+{
+    gceSTATUS status;
+    gctPOINTER pointer = gcvNULL;
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Name=%d", Kernel, Name);
+
+    /* Lookup in database to get pointer. */
+    gcmkONERROR(gckKERNEL_QueryIntegerId(database, Name, &pointer));
+
+    gcmkFOOTER_ARG("pointer=0x%X", pointer);
+    return pointer;
+
+OnError:
+    gcmkFOOTER();
+    return gcvNULL;
+}
+
+gceSTATUS
+gckKERNEL_DeleteName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    )
+{
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Name=0x%X", Kernel, Name);
+
+    /* Free name if exists. */
+    gcmkVERIFY_OK(gckKERNEL_FreeIntegerId(database, Name));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
 /*******************************************************************************
 ***** Test Code ****************************************************************
 *******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 1f3c9cc..5896e93 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_h_
 #define __gc_hal_kernel_h_
 
@@ -134,6 +132,7 @@ gcskSECURE_CACHE;
 typedef enum _gceDATABASE_TYPE
 {
     gcvDB_VIDEO_MEMORY = 1,             /* Video memory created. */
+    gcvDB_COMMAND_BUFFER,               /* Command Buffer. */
     gcvDB_NON_PAGED,                    /* Non paged memory. */
     gcvDB_CONTIGUOUS,                   /* Contiguous memory. */
     gcvDB_SIGNAL,                       /* Signal. */
@@ -187,12 +186,15 @@ typedef struct _gcsDATABASE
     gctUINT64                           idle;
 
     /* Pointer to database. */
-    gcsDATABASE_RECORD_PTR              list;
+    gcsDATABASE_RECORD_PTR              list[48];
 
 #if gcdSECURE_USER
     /* Secure cache. */
     gcskSECURE_CACHE                    cache;
 #endif
+
+    gctPOINTER                          handleDatabase;
+    gctPOINTER                          handleDatabaseMutex;
 }
 gcsDATABASE;
 
@@ -251,6 +253,63 @@ gckKERNEL_QueryProcessDB(
     OUT gcuDATABASE_INFO * Info
     );
 
+/* Dump the process database. */
+gceSTATUS
+gckKERNEL_DumpProcessDB(
+    IN gckKERNEL Kernel
+    );
+
+/* ID database */
+gceSTATUS
+gckKERNEL_CreateIntegerDatabase(
+    IN gckKERNEL Kernel,
+    OUT gctPOINTER * Database
+    );
+
+gceSTATUS
+gckKERNEL_DestroyIntegerDatabase(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Database
+    );
+
+gceSTATUS
+gckKERNEL_AllocateIntegerId(
+    IN gctPOINTER Database,
+    IN gctPOINTER Pointer,
+    OUT gctUINT32 * Id
+    );
+
+gceSTATUS
+gckKERNEL_FreeIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id
+    );
+
+gceSTATUS
+gckKERNEL_QueryIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id,
+    OUT gctPOINTER * Pointer
+    );
+
+gctUINT32
+gckKERNEL_AllocateNameFromPointer(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Pointer
+    );
+
+gctPOINTER
+gckKERNEL_QueryPointerFromName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    );
+
+gceSTATUS
+gckKERNEL_DeleteName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    );
+
 #if gcdSECURE_USER
 /* Get secure cache from the process database. */
 gceSTATUS
@@ -290,8 +349,29 @@ struct _gckDB
     gctUINT64                   idleTime;
     gctUINT64                   lastSlowdown;
     gctUINT64                   lastSlowdownIdle;
+    /* ID - Pointer database*/
+    gctPOINTER                  pointerDatabase;
+    gctPOINTER                  pointerDatabaseMutex;
 };
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+typedef struct _gckVIRTUAL_COMMAND_BUFFER * gckVIRTUAL_COMMAND_BUFFER_PTR;
+typedef struct _gckVIRTUAL_COMMAND_BUFFER
+{
+    gctPHYS_ADDR                physical;
+    gctPOINTER                  userLogical;
+    gctPOINTER                  kernelLogical;
+    gctSIZE_T                   pageCount;
+    gctPOINTER                  pageTable;
+    gctUINT32                   gpuAddress;
+    gctUINT                     pid;
+    gckVIRTUAL_COMMAND_BUFFER_PTR   next;
+    gckVIRTUAL_COMMAND_BUFFER_PTR   prev;
+    gckKERNEL                   kernel;
+}
+gckVIRTUAL_COMMAND_BUFFER;
+#endif
+
 /* gckKERNEL object. */
 struct _gckKERNEL
 {
@@ -328,6 +408,10 @@ struct _gckKERNEL
 
     /* The profile file name */
     gctCHAR                     profileFileName[gcdMAX_PROFILE_FILE_NAME];
+
+    /* Clear profile register or not*/
+    gctBOOL                     profileCleanRegister;
+
 #endif
 
 #ifdef QNX_SINGLE_THREADED_DEBUGGING
@@ -341,6 +425,7 @@ struct _gckKERNEL
 #if gcdENABLE_RECOVERY
     gctPOINTER                  resetFlagClearTimer;
     gctPOINTER                  resetAtom;
+    gctUINT64                   resetTimeStamp;
 #endif
 
     /* Pointer to gckEVENT object. */
@@ -350,6 +435,36 @@ struct _gckKERNEL
 #if gcdENABLE_VG
     gckVGKERNEL                 vg;
 #endif
+
+#if gcdVIRTUAL_COMMAND_BUFFER
+    gckVIRTUAL_COMMAND_BUFFER_PTR virtualBufferHead;
+    gckVIRTUAL_COMMAND_BUFFER_PTR virtualBufferTail;
+    gctPOINTER                    virtualBufferLock;
+#endif
+
+#if gcdDVFS
+    gckDVFS                     dvfs;
+#endif
+};
+
+struct _FrequencyHistory
+{
+    gctUINT32                   frequency;
+    gctUINT32                   count;
+};
+
+/* gckDVFS object. */
+struct _gckDVFS
+{
+    gckOS                       os;
+    gckHARDWARE                 hardware;
+    gctPOINTER                  timer;
+    gctUINT32                   pollingTime;
+    gctBOOL                     stop;
+    gctUINT32                   totalConfig;
+    gctUINT32                   loads[8];
+    gctUINT8                    currentScale;
+    struct _FrequencyHistory    frequencyHistory[16];
 };
 
 /* gckCOMMAND object. */
@@ -452,6 +567,8 @@ typedef struct _gcsEVENT
     /* Kernel. */
     gckKERNEL                   kernel;
 #endif
+
+    gctBOOL                     fromKernel;
 }
 gcsEVENT;
 
@@ -735,6 +852,51 @@ struct _gckMMU
 #endif
 };
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckOS_CreateKernelVirtualMapping(
+    IN gctPHYS_ADDR Physical,
+    OUT gctSIZE_T * PageCount,
+    OUT gctPOINTER * Logical
+    );
+
+gceSTATUS
+gckOS_DestroyKernelVirtualMapping(
+    IN gctPOINTER Logical
+    );
+
+gceSTATUS
+gckKERNEL_AllocateVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+gceSTATUS
+gckKERNEL_DestroyVirtualCommandBuffer(
+    IN gckKERNEL Kernel,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical
+    );
+
+gceSTATUS
+gckKERNEL_GetGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    );
+
+gceSTATUS
+gckKERNEL_QueryGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 GpuAddress,
+    OUT gckVIRTUAL_COMMAND_BUFFER_PTR * Buffer
+    );
+#endif
+
 gceSTATUS
 gckKERNEL_AttachProcess(
     IN gckKERNEL Kernel,
@@ -795,6 +957,23 @@ gckCONTEXT_Update(
     IN gcsSTATE_DELTA_PTR StateDelta
     );
 
+#if gcdLINK_QUEUE_SIZE
+void
+gckLINKQUEUE_Enqueue(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 start,
+    IN gctUINT32 end
+    );
+
+void
+gckLINKQUEUE_GetData(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 Index,
+    OUT gckLINKDATA * Data
+    );
+#endif
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index fbaff66..9ee9ea1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include "gc_hal_kernel_context.h"
 
@@ -30,9 +28,6 @@
 
 #define _GC_OBJ_ZONE            gcvZONE_COMMAND
 
-#if gcdENABLE_FSCALE_VAL_ADJUST
-extern int thermal_hot;
-#endif
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
@@ -253,7 +248,7 @@ _ProcessHints(
         if (Command->hintArrayAllocated &&
             (Command->hintArraySize < CommandBuffer->hintArraySize))
         {
-            gcmkONERROR(gcmkOS_SAFE_FREE(Command->os, Command->hintArray));
+            gcmkONERROR(gcmkOS_SAFE_FREE(Command->os, gcmUINT64_TO_PTR(Command->hintArray)));
             Command->hintArraySize = gcvFALSE;
         }
 
@@ -267,18 +262,18 @@ _ProcessHints(
                 &pointer
                 ));
 
-            Command->hintArray          = pointer;
+            Command->hintArray          = gcmPTR_TO_UINT64(pointer);
             Command->hintArrayAllocated = gcvTRUE;
             Command->hintArraySize      = CommandBuffer->hintArraySize;
         }
 
-        hintArray = Command->hintArray;
+        hintArray = gcmUINT64_TO_PTR(Command->hintArray);
         copySize   = hintCount * gcmSIZEOF(gctUINT32);
 
         gcmkONERROR(gckOS_CopyFromUserData(
             Command->os,
             hintArray,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             copySize
             ));
     }
@@ -288,7 +283,7 @@ _ProcessHints(
 
         gcmkONERROR(gckOS_MapUserPointer(
             Command->os,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             CommandBuffer->hintArraySize,
             &pointer
             ));
@@ -314,7 +309,7 @@ OnError:
     {
         gcmkVERIFY_OK(gckOS_UnmapUserPointer(
             Command->os,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             CommandBuffer->hintArraySize,
             hintArray
             ));
@@ -351,6 +346,86 @@ OnError:
     return status;
 }
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+static void
+_DumpBuffer(
+    IN gctPOINTER Buffer,
+    IN gctUINT32 GpuAddress,
+    IN gctSIZE_T Size
+    )
+{
+    gctINT i, line, left;
+    gctUINT32_PTR data = Buffer;
+
+    line = Size / 32;
+    left = Size % 32;
+
+
+    for (i = 0; i < line; i++)
+    {
+        gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X %08X %08X ",
+                  GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]);
+        data += 8;
+        GpuAddress += 8 * 4;
+    }
+
+    switch(left)
+    {
+        case 28:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5], data[6]);
+            break;
+        case 24:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5]);
+            break;
+        case 20:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4]);
+            break;
+        case 16:
+            gcmkPRINT("%X : %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3]);
+            break;
+        case 12:
+            gcmkPRINT("%X : %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2]);
+            break;
+        case 8:
+            gcmkPRINT("%X : %08X %08X ",
+                      GpuAddress, data[0], data[1]);
+            break;
+        case 4:
+            gcmkPRINT("%X : %08X ",
+                      GpuAddress, data[0]);
+            break;
+        default:
+            break;
+    }
+}
+
+static void
+_DumpKernelCommandBuffer(
+    IN gckCOMMAND Command
+)
+{
+    gctINT i;
+    gctUINT32 physical;
+    gctPOINTER entry;
+
+    for (i = 0; i < gcdCOMMAND_QUEUES; i++)
+    {
+        entry = Command->queues[i].logical;
+
+        gckOS_GetPhysicalAddress(Command->os, entry, &physical);
+
+        gcmkPRINT("Kernel command buffer %d\n", i);
+
+        _DumpBuffer(entry, physical, Command->pageSize);
+    }
+}
+#endif
+
 /******************************************************************************\
 ****************************** gckCOMMAND API Code ******************************
 \******************************************************************************/
@@ -600,7 +675,7 @@ gckCOMMAND_Destroy(
     /* Free state array. */
     if (Command->hintArrayAllocated)
     {
-        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Command->os, Command->hintArray));
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Command->os, gcmUINT64_TO_PTR(Command->hintArray)));
         Command->hintArrayAllocated = gcvFALSE;
     }
 #endif
@@ -1083,24 +1158,6 @@ gckCOMMAND_Commit(
     /* Extract the gckHARDWARE and gckEVENT objects. */
     hardware = Command->kernel->hardware;
 
-#if gcdENABLE_FSCALE_VAL_ADJUST
-    if(hardware->core == gcvCORE_MAJOR){
-        static gctUINT orgFscale,minFscale,maxFscale;
-        static gctBOOL bAlreadyTooHot = gcvFALSE;
-        if((thermal_hot > 0) && (!bAlreadyTooHot)) {
-            gckHARDWARE_GetFscaleValue(hardware,&orgFscale,&minFscale, &maxFscale);
-            gckHARDWARE_SetFscaleValue(hardware, minFscale);
-            bAlreadyTooHot = gcvTRUE;
-            gckOS_Print("System is too hot. GPU3D will work at %d/64 clock.\n", minFscale);
-        } else if((!(thermal_hot > 0)) && bAlreadyTooHot) {
-            gckHARDWARE_SetFscaleValue(hardware, orgFscale);
-            gckOS_Print("Hot alarm is canceled. GPU3D clock will return to %d/64\n", orgFscale);
-            bAlreadyTooHot = gcvFALSE;
-        }
-
-    }
-#endif
-
     /* Check wehther we need to copy the structures or not. */
     gcmkONERROR(gckOS_QueryNeedCopy(Command->os, ProcessID, &needCopy));
 
@@ -1160,7 +1217,7 @@ gckCOMMAND_Commit(
 
     /* Compute the command buffer entry and the size. */
     commandBufferLogical
-        = (gctUINT8_PTR) commandBufferObject->logical
+        = (gctUINT8_PTR) gcmUINT64_TO_PTR(commandBufferObject->logical)
         +                commandBufferObject->startOffset;
 
     gcmkONERROR(gckOS_GetPhysicalAddress(
@@ -1833,7 +1890,7 @@ gckCOMMAND_Commit(
 
     /* Determine the location of the LINK command in the command buffer. */
     commandBufferLink
-        = (gctUINT8_PTR) commandBufferObject->logical
+        = (gctUINT8_PTR) gcmUINT64_TO_PTR(commandBufferObject->logical)
         +                commandBufferObject->offset;
 
     /* Generate a LINK from the end of the command buffer being scheduled
@@ -1971,11 +2028,11 @@ gckCOMMAND_Commit(
 
         /* Append event record to event queue. */
         gcmkONERROR(gckEVENT_AddList(
-            Command->kernel->eventObj, &eventRecord->iface, gcvKERNEL_PIXEL, gcvTRUE
+            Command->kernel->eventObj, &eventRecord->iface, gcvKERNEL_PIXEL, gcvTRUE, gcvFALSE
             ));
 
         /* Next record in the queue. */
-        nextEventRecord = eventRecord->next;
+        nextEventRecord = gcmUINT64_TO_PTR(eventRecord->next);
 
         if (!needCopy)
         {
@@ -1990,14 +2047,14 @@ gckCOMMAND_Commit(
         EventQueue = nextEventRecord;
     }
 
-#if gcdPOWER_MANAGEMENT
-    if (Command->kernel->eventObj->queueHead == gcvNULL)
+    if (Command->kernel->eventObj->queueHead == gcvNULL
+     && Command->kernel->hardware->powerManagement == gcvTRUE
+    )
     {
         /* Commit done event by which work thread knows all jobs done. */
         gcmkVERIFY_OK(
             gckEVENT_CommitDone(Command->kernel->eventObj, gcvKERNEL_PIXEL));
     }
-#endif
 
     /* Submit events. */
     status = gckEVENT_Submit(Command->kernel->eventObj, gcvTRUE, gcvFALSE);
@@ -2667,3 +2724,262 @@ OnError:
     gcmkFOOTER();
     return status;
 }
+
+#if gcdVIRTUAL_COMMAND_BUFFER
+/*******************************************************************************
+**
+**  gckCOMMAND_DumpExecutingBuffer
+**
+**  Dump the command buffer which GPU is executing.
+**
+**  INPUT:
+**
+**      gckCOMMAND Command
+**          Pointer to a gckCOMMAND object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckCOMMAND_DumpExecutingBuffer(
+    IN gckCOMMAND Command
+    )
+{
+    gceSTATUS status;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctUINT32 gpuAddress;
+    gctSIZE_T pageCount;
+    gctPOINTER entry;
+    gckOS os = Command->os;
+    gckKERNEL kernel = Command->kernel;
+#if gcdLINK_QUEUE_SIZE
+    gctINT pid;
+    gctINT i, rear;
+    gctUINT32 start, end;
+    gctUINT32 dumpFront, dumpRear;
+    gckLINKQUEUE queue = &kernel->hardware->linkQueue;
+    gckLINKQUEUE queueMirror;
+    gctUINT32 bytes;
+    gckLINKDATA linkData;
+#endif
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("**** COMMAND BUF DUMP ****\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkVERIFY_OK(gckOS_ReadRegisterEx(os, kernel->core, 0x664, &gpuAddress));
+
+    gcmkPRINT("DMA Address 0x%08X", gpuAddress);
+
+#if gcdLINK_QUEUE_SIZE
+    /* Duplicate queue because it will be changed.*/
+    gcmkONERROR(gckOS_AllocateMemory(os,
+                                     sizeof(struct _gckLINKQUEUE),
+                                     (gctPOINTER *)&queueMirror));
+
+    gcmkONERROR(gckOS_MemCopy(queueMirror,
+                              queue,
+                              sizeof(struct _gckLINKQUEUE)));
+
+    /* If kernel command buffer link to a context buffer, then link to a user command
+    ** buffer, the second link will be in queue first, so we must fix this.
+    **     In Queue:    C1 U1 U2 C2 U3 U4 U5 C3
+    **         Real: C1 X1 U1 C2 U2 U3 U4 C3 U5
+    ** Command buffer X1 which is after C1 is out of queue, so C1 is meaningless.
+    */
+    for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+
+        status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
+
+        if (gcmIS_ERROR(status))
+        {
+            /* Can't find it in virtual command buffer list, ignore it. */
+            continue;
+        }
+
+        if (buffer->kernelLogical)
+        {
+            /* It is a context buffer. */
+            if (i == 0)
+            {
+                /* The real command buffer is out, so clear this slot. */
+                linkData->start = 0;
+                linkData->end = 0;
+                linkData->pid = 0;
+            }
+            else
+            {
+                /* switch context buffer and command buffer. */
+                struct _gckLINKDATA tmp = *linkData;
+                gckLINKDATA linkDataPrevious;
+
+                gckLINKQUEUE_GetData(queueMirror, i - 1, &linkDataPrevious);
+                *linkData = *linkDataPrevious;
+                *linkDataPrevious = tmp;
+           }
+        }
+    }
+
+    /* Clear search result. */
+    dumpFront = dumpRear = gcvINFINITE;
+
+    gcmkPRINT("Link Stack:");
+
+    /* Search stuck address in link queue from rear. */
+    rear = gcdLINK_QUEUE_SIZE - 1;
+    for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
+
+        start = linkData->start;
+        end = linkData->end;
+        pid = linkData->pid;
+
+        if (gpuAddress >= start && gpuAddress < end)
+        {
+            /* Find latest matched command buffer. */
+            gcmkPRINT("  %d, [%08X - %08X]", pid, start, end);
+
+            /* Initiliaze dump information. */
+            dumpFront = dumpRear = rear;
+        }
+
+        /* Advance to previous one. */
+        rear--;
+
+        if (dumpFront != gcvINFINITE)
+        {
+            break;
+        }
+    }
+
+    if (dumpFront == gcvINFINITE)
+    {
+        /* Can't find matched record in link queue, dump kernel command buffer. */
+        _DumpKernelCommandBuffer(Command);
+
+        /* Free local copy. */
+        gcmkOS_SAFE_FREE(os, queueMirror);
+        return gcvSTATUS_OK;
+    }
+
+    /* Search the last context buffer linked. */
+    while (rear >= 0)
+    {
+        gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
+
+        gcmkPRINT("  %d, [%08X - %08X]",
+                  linkData->pid,
+                  linkData->start,
+                  linkData->end);
+
+        status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
+
+        if (gcmIS_SUCCESS(status) && buffer->kernelLogical)
+        {
+            /* Find a context buffer. */
+            dumpFront = rear;
+            break;
+        }
+
+        rear--;
+    }
+
+    /* Dump from last context buffer to last command buffer where hang happens. */
+    for (i = dumpFront; i <= dumpRear; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+
+        /* Get gpu address of this command buffer. */
+        gpuAddress = linkData->start;
+        bytes = linkData->end - gpuAddress;
+
+        /* Get the whole buffer. */
+        status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+
+        if (gcmIS_ERROR(status))
+        {
+            gcmkPRINT("Buffer [%08X - %08X] is lost",
+                      linkData->start,
+                      linkData->end);
+            continue;
+        }
+
+        /* Get kernel logical for dump. */
+        if (buffer->kernelLogical)
+        {
+            /* Get kernel logical directly if it is a context buffer. */
+            entry = buffer->kernelLogical;
+            gcmkPRINT("Context Buffer:");
+        }
+        else
+        {
+            /* Make it accessiable by kernel if it is a user command buffer. */
+            gcmkVERIFY_OK(
+                gckOS_CreateKernelVirtualMapping(buffer->physical,
+                                                 &pageCount,
+                                                 &entry));
+            gcmkPRINT("User Command Buffer:");
+        }
+
+        /* Dump from the entry. */
+        _DumpBuffer(entry + (gpuAddress - buffer->gpuAddress), gpuAddress, bytes);
+
+        /* Release kernel logical address if neccessary. */
+        if (!buffer->kernelLogical)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyKernelVirtualMapping(entry));
+        }
+    }
+
+    /* Free local copy. */
+    gcmkOS_SAFE_FREE(os, queueMirror);
+    return gcvSTATUS_OK;
+OnError:
+    return status;
+#else
+    /* Without link queue information, we don't know the entry of last command
+    ** buffer, just dump the page where GPU stuck. */
+    status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+
+    if (gcmIS_SUCCESS(status))
+    {
+        gcmkVERIFY_OK(
+            gckOS_CreateKernelVirtualMapping(buffer->physical, &pageCount, &entry));
+
+        if (entry)
+        {
+            gctUINT32 offset = gpuAddress - buffer->gpuAddress;
+            gctPOINTER entryDump = entry;
+
+            /* Dump one pages. */
+            gctUINT32 bytes = 4096;
+
+            /* Align to page. */
+            offset &= 0xfffff000;
+
+            /* Kernel address of page where stall point stay. */
+            entryDump += offset;
+
+            /* Align to page. */
+            gpuAddress &= 0xfffff000;
+
+            gcmkPRINT("User Command Buffer:\n");
+            _DumpBuffer(entryDump, gpuAddress, bytes);
+        }
+
+        gcmkVERIFY_OK(
+            gckOS_DestroyKernelVirtualMapping(entry));
+    }
+    else
+    {
+        _DumpKernelCommandBuffer(Command);
+    }
+
+    return gcvSTATUS_OK;
+#endif
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index e5b6592..76c1c10 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
@@ -630,7 +628,7 @@ _RemoveRecordFromProcesDB(
                 Command->kernel->kernel,
                 pid,
                 gcvDB_VIDEO_MEMORY,
-                freeVideoMemory->node));
+                gcmUINT64_TO_PTR(freeVideoMemory->node)));
 
             /* Advance to next task. */
             size -= sizeof(gcsTASK_FREE_VIDEO_MEMORY);
@@ -645,7 +643,7 @@ _RemoveRecordFromProcesDB(
                 Command->kernel->kernel,
                 pid,
                 gcvDB_VIDEO_MEMORY_LOCKED,
-                unlockVideoMemory->node));
+                gcmUINT64_TO_PTR(unlockVideoMemory->node)));
 
             /* Advance to next task. */
             size -= sizeof(gcsTASK_UNLOCK_VIDEO_MEMORY);
@@ -915,7 +913,7 @@ _HardwareToKernel(
     }
 
     offset = Address - nodePhysical;
-    *KernelPointer = (gctPOINTER)((gctUINT32)Node->VidMem.kernelVirtual + offset);
+    *KernelPointer = (gctPOINTER)((gctUINT8_PTR)Node->VidMem.kernelVirtual + offset);
 #else
     /* Determine the header offset within the pool it is allocated in. */
     offset = Address - memory->baseAddress;
@@ -963,7 +961,7 @@ _ConvertUserCommandBufferPointer(
         /* Translate the logical address to the kernel space. */
         gcmkERR_BREAK(_HardwareToKernel(
             Command->os,
-            mappedUserCommandBuffer->node,
+            gcmUINT64_TO_PTR(mappedUserCommandBuffer->node),
             headerAddress,
             (gctPOINTER *) KernelCommandBuffer
             ));
@@ -1137,7 +1135,7 @@ _AllocateCommandBuffer(
 
         /* Initialize the structure. */
         commandBuffer->completion    = gcvVACANT_BUFFER;
-        commandBuffer->node          = node;
+        commandBuffer->node          = gcmPTR_TO_UINT64(node);
         commandBuffer->address       = address + alignedHeaderSize;
         commandBuffer->bufferOffset  = alignedHeaderSize;
         commandBuffer->size          = requestedSize;
@@ -1192,7 +1190,7 @@ _FreeCommandBuffer(
     gceSTATUS status;
 
     /* Free the buffer. */
-    status = _FreeLinear(Kernel, CommandBuffer->node);
+    status = _FreeLinear(Kernel, gcmUINT64_TO_PTR(CommandBuffer->node));
 
     /* Return status. */
     return status;
@@ -1236,7 +1234,6 @@ _EventHandler_BusError(
     return gcvSTATUS_OK;
 }
 
-#if gcdPOWER_MANAGEMENT
 /******************************************************************************\
 ****************************** Power Stall Handler *******************************
 \******************************************************************************/
@@ -1252,7 +1249,6 @@ _EventHandler_PowerStall(
         Kernel->command->powerStallSignal,
         gcvTRUE);
 }
-#endif
 
 /******************************************************************************\
 ******************************** Task Routines *********************************
@@ -1649,7 +1645,7 @@ _TaskUnlockVideoMemory(
         /* Unlock video memory. */
         gcmkERR_BREAK(gckVIDMEM_Unlock(
             Command->kernel->kernel,
-            task->node,
+            gcmUINT64_TO_PTR(task->node),
             gcvSURF_TYPE_UNKNOWN,
             gcvNULL));
 
@@ -1680,7 +1676,7 @@ _TaskFreeVideoMemory(
             = (gcsTASK_FREE_VIDEO_MEMORY_PTR) TaskHeader->task;
 
         /* Free video memory. */
-        gcmkERR_BREAK(gckVIDMEM_Free(task->node));
+        gcmkERR_BREAK(gckVIDMEM_Free(gcmUINT64_TO_PTR(task->node)));
 
         /* Update the reference counter. */
         TaskHeader->container->referenceCount -= 1;
@@ -1967,15 +1963,12 @@ gcmDECLARE_INTERRUPT_HANDLER(COMMAND, 0)
                             );
                     }
                 }
-#if gcdPOWER_MANAGEMENT
                 else
                 {
-
                     status = gckVGHARDWARE_SetPowerManagementState(
                                 Kernel->command->hardware, gcvPOWER_IDLE_BROADCAST
                                 );
                 }
-#endif
 
                 /* Break out of the loop. */
                 break;
@@ -2850,7 +2843,7 @@ gckVGCOMMAND_Construct(
             _EventHandler_BusError
             ));
 
-#if gcdPOWER_MANAGEMENT
+
         command->powerStallInt = 30;
         /* Enable the interrupt. */
         gcmkERR_BREAK(gckVGINTERRUPT_Enable(
@@ -2858,7 +2851,6 @@ gckVGCOMMAND_Construct(
             &command->powerStallInt,
             _EventHandler_PowerStall
             ));
-#endif
 
         /***********************************************************************
         ** Task management initialization.
@@ -3421,7 +3413,6 @@ gckVGCOMMAND_Commit(
             gcvINFINITE
             ));
 
-#if gcdPOWER_MANAGEMENT
         status = gckVGHARDWARE_SetPowerManagementState(
             Command->hardware, gcvPOWER_ON_AUTO);
 
@@ -3449,7 +3440,7 @@ gckVGCOMMAND_Commit(
 
             break;
         }
-#endif
+
         gcmkERR_BREAK(_FlushMMU(Command));
 
         do
@@ -3678,10 +3669,9 @@ gckVGCOMMAND_Commit(
         }
         while (gcvFALSE);
 
-#if gcdPOWER_MANAGEMENT
         gcmkVERIFY_OK(gckOS_ReleaseSemaphore(
             Command->os, Command->powerSemaphore));
-#endif
+
         /* Release the mutex. */
         gcmkCHECK_STATUS(gckOS_ReleaseMutex(
             Command->os,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
index 9dbb9d3..673d4f7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_DATABASE
@@ -28,6 +26,9 @@
 /*******************************************************************************
 ***** Private fuctions ********************************************************/
 
+#define _GetSlot(database, x) \
+    (gctUINT32)(((gcmPTR_TO_UINT64(x) >> 7) % gcmCOUNTOF(database->list)))
+
 /*******************************************************************************
 **  gckKERNEL_NewDatabase
 **
@@ -58,6 +59,7 @@ gckKERNEL_NewDatabase(
     gcsDATABASE_PTR database;
     gctBOOL acquired = gcvFALSE;
     gctSIZE_T slot;
+    gcsDATABASE_PTR existingDatabase;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -65,6 +67,21 @@ gckKERNEL_NewDatabase(
     gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
+    /* Compute the hash for the database. */
+    slot = ProcessID % gcmCOUNTOF(Kernel->db->db);
+
+    /* Walk the hash list. */
+    for (existingDatabase = Kernel->db->db[slot];
+         existingDatabase != gcvNULL;
+         existingDatabase = existingDatabase->next)
+    {
+        if (existingDatabase->processID == ProcessID)
+        {
+            /* One process can't be added twice. */
+            gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+        }
+    }
+
     if (Kernel->db->freeDatabase != gcvNULL)
     {
         /* Allocate a database from the free list. */
@@ -83,9 +100,6 @@ gckKERNEL_NewDatabase(
         database = pointer;
     }
 
-    /* Compute the hash for the database. */
-    slot = ProcessID % gcmCOUNTOF(Kernel->db->db);
-
     /* Insert the database into the hash. */
     database->next   = Kernel->db->db[slot];
     Kernel->db->db[slot] = database;
@@ -352,6 +366,7 @@ static gceSTATUS
 gckKERNEL_NewRecord(
     IN gckKERNEL Kernel,
     IN gcsDATABASE_PTR Database,
+    IN gctUINT32 Slot,
     OUT gcsDATABASE_RECORD_PTR * Record
     )
 {
@@ -385,8 +400,8 @@ gckKERNEL_NewRecord(
     }
 
     /* Insert the record in the database. */
-    record->next   = Database->list;
-    Database->list = record;
+    record->next         = Database->list[Slot];
+    Database->list[Slot] = record;
 
     /* Release the database mutex. */
     gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
@@ -451,6 +466,7 @@ gckKERNEL_DeleteRecord(
     gceSTATUS status;
     gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record, previous;
+    gctUINT32 slot = _GetSlot(Database, Data);
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x Type=%d Data=0x%x",
                    Kernel, Database, Type, Data);
@@ -460,8 +476,9 @@ gckKERNEL_DeleteRecord(
         gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
+
     /* Scan the database for this record. */
-    for (record = Database->list, previous = gcvNULL;
+    for (record = Database->list[slot], previous = gcvNULL;
          record != gcvNULL;
          record = record->next
     )
@@ -492,7 +509,7 @@ gckKERNEL_DeleteRecord(
     /* Remove record from database. */
     if (previous == gcvNULL)
     {
-        Database->list = record->next;
+        Database->list[slot] = record->next;
     }
     else
     {
@@ -559,6 +576,7 @@ gckKERNEL_FindRecord(
     gceSTATUS status;
     gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record;
+    gctUINT32 slot = _GetSlot(Database, Data);
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x Type=%d Data=0x%x",
                    Kernel, Database, Type, Data);
@@ -569,7 +587,7 @@ gckKERNEL_FindRecord(
     acquired = gcvTRUE;
 
     /* Scan the database for this record. */
-    for (record = Database->list;
+    for (record = Database->list[slot];
          record != gcvNULL;
          record = record->next
     )
@@ -644,6 +662,7 @@ gckKERNEL_CreateProcessDB(
 {
     gceSTATUS status;
     gcsDATABASE_PTR database = gcvNULL;
+    gctUINT32 i;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -670,7 +689,11 @@ gckKERNEL_CreateProcessDB(
     database->mapUserMemory.bytes      = 0;
     database->mapUserMemory.maxBytes   = 0;
     database->mapUserMemory.totalBytes = 0;
-    database->list                  = gcvNULL;
+
+    for (i = 0; i < gcmCOUNTOF(database->list); i++)
+    {
+        database->list[i]              = gcvNULL;
+    }
 
 #if gcdSECURE_USER
     {
@@ -850,7 +873,7 @@ gckKERNEL_AddProcessDB(
     gcmkONERROR(gckKERNEL_FindDatabase(Kernel, ProcessID, gcvFALSE, &database));
 
     /* Create a new record in the database. */
-    gcmkONERROR(gckKERNEL_NewRecord(Kernel, database, &record));
+    gcmkONERROR(gckKERNEL_NewRecord(Kernel, database, _GetSlot(database, Pointer), &record));
 
     /* Initialize the record. */
     record->kernel   = Kernel;
@@ -1085,6 +1108,10 @@ gckKERNEL_DestroyProcessDB(
     gcsDATABASE_PTR database;
     gcsDATABASE_RECORD_PTR record, next;
     gctBOOL asynchronous;
+    gctPHYS_ADDR physical;
+    gcuVIDMEM_NODE_PTR node;
+    gckKERNEL kernel = Kernel;
+    gctUINT32 i;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -1125,8 +1152,11 @@ gckKERNEL_DestroyProcessDB(
                        ProcessID);
     }
 
+    for(i = 0; i < gcmCOUNTOF(database->list); i++)
+    {
+
     /* Walk all records. */
-    for (record = database->list; record != gcvNULL; record = next)
+    for (record = database->list[i]; record != gcvNULL; record = next)
     {
         /* Next next record. */
         next = record->next;
@@ -1136,7 +1166,7 @@ gckKERNEL_DestroyProcessDB(
         {
         case gcvDB_VIDEO_MEMORY:
             /* Free the video memory. */
-            status = gckVIDMEM_Free(record->data);
+            status = gckVIDMEM_Free(gcmUINT64_TO_PTR(record->data));
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY 0x%x (status=%d)",
@@ -1144,36 +1174,56 @@ gckKERNEL_DestroyProcessDB(
             break;
 
         case gcvDB_NON_PAGED:
+            physical = gcmNAME_TO_PTR(record->physical);
             /* Unmap user logical memory first. */
             status = gckOS_UnmapUserLogical(Kernel->os,
-                                            record->physical,
+                                            physical,
                                             record->bytes,
                                             record->data);
 
             /* Free the non paged memory. */
             status = gckOS_FreeNonPagedMemory(Kernel->os,
                                               record->bytes,
-                                              record->physical,
+                                              physical,
                                               record->data);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: NON_PAGED 0x%x, bytes=%lu (status=%d)",
                            record->data, record->bytes, status);
             break;
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+        case gcvDB_COMMAND_BUFFER:
+            /* Free the command buffer. */
+            status = gckEVENT_DestroyVirtualCommandBuffer(record->kernel->eventObj,
+                                                          record->bytes,
+                                                          gcmNAME_TO_PTR(record->physical),
+                                                          record->data,
+                                                          gcvKERNEL_PIXEL);
+            gcmRELEASE_NAME(record->physical);
+
+            gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
+                           "DB: COMMAND_BUFFER 0x%x, bytes=%lu (status=%d)",
+                           record->data, record->bytes, status);
+            break;
+#endif
+
         case gcvDB_CONTIGUOUS:
+            physical = gcmNAME_TO_PTR(record->physical);
             /* Unmap user logical memory first. */
             status = gckOS_UnmapUserLogical(Kernel->os,
-                                            record->physical,
+                                            physical,
                                             record->bytes,
                                             record->data);
 
             /* Free the contiguous memory. */
             status = gckEVENT_FreeContiguousMemory(Kernel->eventObj,
                                                    record->bytes,
-                                                   record->physical,
+                                                   physical,
                                                    record->data,
                                                    gcvKERNEL_PIXEL);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: CONTIGUOUS 0x%x bytes=%lu (status=%d)",
@@ -1191,13 +1241,14 @@ gckKERNEL_DestroyProcessDB(
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: SIGNAL %d (status=%d)",
-                           (gctINT) record->data, status);
+                           (gctINT)(gctUINTPTR_T)record->data, status);
             break;
 
         case gcvDB_VIDEO_MEMORY_LOCKED:
+            node = gcmUINT64_TO_PTR(record->data);
             /* Unlock what we still locked */
             status = gckVIDMEM_Unlock(record->kernel,
-                                      record->data,
+                                      node,
                                       gcvSURF_TYPE_UNKNOWN,
                                       &asynchronous);
 
@@ -1205,19 +1256,20 @@ gckKERNEL_DestroyProcessDB(
             {
                 /* TODO: we maybe need to schedule a event here */
                 status = gckVIDMEM_Unlock(record->kernel,
-                                          record->data,
+                                          node,
                                           gcvSURF_TYPE_UNKNOWN,
                                           gcvNULL);
             }
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY_LOCKED 0x%x (status=%d)",
-                           record->data, status);
+                           node, status);
             break;
 
         case gcvDB_CONTEXT:
             /* TODO: Free the context */
-            status = gckCOMMAND_Detach(Kernel->command, record->data);
+            status = gckCOMMAND_Detach(Kernel->command, gcmNAME_TO_PTR(record->data));
+            gcmRELEASE_NAME(record->data);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: CONTEXT 0x%x (status=%d)",
@@ -1242,17 +1294,18 @@ gckKERNEL_DestroyProcessDB(
                                            Kernel->core,
                                            record->physical,
                                            record->bytes,
-                                           record->data,
+                                           gcmNAME_TO_PTR(record->data),
                                            0);
+            gcmRELEASE_NAME(record->data);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: MAP USER MEMORY %d (status=%d)",
                            gcmPTR2INT(record->data), status);
             break;
 
-                    case gcvDB_SHARED_INFO:
-                        status = gckOS_FreeMemory(Kernel->os, record->physical);
-                        break;
+        case gcvDB_SHARED_INFO:
+            status = gckOS_FreeMemory(Kernel->os, record->physical);
+            break;
 
         default:
             gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DATABASE,
@@ -1269,6 +1322,8 @@ gckKERNEL_DestroyProcessDB(
                                            gcvNULL));
     }
 
+    }
+
     /* Delete the database. */
     gcmkONERROR(gckKERNEL_DeleteDatabase(Kernel, database));
 
@@ -1335,21 +1390,21 @@ gckKERNEL_QueryProcessDB(
     switch (Type)
     {
     case gcvDB_VIDEO_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->vidMem,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_NON_PAGED:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->nonPaged,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_CONTIGUOUS:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->contiguous,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_IDLE:
@@ -1358,15 +1413,15 @@ gckKERNEL_QueryProcessDB(
         break;
 
     case gcvDB_MAP_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->mapMemory,
-                                  gcmSIZEOF(database->mapMemory)));
+                                  gcmSIZEOF(database->mapMemory));
         break;
 
     case gcvDB_MAP_USER_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->mapUserMemory,
-                                  gcmSIZEOF(database->mapUserMemory)));
+                                  gcmSIZEOF(database->mapUserMemory));
         break;
 
     default:
@@ -1434,3 +1489,48 @@ OnError:
     return status;
 }
 #endif
+
+gceSTATUS
+gckKERNEL_DumpProcessDB(
+    IN gckKERNEL Kernel
+    )
+{
+    gcsDATABASE_PTR database;
+    gctINT i, pid;
+    gctUINT8 name[24];
+
+    gcmkHEADER_ARG("Kernel=0x%x", Kernel);
+
+    /* Acquire the database mutex. */
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("***  PROCESS DB DUMP   ***\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkPRINT_N(8, "%-8s%s\n", "PID", "NAME");
+    /* Walk the databases. */
+    for (i = 0; i < gcmCOUNTOF(Kernel->db->db); ++i)
+    {
+        for (database = Kernel->db->db[i];
+             database != gcvNULL;
+             database = database->next)
+        {
+            pid = database->processID;
+
+            gcmkVERIFY_OK(gckOS_ZeroMemory(name, gcmSIZEOF(name)));
+
+            gcmkVERIFY_OK(gckOS_GetProcessNameByPid(pid, gcmSIZEOF(name), name));
+
+            gcmkPRINT_N(8, "%-8d%s\n", pid, name);
+        }
+    }
+
+    /* Release the database mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
index 00decd9..a689bc3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include <gc_hal_kernel_debug.h>
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index d38312d..217f7f1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include "gc_hal_kernel_buffer.h"
 
@@ -286,6 +284,21 @@ __RemoveRecordFromProcessDB(
 
     while (Record != gcvNULL)
     {
+        if (Record->info.command == gcvHAL_SIGNAL)
+        {
+            /* TODO: Find a better place to bind signal to hardware.*/
+            gcmkVERIFY_OK(gckOS_SignalSetHardware(Event->os,
+                        gcmUINT64_TO_PTR(Record->info.u.Signal.signal),
+                        Event->kernel->hardware));
+        }
+
+        if (Record->fromKernel)
+        {
+            /* No need to check db if event is from kernel. */
+            Record = Record->next;
+            continue;
+        }
+
         switch (Record->info.command)
         {
         case gcvHAL_FREE_NON_PAGED_MEMORY:
@@ -293,7 +306,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_NON_PAGED,
-                Record->info.u.FreeNonPagedMemory.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeNonPagedMemory.logical)));
             break;
 
         case gcvHAL_FREE_CONTIGUOUS_MEMORY:
@@ -301,7 +314,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_CONTIGUOUS,
-                Record->info.u.FreeContiguousMemory.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeContiguousMemory.logical)));
             break;
 
         case gcvHAL_FREE_VIDEO_MEMORY:
@@ -309,7 +322,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_VIDEO_MEMORY,
-                Record->info.u.FreeVideoMemory.node));
+                gcmUINT64_TO_PTR(Record->info.u.FreeVideoMemory.node)));
             break;
 
         case gcvHAL_UNLOCK_VIDEO_MEMORY:
@@ -317,7 +330,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_VIDEO_MEMORY_LOCKED,
-                Record->info.u.UnlockVideoMemory.node));
+                gcmUINT64_TO_PTR(Record->info.u.UnlockVideoMemory.node)));
             break;
 
         case gcvHAL_UNMAP_USER_MEMORY:
@@ -325,13 +338,15 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_MAP_USER_MEMORY,
-                Record->info.u.UnmapUserMemory.info));
+                gcmINT2PTR(Record->info.u.UnmapUserMemory.info)));
             break;
 
-        case gcvHAL_SIGNAL:
-            gcmkVERIFY_OK(gckOS_SignalSetHardware(Event->os,
-                Record->info.u.Signal.signal,
-                Event->kernel->hardware));
+        case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
+            gcmkVERIFY_OK(gckKERNEL_RemoveProcessDB(
+                Event->kernel,
+                Record->processID,
+                gcvDB_COMMAND_BUFFER,
+                gcmUINT64_TO_PTR(Record->info.u.FreeVirtualCommandBuffer.logical)));
             break;
 
         default:
@@ -534,7 +549,7 @@ gckEVENT_Destroy(
     if (Event->submitTimer != gcvNULL)
     {
         gcmkVERIFY_OK(gckOS_StopTimer(Event->os, Event->submitTimer));
-        gcmkVERIFY_OK(gckOS_DestoryTimer(Event->os, Event->submitTimer));
+        gcmkVERIFY_OK(gckOS_DestroyTimer(Event->os, Event->submitTimer));
     }
 
     /* Delete the queue mutex. */
@@ -883,13 +898,15 @@ gckEVENT_AddList(
     IN gckEVENT Event,
     IN gcsHAL_INTERFACE_PTR Interface,
     IN gceKERNEL_WHERE FromWhere,
-    IN gctBOOL AllocateAllowed
+    IN gctBOOL AllocateAllowed,
+    IN gctBOOL FromKernel
     )
 {
     gceSTATUS status;
     gctBOOL acquired = gcvFALSE;
     gcsEVENT_PTR record = gcvNULL;
     gcsEVENT_QUEUE_PTR queue;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Interface=0x%x",
                    Event, Interface);
@@ -913,6 +930,7 @@ gckEVENT_AddList(
         || (Interface->command == gcvHAL_UNMAP_USER_MEMORY)
         || (Interface->command == gcvHAL_TIMESTAMP)
         || (Interface->command == gcvHAL_COMMIT_DONE)
+        || (Interface->command == gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER)
         );
 
     /* Validate the source. */
@@ -928,8 +946,11 @@ gckEVENT_AddList(
     /* Termninate the record. */
     record->next = gcvNULL;
 
+    /* Record the committer. */
+    record->fromKernel = FromKernel;
+
     /* Copy the event interface into the record. */
-    gcmkONERROR(gckOS_MemCopy(&record->info, Interface, gcmSIZEOF(record->info)));
+    gckOS_MemCopy(&record->info, Interface, gcmSIZEOF(record->info));
 
     /* Get process ID. */
     gcmkONERROR(gckOS_GetProcessID(&record->processID));
@@ -938,6 +959,8 @@ gckEVENT_AddList(
     record->kernel = Event->kernel;
 #endif
 
+    gcmkONERROR(__RemoveRecordFromProcessDB(Event, record));
+
     /* Acquire the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Event->os, Event->eventListMutex, gcvINFINITE));
     acquired = gcvTRUE;
@@ -991,16 +1014,16 @@ gckEVENT_AddList(
     case gcvHAL_FREE_NON_PAGED_MEMORY:
         gcmkONERROR(gckOS_UnmapUserLogical(
                         Event->os,
-                        Interface->u.FreeNonPagedMemory.physical,
-                        Interface->u.FreeNonPagedMemory.bytes,
-                        Interface->u.FreeNonPagedMemory.logical));
+                        gcmNAME_TO_PTR(Interface->u.FreeNonPagedMemory.physical),
+                        (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
+                        gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
         break;
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
         gcmkONERROR(gckOS_UnmapUserLogical(
                         Event->os,
-                        Interface->u.FreeContiguousMemory.physical,
-                        Interface->u.FreeContiguousMemory.bytes,
-                        Interface->u.FreeContiguousMemory.logical));
+                        gcmNAME_TO_PTR(Interface->u.FreeContiguousMemory.physical),
+                        (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes,
+                        gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical)));
         break;
     default:
         break;
@@ -1076,12 +1099,12 @@ gckEVENT_Unlock(
 
     /* Mark the event as an unlock. */
     iface.command                           = gcvHAL_UNLOCK_VIDEO_MEMORY;
-    iface.u.UnlockVideoMemory.node          = Node;
+    iface.u.UnlockVideoMemory.node          = gcmPTR_TO_UINT64(Node);
     iface.u.UnlockVideoMemory.type          = Type;
     iface.u.UnlockVideoMemory.asynchroneous = 0;
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1133,10 +1156,10 @@ gckEVENT_FreeVideoMemory(
 
     /* Create an event. */
     iface.command = gcvHAL_FREE_VIDEO_MEMORY;
-    iface.u.FreeVideoMemory.node = VideoMemory;
+    iface.u.FreeVideoMemory.node = gcmPTR_TO_UINT64(VideoMemory);
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1182,6 +1205,7 @@ gckEVENT_FreeNonPagedMemory(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1196,11 +1220,53 @@ gckEVENT_FreeNonPagedMemory(
     /* Create an event. */
     iface.command = gcvHAL_FREE_NON_PAGED_MEMORY;
     iface.u.FreeNonPagedMemory.bytes    = Bytes;
-    iface.u.FreeNonPagedMemory.physical = Physical;
-    iface.u.FreeNonPagedMemory.logical  = Logical;
+    iface.u.FreeNonPagedMemory.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeNonPagedMemory.logical  = gcmPTR_TO_UINT64(Logical);
+
+    /* Append it to the queue. */
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckEVENT_DestroyVirtualCommandBuffer(
+    IN gckEVENT Event,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gceKERNEL_WHERE FromWhere
+    )
+{
+    gceSTATUS status;
+    gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
+
+    gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
+                   "FromWhere=%d",
+                   Event, Bytes, Physical, Logical, FromWhere);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+
+    /* Create an event. */
+    iface.command = gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER;
+    iface.u.FreeVirtualCommandBuffer.bytes    = Bytes;
+    iface.u.FreeVirtualCommandBuffer.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeVirtualCommandBuffer.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1246,6 +1312,7 @@ gckEVENT_FreeContiguousMemory(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1260,11 +1327,11 @@ gckEVENT_FreeContiguousMemory(
     /* Create an event. */
     iface.command = gcvHAL_FREE_CONTIGUOUS_MEMORY;
     iface.u.FreeContiguousMemory.bytes    = Bytes;
-    iface.u.FreeContiguousMemory.physical = Physical;
-    iface.u.FreeContiguousMemory.logical  = Logical;
+    iface.u.FreeContiguousMemory.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeContiguousMemory.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1316,16 +1383,16 @@ gckEVENT_Signal(
 
     /* Mark the event as a signal. */
     iface.command            = gcvHAL_SIGNAL;
-    iface.u.Signal.signal    = Signal;
+    iface.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
 #ifdef __QNXNTO__
     iface.u.Signal.coid      = 0;
     iface.u.Signal.rcvid     = 0;
 #endif
-    iface.u.Signal.auxSignal = gcvNULL;
-    iface.u.Signal.process   = gcvNULL;
+    iface.u.Signal.auxSignal = 0;
+    iface.u.Signal.process   = 0;
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1372,7 +1439,7 @@ gckEVENT_CommitDone(
     iface.command = gcvHAL_COMMIT_DONE;
 
     /* Append it to the queue. */
-    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -1474,9 +1541,6 @@ gckEVENT_Submit(
             gcmkONERROR(gckOS_ReleaseMutex(Event->os, Event->eventListMutex));
             acquired = gcvFALSE;
 
-            gcmkONERROR(__RemoveRecordFromProcessDB(Event,
-                Event->queues[id].head));
-
 #if gcdNULL_DRIVER
             /* Notify immediately on infinite hardware. */
             gcmkONERROR(gckEVENT_Interrupt(Event, 1 << id));
@@ -1624,10 +1688,10 @@ gckEVENT_Commit(
 
         /* Append event record to event queue. */
         gcmkONERROR(
-            gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL, gcvTRUE));
+            gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL, gcvTRUE, gcvFALSE));
 
         /* Next record in the queue. */
-        next = record->next;
+        next = gcmUINT64_TO_PTR(record->next);
 
         if (!needCopy)
         {
@@ -1720,12 +1784,12 @@ gckEVENT_Compose(
     tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
     tempRecord->info.u.Signal.signal    = Info->signal;
-    tempRecord->info.u.Signal.auxSignal = gcvNULL;
+    tempRecord->info.u.Signal.auxSignal = 0;
     tempRecord->next = gcvNULL;
     tempRecord->processID = processID;
 
     /* Allocate another record for user signal #1. */
-    if (Info->userSignal1 != gcvNULL)
+    if (gcmUINT64_TO_PTR(Info->userSignal1) != gcvNULL)
     {
         /* Allocate a record. */
         gcmkONERROR(gckEVENT_AllocateRecord(Event, gcvTRUE, &tempRecord));
@@ -1740,13 +1804,13 @@ gckEVENT_Compose(
         tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
         tempRecord->info.u.Signal.signal    = Info->userSignal1;
-        tempRecord->info.u.Signal.auxSignal = gcvNULL;
+        tempRecord->info.u.Signal.auxSignal = 0;
         tempRecord->next = gcvNULL;
         tempRecord->processID = processID;
     }
 
     /* Allocate another record for user signal #2. */
-    if (Info->userSignal2 != gcvNULL)
+    if (gcmUINT64_TO_PTR(Info->userSignal2) != gcvNULL)
     {
         /* Allocate a record. */
         gcmkONERROR(gckEVENT_AllocateRecord(Event, gcvTRUE, &tempRecord));
@@ -1761,7 +1825,7 @@ gckEVENT_Compose(
         tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
         tempRecord->info.u.Signal.signal    = Info->userSignal2;
-        tempRecord->info.u.Signal.auxSignal = gcvNULL;
+        tempRecord->info.u.Signal.auxSignal = 0;
         tempRecord->next = gcvNULL;
         tempRecord->processID = processID;
     }
@@ -1772,7 +1836,7 @@ gckEVENT_Compose(
     /* Start composition. */
     gcmkONERROR(gckHARDWARE_Compose(
         Event->kernel->hardware, processID,
-        Info->physical, Info->logical, Info->offset, Info->size, id
+        gcmUINT64_TO_PTR(Info->physical), gcmUINT64_TO_PTR(Info->logical), Info->offset, Info->size, id
         ));
 
     /* Success. */
@@ -1855,10 +1919,11 @@ gckEVENT_Notify(
     gcsEVENT_QUEUE * queue;
     gctUINT mask = 0;
     gctBOOL acquired = gcvFALSE;
-#ifdef __QNXNTO__
     gcuVIDMEM_NODE_PTR node;
-#endif
+    gctPOINTER info;
+    gctSIGNAL signal;
     gctUINT pending;
+    gckKERNEL kernel = Event->kernel;
 #if !gcdSMP
     gctBOOL suspended = gcvFALSE;
 #endif
@@ -2119,14 +2184,14 @@ gckEVENT_Notify(
             case gcvHAL_FREE_NON_PAGED_MEMORY:
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_FREE_NON_PAGED_MEMORY: 0x%x",
-                               record->info.u.FreeNonPagedMemory.physical);
+                               gcmNAME_TO_PTR(record->info.u.FreeNonPagedMemory.physical));
 
                 /* Free non-paged memory. */
                 status = gckOS_FreeNonPagedMemory(
                             Event->os,
-                            record->info.u.FreeNonPagedMemory.bytes,
-                            record->info.u.FreeNonPagedMemory.physical,
-                            record->info.u.FreeNonPagedMemory.logical);
+                            (gctSIZE_T) record->info.u.FreeNonPagedMemory.bytes,
+                            gcmNAME_TO_PTR(record->info.u.FreeNonPagedMemory.physical),
+                            gcmUINT64_TO_PTR(record->info.u.FreeNonPagedMemory.logical));
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -2134,24 +2199,25 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        record->event.u.FreeNonPagedMemory.logical,
-                        record->event.u.FreeNonPagedMemory.bytes));
+                        gcmUINT64_TO_PTR(record->record.u.FreeNonPagedMemory.logical),
+                        (gctSIZE_T) record->record.u.FreeNonPagedMemory.bytes));
 #endif
                 }
+                gcmRELEASE_NAME(record->info.u.FreeNonPagedMemory.physical);
                 break;
 
             case gcvHAL_FREE_CONTIGUOUS_MEMORY:
                 gcmkTRACE_ZONE(
                     gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                     "gcvHAL_FREE_CONTIGUOUS_MEMORY: 0x%x",
-                    record->info.u.FreeContiguousMemory.physical);
+                    gcmNAME_TO_PTR(record->info.u.FreeContiguousMemory.physical));
 
                 /* Unmap the user memory. */
                 status = gckOS_FreeContiguous(
                             Event->os,
-                            record->info.u.FreeContiguousMemory.physical,
-                            record->info.u.FreeContiguousMemory.logical,
-                            record->info.u.FreeContiguousMemory.bytes);
+                            gcmNAME_TO_PTR(record->info.u.FreeContiguousMemory.physical),
+                            gcmUINT64_TO_PTR(record->info.u.FreeContiguousMemory.logical),
+                            (gctSIZE_T) record->info.u.FreeContiguousMemory.bytes);
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -2159,19 +2225,19 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        event->event.u.FreeContiguousMemory.logical,
-                        event->event.u.FreeContiguousMemory.bytes));
+                        gcmUINT64_TO_PTR(record->record.u.FreeContiguousMemory.logical),
+                        (gctSIZE_T) record->record.u.FreeContiguousMemory.bytes));
 #endif
                 }
+                gcmRELEASE_NAME(record->info.u.FreeContiguousMemory.physical);
                 break;
 
             case gcvHAL_FREE_VIDEO_MEMORY:
+                node = gcmUINT64_TO_PTR(record->info.u.FreeVideoMemory.node);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_FREE_VIDEO_MEMORY: 0x%x",
-                               record->info.u.FreeVideoMemory.node);
-
+                               node);
 #ifdef __QNXNTO__
-                node = record->info.u.FreeVideoMemory.node;
 #if gcdUSE_VIDMEM_PER_PID
                 /* Check if the VidMem object still exists. */
                 if (gckKERNEL_GetVideoMemoryPoolPid(record->kernel,
@@ -2200,7 +2266,7 @@ gckEVENT_Notify(
 
                 /* Free video memory. */
                 status =
-                    gckVIDMEM_Free(record->info.u.FreeVideoMemory.node);
+                    gckVIDMEM_Free(node);
 
                 break;
 
@@ -2235,13 +2301,14 @@ gckEVENT_Notify(
                 break;
 
             case gcvHAL_UNLOCK_VIDEO_MEMORY:
+                node = gcmUINT64_TO_PTR(record->info.u.UnlockVideoMemory.node);
+
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_UNLOCK_VIDEO_MEMORY: 0x%x",
-                               record->info.u.UnlockVideoMemory.node);
+                               node);
 
                 /* Save node information before it disappears. */
 #if gcdSECURE_USER
-                node = event->event.u.UnlockVideoMemory.node;
                 if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
                 {
                     logical = gcvNULL;
@@ -2257,7 +2324,7 @@ gckEVENT_Notify(
                 /* Unlock. */
                 status = gckVIDMEM_Unlock(
                     Event->kernel,
-                    record->info.u.UnlockVideoMemory.node,
+                    node,
                     record->info.u.UnlockVideoMemory.type,
                     gcvNULL);
 
@@ -2274,9 +2341,10 @@ gckEVENT_Notify(
                 break;
 
             case gcvHAL_SIGNAL:
+                signal = gcmUINT64_TO_PTR(record->info.u.Signal.signal);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_SIGNAL: 0x%x",
-                               record->info.u.Signal.signal);
+                               signal);
 
 #ifdef __QNXNTO__
                 if ((record->info.u.Signal.coid == 0)
@@ -2286,7 +2354,7 @@ gckEVENT_Notify(
                     /* Kernel signal. */
                     gcmkERR_BREAK(
                         gckOS_Signal(Event->os,
-                                     record->info.u.Signal.signal,
+                                     signal,
                                      gcvTRUE));
                 }
                 else
@@ -2294,18 +2362,18 @@ gckEVENT_Notify(
                     /* User signal. */
                     gcmkERR_BREAK(
                         gckOS_UserSignal(Event->os,
-                                         record->info.u.Signal.signal,
+                                         signal,
                                          record->info.u.Signal.rcvid,
                                          record->info.u.Signal.coid));
                 }
 #else
                 /* Set signal. */
-                if (record->info.u.Signal.process == gcvNULL)
+                if (gcmUINT64_TO_PTR(record->info.u.Signal.process) == gcvNULL)
                 {
                     /* Kernel signal. */
                     gcmkERR_BREAK(
                         gckOS_Signal(Event->os,
-                                     record->info.u.Signal.signal,
+                                     signal,
                                      gcvTRUE));
                 }
                 else
@@ -2313,26 +2381,27 @@ gckEVENT_Notify(
                     /* User signal. */
                     gcmkERR_BREAK(
                         gckOS_UserSignal(Event->os,
-                                         record->info.u.Signal.signal,
-                                         record->info.u.Signal.process));
+                                         signal,
+                                         gcmUINT64_TO_PTR(record->info.u.Signal.process)));
                 }
 
-                gcmkASSERT(record->info.u.Signal.auxSignal == gcvNULL);
+                gcmkASSERT(record->info.u.Signal.auxSignal == 0);
 #endif
                 break;
 
             case gcvHAL_UNMAP_USER_MEMORY:
+                info = gcmNAME_TO_PTR(record->info.u.UnmapUserMemory.info);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_UNMAP_USER_MEMORY: 0x%x",
-                               record->info.u.UnmapUserMemory.info);
+                               info);
 
                 /* Unmap the user memory. */
                 status = gckOS_UnmapUserMemory(
                     Event->os,
                     Event->kernel->core,
-                    record->info.u.UnmapUserMemory.memory,
-                    record->info.u.UnmapUserMemory.size,
-                    record->info.u.UnmapUserMemory.info,
+                    gcmUINT64_TO_PTR(record->info.u.UnmapUserMemory.memory),
+                    (gctSIZE_T) record->info.u.UnmapUserMemory.size,
+                    info,
                     record->info.u.UnmapUserMemory.address);
 
 #if gcdSECURE_USER
@@ -2341,10 +2410,11 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        event->event.u.UnmapUserMemory.memory,
-                        event->event.u.UnmapUserMemory.size));
+                        gcmUINT64_TO_PTR(record->info.u.UnmapUserMemory.memory),
+                        (gctSIZE_T) record->info.u.UnmapUserMemory.size));
                 }
 #endif
+                gcmRELEASE_NAME(record->info.u.UnmapUserMemory.info);
                 break;
 
             case gcvHAL_TIMESTAMP:
@@ -2381,6 +2451,18 @@ gckEVENT_Notify(
                 }
                 break;
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+             case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
+                 gcmkVERIFY_OK(
+                     gckKERNEL_DestroyVirtualCommandBuffer(Event->kernel,
+                         (gctSIZE_T) record->info.u.FreeVirtualCommandBuffer.bytes,
+                         gcmNAME_TO_PTR(record->info.u.FreeVirtualCommandBuffer.physical),
+                         gcmUINT64_TO_PTR(record->info.u.FreeVirtualCommandBuffer.logical)
+                         ));
+                 gcmRELEASE_NAME(record->info.u.FreeVirtualCommandBuffer.physical);
+                 break;
+#endif
+
             case gcvHAL_COMMIT_DONE:
                 break;
 
@@ -2627,13 +2709,13 @@ gckEVENT_Stop(
     record->next = gcvNULL;
     record->processID               = ProcessID;
     record->info.command            = gcvHAL_SIGNAL;
-    record->info.u.Signal.signal    = Signal;
+    record->info.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
 #ifdef __QNXNTO__
     record->info.u.Signal.coid      = 0;
     record->info.u.Signal.rcvid     = 0;
 #endif
-    record->info.u.Signal.auxSignal = gcvNULL;
-    record->info.u.Signal.process   = gcvNULL;
+    record->info.u.Signal.auxSignal = 0;
+    record->info.u.Signal.process   = 0;
 
     /* Append the record. */
     Event->queues[id].head      = record;
@@ -2714,6 +2796,11 @@ _PrintRecord(
         gcmkPRINT("      gcvHAL_COMMIT_DONE");
         break;
 
+    case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
+        gcmkPRINT("      gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER logical=0x%08x",
+                  record->info.u.FreeVirtualCommandBuffer.logical);
+        break;
+
     default:
         gcmkPRINT("      Illegal Event %d", record->info.command);
         break;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
index c68e0c1..a5affb9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /**
 **  @file
 **  gckHEAP object for kernel HAL layer.  The heap implemented here is an arena-
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
index e2f84f6..8ac187b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
index 9012599..c7f67c7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_MMU
@@ -37,6 +35,8 @@ gceMMU_TYPE;
 
 #define gcdMMU_TABLE_DUMP       0
 
+#define gcdUSE_MMU_EXCEPTION    0
+
 /*
     gcdMMU_CLEAR_VALUE
 
@@ -78,6 +78,70 @@ gcsSharedPageTable;
 static gcsSharedPageTable_PTR sharedPageTable = gcvNULL;
 #endif
 
+#if gcdMIRROR_PAGETABLE
+typedef struct _gcsMirrorPageTable * gcsMirrorPageTable_PTR;
+typedef struct _gcsMirrorPageTable
+{
+    /* gckMMU objects. */
+    gckMMU          mmus[gcdMAX_GPU_COUNT];
+
+    /* Hardwares which use this shared pagetable. */
+    gckHARDWARE     hardwares[gcdMAX_GPU_COUNT];
+
+    /* Number of cores use this shared pagetable. */
+    gctUINT32       reference;
+}
+gcsMirrorPageTable;
+
+static gcsMirrorPageTable_PTR mirrorPageTable = gcvNULL;
+static gctPOINTER mirrorPageTableMutex = gcvNULL;
+#endif
+
+typedef struct _gcsDynamicSpaceNode * gcsDynamicSpaceNode_PTR;
+typedef struct _gcsDynamicSpaceNode
+{
+    gctUINT32       start;
+    gctINT32        entries;
+}
+gcsDynamicSpaceNode;
+
+static void
+_WritePageEntry(
+    IN gctUINT32_PTR PageEntry,
+    IN gctUINT32     EntryValue
+    )
+{
+    static gctUINT16 data = 0xff00;
+
+    if (*(gctUINT8 *)&data == 0xff)
+    {
+        *PageEntry = gcmSWAB32(EntryValue);
+    }
+    else
+    {
+        *PageEntry = EntryValue;
+    }
+}
+
+static gctUINT32
+_ReadPageEntry(
+    IN gctUINT32_PTR PageEntry
+    )
+{
+    static gctUINT16 data = 0xff00;
+    gctUINT32 entryValue;
+
+    if (*(gctUINT8 *)&data == 0xff)
+    {
+        entryValue = *PageEntry;
+        return gcmSWAB32(entryValue);
+    }
+    else
+    {
+        return *PageEntry;
+    }
+}
+
 static gceSTATUS
 _FillPageTable(
     IN gctUINT32_PTR PageTable,
@@ -89,7 +153,7 @@ _FillPageTable(
 
     for (i = 0; i < PageCount; i++)
     {
-        PageTable[i] = EntryValue;
+        _WritePageEntry(PageTable + i, EntryValue);
     }
 
     return gcvSTATUS_OK;
@@ -113,16 +177,16 @@ _Link(
         gctUINT32_PTR pageTable = Mmu->pageTableLogical;
 
         /* Dispatch on node type. */
-        switch (gcmENTRY_TYPE(pageTable[Index]))
+        switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[Index])))
         {
         case gcvMMU_SINGLE:
             /* Set single index. */
-            pageTable[Index] = (Next << 8) | gcvMMU_SINGLE;
+            _WritePageEntry(&pageTable[Index], (Next << 8) | gcvMMU_SINGLE);
             break;
 
         case gcvMMU_FREE:
             /* Set index. */
-            pageTable[Index + 1] = Next;
+            _WritePageEntry(&pageTable[Index + 1], Next);
             break;
 
         default:
@@ -148,13 +212,13 @@ _AddFree(
     if (Count == 1)
     {
         /* Initialize a single page node. */
-        pageTable[Node] = (~((1U<<8)-1)) | gcvMMU_SINGLE;
+        _WritePageEntry(pageTable + Node, (~((1U<<8)-1)) | gcvMMU_SINGLE);
     }
     else
     {
         /* Initialize the node. */
-        pageTable[Node + 0] = (Count << 8) | gcvMMU_FREE;
-        pageTable[Node + 1] = ~0U;
+        _WritePageEntry(pageTable + Node + 0, (Count << 8) | gcvMMU_FREE);
+        _WritePageEntry(pageTable + Node + 1, ~0U);
     }
 
     /* Append the node. */
@@ -177,7 +241,7 @@ _Collect(
     for (i = 0; i < Mmu->pageTableEntries; ++i)
     {
         /* Dispatch based on type of page. */
-        switch (gcmENTRY_TYPE(pageTable[i]))
+        switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[i])))
         {
         case gcvMMU_USED:
             /* Used page, so close any open node. */
@@ -210,10 +274,10 @@ _Collect(
             }
 
             /* Advance the count. */
-            count += pageTable[i] >> 8;
+            count += _ReadPageEntry(&pageTable[i]) >> 8;
 
             /* Advance the index into the page table. */
-            i     += (pageTable[i] >> 8) - 1;
+            i     += (_ReadPageEntry(&pageTable[i]) >> 8) - 1;
             break;
 
         default:
@@ -322,19 +386,20 @@ _FillFlatMapping(
                 gcmkONERROR(gcvSTATUS_NOT_ALIGNED);
             }
 
-            *(Mmu->mtlbLogical + mStart)
-                      = stlb->physBase
-                        /* 64KB page size */
-                        | (1 << 2)
-                        /* Ignore exception */
-                        | (0 << 1)
-                        /* Present */
-                        | (1 << 0);
+            _WritePageEntry(Mmu->mtlbLogical + mStart,
+                            stlb->physBase
+                            /* 64KB page size */
+                            | (1 << 2)
+                            /* Ignore exception */
+                            | (0 << 1)
+                            /* Present */
+                            | (1 << 0)
+                            );
 #if gcdMMU_TABLE_DUMP
             gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
                 __FUNCTION__, __LINE__,
                 mStart,
-                *(Mmu->mtlbLogical + mStart));
+                _ReadPageEntry(Mmu->mtlbLogical + mStart));
 #endif
 
             stlb->mtlbIndex = mStart;
@@ -349,12 +414,12 @@ _FillFlatMapping(
             while (sStart <= last)
             {
                 gcmkASSERT(!(start & gcdMMU_PAGE_64K_MASK));
-                *(stlb->logical + sStart) = _SetPage(start);
+                _WritePageEntry(stlb->logical + sStart, _SetPage(start));
 #if gcdMMU_TABLE_DUMP
                 gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
                     __FUNCTION__, __LINE__,
                     sStart,
-                    *(stlb->logical + sStart));
+                    _ReadPageEntry(stlb->logical + sStart));
 #endif
                 /* next page. */
                 start += gcdMMU_PAGE_64K_SIZE;
@@ -409,7 +474,7 @@ OnError:
         if (pre->mtlbEntryNum != 0)
         {
             gcmkASSERT(pre->mtlbEntryNum == 1);
-            *(Mmu->mtlbLogical + pre->mtlbIndex) = 0;
+            _WritePageEntry(Mmu->mtlbLogical + pre->mtlbIndex, 0);
         }
 
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, pre));
@@ -425,30 +490,117 @@ OnError:
 }
 
 static gceSTATUS
+_FindDynamicSpace(
+    IN gckMMU Mmu,
+    OUT gcsDynamicSpaceNode_PTR *Array,
+    OUT gctINT * Size
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+    gctPOINTER pointer = gcvNULL;
+    gcsDynamicSpaceNode_PTR array = gcvNULL;
+    gctINT size = 0;
+    gctINT i = 0, nodeStart = -1, nodeEntries = 0;
+
+    /* Allocate memory for the array. */
+    gcmkONERROR(gckOS_Allocate(Mmu->os,
+                               gcmSIZEOF(*array) * (gcdMMU_MTLB_ENTRY_NUM / 2),
+                               &pointer));
+
+    array = (gcsDynamicSpaceNode_PTR)pointer;
+
+    /* Loop all the entries. */
+    while (i < gcdMMU_MTLB_ENTRY_NUM)
+    {
+        if (!Mmu->mtlbLogical[i])
+        {
+            if (nodeStart < 0)
+            {
+                /* This is the first entry of the dynamic space. */
+                nodeStart   = i;
+                nodeEntries = 1;
+            }
+            else
+            {
+                /* Other entries of the dynamic space. */
+                nodeEntries++;
+            }
+        }
+        else if (nodeStart >= 0)
+        {
+            /* Save the previous node. */
+            array[size].start   = nodeStart;
+            array[size].entries = nodeEntries;
+            size++;
+
+            /* Reset the start. */
+            nodeStart   = -1;
+            nodeEntries = 0;
+        }
+
+        i++;
+    }
+
+    /* Save the previous node. */
+    if (nodeStart >= 0)
+    {
+        array[size].start   = nodeStart;
+        array[size].entries = nodeEntries;
+        size++;
+    }
+
+#if gcdMMU_TABLE_DUMP
+    for (i = 0; i < size; i++)
+    {
+        gckOS_Print("%s(%d): [%d]: start=%d, entries=%d.\n",
+                __FUNCTION__, __LINE__,
+                i,
+                array[i].start,
+                array[i].entries);
+    }
+#endif
+
+    *Array = array;
+    *Size  = size;
+
+    return gcvSTATUS_OK;
+
+OnError:
+    if (pointer != gcvNULL)
+    {
+        gckOS_Free(Mmu->os, pointer);
+    }
+
+    return status;
+}
+
+static gceSTATUS
 _SetupDynamicSpace(
     IN gckMMU Mmu
     )
 {
     gceSTATUS status;
-    gctINT i;
+    gcsDynamicSpaceNode_PTR nodeArray = gcvNULL;
+    gctINT i, nodeArraySize = 0;
     gctUINT32 physical;
-    gctINT numEntries;
+    gctINT numEntries = 0;
     gctUINT32_PTR pageTable;
     gctBOOL acquired = gcvFALSE;
 
-    /* find the start of dynamic address space. */
-    for (i = 0; i < gcdMMU_MTLB_ENTRY_NUM; i++)
+    /* Find all the dynamic address space. */
+    gcmkONERROR(_FindDynamicSpace(Mmu, &nodeArray, &nodeArraySize));
+
+    /* TODO: We only use the largest one for now. */
+    for (i = 0; i < nodeArraySize; i++)
     {
-        if (!Mmu->mtlbLogical[i])
+        if (nodeArray[i].entries > numEntries)
         {
-            break;
+            Mmu->dynamicMappingStart = nodeArray[i].start;
+            numEntries               = nodeArray[i].entries;
         }
     }
 
-    Mmu->dynamicMappingStart = i;
-
-    /* Number of entries in Master TLB for dynamic mapping. */
-    numEntries = gcdMMU_MTLB_ENTRY_NUM - i;
+    gckOS_Free(Mmu->os, (gctPOINTER)nodeArray);
 
     Mmu->pageTableSize = numEntries * 4096;
 
@@ -461,14 +613,21 @@ _SetupDynamicSpace(
                 &Mmu->pageTablePhysical,
                 (gctPOINTER)&Mmu->pageTableLogical));
 
+#if gcdUSE_MMU_EXCEPTION
+    gcmkONERROR(_FillPageTable(Mmu->pageTableLogical,
+                               Mmu->pageTableEntries,
+                               /* Enable exception */
+                               1 << 1));
+#else
     /* Invalidate all entries. */
     gcmkONERROR(gckOS_ZeroMemory(Mmu->pageTableLogical,
                 Mmu->pageTableSize));
+#endif
 
     /* Initilization. */
     pageTable      = Mmu->pageTableLogical;
-    pageTable[0]   = (Mmu->pageTableEntries << 8) | gcvMMU_FREE;
-    pageTable[1]   = ~0U;
+    _WritePageEntry(pageTable,     (Mmu->pageTableEntries << 8) | gcvMMU_FREE);
+    _WritePageEntry(pageTable + 1, ~0U);
     Mmu->heapList  = 0;
     Mmu->freeNodes = gcvFALSE;
 
@@ -481,20 +640,24 @@ _SetupDynamicSpace(
     acquired = gcvTRUE;
 
     /* Map to Master TLB. */
-    for (; i < gcdMMU_MTLB_ENTRY_NUM; i++)
+    for (i = (gctINT)Mmu->dynamicMappingStart;
+         i < (gctINT)Mmu->dynamicMappingStart + numEntries;
+         i++)
     {
-        Mmu->mtlbLogical[i] = physical
-                            /* 4KB page size */
-                            | (0 << 2)
-                            /* Ignore exception */
-                            | (0 << 1)
-                            /* Present */
-                            | (1 << 0);
+        _WritePageEntry(Mmu->mtlbLogical + i,
+                        physical
+                        /* 4KB page size */
+                        | (0 << 2)
+                        /* Ignore exception */
+                        | (0 << 1)
+                        /* Present */
+                        | (1 << 0)
+                        );
 #if gcdMMU_TABLE_DUMP
         gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
                 __FUNCTION__, __LINE__,
                 i,
-                *(Mmu->mtlbLogical + i));
+                _ReadPageEntry(Mmu->mtlbLogical + i));
 #endif
         physical += gcdMMU_STLB_4K_SIZE;
     }
@@ -619,18 +782,11 @@ _Construct(
         pageTable      = mmu->pageTableLogical;
 
 #if gcdMMU_CLEAR_VALUE
-        {
-            gctUINT32 i;
-
-            for (i = 0; i < mmu->pageTableEntries; ++i)
-            {
-                pageTable[i] = gcdMMU_CLEAR_VALUE;
-            }
-        }
+        _FillPageTable(pageTable, mmu->pageTableEntries, gcdMMU_CLEAR_VALUE);
 #endif
 
-        pageTable[0]   = (mmu->pageTableEntries << 8) | gcvMMU_FREE;
-        pageTable[1]   = ~0U;
+        _WritePageEntry(pageTable,     (mmu->pageTableEntries << 8) | gcvMMU_FREE);
+        _WritePageEntry(pageTable + 1, ~0U);
         mmu->heapList  = 0;
         mmu->freeNodes = gcvFALSE;
 
@@ -771,7 +927,7 @@ _Destroy(
         if (pre->mtlbEntryNum != 0)
         {
             gcmkASSERT(pre->mtlbEntryNum == 1);
-            *(Mmu->mtlbLogical + pre->mtlbIndex) = 0;
+            _WritePageEntry(Mmu->mtlbLogical + pre->mtlbIndex, 0);
 #if gcdMMU_TABLE_DUMP
             gckOS_Print("%s(%d): clean MTLB[%d]\n",
                 __FUNCTION__, __LINE__,
@@ -873,6 +1029,47 @@ OnError:
 
     gcmkFOOTER();
     return status;
+#elif gcdMIRROR_PAGETABLE
+    gceSTATUS status;
+    gctPOINTER pointer;
+
+    gcmkHEADER_ARG("Kernel=0x%08x", Kernel);
+
+    if (mirrorPageTable == gcvNULL)
+    {
+        gcmkONERROR(
+            gckOS_Allocate(Kernel->os,
+                           sizeof(struct _gcsMirrorPageTable),
+                           &pointer));
+        mirrorPageTable = pointer;
+
+        gcmkONERROR(
+            gckOS_ZeroMemory(mirrorPageTable,
+                    sizeof(struct _gcsMirrorPageTable)));
+
+        gcmkONERROR(
+            gckOS_CreateMutex(Kernel->os, &mirrorPageTableMutex));
+    }
+
+    gcmkONERROR(_Construct(Kernel, MmuSize, Mmu));
+
+    mirrorPageTable->mmus[mirrorPageTable->reference] = *Mmu;
+
+    mirrorPageTable->hardwares[mirrorPageTable->reference] = Kernel->hardware;
+
+    mirrorPageTable->reference++;
+
+    gcmkFOOTER_ARG("mirrorPageTable->reference=%lu", mirrorPageTable->reference);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (mirrorPageTable && mirrorPageTable->reference == 0)
+    {
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Kernel->os, mirrorPageTable));
+    }
+
+    gcmkFOOTER();
+    return status;
 #else
     return _Construct(Kernel, MmuSize, Mmu);
 #endif
@@ -897,6 +1094,16 @@ gckMMU_Destroy(
     }
 
     return gcvSTATUS_OK;
+#elif gcdMIRROR_PAGETABLE
+    mirrorPageTable->reference--;
+
+    if (mirrorPageTable->reference == 0)
+    {
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, mirrorPageTable));
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, mirrorPageTableMutex));
+    }
+
+    return _Destroy(Mmu);
 #else
     return _Destroy(Mmu);
 #endif
@@ -926,7 +1133,7 @@ gckMMU_Destroy(
 **          Pointer to a variable that receives the hardware specific address.
 */
 gceSTATUS
-gckMMU_AllocatePages(
+_AllocatePages(
     IN gckMMU Mmu,
     IN gctSIZE_T PageCount,
     OUT gctPOINTER * PageTable,
@@ -949,6 +1156,9 @@ gckMMU_AllocatePages(
 
     if (PageCount > Mmu->pageTableEntries)
     {
+        gcmkPRINT("[galcore]: %s(%d): Run out of free page entry.",
+                  __FUNCTION__, __LINE__);
+
         /* Not enough pages avaiable. */
         gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
     }
@@ -964,7 +1174,7 @@ gckMMU_AllocatePages(
         for (index = Mmu->heapList; !gotIt && (index < Mmu->pageTableEntries);)
         {
             /* Check the node type. */
-            switch (gcmENTRY_TYPE(pageTable[index]))
+            switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[index])))
             {
             case gcvMMU_SINGLE:
                 /* Single odes are valid if we only need 1 page. */
@@ -976,13 +1186,13 @@ gckMMU_AllocatePages(
                 {
                     /* Move to next node. */
                     previous = index;
-                    index    = pageTable[index] >> 8;
+                    index    = _ReadPageEntry(&pageTable[index]) >> 8;
                 }
                 break;
 
             case gcvMMU_FREE:
                 /* Test if the node has enough space. */
-                if (PageCount <= (pageTable[index] >> 8))
+                if (PageCount <= (_ReadPageEntry(&pageTable[index]) >> 8))
                 {
                     gotIt = gcvTRUE;
                 }
@@ -990,7 +1200,7 @@ gckMMU_AllocatePages(
                 {
                     /* Move to next node. */
                     previous = index;
-                    index    = pageTable[index + 1];
+                    index    = _ReadPageEntry(&pageTable[index + 1]);
                 }
                 break;
 
@@ -1010,42 +1220,45 @@ gckMMU_AllocatePages(
             }
             else
             {
+                gcmkPRINT("[galcore]: %s(%d): Run out of free page entry.",
+                          __FUNCTION__, __LINE__);
+
                 /* Out of resources. */
                 gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
         }
     }
 
-    switch (gcmENTRY_TYPE(pageTable[index]))
+    switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[index])))
     {
     case gcvMMU_SINGLE:
         /* Unlink single node from free list. */
         gcmkONERROR(
-            _Link(Mmu, previous, pageTable[index] >> 8));
+            _Link(Mmu, previous, _ReadPageEntry(&pageTable[index]) >> 8));
         break;
 
     case gcvMMU_FREE:
         /* Check how many pages will be left. */
-        left = (pageTable[index] >> 8) - PageCount;
+        left = (_ReadPageEntry(&pageTable[index]) >> 8) - PageCount;
         switch (left)
         {
         case 0:
             /* The entire node is consumed, just unlink it. */
             gcmkONERROR(
-                _Link(Mmu, previous, pageTable[index + 1]));
+                _Link(Mmu, previous, _ReadPageEntry(&pageTable[index + 1])));
             break;
 
         case 1:
             /* One page will remain.  Convert the node to a single node and
             ** advance the index. */
-            pageTable[index] = (pageTable[index + 1] << 8) | gcvMMU_SINGLE;
+            _WritePageEntry(&pageTable[index], (_ReadPageEntry(&pageTable[index + 1]) << 8) | gcvMMU_SINGLE);
             index ++;
             break;
 
         default:
             /* Enough pages remain for a new node.  However, we will just adjust
             ** the size of the current node and advance the index. */
-            pageTable[index] = (left << 8) | gcvMMU_FREE;
+            _WritePageEntry(&pageTable[index], (left << 8) | gcvMMU_FREE);
             index += left;
             break;
         }
@@ -1122,7 +1335,7 @@ OnError:
 **      Nothing.
 */
 gceSTATUS
-gckMMU_FreePages(
+_FreePages(
     IN gckMMU Mmu,
     IN gctPOINTER PageTable,
     IN gctSIZE_T PageCount
@@ -1149,25 +1362,37 @@ gckMMU_FreePages(
 #if gcdMMU_CLEAR_VALUE
     if (Mmu->hardware->mmuVersion == 0)
     {
-        gctUINT32 i;
-
-        for (i = 0; i < PageCount; ++i)
-        {
-            pageTable[i] = gcdMMU_CLEAR_VALUE;
-        }
+        _FillPageTable(pageTable, PageCount, gcdMMU_CLEAR_VALUE);
     }
 #endif
 
     if (PageCount == 1)
     {
         /* Single page node. */
-        pageTable[0] = (~((1U<<8)-1)) | gcvMMU_SINGLE;
+        _WritePageEntry(pageTable,
+                        (~((1U<<8)-1)) | gcvMMU_SINGLE
+#if gcdUSE_MMU_EXCEPTION
+                        /* Enable exception */
+                        | 1 << 1
+#endif
+                        );
     }
     else
     {
         /* Mark the node as free. */
-        pageTable[0] = (PageCount << 8) | gcvMMU_FREE;
-        pageTable[1] = ~0U;
+        _WritePageEntry(pageTable,
+                        (PageCount << 8) | gcvMMU_FREE
+#if gcdUSE_MMU_EXCEPTION
+                        /* Enable exception */
+                        | 1 << 1
+#endif
+                       );
+        _WritePageEntry(pageTable + 1, ~0U);
+
+#if gcdUSE_MMU_EXCEPTION
+        /* Enable exception */
+        gcmkVERIFY_OK(_FillPageTable(pageTable + 2, PageCount - 2, 1 << 1));
+#endif
     }
 
     /* We have free nodes. */
@@ -1191,6 +1416,109 @@ OnError:
 }
 
 gceSTATUS
+gckMMU_AllocatePages(
+    IN gckMMU Mmu,
+    IN gctSIZE_T PageCount,
+    OUT gctPOINTER * PageTable,
+    OUT gctUINT32 * Address
+    )
+{
+#if gcdMIRROR_PAGETABLE
+    gceSTATUS status;
+    gctPOINTER pageTable;
+    gctUINT32 address;
+    gctINT i;
+    gckMMU mmu;
+    gctBOOL acquired = gcvFALSE;
+    gctBOOL allocated = gcvFALSE;
+
+    gckOS_AcquireMutex(Mmu->os, mirrorPageTableMutex, gcvINFINITE);
+    acquired = gcvTRUE;
+
+    /* Allocate page table for current MMU. */
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        if (Mmu == mirrorPageTable->mmus[i])
+        {
+            gcmkONERROR(_AllocatePages(Mmu, PageCount, PageTable, Address));
+            allocated = gcvTRUE;
+        }
+    }
+
+    /* Allocate page table for other MMUs. */
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        mmu = mirrorPageTable->mmus[i];
+
+        if (Mmu != mmu)
+        {
+            gcmkONERROR(_AllocatePages(mmu, PageCount, &pageTable, &address));
+            gcmkASSERT(address == *Address);
+        }
+    }
+
+    gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+    acquired = gcvFALSE;
+
+    return gcvSTATUS_OK;
+OnError:
+
+    if (allocated)
+    {
+        /* Page tables for multiple GPU always keep the same. So it is impossible
+         * the fist one allocates successfully but others fail.
+         */
+        gcmkASSERT(0);
+    }
+
+    if (acquired)
+    {
+        gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+    }
+
+    return status;
+#else
+    return _AllocatePages(Mmu, PageCount, PageTable, Address);
+#endif
+}
+
+gceSTATUS
+gckMMU_FreePages(
+    IN gckMMU Mmu,
+    IN gctPOINTER PageTable,
+    IN gctSIZE_T PageCount
+    )
+{
+#if gcdMIRROR_PAGETABLE
+    gctINT i;
+    gctUINT32 offset;
+    gckMMU mmu;
+
+    gckOS_AcquireMutex(Mmu->os, mirrorPageTableMutex, gcvINFINITE);
+
+    gcmkVERIFY_OK(_FreePages(Mmu, PageTable, PageCount));
+
+    offset = (gctUINT32)PageTable - (gctUINT32)Mmu->pageTableLogical;
+
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        mmu = mirrorPageTable->mmus[i];
+
+        if (mmu != Mmu)
+        {
+            gcmkVERIFY_OK(_FreePages(mmu, mmu->pageTableLogical + offset/4, PageCount));
+        }
+    }
+
+    gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+
+    return gcvSTATUS_OK;
+#else
+    return _FreePages(Mmu, PageTable, PageCount);
+#endif
+}
+
+gceSTATUS
 gckMMU_Enable(
     IN gckMMU Mmu,
     IN gctUINT32 PhysBaseAddr,
@@ -1284,6 +1612,14 @@ gckMMU_SetPage(
     IN gctUINT32 *PageEntry
     )
 {
+#if gcdMIRROR_PAGETABLE
+    gctUINT32_PTR pageEntry;
+    gctINT i;
+    gckMMU mmu;
+    gctUINT32 offset = (gctUINT32)PageEntry - (gctUINT32)Mmu->pageTableLogical;
+#endif
+
+    gctUINT32 data;
     gcmkHEADER_ARG("Mmu=0x%x", Mmu);
 
     /* Verify the arguments. */
@@ -1293,13 +1629,36 @@ gckMMU_SetPage(
 
     if (Mmu->hardware->mmuVersion == 0)
     {
-        *PageEntry = PageAddress;
+        data = PageAddress;
     }
     else
     {
-        *PageEntry = _SetPage(PageAddress);
+        data = _SetPage(PageAddress);
     }
 
+    _WritePageEntry(PageEntry, data);
+
+#if gcdMIRROR_PAGETABLE
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        mmu = mirrorPageTable->mmus[i];
+
+        if (mmu != Mmu)
+        {
+            pageEntry = mmu->pageTableLogical + offset / 4;
+
+            if (mmu->hardware->mmuVersion == 0)
+            {
+                _WritePageEntry(pageEntry, PageAddress);
+            }
+            else
+            {
+                _WritePageEntry(pageEntry, _SetPage(PageAddress));
+            }
+        }
+
+    }
+#endif
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -1453,6 +1812,16 @@ gckMMU_Flush(
                 gckOS_AtomSet(hardware->os, hardware->pageTableDirty, 1));
         }
     }
+#elif gcdMIRROR_PAGETABLE
+    gctINT i;
+    for (i = 0; i < mirrorPageTable->reference; i++)
+    {
+        hardware = mirrorPageTable->hardwares[i];
+
+        /* Notify cores who use this page table. */
+        gcmkVERIFY_OK(
+            gckOS_AtomSet(hardware->os, hardware->pageTableDirty, 1));
+    }
 #else
     hardware = Mmu->hardware;
     gcmkVERIFY_OK(
@@ -1462,6 +1831,39 @@ gckMMU_Flush(
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckMMU_DumpPageTableEntry(
+    IN gckMMU Mmu,
+    IN gctUINT32 Address
+    )
+{
+    gctUINT32_PTR pageTable;
+    gctUINT32 index;
+    gctUINT32 mtlb, stlb;
+
+    gcmkHEADER_ARG("Mmu=0x%08X Address=0x%08X", Mmu, Address);
+    gcmkVERIFY_OBJECT(Mmu, gcvOBJ_MMU);
+
+    gcmkASSERT(Mmu->hardware->mmuVersion > 0);
+
+    mtlb   = (Address & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT;
+    stlb   = (Address & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+
+    if (Address >= 0x80000000)
+    {
+        pageTable = Mmu->pageTableLogical;
+
+        index = (mtlb - Mmu->dynamicMappingStart)
+              * gcdMMU_STLB_4K_ENTRY_NUM
+              + stlb;
+
+        gcmkPRINT("    Page table entry = 0x%08X", _ReadPageEntry(pageTable + index));
+    }
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 /******************************************************************************
 ****************************** T E S T   C O D E ******************************
 ******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
index 46d1761..0c20290 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
new file mode 100644
index 0000000..df7579d
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
@@ -0,0 +1,347 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#include "gc_hal_kernel_precomp.h"
+
+#define _GC_OBJ_ZONE    gcvZONE_POWER
+
+/******************************************************************************\
+************************ Dynamic Voltage Frequency Setting *********************
+\******************************************************************************/
+#if gcdDVFS
+static gctUINT32
+_GetLoadHistory(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Select,
+    IN gctUINT32 Index
+)
+{
+    return Dvfs->loads[Index];
+}
+
+static void
+_IncreaseScale(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Load,
+    OUT gctUINT8 *Scale
+    )
+{
+    if (Dvfs->currentScale < 32)
+    {
+        *Scale = Dvfs->currentScale + 8;
+    }
+    else
+    {
+        *Scale = Dvfs->currentScale + 8;
+        *Scale = gcmMIN(64, *Scale);
+    }
+}
+
+static void
+_RecordFrequencyHistory(
+    gckDVFS Dvfs,
+    gctUINT32 Frequency
+    )
+{
+    gctUINT32 i = 0;
+
+    struct _FrequencyHistory *history = Dvfs->frequencyHistory;
+
+    for (i = 0; i < 16; i++)
+    {
+        if (history->frequency == Frequency)
+        {
+            break;
+        }
+
+        if (history->frequency == 0)
+        {
+            history->frequency = Frequency;
+            break;
+        }
+
+        history++;
+    }
+
+    if (i < 16)
+    {
+        history->count++;
+    }
+}
+
+static gctUINT32
+_GetFrequencyHistory(
+    gckDVFS Dvfs,
+    gctUINT32 Frequency
+    )
+{
+    gctUINT32 i = 0;
+
+    struct _FrequencyHistory * history = Dvfs->frequencyHistory;
+
+    for (i = 0; i < 16; i++)
+    {
+        if (history->frequency == Frequency)
+        {
+            break;
+        }
+
+        history++;
+    }
+
+    if (i < 16)
+    {
+        return history->count;
+    }
+
+    return 0;
+}
+
+static void
+_Policy(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Load,
+    OUT gctUINT8 *Scale
+    )
+{
+    gctUINT8 load[4], nextLoad;
+    gctUINT8 scale;
+
+    /* Last 4 history. */
+    load[0] = (Load & 0xFF);
+    load[1] = (Load & 0xFF00) >> 8;
+    load[2] = (Load & 0xFF0000) >> 16;
+    load[3] = (Load & 0xFF000000) >> 24;
+
+    /* Determine target scale. */
+    if (load[0] > 54)
+    {
+        _IncreaseScale(Dvfs, Load, &scale);
+    }
+    else
+    {
+        nextLoad = (load[0] + load[1] + load[2] + load[3])/4;
+
+        scale = Dvfs->currentScale * (nextLoad) / 54;
+
+        scale = gcmMAX(1, scale);
+        scale = gcmMIN(64, scale);
+    }
+
+    Dvfs->totalConfig++;
+
+    Dvfs->loads[(load[0]-1)/8]++;
+
+    *Scale = scale;
+
+
+    if (Dvfs->totalConfig % 100 == 0)
+    {
+        gcmkPRINT("=======================================================");
+        gcmkPRINT("GPU Load:       %-8d %-8d %-8d %-8d %-8d %-8d %-8d %-8d",
+                                   8, 16, 24, 32, 40, 48, 56, 64);
+        gcmkPRINT("                %-8d %-8d %-8d %-8d %-8d %-8d %-8d %-8d",
+                  _GetLoadHistory(Dvfs,2, 0),
+                  _GetLoadHistory(Dvfs,2, 1),
+                  _GetLoadHistory(Dvfs,2, 2),
+                  _GetLoadHistory(Dvfs,2, 3),
+                  _GetLoadHistory(Dvfs,2, 4),
+                  _GetLoadHistory(Dvfs,2, 5),
+                  _GetLoadHistory(Dvfs,2, 6),
+                  _GetLoadHistory(Dvfs,2, 7)
+                  );
+
+        gcmkPRINT("Frequency(MHz)  %-8d %-8d %-8d %-8d %-8d",
+                  58, 120, 240, 360, 480);
+        gcmkPRINT("                %-8d %-8d %-8d %-8d %-8d",
+                  _GetFrequencyHistory(Dvfs, 58),
+                  _GetFrequencyHistory(Dvfs,120),
+                  _GetFrequencyHistory(Dvfs,240),
+                  _GetFrequencyHistory(Dvfs,360),
+                  _GetFrequencyHistory(Dvfs,480)
+                  );
+    }
+}
+
+static void
+_TimerFunction(
+    gctPOINTER Data
+    )
+{
+    gceSTATUS status;
+    gckDVFS dvfs = (gckDVFS) Data;
+    gckHARDWARE hardware = dvfs->hardware;
+    gctUINT32 value;
+    gctUINT32 frequency;
+    gctUINT8 scale;
+    gctUINT32 t1, t2, consumed;
+
+    gckOS_GetTicks(&t1);
+
+    gcmkONERROR(gckHARDWARE_QueryLoad(hardware, &value));
+
+    /* determine target sacle. */
+    _Policy(dvfs, value, &scale);
+
+    /* Set frequency and voltage. */
+    gcmkONERROR(gckOS_SetGPUFrequency(hardware->os, hardware->core, scale));
+
+    /* Query real frequency. */
+    gcmkONERROR(
+        gckOS_QueryGPUFrequency(hardware->os,
+                                hardware->core,
+                                &frequency,
+                                &dvfs->currentScale));
+
+    _RecordFrequencyHistory(dvfs, frequency);
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_POWER,
+                   "Current frequency = %d",
+                   frequency);
+
+    /* Set period. */
+    gcmkONERROR(gckHARDWARE_SetDVFSPeroid(hardware, frequency));
+
+OnError:
+    /* Determine next querying time. */
+    gckOS_GetTicks(&t2);
+
+    consumed = gcmMIN(((long)t2 - (long)t1), 5);
+
+    if (dvfs->stop == gcvFALSE)
+    {
+        gcmkVERIFY_OK(gckOS_StartTimer(hardware->os,
+                                       dvfs->timer,
+                                       dvfs->pollingTime - consumed));
+    }
+
+    return;
+}
+
+gceSTATUS
+gckDVFS_Construct(
+    IN gckHARDWARE Hardware,
+    OUT gckDVFS * Dvfs
+    )
+{
+    gceSTATUS status;
+    gctPOINTER pointer;
+    gckDVFS dvfs = gcvNULL;
+    gckOS os = Hardware->os;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    /* Allocate a gckDVFS manager. */
+    gcmkONERROR(gckOS_Allocate(os, gcmSIZEOF(struct _gckDVFS), &pointer));
+
+    gckOS_ZeroMemory(pointer, gcmSIZEOF(struct _gckDVFS));
+
+    dvfs = pointer;
+
+    /* Initialization. */
+    dvfs->hardware = Hardware;
+    dvfs->pollingTime = gcdDVFS_POLLING_TIME;
+    dvfs->os = Hardware->os;
+    dvfs->currentScale = 64;
+
+    /* Create a polling timer. */
+    gcmkONERROR(gckOS_CreateTimer(os, _TimerFunction, pointer, &dvfs->timer));
+
+    /* Initialize frequency and voltage adjustment helper. */
+    gcmkONERROR(gckOS_PrepareGPUFrequency(os, Hardware->core));
+
+    /* Return result. */
+    *Dvfs = dvfs;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Roll back. */
+    if (dvfs)
+    {
+        if (dvfs->timer)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyTimer(os, dvfs->timer));
+        }
+
+        gcmkOS_SAFE_FREE(os, dvfs);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckDVFS_Destroy(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    /* Deinitialize helper fuunction. */
+    gcmkVERIFY_OK(gckOS_FinishGPUFrequency(Dvfs->os, Dvfs->hardware->core));
+
+    /* DestroyTimer. */
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Dvfs->os, Dvfs->timer));
+
+    gcmkOS_SAFE_FREE(Dvfs->os, Dvfs);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDVFS_Start(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    gckHARDWARE_InitDVFS(Dvfs->hardware);
+
+    Dvfs->stop = gcvFALSE;
+
+    gckOS_StartTimer(Dvfs->os, Dvfs->timer, Dvfs->pollingTime);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDVFS_Stop(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    Dvfs->stop = gcvTRUE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
index 004e6bd..1e764c2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_precomp_h_
 #define __gc_hal_kernel_precomp_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
index ee63e9b..7d0032e3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,12 +19,12 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
 
+#define ENABLE_VG_TRY_VIRTUAL_MEMORY 0
+
 #define _GC_OBJ_ZONE            gcvZONE_VG
 
 /******************************************************************************\
@@ -333,11 +333,18 @@ gckKERNEL_AllocateLinearMemory(
         else if (pool == gcvPOOL_SYSTEM)
         {
             /* Advance to virtual memory. */
+#if ENABLE_VG_TRY_VIRTUAL_MEMORY
             pool = gcvPOOL_VIRTUAL;
+#else
+            /*VG non-contiguous memory support is not ready yet, disable it temporary*/
+            status = gcvSTATUS_OUT_OF_MEMORY;
+            break;
+#endif
         }
         else
         {
             /* Out of pools. */
+            status = gcvSTATUS_OUT_OF_MEMORY;
             break;
         }
     }
@@ -388,6 +395,11 @@ gceSTATUS gckVGKERNEL_Dispatch(
     gcsHAL_INTERFACE * kernelInterface = Interface;
     gcuVIDMEM_NODE_PTR node;
     gctUINT32 processID;
+    gckKERNEL kernel = Kernel;
+    gctPOINTER info = gcvNULL;
+    gctPHYS_ADDR physical = gcvNULL;
+    gctPOINTER logical = gcvNULL;
+    gctSIZE_T bytes = 0;
 
     gcmkHEADER_ARG("Kernel=0x%x Interface=0x%x ", Kernel, Interface);
 
@@ -427,61 +439,78 @@ gceSTATUS gckVGKERNEL_Dispatch(
             ));
         break;
     case gcvHAL_ALLOCATE_NON_PAGED_MEMORY:
+        bytes = (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes;
         /* Allocate non-paged memory. */
         gcmkERR_BREAK(gckOS_AllocateContiguous(
             Kernel->os,
             gcvTRUE,
-            &kernelInterface->u.AllocateNonPagedMemory.bytes,
-            &kernelInterface->u.AllocateNonPagedMemory.physical,
-            &kernelInterface->u.AllocateNonPagedMemory.logical
+            &bytes,
+            &physical,
+            &logical
             ));
+
+        kernelInterface->u.AllocateNonPagedMemory.bytes    = bytes;
+        kernelInterface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        kernelInterface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
         break;
 
     case gcvHAL_FREE_NON_PAGED_MEMORY:
+        physical = gcmNAME_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.physical);
+
         /* Unmap user logical out of physical memory first. */
         gcmkERR_BREAK(gckOS_UnmapUserLogical(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            physical,
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
 
         /* Free non-paged memory. */
         gcmkERR_BREAK(gckOS_FreeNonPagedMemory(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            physical,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
+
+        gcmRELEASE_NAME(kernelInterface->u.AllocateNonPagedMemory.physical);
         break;
 
     case gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY:
+        bytes = (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes;
         /* Allocate contiguous memory. */
         gcmkERR_BREAK(gckOS_AllocateContiguous(
             Kernel->os,
             gcvTRUE,
-            &kernelInterface->u.AllocateNonPagedMemory.bytes,
-            &kernelInterface->u.AllocateNonPagedMemory.physical,
-            &kernelInterface->u.AllocateNonPagedMemory.logical
+            &bytes,
+            &physical,
+            &logical
             ));
+
+        kernelInterface->u.AllocateNonPagedMemory.bytes    = bytes;
+        kernelInterface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        kernelInterface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
         break;
 
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
+        physical = gcmNAME_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.physical);
         /* Unmap user logical out of physical memory first. */
         gcmkERR_BREAK(gckOS_UnmapUserLogical(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            physical,
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
 
         /* Free contiguous memory. */
         gcmkERR_BREAK(gckOS_FreeContiguous(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.logical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes
+            physical,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical),
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes
             ));
+
+        gcmRELEASE_NAME(kernelInterface->u.AllocateNonPagedMemory.physical);
         break;
 
     case gcvHAL_ALLOCATE_VIDEO_MEMORY:
@@ -523,8 +552,10 @@ gceSTATUS gckVGKERNEL_Dispatch(
                 bytes,
                 64,
                 kernelInterface->u.AllocateVideoMemory.type,
-                &kernelInterface->u.AllocateVideoMemory.node
+                &node
                 ));
+
+            kernelInterface->u.AllocateVideoMemory.node = gcmPTR_TO_UINT64(node);
         }
         break;
 
@@ -536,22 +567,23 @@ gceSTATUS gckVGKERNEL_Dispatch(
             kernelInterface->u.AllocateLinearVideoMemory.bytes,
             kernelInterface->u.AllocateLinearVideoMemory.alignment,
             kernelInterface->u.AllocateLinearVideoMemory.type,
-            &kernelInterface->u.AllocateLinearVideoMemory.node
+            &node
             ));
 
         gcmkERR_BREAK(gckKERNEL_AddProcessDB(Kernel,
            processID, gcvDB_VIDEO_MEMORY,
-           Interface->u.AllocateLinearVideoMemory.node,
+           node,
            gcvNULL,
            kernelInterface->u.AllocateLinearVideoMemory.bytes
            ));
 
+        kernelInterface->u.AllocateLinearVideoMemory.node = gcmPTR_TO_UINT64(node);
         break;
 
     case gcvHAL_FREE_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.FreeVideoMemory.node);
 #ifdef __QNXNTO__
         /* Unmap the video memory */
-        node = Interface->u.FreeVideoMemory.node;
 
         if ((node->VidMem.memory->object.type == gcvOBJ_VIDMEM) &&
             (node->VidMem.logical != gcvNULL))
@@ -566,13 +598,13 @@ gceSTATUS gckVGKERNEL_Dispatch(
 
         /* Free video memory. */
         gcmkERR_BREAK(gckVIDMEM_Free(
-            Interface->u.FreeVideoMemory.node
+            node
             ));
 
         gcmkERR_BREAK(gckKERNEL_RemoveProcessDB(
             Kernel,
             processID, gcvDB_VIDEO_MEMORY,
-            Interface->u.FreeVideoMemory.node
+            node
             ));
 
         break;
@@ -581,19 +613,20 @@ gceSTATUS gckVGKERNEL_Dispatch(
         /* Map memory. */
         gcmkERR_BREAK(gckKERNEL_MapMemory(
             Kernel,
-            kernelInterface->u.MapMemory.physical,
-            kernelInterface->u.MapMemory.bytes,
-            &kernelInterface->u.MapMemory.logical
+            gcmINT2PTR(kernelInterface->u.MapMemory.physical),
+            (gctSIZE_T) kernelInterface->u.MapMemory.bytes,
+            &logical
             ));
+        kernelInterface->u.MapMemory.logical = gcmPTR_TO_UINT64(logical);
         break;
 
     case gcvHAL_UNMAP_MEMORY:
         /* Unmap memory. */
         gcmkERR_BREAK(gckKERNEL_UnmapMemory(
             Kernel,
-            kernelInterface->u.MapMemory.physical,
-            kernelInterface->u.MapMemory.bytes,
-            kernelInterface->u.MapMemory.logical
+            gcmINT2PTR(kernelInterface->u.MapMemory.physical),
+            (gctSIZE_T) kernelInterface->u.MapMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.MapMemory.logical)
             ));
         break;
 
@@ -602,12 +635,14 @@ gceSTATUS gckVGKERNEL_Dispatch(
         gcmkERR_BREAK(gckOS_MapUserMemory(
             Kernel->os,
             gcvCORE_VG,
-            kernelInterface->u.MapUserMemory.memory,
+            gcmUINT64_TO_PTR(kernelInterface->u.MapUserMemory.memory),
             kernelInterface->u.MapUserMemory.physical,
-            kernelInterface->u.MapUserMemory.size,
-            &kernelInterface->u.MapUserMemory.info,
+            (gctSIZE_T) kernelInterface->u.MapUserMemory.size,
+            &info,
             &kernelInterface->u.MapUserMemory.address
             ));
+
+        kernelInterface->u.MapUserMemory.info = gcmPTR_TO_NAME(info);
         break;
 
     case gcvHAL_UNMAP_USER_MEMORY:
@@ -615,21 +650,22 @@ gceSTATUS gckVGKERNEL_Dispatch(
         gcmkERR_BREAK(gckOS_UnmapUserMemory(
             Kernel->os,
             gcvCORE_VG,
-            kernelInterface->u.UnmapUserMemory.memory,
-            kernelInterface->u.UnmapUserMemory.size,
-            kernelInterface->u.UnmapUserMemory.info,
+            gcmUINT64_TO_PTR(kernelInterface->u.UnmapUserMemory.memory),
+            (gctSIZE_T) kernelInterface->u.UnmapUserMemory.size,
+            gcmNAME_TO_PTR(kernelInterface->u.UnmapUserMemory.info),
             kernelInterface->u.UnmapUserMemory.address
             ));
         break;
     case gcvHAL_LOCK_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node);
+
         /* Lock video memory. */
         gcmkERR_BREAK(
             gckVIDMEM_Lock(Kernel,
-                           Interface->u.LockVideoMemory.node,
+                           node,
 						   gcvFALSE,
                            &Interface->u.LockVideoMemory.address));
 
-        node = Interface->u.LockVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Map video memory address into user space. */
@@ -645,19 +681,20 @@ gceSTATUS gckVGKERNEL_Dispatch(
                                          &node->VidMem.logical));
         }
 
-        Interface->u.LockVideoMemory.memory = node->VidMem.logical;
+        Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->VidMem.logical);
 #else
             gcmkERR_BREAK(
                 gckKERNEL_MapVideoMemoryEx(Kernel,
                                          gcvCORE_VG,
                                          FromUser,
                                          Interface->u.LockVideoMemory.address,
-                                         &Interface->u.LockVideoMemory.memory));
+                                         &logical));
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(logical);
 #endif
         }
         else
         {
-            Interface->u.LockVideoMemory.memory = node->Virtual.logical;
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->Virtual.logical);
 
             /* Success. */
             status = gcvSTATUS_OK;
@@ -666,19 +703,19 @@ gceSTATUS gckVGKERNEL_Dispatch(
 #if gcdSECURE_USER
         /* Return logical address as physical address. */
         Interface->u.LockVideoMemory.address =
-            gcmPTR2INT(Interface->u.LockVideoMemory.memory);
+            (gctUINT32)(Interface->u.LockVideoMemory.memory);
 #endif
         gcmkERR_BREAK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                   Interface->u.LockVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    0));
         break;
 
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         /* Unlock video memory. */
-        node = Interface->u.UnlockVideoMemory.node;
+        node = gcmUINT64_TO_PTR(Interface->u.UnlockVideoMemory.node);
 
 #if gcdSECURE_USER
         /* Save node information before it disappears. */
@@ -718,7 +755,7 @@ gceSTATUS gckVGKERNEL_Dispatch(
             gcmkERR_BREAK(
                     gckKERNEL_RemoveProcessDB(Kernel,
                         processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                        Interface->u.UnlockVideoMemory.node));
+                        node));
         }
 
         break;
@@ -780,10 +817,10 @@ gceSTATUS gckVGKERNEL_Dispatch(
         /* Commit a command and context buffer. */
         gcmkERR_BREAK(gckVGCOMMAND_Commit(
             Kernel->vg->command,
-            kernelInterface->u.VGCommit.context,
-            kernelInterface->u.VGCommit.queue,
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.context),
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.queue),
             kernelInterface->u.VGCommit.entryCount,
-            kernelInterface->u.VGCommit.taskTable
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.taskTable)
             ));
         break;
     case gcvHAL_VERSION:
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
index b86b0c9..b6c6d7e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_kernel_vg_h_
 #define __gc_hal_kernel_vg_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
index dc39b39..8b8bbdc 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_VIDMEM
@@ -1029,7 +1027,8 @@ gckVIDMEM_AllocateLinear(
     )
     {
         /* The left memory is for small memory.*/
-        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        status = gcvSTATUS_OUT_OF_MEMORY;
+        goto OnError;
     }
 #endif
 
@@ -2145,6 +2144,9 @@ gckVIDMEM_Unlock(
 
             if (!Node->Virtual.contiguous
             &&  (Node->Virtual.lockeds[Kernel->core] == 1)
+#if gcdENABLE_VG
+            && (Kernel->vg == gcvNULL)
+#endif
             )
             {
                 if (Type == gcvSURF_BITMAP)
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index 5bf8870..4406d7e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_h_
 #define __gc_hal_h_
 
@@ -49,7 +47,7 @@ extern "C" {
 
 #define gcmALIGN_BASE(n, align) \
 ( \
-    (n) & ~((align) - 1) \
+    ((n) & ~((align) - 1)) \
 )
 
 /******************************************************************************\
@@ -67,6 +65,59 @@ extern "C" {
 )
 
 /******************************************************************************\
+********************************* Cast Macro **********************************
+\******************************************************************************/
+#define gcmNAME_TO_PTR(na) \
+        gckKERNEL_QueryPointerFromName(kernel, gcmALL_TO_UINT32(na))
+
+#define gcmPTR_TO_NAME(ptr) \
+        gckKERNEL_AllocateNameFromPointer(kernel, ptr)
+
+#define gcmRELEASE_NAME(na) \
+        gckKERNEL_DeleteName(kernel, gcmALL_TO_UINT32(na))
+
+#ifdef __LP64__
+
+#define gcmALL_TO_UINT32(t) \
+( \
+    (gctUINT32) (gctUINTPTR_T) (t)\
+)
+
+#define gcmPTR_TO_UINT64(p) \
+( \
+    (gctUINT64) (p)\
+)
+
+#define gcmUINT64_TO_PTR(u) \
+( \
+    (gctPOINTER) (u)\
+)
+
+#else /* 32 bit */
+
+#define gcmALL_TO_UINT32(t) \
+( \
+    (gctUINT32) (t)\
+)
+
+#define gcmPTR_TO_UINT64(p) \
+( \
+    (gctUINT64) (gctUINTPTR_T) (p)\
+)
+
+#define gcmUINT64_TO_PTR(u) \
+( \
+    (gctPOINTER) (gctUINTPTR_T) (u)\
+)
+
+#endif
+
+#define gcmUINT64_TO_TYPE(u, t) \
+( \
+    (t) (gctUINTPTR_T) (u)\
+)
+
+/******************************************************************************\
 ******************************** Useful Macro *********************************
 \******************************************************************************/
 
@@ -579,11 +630,19 @@ gckOS_AtomClearMask(
 #endif
 
 gceSTATUS
-gckOS_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
+gckOS_DumpCallStack(
+    IN gckOS Os
     );
 
+gceSTATUS
+gckOS_GetProcessNameByPid(
+    IN gctINT Pid,
+    IN gctSIZE_T Length,
+    OUT gctUINT8_PTR String
+    );
+
+
+
 /*******************************************************************************
 **
 **  gckOS_AtomConstruct
@@ -1267,6 +1326,33 @@ gckOS_ResetGPU(
     IN gceCORE Core
     );
 
+gceSTATUS
+gckOS_PrepareGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_FinishGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_QueryGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gctUINT32 * Frequency,
+    OUT gctUINT8 * Scale
+    );
+
+gceSTATUS
+gckOS_SetGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT8 Scale
+    );
+
 /*******************************************************************************
 ** Semaphores.
 */
@@ -1331,7 +1417,7 @@ gckOS_CreateTimer(
 
 /* Destory a timer. */
 gceSTATUS
-gckOS_DestoryTimer(
+gckOS_DestroyTimer(
     IN gckOS Os,
     IN gctPOINTER Timer
     );
@@ -1406,6 +1492,7 @@ gckHEAP_ProfileEnd(
 typedef struct _gckVIDMEM *         gckVIDMEM;
 typedef struct _gckKERNEL *         gckKERNEL;
 typedef struct _gckDB *             gckDB;
+typedef struct _gckDVFS *           gckDVFS;
 
 /* Construct a new gckVIDMEM object. */
 gceSTATUS
@@ -1696,6 +1783,27 @@ gckKERNEL_CloseUserData(
     OUT gctPOINTER * KernelPointer
     );
 
+gceSTATUS
+gckDVFS_Construct(
+    IN gckHARDWARE Hardware,
+    OUT gckDVFS * Frequency
+    );
+
+gceSTATUS
+gckDVFS_Destroy(
+    IN gckDVFS Dvfs
+    );
+
+gceSTATUS
+gckDVFS_Start(
+    IN gckDVFS Dvfs
+    );
+
+gceSTATUS
+gckDVFS_Stop(
+    IN gckDVFS Dvfs
+    );
+
 /******************************************************************************\
 ******************************* gckHARDWARE Object *****************************
 \******************************************************************************/
@@ -1964,6 +2072,12 @@ gckHARDWARE_QueryPowerManagementState(
     OUT gceCHIPPOWERSTATE* State
     );
 
+gceSTATUS
+gckHARDWARE_SetPowerManagement(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    );
+
 #if gcdENABLE_FSCALE_VAL_ADJUST
 gceSTATUS
 gckHARDWARE_SetFscaleValue(
@@ -2045,6 +2159,28 @@ gckHARDWARE_DumpMMUException(
     IN gckHARDWARE Hardware
     );
 
+gceSTATUS
+gckHARDWARE_DumpGPUState(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_InitDVFS(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_QueryLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 * Load
+    );
+
+gceSTATUS
+gckHARDWARE_SetDVFSPeroid(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 Frequency
+    );
+
 #if !gcdENABLE_VG
 /******************************************************************************\
 ***************************** gckINTERRUPT Object ******************************
@@ -2114,7 +2250,8 @@ gckEVENT_AddList(
     IN gckEVENT Event,
     IN gcsHAL_INTERFACE_PTR Interface,
     IN gceKERNEL_WHERE FromWhere,
-    IN gctBOOL AllocateAllowed
+    IN gctBOOL AllocateAllowed,
+    IN gctBOOL FromKernel
     );
 
 /* Schedule a FreeNonPagedMemory event. */
@@ -2168,6 +2305,18 @@ gckEVENT_CommitDone(
     IN gceKERNEL_WHERE FromWhere
     );
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+/* Schedule a FreeVirtualCommandBuffer event. */
+gceSTATUS
+gckEVENT_DestroyVirtualCommandBuffer(
+    IN gckEVENT Event,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gceKERNEL_WHERE FromWhere
+    );
+#endif
+
 gceSTATUS
 gckEVENT_Submit(
     IN gckEVENT Event,
@@ -2303,6 +2452,13 @@ gckCOMMAND_Detach(
     IN gckCONTEXT Context
     );
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckCOMMAND_DumpExecutingBuffer(
+    IN gckCOMMAND Command
+    );
+#endif
+
 /******************************************************************************\
 ********************************* gckMMU Object ********************************
 \******************************************************************************/
@@ -2382,11 +2538,18 @@ gckMMU_Flush(
     IN gckMMU Mmu
     );
 
+gceSTATUS
+gckMMU_DumpPageTableEntry(
+    IN gckMMU Mmu,
+    IN gctUINT32 Address
+    );
+
 
 #if VIVANTE_PROFILER
 gceSTATUS
 gckHARDWARE_QueryProfileRegisters(
     IN gckHARDWARE Hardware,
+    IN gctBOOL   Clear,
     OUT gcsPROFILER_COUNTERS * Counters
     );
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index 7cfd2e1..44689b0 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_base_h_
 #define __gc_hal_base_h_
 
@@ -58,6 +56,8 @@ typedef struct _gcoDUMP *               gcoDUMP;
 typedef struct _gcoHARDWARE *           gcoHARDWARE;
 typedef union  _gcuVIDMEM_NODE *        gcuVIDMEM_NODE_PTR;
 
+typedef struct gcsATOM *                gcsATOM_PTR;
+
 #if gcdENABLE_VG
 typedef struct _gcoVG *                 gcoVG;
 typedef struct _gcsCOMPLETION_SIGNAL *	gcsCOMPLETION_SIGNAL_PTR;
@@ -66,10 +66,14 @@ typedef struct _gcsCONTEXT_MAP *		gcsCONTEXT_MAP_PTR;
 typedef void *                          gcoVG;
 #endif
 
+#if gcdSYNC
+typedef struct _gcoFENCE *              gcoFENCE;
+typedef struct _gcsSYNC_CONTEXT  *      gcsSYNC_CONTEXT_PTR;
+#endif
+
 /******************************************************************************\
 ******************************* Process local storage *************************
 \******************************************************************************/
-
 typedef struct _gcsPLS * gcsPLS_PTR;
 typedef struct _gcsPLS
 {
@@ -97,6 +101,16 @@ typedef struct _gcsPLS
     gctPOINTER                  eglSurfaceInfo;
     gceSURF_FORMAT              eglConfigFormat;
 
+    /* PorcessID of the constrcutor process */
+    gctUINT32                   processID;
+
+    /* Reference count for destructor. */
+    gcsATOM_PTR                 reference;
+    gctBOOL                     bKFS;
+#if gcdUSE_NPOT_PATCH
+    gctBOOL                     bNeedSupportNP2Texture;
+#endif
+
 }
 gcsPLS;
 
@@ -109,7 +123,7 @@ extern gcsPLS gcPLS;
 typedef struct _gcsTLS * gcsTLS_PTR;
 
 typedef void (* gctTLS_DESTRUCTOR) (
-    gcsTLS_PTR TLS
+    gcsTLS_PTR
     );
 
 typedef struct _gcsTLS
@@ -129,6 +143,9 @@ typedef struct _gcsTLS
 #ifndef VIVANTE_NO_3D
 	gco3D						engine3D;
 #endif
+#if gcdSYNC
+    gctBOOL                     fenceEnable;
+#endif
 	gco2D						engine2D;
     gctBOOL                     copied;
 }
@@ -360,6 +377,11 @@ gcoHAL_GetFscaleValue(
     OUT gctUINT * MaxFscaleValue
     );
 
+gceSTATUS
+gcoHAL_SetBltNP2Texture(
+    gctBOOL enable
+    );
+
 #ifndef VIVANTE_NO_3D
 /* Get pointer to gco3D object. */
 gceSTATUS
@@ -636,8 +658,6 @@ gcoHAL_QueryChipFeature(
     IN gceFEATURE   Feature);
 
 #endif
-
-
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
 \******************************************************************************/
@@ -1006,29 +1026,6 @@ gcoOS_GetPos(
     OUT gctUINT32 * Position
     );
 
-/* Perform a memory copy. */
-gceSTATUS
-gcoOS_MemCopy(
-    IN gctPOINTER Destination,
-    IN gctCONST_POINTER Source,
-    IN gctSIZE_T Bytes
-    );
-
-/* Perform a memory fill. */
-gceSTATUS
-gcoOS_MemFill(
-    IN gctPOINTER Destination,
-    IN gctUINT8 Filler,
-    IN gctSIZE_T Bytes
-    );
-
-/* Zero memory. */
-gceSTATUS
-gcoOS_ZeroMemory(
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Bytes
-    );
-
 /* Same as strstr. */
 gceSTATUS
 gcoOS_StrStr(
@@ -1046,12 +1043,6 @@ gcoOS_StrFindReverse(
     );
 
 gceSTATUS
-gcoOS_StrLen(
-    IN gctCONST_STRING String,
-    OUT gctSIZE_T * Length
-    );
-
-gceSTATUS
 gcoOS_StrDup(
     IN gcoOS Os,
     IN gctCONST_STRING String,
@@ -1097,13 +1088,15 @@ gcoOS_StrToFloat(
     );
 
 /* Convert hex string to integer. */
-gceSTATUS gcoOS_HexStrToInt(
+gceSTATUS
+gcoOS_HexStrToInt(
 	IN gctCONST_STRING String,
 	OUT gctINT * Int
 	);
 
 /* Convert hex string to float. */
-gceSTATUS gcoOS_HexStrToFloat(
+gceSTATUS
+gcoOS_HexStrToFloat(
 	IN gctCONST_STRING String,
 	OUT gctFLOAT * Float
 	);
@@ -1182,6 +1175,11 @@ gcoOS_SetProfileSetting(
         );
 #endif
 
+gctBOOL
+gcoOS_IsNeededSupportNP2Texture(
+    IN gctCHAR* ProcName
+    );
+
 /* Query the video memory. */
 gceSTATUS
 gcoOS_QueryVideoMemory(
@@ -1207,11 +1205,14 @@ gcoOS_DetectProcessByName(
     IN gctCONST_STRING Name
     );
 
+gceSTATUS
+gcoOS_DetectProcessByEncryptedName(
+    IN gctCONST_STRING Name
+    );
+
 /*----------------------------------------------------------------------------*/
 /*----- Atoms ----------------------------------------------------------------*/
 
-typedef struct gcsATOM * gcsATOM_PTR;
-
 /* Construct an atom. */
 gceSTATUS
 gcoOS_AtomConstruct(
@@ -1421,7 +1422,7 @@ gcoOS_ReadRegister(
 gceSTATUS
 gcoOS_CacheClean(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1429,7 +1430,7 @@ gcoOS_CacheClean(
 gceSTATUS
 gcoOS_CacheFlush(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1437,7 +1438,7 @@ gcoOS_CacheFlush(
 gceSTATUS
 gcoOS_CacheInvalidate(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1767,25 +1768,11 @@ gcoSURF_MapUserSurface(
 gceSTATUS
 gcoSURF_QueryVidMemNode(
     IN gcoSURF Surface,
-    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT64 * Node,
     OUT gcePOOL * Pool,
     OUT gctUINT_PTR Bytes
     );
 
-/*  Set usage attribute of a surface. */
-gceSTATUS
-gcoSURF_SetUsage(
-    IN gcoSURF Surface,
-    IN gceSURF_USAGE Usage
-    );
-
-/*  Return usage attribute of a surface. */
-gceSTATUS
-gcoSURF_QueryUsage(
-    IN gcoSURF Surface,
-    OUT gceSURF_USAGE *Usage
-    );
-
 /* Set the color type of the surface. */
 gceSTATUS
 gcoSURF_SetColorType(
@@ -1972,6 +1959,14 @@ gcoSURF_SetWindow(
     IN gctUINT Height
     );
 
+/* Set width/height alignment of the surface directly and calculate stride/size. This is only for dri backend now. Please be careful before use. */
+gceSTATUS
+gcoSURF_SetAlignment(
+    IN gcoSURF Surface,
+    IN gctUINT Width,
+    IN gctUINT Height
+    );
+
 /* Increase reference count of the surface. */
 gceSTATUS
 gcoSURF_ReferenceSurface(
@@ -2006,6 +2001,12 @@ gcoSURF_SetOffset(
     );
 
 gceSTATUS
+gcoSURF_GetOffset(
+    IN gcoSURF Surface,
+    OUT gctUINT *Offset
+    );
+
+gceSTATUS
 gcoSURF_NODE_Cache(
     IN gcsSURF_NODE_PTR Node,
     IN gctPOINTER Logical,
@@ -2431,6 +2432,7 @@ gcoOS_DebugTrace(
 #define gcvZONE_DEVICE          (1 << 10)
 #define gcvZONE_DATABASE        (1 << 11)
 #define gcvZONE_INTERRUPT       (1 << 12)
+#define gcvZONE_POWER           (1 << 13)
 
 /* User zones. */
 #define gcvZONE_HAL             (1 << 3)
@@ -3645,6 +3647,7 @@ gckOS_DebugStatus2Name(
 #   define gcmDEBUG_VERIFY_ARGUMENT(arg)
 #   define gcmkDEBUG_VERIFY_ARGUMENT(arg)
 #endif
+
 /*******************************************************************************
 **
 **  gcmVERIFY_ARGUMENT_RETURN
@@ -3702,6 +3705,7 @@ gcGetUserDebugOption(
     void
     );
 
+#if gcdHAS_ELLIPSES
 #define gcmUSER_DEBUG_MSG(level, ...) \
     do \
     { \
@@ -3713,6 +3717,11 @@ gcGetUserDebugOption(
 
 #define gcmUSER_DEBUG_ERROR_MSG(...)   gcmUSER_DEBUG_MSG(gcvDEBUG_MSG_ERROR, "Error: " __VA_ARGS__)
 #define gcmUSER_DEBUG_WARNING_MSG(...) gcmUSER_DEBUG_MSG(gcvDEBUG_MSG_WARNING, "Warring: " __VA_ARGS__)
+#else
+#define gcmUSER_DEBUG_MSG
+#define gcmUSER_DEBUG_ERROR_MSG
+#define gcmUSER_DEBUG_WARNING_MSG
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
index 8d50c97..8693c37 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /*
 **	Include file the defines the front- and back-end compilers, as well as the
 **	objects they use.
@@ -38,9 +36,16 @@ extern "C" {
 #endif
 
 #ifndef GC_ENABLE_LOADTIME_OPT
-#define GC_ENABLE_LOADTIME_OPT      1
+#define GC_ENABLE_LOADTIME_OPT           1
 #endif
 
+#define TEMP_OPT_CONSTANT_TEXLD_COORD    1
+
+#define TEMP_SHADER_PATCH                1
+
+#define ADD_PRE_ROTATION_TO_VS           0
+
+#define TEMP_INLINE_ALL_EXPANSION            1
 /******************************* IR VERSION ******************/
 #define gcdSL_IR_VERSION gcmCC('\0','\0','\0','\1')
 
@@ -48,6 +53,126 @@ extern "C" {
 |******************************* SHADER LANGUAGE ******************************|
 \******************************************************************************/
 
+    /* allocator/deallocator function pointer */
+typedef gceSTATUS (*gctAllocatorFunc)(
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+typedef gceSTATUS (*gctDeallocatorFunc)(
+    IN gctPOINTER Memory
+    );
+
+typedef gctBOOL (*compareFunc) (
+     IN void *    data,
+     IN void *    key
+     );
+
+typedef struct _gcsListNode gcsListNode;
+struct _gcsListNode
+{
+    gcsListNode *       next;
+    void *              data;
+};
+
+typedef struct _gcsAllocator
+{
+    gctAllocatorFunc    allocate;
+    gctDeallocatorFunc  deallocate;
+} gcsAllocator;
+
+/* simple map structure */
+typedef struct _SimpleMap SimpleMap;
+struct _SimpleMap
+{
+    gctUINT32     key;
+    gctUINT32     val;
+    SimpleMap    *next;
+    gcsAllocator *allocator;
+
+};
+
+/* SimpleMap Operations */
+/* return -1 if not found, otherwise return the mapped value */
+gctUINT32
+gcSimpleMap_Find(
+     IN SimpleMap *Map,
+     IN gctUINT32    Key
+     );
+
+gceSTATUS
+gcSimpleMap_Destory(
+     IN SimpleMap *    Map,
+     IN gcsAllocator * Allocator
+     );
+
+/* Add a pair <Key, Val> to the Map head, the user should be aware that the
+ * map pointer is always changed when adding a new node :
+ *
+ *   gcSimpleMap_AddNode(&theMap, key, val, allocator);
+ *
+ */
+gceSTATUS
+gcSimpleMap_AddNode(
+     IN SimpleMap **   Map,
+     IN gctUINT32      Key,
+     IN gctUINT32      Val,
+     IN gcsAllocator * Allocator
+     );
+
+/* gcsList data structure and related operations */
+typedef struct _gcsList
+{
+    gcsListNode  *head;
+    gcsListNode  *tail;
+    gctINT        count;
+    gcsAllocator *allocator;
+} gcsList;
+
+/* List operations */
+void
+gcList_Init(
+    IN gcsList *list,
+    IN gcsAllocator *allocator
+    );
+
+gceSTATUS
+gcList_CreateNode(
+    IN void *             Data,
+    IN gctAllocatorFunc   Allocator,
+    OUT gcsListNode **    ListNode
+    );
+
+gceSTATUS
+gcList_Clean(
+    IN gcsList *          List,
+    IN gctBOOL            FreeData
+    );
+
+gcsListNode *
+gcList_FindNode(
+    IN gcsList *      List,
+    IN void *         Key,
+    IN compareFunc    compare
+    );
+
+gceSTATUS
+gcList_AddNode(
+    IN gcsList *          List,
+    IN void *             Data
+    );
+
+gceSTATUS
+gcList_RemoveNode(
+    IN gcsList *          List,
+    IN gcsListNode *      Node
+    );
+
+/*  link list structure for code list */
+typedef gcsList gcsCodeList;
+typedef gcsCodeList * gctCodeList;
+typedef gcsListNode gcsCodeListNode;
+
 /* Possible shader language opcodes. */
 typedef enum _gcSL_OPCODE
 {
@@ -146,6 +271,7 @@ typedef enum _gcSL_OPCODE
 	gcSL_ADDSAT,						/* 0x5C */  /* Integer only. */
 	gcSL_SUBSAT,						/* 0x5D */  /* Integer only. */
 	gcSL_MULSAT,						/* 0x5E */  /* Integer only. */
+	gcSL_MAXOPCODE
 }
 gcSL_OPCODE;
 
@@ -340,6 +466,14 @@ struct _gcsHINT
     /* Flag whether the VS has point size or not. */
     gctBOOL     vsHasPointSize;
 
+#if gcdUSE_WCLIP_PATCH
+    /* Flag whether the VS gl_position.z depends on gl_position.w
+       it's a hint for wclipping */
+    gctBOOL     vsPositionZDependsOnW;
+#endif
+
+    gctBOOL     clipW;
+
     /* Element count. */
     gctUINT32   elementCount;
 
@@ -379,13 +513,20 @@ struct _gcsHINT
     gctUINT32   colorKillInstruction[3];
 #endif
 
+#if TEMP_SHADER_PATCH
+	gctUINT32	pachedShaderIdentifier;
+#endif
 };
 
+#if TEMP_SHADER_PATCH
+#define INVALID_SHADER_IDENTIFIER 0xFFFFFFFF
+#endif
+
 /* gcSHADER_TYPE enumeration. */
 typedef enum _gcSHADER_TYPE
 {
-	gcSHADER_FLOAT_X1,				/* 0x00 */
-	gcSHADER_FLOAT_X2,				/* 0x01 */
+    gcSHADER_FLOAT_X1   = 0,        /* 0x00 */
+    gcSHADER_FLOAT_X2,				/* 0x01 */
 	gcSHADER_FLOAT_X3,				/* 0x02 */
 	gcSHADER_FLOAT_X4,				/* 0x03 */
 	gcSHADER_FLOAT_2X2,				/* 0x04 */
@@ -423,10 +564,50 @@ typedef enum _gcSHADER_TYPE
 	gcSHADER_USAMPLER_3D,			/* 0x24 */
 	gcSHADER_USAMPLER_CUBIC,		/* 0x25 */
 	gcSHADER_SAMPLER_EXTERNAL_OES,		/* 0x26 */
-    gcSHADER_TYPE_COUNT
-}
+
+	gcSHADER_UINT_X1,			/* 0x27 */
+	gcSHADER_UINT_X2,			/* 0x28 */
+	gcSHADER_UINT_X3,			/* 0x29 */
+	gcSHADER_UINT_X4,			/* 0x2A */
+
+    gcSHADER_UNKONWN_TYPE,      /* do not add type after this */
+    gcSHADER_TYPE_COUNT         /* must to change gcvShaderTypeInfo at the
+                                 * same time if you add any new type! */}
 gcSHADER_TYPE;
 
+typedef enum _gcSHADER_TYPE_KIND
+{
+    gceTK_UNKOWN,
+    gceTK_FLOAT,
+    gceTK_INT,
+    gceTK_UINT,
+    gceTK_BOOL,
+    gceTK_FIXED,
+    gceTK_SAMPLER,
+    gceTK_IMAGE,
+    gceTK_OTHER
+} gcSHADER_TYPE_KIND;
+
+typedef struct _gcSHADER_TYPEINFO
+{
+    gcSHADER_TYPE      type;              /* e.g. gcSHADER_FLOAT_2X4 */
+    gctINT             components;        /* e.g. 4 components       */
+    gctINT             rows;              /* e.g. 2 rows             */
+    gcSHADER_TYPE      componentType;     /* e.g. gcSHADER_FLOAT_X4  */
+    gcSHADER_TYPE_KIND kind;              /* e.g. gceTK_FLOAT */
+    gctCONST_STRING    name;              /* e.g. "FLOAT_2X4" */
+} gcSHADER_TYPEINFO;
+
+extern gcSHADER_TYPEINFO gcvShaderTypeInfo[];
+
+#define gcmType_Comonents(Type)    (gcvShaderTypeInfo[Type].components)
+#define gcmType_Rows(Type)         (gcvShaderTypeInfo[Type].rows)
+#define gcmType_ComonentType(Type) (gcvShaderTypeInfo[Type].componentType)
+#define gcmType_Kind(Type)         (gcvShaderTypeInfo[Type].kind)
+#define gcmType_Name(Type)         (gcvShaderTypeInfo[Type].name)
+
+#define gcmType_isMatrix(type) (gcmType_Rows(type) > 1)
+
 typedef enum _gcSHADER_VAR_CATEGORY
 {
     gcSHADER_VAR_CATEGORY_NORMAL  =  0, /* primitive type and its array */
@@ -443,7 +624,6 @@ typedef enum _gceTYPE_QUALIFIER
 typedef gctUINT16  gctTYPE_QUALIFIER;
 
 #if GC_ENABLE_LOADTIME_OPT
-
 typedef struct _gcSHADER_TYPE_INFO
 {
     gcSHADER_TYPE    type;        /* eg. gcSHADER_FLOAT_2X3 is the type */
@@ -454,6 +634,8 @@ typedef struct _gcSHADER_TYPE_INFO
     gctINT           size;        /* the size in byte */
 } gcSHADER_TYPE_INFO;
 
+extern gcSHADER_TYPE_INFO shader_type_info[];
+
 enum gceLTCDumpOption {
     gceLTC_DUMP_UNIFORM      = 0x0001,
     gceLTC_DUMP_EVALUATION   = 0x0002,
@@ -463,11 +645,8 @@ enum gceLTCDumpOption {
 
 gctBOOL gcDumpOption(gctINT Opt);
 
-extern gcSHADER_TYPE_INFO shader_type_info[];
-
 #endif /* GC_ENABLE_LOADTIME_OPT */
 
-
 #define IS_MATRIX_TYPE(type) \
     (((type >= gcSHADER_FLOAT_2X2) && (type <= gcSHADER_FLOAT_4X4)) || \
      ((type >= gcSHADER_FLOAT_2X3) && (type <= gcSHADER_FLOAT_4X3)))
@@ -508,9 +687,301 @@ typedef enum _gceSHADER_FLAGS
     gcvSHADER_USE_ALPHA_KILL            = 0x100,
 #endif
 
+#if ADD_PRE_ROTATION_TO_VS
+    gcvSHADER_VS_PRE_ROTATION           = 0x200,
+#endif
+
+#if TEMP_INLINE_ALL_EXPANSION
+    gcvSHADER_INLINE_ALL_EXPANSION      = 0x200,
+#endif
 }
 gceSHADER_FLAGS;
 
+gceSTATUS
+gcSHADER_CheckClipW(
+    IN gctCONST_STRING VertexSource,
+    IN gctCONST_STRING FragmentSource,
+    OUT gctBOOL * clipW);
+
+/*******************************************************************************
+**							gcOptimizer Data Structures
+*******************************************************************************/
+typedef enum _gceSHADER_OPTIMIZATION
+{
+    /*  No optimization. */
+	gcvOPTIMIZATION_NONE,
+
+    /*  Flow graph construction. */
+	gcvOPTIMIZATION_CONSTRUCTION                = 1 << 0,
+
+    /*  Dead code elimination. */
+	gcvOPTIMIZATION_DEAD_CODE                   = 1 << 1,
+
+    /*  Redundant move instruction elimination. */
+	gcvOPTIMIZATION_REDUNDANT_MOVE              = 1 << 2,
+
+    /*  Inline expansion. */
+	gcvOPTIMIZATION_INLINE_EXPANSION            = 1 << 3,
+
+    /*  Constant propagation. */
+	gcvOPTIMIZATION_CONSTANT_PROPAGATION        = 1 << 4,
+
+    /*  Redundant bounds/checking elimination. */
+	gcvOPTIMIZATION_REDUNDANT_CHECKING          = 1 << 5,
+
+    /*  Loop invariant movement. */
+	gcvOPTIMIZATION_LOOP_INVARIANT              = 1 << 6,
+
+    /*  Induction variable removal. */
+	gcvOPTIMIZATION_INDUCTION_VARIABLE          = 1 << 7,
+
+    /*  Common subexpression elimination. */
+	gcvOPTIMIZATION_COMMON_SUBEXPRESSION        = 1 << 8,
+
+    /*  Control flow/banch optimization. */
+	gcvOPTIMIZATION_CONTROL_FLOW                = 1 << 9,
+
+    /*  Vector component operation merge. */
+	gcvOPTIMIZATION_VECTOR_INSTRUCTION_MERGE    = 1 << 10,
+
+    /*  Algebra simplificaton. */
+	gcvOPTIMIZATION_ALGEBRAIC_SIMPLIFICATION    = 1 << 11,
+
+    /*  Pattern matching and replacing. */
+	gcvOPTIMIZATION_PATTERN_MATCHING            = 1 << 12,
+
+    /*  Interprocedural constant propagation. */
+	gcvOPTIMIZATION_IP_CONSTANT_PROPAGATION     = 1 << 13,
+
+    /*  Interprecedural register optimization. */
+	gcvOPTIMIZATION_IP_REGISTRATION             = 1 << 14,
+
+    /*  Optimization option number. */
+	gcvOPTIMIZATION_OPTION_NUMBER               = 1 << 15,
+
+	/*  Loadtime constant. */
+    gcvOPTIMIZATION_LOADTIME_CONSTANT           = 1 << 16,
+
+    /*  MAD instruction optimization. */
+	gcvOPTIMIZATION_MAD_INSTRUCTION             = 1 << 17,
+
+    /*  Special optimization for LOAD SW workaround. */
+	gcvOPTIMIZATION_LOAD_SW_WORKAROUND          = 1 << 18,
+
+    /* move code into conditional block if possile */
+	gcvOPTIMIZATION_CONDITIONALIZE              = 1 << 19,
+
+    /* expriemental: power optimization mode
+        1. add extra dummy texld to tune performance
+        2. insert NOP after high power instrucitons
+        3. split high power vec3/vec4 instruciton to vec2/vec1 operation
+        4. ...
+     */
+	gcvOPTIMIZATION_POWER_OPTIMIZATION           = 1 << 20,
+
+    /* optimize varying packing */
+    gcvOPTIMIZATION_VARYINGPACKING              = 1 << 22,
+
+#if TEMP_INLINE_ALL_EXPANSION
+	gcvOPTIMIZATION_INLINE_ALL_EXPANSION        = 1 << 23,
+#endif
+
+    /*  Full optimization. */
+    /*  Note that gcvOPTIMIZATION_LOAD_SW_WORKAROUND is off. */
+	gcvOPTIMIZATION_FULL                        = 0x7FFFFFFF &
+                                                  ~gcvOPTIMIZATION_LOAD_SW_WORKAROUND &
+                                                  ~gcvOPTIMIZATION_INLINE_ALL_EXPANSION &
+                                                  ~gcvOPTIMIZATION_POWER_OPTIMIZATION,
+
+	/* Optimization Unit Test flag. */
+    gcvOPTIMIZATION_UNIT_TEST                   = 1 << 31
+}
+gceSHADER_OPTIMIZATION;
+
+typedef enum _gceOPTIMIZATION_VaryingPaking
+{
+    gcvOPTIMIZATION_VARYINGPACKING_NONE = 0,
+    gcvOPTIMIZATION_VARYINGPACKING_NOSPLIT,
+    gcvOPTIMIZATION_VARYINGPACKING_SPLIT
+} gceOPTIMIZATION_VaryingPaking;
+
+typedef struct _gcOPTIMIZER_OPTION
+{
+    gceSHADER_OPTIMIZATION     optFlags;
+
+    /* debug & dump options:
+
+         VC_OPTION=-DUMP:SRC:OPT|:OPTV|:CG|:CGV:|ALL|ALLV
+
+         SRC:  dump shader source code
+         OPT:  dump incoming and final IR
+         OPTV: dump result IR in each optimization phase
+         CG:   dump generated machine code
+         CGV:  dump BE tree and optimization detail
+
+         ALL = SRC|OPT|CG
+         ALLV = SRC|OPT|OPTV|CG|CGV
+     */
+    gctBOOL     dumpShaderSource;      /* dump shader source code */
+    gctBOOL     dumpOptimizer;         /* dump incoming and final IR */
+    gctBOOL     dumpOptimizerVerbose;  /* dump result IR in each optimization phase */
+    gctBOOL     dumpBEGenertedCode;    /* dump generated machine code */
+    gctBOOL     dumpBEVerbose;         /* dump BE tree and optimization detail */
+
+    /* Code generation */
+
+    /* Varying Packing:
+
+          VC_OPTION=-PACKVARYING:[0-2]|:T[-]m[,n]|:LshaderIdx,min,max
+
+          0: turn off varying packing
+          1: pack varyings, donot split any varying
+          2: pack varyings, may split to make fully packed output
+
+          Tm:    only packing shader pair which vertex shader id is m
+          Tm,n:  only packing shader pair which vertex shader id
+                   is in range of [m, n]
+          T-m:   do not packing shader pair which vertex shader id is m
+          T-m,n: do not packing shader pair which vertex shader id
+                   is in range of [m, n]
+
+          LshaderIdx,min,max : set  load balance (min, max) for shaderIdx
+                               if shaderIdx is -1, all shaders are impacted
+                               newMin = origMin * (min/100.);
+                               newMax = origMax * (max/100.);
+     */
+    gceOPTIMIZATION_VaryingPaking    packVarying;
+    gctINT                           _triageStart;
+    gctINT                           _triageEnd;
+    gctINT                           _loadBalanceShaderIdx;
+    gctINT                           _loadBalanceMin;
+    gctINT                           _loadBalanceMax;
+
+    /* Do not generate immdeiate
+
+          VC_OPTION=-NOIMM
+
+       Force generate immediate even the machine model don't support it,
+       for testing purpose only
+
+          VC_OPTION=-FORCEIMM
+     */
+    gctBOOL     noImmediate;
+    gctBOOL     forceImmediate;
+
+    /* Power reduction mode options */
+    gctBOOL   needPowerOptimization;
+
+    /* Patch TEXLD instruction by adding dummy texld
+       (can be used to tune GPU power usage):
+         for every TEXLD we seen, add n dummy TEXLD
+
+        it can be enabled by environment variable:
+
+          VC_OPTION=-PATCH_TEXLD:M:N
+
+        (for each M texld, add N dummy texld)
+     */
+    gctINT      patchEveryTEXLDs;
+    gctINT      patchDummyTEXLDs;
+
+    /* Insert NOP after high power consumption instructions
+
+         VC_OPTION="-INSERTNOP:MUL:MULLO:DP3:DP4:SEENTEXLD"
+     */
+    gctBOOL     insertNOP;
+    gctBOOL     insertNOPAfterMUL;
+    gctBOOL     insertNOPAfterMULLO;
+    gctBOOL     insertNOPAfterDP3;
+    gctBOOL     insertNOPAfterDP4;
+    gctBOOL     insertNOPOnlyWhenTexldSeen;
+
+    /* split MAD to MUL and ADD:
+
+         VC_OPTION=-SPLITMAD
+     */
+    gctBOOL     splitMAD;
+
+    /* Convert vect3/vec4 operations to multiple vec2/vec1 operations
+
+         VC_OPTION=-SPLITVEC:MUL:MULLO:DP3:DP4
+     */
+    gctBOOL     splitVec;
+    gctBOOL     splitVec4MUL;
+    gctBOOL     splitVec4MULLO;
+    gctBOOL     splitVec4DP3;
+    gctBOOL     splitVec4DP4;
+
+    /* turn/off features:
+
+          VC_OPTION=-F:n,[0|1]
+          Note: n must be decimal number
+     */
+    gctUINT     featureBits;
+
+    /* inline level (default 2 at O1):
+
+          VC_OPTION=-INLINELEVEL:[0-3]
+             0:  no inline
+             1:  only inline the function only called once or small function
+             2:  inline functions be called less than 5 times or medium size function
+             3:  inline everything possible
+     */
+    gctUINT     inlineLevel;
+} gcOPTIMIZER_OPTION;
+
+extern gcOPTIMIZER_OPTION theOptimizerOption;
+#define gcmGetOptimizerOption() gcGetOptimizerOption()
+
+#define gcmOPT_DUMP_SHADER_SRC()         \
+             (gcmGetOptimizerOption()->dumpShaderSource != 0)
+#define gcmOPT_DUMP_OPTIMIZER()          \
+             (gcmGetOptimizerOption()->dumpOptimizer != 0 || \
+              gcmOPT_DUMP_OPTIMIZER_VERBOSE() )
+#define gcmOPT_DUMP_OPTIMIZER_VERBOSE()  \
+             (gcmGetOptimizerOption()->dumpOptimizerVerbose != 0)
+#define gcmOPT_DUMP_CODEGEN()            \
+             (gcmGetOptimizerOption()->dumpBEGenertedCode != 0 || \
+              gcmOPT_DUMP_CODEGEN_VERBOSE() )
+#define gcmOPT_DUMP_CODEGEN_VERBOSE()    \
+             (gcmGetOptimizerOption()->dumpBEVerbose != 0)
+
+#define gcmOPT_SET_DUMP_SHADER_SRC(v)   \
+             gcmGetOptimizerOption()->dumpShaderSource = (v)
+
+#define gcmOPT_PATCH_TEXLD()  (gcmGetOptimizerOption()->patchDummyTEXLDs != 0)
+#define gcmOPT_INSERT_NOP()   (gcmGetOptimizerOption()->insertNOP == gcvTRUE)
+#define gcmOPT_SPLITMAD()     (gcmGetOptimizerOption()->splitMAD == gcvTRUE)
+#define gcmOPT_SPLITVEC()     (gcmGetOptimizerOption()->splitVec == gcvTRUE)
+
+#define gcmOPT_NOIMMEDIATE()  (gcmGetOptimizerOption()->noImmediate == gcvTRUE)
+#define gcmOPT_FORCEIMMEDIATE()  (gcmGetOptimizerOption()->forceImmediate == gcvTRUE)
+
+#define gcmOPT_PACKVARYING()     (gcmGetOptimizerOption()->packVarying)
+#define gcmOPT_PACKVARYING_triageStart()   (gcmGetOptimizerOption()->_triageStart)
+#define gcmOPT_PACKVARYING_triageEnd()     (gcmGetOptimizerOption()->_triageEnd)
+
+#define gcmOPT_INLINELEVEL()     (gcmGetOptimizerOption()->inlineLevel)
+
+/* Setters */
+#define gcmOPT_SetPatchTexld(m,n) (gcmGetOptimizerOption()->patchEveryTEXLDs = (m),\
+                                   gcmGetOptimizerOption()->patchDummyTEXLDs = (n))
+#define gcmOPT_SetSplitVecMUL() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4MUL = gcvTRUE)
+#define gcmOPT_SetSplitVecMULLO() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                  gcmGetOptimizerOption()->splitVec4MULLO = gcvTRUE)
+#define gcmOPT_SetSplitVecDP3() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4DP3 = gcvTRUE)
+#define gcmOPT_SetSplitVecDP4() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4DP4 = gcvTRUE)
+
+#define gcmOPT_SetPackVarying(v)     (gcmGetOptimizerOption()->packVarying = v)
+
+#define FB_LIVERANGE_FIX1     0x0001
+
+
+#define PredefinedDummySamplerId       8
+
 /* Function argument qualifier */
 typedef enum _gceINPUT_OUTPUT
 {
@@ -562,6 +1033,50 @@ typedef enum _gceVARIABLE_UPDATE_FLAGS
     gcvVARIABLE_UPDATE_TYPE_QUALIFIER,
 }gceVARIABLE_UPDATE_FLAGS;
 
+typedef struct _gcMACHINE_INST
+{
+    gctUINT        state0;
+    gctUINT        state1;
+    gctUINT        state2;
+    gctUINT        state3;
+}gcMACHINE_INST, *gcMACHINE_INST_PTR;
+
+typedef struct _gcMACHINECODE
+{
+    gcMACHINE_INST_PTR   pCode;          /* machine code  */
+    gctUINT              instCount;      /* 128-bit count */
+    gctUINT              maxConstRegNo;
+    gctUINT              maxTempRegNo;
+    gctUINT              endPCOfMainRoutine;
+}gcMACHINECODE, *gcMACHINECODE_PTR;
+
+typedef enum NP2_ADDRESS_MODE
+{
+    NP2_ADDRESS_MODE_CLAMP  = 0,
+    NP2_ADDRESS_MODE_REPEAT = 1,
+    NP2_ADDRESS_MODE_MIRROR = 2
+}NP2_ADDRESS_MODE;
+
+typedef struct _gcNPOT_PATCH_PARAM
+{
+    gctINT               samplerSlot;
+    NP2_ADDRESS_MODE     addressMode[3];
+    gctINT               texDimension;    /* 2 or 3 */
+}gcNPOT_PATCH_PARAM, *gcNPOT_PATCH_PARAM_PTR;
+
+void
+gcGetOptionFromEnv(
+    IN OUT gcOPTIMIZER_OPTION * Option
+    );
+
+void
+gcSetOptimizerOption(
+    IN gceSHADER_FLAGS Flags
+    );
+
+gcOPTIMIZER_OPTION *
+gcGetOptimizerOption();
+
 /*******************************************************************************
 **  gcSHADER_SetCompilerVersion
 **
@@ -622,6 +1137,9 @@ gcSHADER_GetType(
     IN gcSHADER Shader,
     OUT gctINT *Type
     );
+
+gctUINT
+gcSHADER_NextId();
 /*******************************************************************************
 **                             gcSHADER_Construct
 ********************************************************************************
@@ -2527,6 +3045,14 @@ gcSHADER_CheckValidity(
     IN gcSHADER Shader
     );
 
+#if gcdUSE_WCLIP_PATCH
+gceSTATUS
+gcATTRIBUTE_IsPosition(
+        IN gcATTRIBUTE Attribute,
+        OUT gctBOOL * IsPosition
+        );
+#endif
+
 /*******************************************************************************
 **                             gcATTRIBUTE_GetType
 ********************************************************************************
@@ -3334,7 +3860,9 @@ gcLinkShaders(
 	IN gceSHADER_FLAGS Flags,
 	OUT gctSIZE_T * StateBufferSize,
 	OUT gctPOINTER * StateBuffer,
-	OUT gcsHINT_PTR * Hints
+	OUT gcsHINT_PTR * Hints,
+    OUT gcMACHINECODE_PTR *ppVsMachineCode,
+    OUT gcMACHINECODE_PTR *ppFsMachineCode
 	);
 
 /*******************************************************************************
@@ -3366,6 +3894,24 @@ gcLoadShaders(
 	IN gcsHINT_PTR Hints
 	);
 
+gceSTATUS
+gcRecompileShaders(
+    IN gcoHAL Hal,
+    IN gcMACHINECODE_PTR pVsMachineCode,
+    IN gcMACHINECODE_PTR pPsMachineCode,
+    /*Recompile variables*/
+    IN OUT gctPOINTER *ppRecompileStateBuffer,
+    IN OUT gctSIZE_T *pRecompileStateBufferSize,
+    IN OUT gcsHINT_PTR *ppRecompileHints,
+    /* natvie state*/
+    IN gctPOINTER pNativeStateBuffer,
+    IN gctSIZE_T nativeStateBufferSize,
+    IN gcsHINT_PTR pNativeHints,
+    /* npt info */
+    IN gctUINT32 Samplers,
+    IN gctUINT32 *SamplerWrapS,
+    IN gctUINT32 *SamplerWrapT
+    );
 /*******************************************************************************
 **                                gcSaveProgram
 ********************************************************************************
@@ -3567,6 +4113,31 @@ gcInvokeThreadWalker(
     IN gcsTHREAD_WALKER_INFO_PTR Info
     );
 
+void
+gcTYPE_GetTypeInfo(
+    IN gcSHADER_TYPE      Type,
+    OUT gctINT *          Components,
+    OUT gctINT *          Rows,
+    OUT gctCONST_STRING * Name
+    );
+
+gctBOOL
+gcOPT_doVaryingPackingForShader(
+	IN gcSHADER Shader
+    );
+
+gceSTATUS
+gcSHADER_PatchNPOTForMachineCode(
+    IN     gcSHADER_KIND          shaderType,
+    IN     gcMACHINECODE_PTR      pMachineCode,
+    IN     gcNPOT_PATCH_PARAM_PTR pPatchParam,
+    IN     gctUINT                countOfPatchParam,
+    IN     gctUINT                hwSupportedInstCount,
+    OUT    gctPOINTER*            ppCmdBuffer,
+    OUT    gctUINT32*             pByteSizeOfCmdBuffer,
+    IN OUT gcsHINT_PTR            pHints /* User needs copy original hints to this one, then passed this one in */
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index 898bfb1..b056c52 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_driver_h_
 #define __gc_hal_driver_h_
 
@@ -95,6 +93,9 @@ typedef enum _gceHAL_COMMAND_CODES
 
     gcvHAL_READ_ALL_PROFILE_REGISTERS,
     gcvHAL_PROFILE_REGISTERS_2D,
+#if VIVANTE_PROFILER_PERDRAW
+    gcvHAL_READ_PROFILER_REGISTER_SETTING,
+#endif
 
     /* Power management. */
     gcvHAL_SET_POWER_MANAGEMENT_STATE,
@@ -155,9 +156,16 @@ typedef enum _gceHAL_COMMAND_CODES
     gcvHAL_DUMP_GPU_STATE,
     gcvHAL_DUMP_EVENT,
 
+    /* Virtual command buffer. */
+    gcvHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER,
+    gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER,
+
     /* FSCALE_VAL. */
     gcvHAL_SET_FSCALE_VALUE,
-    gcvHAL_GET_FSCALE_VALUE
+    gcvHAL_GET_FSCALE_VALUE,
+
+    /* Reset time stamp. */
+    gcvHAL_QUERY_RESET_TIME_STAMP,
 }
 gceHAL_COMMAND_CODES;
 
@@ -202,6 +210,9 @@ typedef struct _gcsHAL_QUERY_CHIP_IDENTITY
     /* Supported minor feature 3 fields. */
     gctUINT32                   chipMinorFeatures3;
 
+    /* Supported minor feature 4 fields. */
+    gctUINT32                   chipMinorFeatures4;
+
     /* Number of streams supported. */
     gctUINT32                   streamCount;
 
@@ -245,19 +256,19 @@ typedef struct _gcsHAL_COMPOSE * gcsHAL_COMPOSE_PTR;
 typedef struct _gcsHAL_COMPOSE
 {
     /* Composition state buffer. */
-    gctPHYS_ADDR                physical;
-    gctPOINTER                  logical;
-    gctSIZE_T                   offset;
-    gctSIZE_T                   size;
+    gctUINT64                   physical;
+    gctUINT64                   logical;
+    gctUINT                     offset;
+    gctUINT                     size;
 
     /* Composition end signal. */
-    gctHANDLE                   process;
-    gctSIGNAL                   signal;
+    gctUINT64                   process;
+    gctUINT64                   signal;
 
     /* User signals. */
-    gctHANDLE                   userProcess;
-    gctSIGNAL                   userSignal1;
-    gctSIGNAL                   userSignal2;
+    gctUINT64                   userProcess;
+    gctUINT64                   userSignal1;
+    gctUINT64                   userSignal2;
 
 #if defined(__QNXNTO__)
     /* Client pulse side-channel connection ID. */
@@ -269,6 +280,7 @@ typedef struct _gcsHAL_COMPOSE
 }
 gcsHAL_COMPOSE;
 
+
 typedef struct _gcsHAL_INTERFACE
 {
     /* Command code. */
@@ -281,7 +293,7 @@ typedef struct _gcsHAL_INTERFACE
     gceSTATUS                   status;
 
     /* Handle to this interface channel. */
-    gctHANDLE                   handle;
+    gctUINT64                   handle;
 
     /* Pid of the client. */
     gctUINT32                   pid;
@@ -300,23 +312,23 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_QUERY_VIDEO_MEMORY */
         struct _gcsHAL_QUERY_VIDEO_MEMORY
         {
-            /* Physical memory address of internal memory. */
-            OUT gctPHYS_ADDR            internalPhysical;
+            /* Physical memory address of internal memory. Just a name. */
+            OUT gctUINT32               internalPhysical;
 
-            /* Size in bytes of internal memory.*/
-            OUT gctSIZE_T               internalSize;
+            /* Size in bytes of internal memory. */
+            OUT gctUINT64               internalSize;
 
-            /* Physical memory address of external memory. */
-            OUT gctPHYS_ADDR            externalPhysical;
+            /* Physical memory address of external memory. Just a name. */
+            OUT gctUINT32               externalPhysical;
 
             /* Size in bytes of external memory.*/
-            OUT gctSIZE_T               externalSize;
+            OUT gctUINT64               externalSize;
 
-            /* Physical memory address of contiguous memory. */
-            OUT gctPHYS_ADDR            contiguousPhysical;
+            /* Physical memory address of contiguous memory. Just a name. */
+            OUT gctUINT32               contiguousPhysical;
 
             /* Size in bytes of contiguous memory.*/
-            OUT gctSIZE_T               contiguousSize;
+            OUT gctUINT64               contiguousSize;
         }
         QueryVideoMemory;
 
@@ -326,28 +338,28 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_MAP_MEMORY */
         struct _gcsHAL_MAP_MEMORY
         {
-            /* Physical memory address to map. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical memory address to map. Just a name on Linux/Qnx. */
+            IN gctUINT32                physical;
 
             /* Number of bytes in physical memory to map. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
             /* Address of mapped memory. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64               logical;
         }
         MapMemory;
 
         /* gcvHAL_UNMAP_MEMORY */
         struct _gcsHAL_UNMAP_MEMORY
         {
-            /* Physical memory address to unmap. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical memory address to unmap. Just a name on Linux/Qnx. */
+            IN gctUINT32                physical;
 
             /* Number of bytes in physical memory to unmap. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
             /* Address of mapped memory to unmap. */
-            IN gctPOINTER               logical;
+            IN gctUINT64                logical;
         }
         UnmapMemory;
 
@@ -366,8 +378,8 @@ typedef struct _gcsHAL_INTERFACE
             /* Memory pool to allocate from. */
             IN OUT gcePOOL              pool;
 
-            /* Allocated video memory. */
-            OUT gcuVIDMEM_NODE_PTR      node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            OUT gctUINT64               node;
         }
         AllocateLinearVideoMemory;
 
@@ -392,24 +404,24 @@ typedef struct _gcsHAL_INTERFACE
             /* Memory pool to allocate from. */
             IN OUT gcePOOL              pool;
 
-            /* Allocated video memory. */
-            OUT gcuVIDMEM_NODE_PTR      node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            OUT gctUINT64               node;
         }
         AllocateVideoMemory;
 
         /* gcvHAL_FREE_VIDEO_MEMORY */
         struct _gcsHAL_FREE_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            IN gctUINT64        node;
 
 #ifdef __QNXNTO__
 /* TODO: This is part of the unlock - why is it here? */
             /* Mapped logical address to unmap in user space. */
-            OUT gctPOINTER              memory;
+            OUT gctUINT64       memory;
 
             /* Number of bytes to allocated. */
-            OUT gctSIZE_T               bytes;
+            OUT gctUINT64       bytes;
 #endif
         }
         FreeVideoMemory;
@@ -417,33 +429,33 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_LOCK_VIDEO_MEMORY */
         struct _gcsHAL_LOCK_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory gcuVIDMEM_NODE gcuVIDMEM_NODE. */
+            IN gctUINT64            node;
 
             /* Cache configuration. */
             /* Only gcvPOOL_CONTIGUOUS and gcvPOOL_VIRUTAL
             ** can be configured */
-            IN gctBOOL                  cacheable;
+            IN gctBOOL              cacheable;
 
             /* Hardware specific address. */
-            OUT gctUINT32               address;
+            OUT gctUINT32           address;
 
             /* Mapped logical address. */
-            OUT gctPOINTER              memory;
+            OUT gctUINT64           memory;
         }
         LockVideoMemory;
 
         /* gcvHAL_UNLOCK_VIDEO_MEMORY */
         struct _gcsHAL_UNLOCK_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            IN gctUINT64            node;
 
             /* Type of surface. */
-            IN gceSURF_TYPE             type;
+            IN gceSURF_TYPE         type;
 
             /* Flag to unlock surface asynchroneously. */
-            IN OUT gctBOOL              asynchroneous;
+            IN OUT gctBOOL          asynchroneous;
         }
         UnlockVideoMemory;
 
@@ -451,13 +463,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_NON_PAGED_MEMORY
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64        bytes;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32           physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64           logical;
         }
         AllocateNonPagedMemory;
 
@@ -465,38 +477,66 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_NON_PAGED_MEMORY
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64            bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32            physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64            logical;
         }
         FreeNonPagedMemory;
 
+        /* gcvHAL_ALLOCATE_NON_PAGED_MEMORY */
+        struct _gcsHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER
+        {
+            /* Number of bytes to allocate. */
+            IN OUT gctUINT64        bytes;
+
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32           physical;
+
+            /* Logical address of allocation. */
+            OUT gctUINT64           logical;
+        }
+        AllocateVirtualCommandBuffer;
+
+        /* gcvHAL_FREE_NON_PAGED_MEMORY */
+        struct _gcsHAL_FREE_VIRTUAL_COMMAND_BUFFER
+        {
+            /* Number of bytes allocated. */
+            IN gctUINT64            bytes;
+
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32            physical;
+
+            /* Logical address of allocation. */
+            IN gctUINT64            logical;
+        }
+        FreeVirtualCommandBuffer;
+
         /* gcvHAL_EVENT_COMMIT. */
         struct _gcsHAL_EVENT_COMMIT
         {
-            /* Event queue. */
-            IN gcsQUEUE_PTR             queue;
+            /* Event queue in gcsQUEUE. */
+            IN gctUINT64             queue;
         }
         Event;
 
         /* gcvHAL_COMMIT */
         struct _gcsHAL_COMMIT
         {
-            /* Context buffer object. */
-            IN gckCONTEXT               context;
+            /* Context buffer object gckCONTEXT. */
+            IN gctUINT64            context;
 
-            /* Command buffer. */
-            IN gcoCMDBUF                commandBuffer;
+            /* Command buffer gcoCMDBUF. */
+            IN gctUINT64            commandBuffer;
 
-            /* State delta buffer. */
-            gcsSTATE_DELTA_PTR          delta;
+            /* State delta buffer in gcsSTATE_DELTA. */
+            gctUINT64               delta;
 
-            /* Event queue. */
-            IN gcsQUEUE_PTR             queue;
+            /* Event queue in gcsQUEUE. */
+            IN gctUINT64            queue;
         }
         Commit;
 
@@ -504,16 +544,16 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_MAP_USER_MEMORY
         {
             /* Base address of user memory to map. */
-            IN gctPOINTER               memory;
+            IN gctUINT64                memory;
 
             /* Physical address of user memory to map. */
             IN gctUINT32                physical;
 
             /* Size of user memory in bytes to map. */
-            IN gctSIZE_T                size;
+            IN gctUINT64                size;
 
-            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. */
-            OUT gctPOINTER              info;
+            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. Just a name. */
+            OUT gctUINT32               info;
 
             /* Physical address of mapped memory. */
             OUT gctUINT32               address;
@@ -524,13 +564,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_UNMAP_USER_MEMORY
         {
             /* Base address of user memory to unmap. */
-            IN gctPOINTER               memory;
+            IN gctUINT64                memory;
 
             /* Size of user memory in bytes to unmap. */
-            IN gctSIZE_T                size;
+            IN gctUINT64                size;
 
-            /* Info record returned by gcvHAL_MAP_USER_MEMORY. */
-            IN gctPOINTER               info;
+            /* Info record returned by gcvHAL_MAP_USER_MEMORY. Just a name. */
+            IN gctUINT32                info;
 
             /* Physical address of mapped memory as returned by
                gcvHAL_MAP_USER_MEMORY. */
@@ -562,14 +602,14 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_SIGNAL. */
         struct _gcsHAL_SIGNAL
         {
-            /* Signal handle to signal. */
-            IN gctSIGNAL                signal;
+            /* Signal handle to signal gctSIGNAL. */
+            IN gctUINT64                signal;
 
-            /* Reserved. */
-            IN gctSIGNAL                auxSignal;
+            /* Reserved gctSIGNAL. */
+            IN gctUINT64                auxSignal;
 
-            /* Process owning the signal. */
-            IN gctHANDLE                process;
+            /* Process owning the signal gctHANDLE. */
+            IN gctUINT64                process;
 
 #if defined(__QNXNTO__)
             /* Client pulse side-channel connection ID. Set by client in gcoOS_CreateSignal. */
@@ -598,16 +638,16 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_CONTIGUOUS_MEMORY
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64            bytes;
 
             /* Hardware address of allocation. */
             OUT gctUINT32               address;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32               physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64               logical;
         }
         AllocateContiguousMemory;
 
@@ -615,13 +655,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_CONTIGUOUS_MEMORY
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32                physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64                logical;
         }
         FreeContiguousMemory;
 
@@ -670,6 +710,16 @@ typedef struct _gcsHAL_INTERFACE
         }
         SetProfileSetting;
 
+#if VIVANTE_PROFILER_PERDRAW
+        /* gcvHAL_READ_PROFILER_REGISTER_SETTING */
+        struct _gcsHAL_READ_PROFILER_REGISTER_SETTING
+         {
+            /*Should Clear Register*/
+            IN gctBOOL               bclear;
+         }
+        SetProfilerRegisterClear;
+#endif
+
         /* gcvHAL_READ_ALL_PROFILE_REGISTERS */
         struct _gcsHAL_READ_ALL_PROFILE_REGISTERS
         {
@@ -681,8 +731,8 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_PROFILE_REGISTERS_2D */
         struct _gcsHAL_PROFILE_REGISTERS_2D
         {
-            /* Data read. */
-            OUT gcs2D_PROFILE_PTR       hwProfile2D;
+            /* Data read in gcs2D_PROFILE. */
+            OUT gctUINT64       hwProfile2D;
         }
         RegisterProfileData2D;
 #endif
@@ -721,7 +771,7 @@ typedef struct _gcsHAL_INTERFACE
             IN gctBOOL                  map;
 
             /* Physical address. */
-            IN OUT gctPHYS_ADDR         physical;
+            IN OUT gctUINT64            physical;
         }
         MapPhysical;
 
@@ -746,10 +796,12 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_CACHE
         {
             IN gceCACHEOPERATION        operation;
-            IN gctHANDLE                process;
-            IN gctPOINTER               logical;
-            IN gctSIZE_T                bytes;
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* gctHANDLE */
+            IN gctUINT64                process;
+            IN gctUINT64                logical;
+            IN gctUINT64                bytes;
+            /* gcuVIDMEM_NODE_PTR */
+            IN gctUINT64                node;
         }
         Cache;
 
@@ -816,29 +868,30 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_ATTACH */
         struct _gcsHAL_ATTACH
         {
-            /* Context buffer object. */
-            OUT gckCONTEXT              context;
+            /* Context buffer object gckCONTEXT. Just a name. */
+            OUT gctUINT32               context;
 
             /* Number of states in the buffer. */
-            OUT gctSIZE_T               stateCount;
+            OUT gctUINT64               stateCount;
         }
         Attach;
 
         /* gcvHAL_DETACH */
         struct _gcsHAL_DETACH
         {
-            /* Context buffer object. */
-            IN gckCONTEXT               context;
+            /* Context buffer object gckCONTEXT. Just a name. */
+            IN gctUINT32                context;
         }
         Detach;
 
         /* gcvHAL_COMPOSE. */
-        gcsHAL_COMPOSE                  Compose;
+        gcsHAL_COMPOSE            Compose;
 
         /* gcvHAL_GET_FRAME_INFO. */
         struct _gcsHAL_GET_FRAME_INFO
         {
-            OUT gcsHAL_FRAME_INFO *     frameInfo;
+            /* gcsHAL_FRAME_INFO* */
+            OUT gctUINT64     frameInfo;
         }
         GetFrameInfo;
 
@@ -853,17 +906,17 @@ typedef struct _gcsHAL_INTERFACE
 		/* gcvHAL_COMMIT */
 		struct _gcsHAL_VGCOMMIT
 		{
-			/* Context buffer. */
-			IN gcsVGCONTEXT_PTR			context;
+			/* Context buffer in gcsVGCONTEXT. */
+			IN gctUINT64			context;
 
-			/* Command queue. */
-			IN gcsVGCMDQUEUE_PTR			queue;
+			/* Command queue in gcsVGCMDQUEUE. */
+			IN gctUINT64			queue;
 
 			/* Number of entries in the queue. */
-			IN gctUINT					entryCount;
+			IN gctUINT			entryCount;
 
-			/* Task table. */
-			IN gcsTASK_MASTER_TABLE_PTR	taskTable;
+			/* Task table in gcsTASK_MASTER_TABLE. */
+			IN gctUINT64	                taskTable;
 		}
 		VGCommit;
 
@@ -879,25 +932,30 @@ typedef struct _gcsHAL_INTERFACE
 
         struct _gcsHAL_GET_SHARED_INFO
         {
+            /* Process id. */
             IN gctUINT32            pid;
+
+            /* Data id. */
             IN gctUINT32            dataId;
-            IN gcuVIDMEM_NODE_PTR   node;
-            OUT gctUINT8_PTR        data;
-            /* fix size */
-            OUT gctUINT8_PTR        nodeData;
-            gctSIZE_T               size;
-            IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
+
+            /* Data size. */
+            IN gctSIZE_T            bytes;
+
+            /* Pointer to save the shared data. */
+            OUT gctPOINTER          data;
         }
         GetSharedInfo;
 
         struct _gcsHAL_SET_SHARED_INFO
         {
+            /* Data id. */
             IN gctUINT32            dataId;
-            IN gcuVIDMEM_NODE_PTR   node;
-            IN gctUINT8_PTR         data;
-            IN gctUINT8_PTR         nodeData;
-            IN gctSIZE_T            size;
-            IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
+
+            /* Data to be shared. */
+            IN gctPOINTER           data;
+
+            /* Data size. */
+            IN gctSIZE_T            bytes;
         }
         SetSharedInfo;
 
@@ -914,6 +972,12 @@ typedef struct _gcsHAL_INTERFACE
             OUT gctUINT             maxValue;
         }
         GetFscaleValue;
+
+        struct _gcsHAL_QUERY_RESET_TIME_STAMP
+        {
+            OUT gctUINT64           timeStamp;
+        }
+        QueryResetTimeStamp;
     }
     u;
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
index c447dcf..b54752f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_driver_vg_h_
 #define __gc_hal_driver_vg_h_
 
@@ -213,7 +210,7 @@ typedef struct _gcsTASK_UNLOCK_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gcuVIDMEM_NODE_PTR       node;
+    IN gctUINT64                node;
 }
 gcsTASK_UNLOCK_VIDEO_MEMORY;
 
@@ -224,7 +221,7 @@ typedef struct _gcsTASK_FREE_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gcuVIDMEM_NODE_PTR       node;
+    IN gctUINT64                node;
 }
 gcsTASK_FREE_VIDEO_MEMORY;
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
index 9b2db22..ffd45e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_dump_h_
 #define __gc_hal_dump_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
index 86ab105..06eea79 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_eglplatform_h_
 #define __gc_hal_eglplatform_h_
 
@@ -45,6 +43,12 @@ typedef struct __BITFIELDINFO{
     RGBQUAD       bmiColors[2];
 } BITFIELDINFO;
 
+#elif defined(LINUX) && defined(EGL_API_DFB) && !defined(__APPLE__)
+#include <directfb.h>
+typedef struct _DFBDisplay * HALNativeDisplayType;
+typedef IDirectFBWindow *  HALNativeWindowType;
+typedef struct _DFBPixmap *  HALNativePixmapType;
+
 #elif defined(LINUX) && defined(EGL_API_FB) && !defined(__APPLE__)
 
 #if defined(EGL_API_WL)
@@ -223,7 +227,8 @@ gcoOS_GetDisplayInfoEx(
     );
 
 gceSTATUS
-gcoOS_GetNextDisplayInfoEx(
+gcoOS_GetNextDisplayInfoExByIndex(
+    IN gctINT Index,
     IN HALNativeDisplayType Display,
     IN HALNativeWindowType Window,
     IN gctUINT DisplayInfoSize,
@@ -258,16 +263,27 @@ gcoOS_SetDisplayVirtual(
     );
 
 gceSTATUS
+gcoOS_SetDisplayVirtualEx(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctPOINTER Context,
+    IN gcoSURF Surface,
+    IN gctUINT Offset,
+    IN gctINT X,
+    IN gctINT Y
+    );
+
+gceSTATUS
 gcoOS_SetSwapInterval(
-	IN HALNativeDisplayType Display,
-	IN gctINT Interval
+    IN HALNativeDisplayType Display,
+    IN gctINT Interval
 );
 
 gceSTATUS
 gcoOS_GetSwapInterval(
-	IN HALNativeDisplayType Display,
-	IN gctINT_PTR Min,
-	IN gctINT_PTR Max
+    IN HALNativeDisplayType Display,
+    IN gctINT_PTR Min,
+    IN gctINT_PTR Max
 );
 
 gceSTATUS
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
index 727758f..4f5c3ce 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_eglplatform_type_h_
 #define __gc_hal_eglplatform_type_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index 7400b32..8481375 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_engine_h_
 #define __gc_hal_engine_h_
 
@@ -325,71 +323,58 @@ gcoSURF_Resolve(
     IN gcoSURF DestSurface
     );
 
-/* Export the render target. */
-gceSTATUS
-gcoSURF_ExportRenderTarget(
-    IN gcoSURF SrcSurface
-);
-
-/* Import the render target. */
-gceSTATUS
-gcoSURF_ImportRenderTarget(
-    IN gctUINT32 Pid,
-    IN gcoSURF SrcSurface
-);
-
-/* Save the Resolve info to kernel. */
+/* Resolve rectangular area of a surface. */
 gceSTATUS
-gcoSURF_PrepareRemoteResolveRect(
+gcoSURF_ResolveRect(
     IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface,
     IN gcsPOINT_PTR SrcOrigin,
     IN gcsPOINT_PTR DestOrigin,
     IN gcsPOINT_PTR RectSize
     );
 
-/* Resolve using the rectangle info previously saved in the vid mem node. */
+/* Set surface resolvability. */
 gceSTATUS
-gcoSURF_ResolveFromStoredRect(
-    IN gcoSURF SrcSurface,
-    IN gcoSURF DestSurface
+gcoSURF_SetResolvability(
+    IN gcoSURF Surface,
+    IN gctBOOL Resolvable
     );
 
-/* Using the info that Process Pid saved to do resolve. */
 gceSTATUS
-gcoSURF_RemoteResolveRect(
-    IN gcoSURF SrcSurface,
-    IN gcoSURF DestSurface,
-    IN gctBOOL *resolveDiscarded
+gcoSURF_IsRenderable(
+    IN gcoSURF Surface
+    );
+
+#if gcdSYNC
+gceSTATUS
+gcoSURF_GetFence(
+    IN gcoSURF Surface
+    );
+gceSTATUS
+gcoSURF_WaitFence(
+    IN gcoSURF Surface
     );
 
-/* Return the "resolve submitted indicator" signal. */
 gceSTATUS
-gcoSURF_GetRTSignal(
-    IN gcoSURF RTSurface,
-    OUT gctSIGNAL * resolveSubmittedSignal
+gcoSTREAM_GetFence(
+    IN gcoSTREAM stream
     );
 
-/* Resolve rectangular area of a surface. */
 gceSTATUS
-gcoSURF_ResolveRect(
-    IN gcoSURF SrcSurface,
-    IN gcoSURF DestSurface,
-    IN gcsPOINT_PTR SrcOrigin,
-    IN gcsPOINT_PTR DestOrigin,
-    IN gcsPOINT_PTR RectSize
+gcoSTREAM_WaitFence(
+    IN gcoSTREAM stream
     );
 
-/* Set surface resolvability. */
 gceSTATUS
-gcoSURF_SetResolvability(
-    IN gcoSURF Surface,
-    IN gctBOOL Resolvable
+gcoINDEX_GetFence(
+    IN gcoINDEX index
     );
 
 gceSTATUS
-gcoSURF_IsRenderable(
-    IN gcoSURF Surface
+gcoINDEX_WaitFence(
+    IN gcoINDEX index
     );
+#endif
 
 /******************************************************************************\
 ******************************** gcoINDEX Object *******************************
@@ -469,6 +454,22 @@ gcoINDEX_UploadOffset(
     IN gctSIZE_T Bytes
     );
 
+/*Merge index2 to index1 from 0, index2 must subset of inex1*/
+gceSTATUS
+gcoINDEX_Merge(
+    IN gcoINDEX Index1,
+    IN gcoINDEX Index2
+    );
+
+/*check if index buffer is enough for this draw*/
+gctBOOL
+gcoINDEX_CheckRange(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE Type,
+    IN gctINT Count,
+    IN gctUINT32  Indices
+    );
+
 /* Query the index capabilities. */
 gceSTATUS
 gcoINDEX_QueryCaps(
@@ -1210,6 +1211,12 @@ gco3D_SetWClipEnable(
     );
 
 gceSTATUS
+gco3D_GetWClipEnable(
+    IN gco3D Engine,
+    OUT gctBOOL * Enable
+    );
+
+gceSTATUS
 gco3D_SetWPlaneLimitF(
 	IN gco3D Engine,
 	IN gctFLOAT Value
@@ -1221,6 +1228,13 @@ gco3D_SetWPlaneLimitX(
 	IN gctFIXED_POINT Value
     );
 
+
+gceSTATUS
+gco3D_SetWPlaneLimit(
+        IN gco3D Engine,
+        IN gctFLOAT Value
+        );
+
 /*----------------------------------------------------------------------------*/
 /*-------------------------- gco3D Fragment Processor ------------------------*/
 
@@ -1372,6 +1386,16 @@ typedef enum _gceTEXTURE_FACE
 }
 gceTEXTURE_FACE;
 
+#if gcdFORCE_MIPMAP
+typedef enum
+{
+    gcvForceMipDisabled  = 0,
+    gcvForceMipEnable    = 1,
+    gcvForceMipGenerated = 2,
+    gcvForceMipNever     = 3,
+}gceFORCE_MIPMAP;
+#endif
+
 typedef struct _gcsTEXTURE
 {
     /* Addressing modes. */
@@ -1387,7 +1411,11 @@ typedef struct _gcsTEXTURE
     gceTEXTURE_FILTER           magFilter;
     gceTEXTURE_FILTER           mipFilter;
     gctUINT                     anisoFilter;
-
+    gctBOOL                     forceTopLevel;
+    gctBOOL                     autoMipmap;
+#if gcdFORCE_MIPMAP
+    gceFORCE_MIPMAP             forceMipmap;
+#endif
     /* Level of detail. */
     gctFIXED_POINT              lodBias;
     gctFIXED_POINT              lodMin;
@@ -1421,6 +1449,31 @@ gceSTATUS
 gcoTEXTURE_Destroy(
     IN gcoTEXTURE Texture
     );
+#if gcdFORCE_MIPMAP
+gceSTATUS
+gcoTEXTURE_DestroyForceMipmap(
+    IN gcoTEXTURE Texture
+    );
+
+gceSTATUS
+gcoTEXTURE_GetMipLevels(
+    IN gcoTEXTURE Texture,
+    OUT gctINT * levels
+    );
+#endif
+/* Replace a mipmap in gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_ReplaceMipMap(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Level,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctINT imageFormat,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Depth,
+    IN gctUINT Faces,
+    IN gcePOOL Pool
+    );
 
 /* Upload data to an gcoTEXTURE object. */
 gceSTATUS
@@ -1478,6 +1531,14 @@ gcoTEXTURE_UploadCompressedSub(
     IN gctSIZE_T Size
     );
 
+/* GetImageFormat of texture. */
+gceSTATUS
+gcoTEXTURE_GetImageFormat(
+    IN gcoTEXTURE Texture,
+    IN gctUINT MipMap,
+    OUT gctINT *  ImageFormat
+    );
+
 /* Get gcoSURF object for a mipmap level. */
 gceSTATUS
 gcoTEXTURE_GetMipMap(
@@ -1525,6 +1586,12 @@ gcoTEXTURE_AddMipMapFromSurface(
     );
 
 gceSTATUS
+gcoTEXTURE_SetMaxLevel(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Levels
+    );
+
+gceSTATUS
 gcoTEXTURE_SetEndianHint(
     IN gcoTEXTURE Texture,
     IN gceENDIAN_HINT EndianHint
@@ -1573,6 +1640,12 @@ gcoTEXTURE_IsRenderable(
     );
 
 gceSTATUS
+gcoTEXTURE_IsRenderableEx(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Level
+    );
+
+gceSTATUS
 gcoTEXTURE_IsComplete(
     IN gcoTEXTURE Texture,
     IN gctINT MaxLevel
@@ -1779,6 +1852,10 @@ typedef struct _gcsVERTEXARRAY
 
     /* Vertex shader linkage. */
     gctUINT             linkage;
+
+#if gcdUSE_WCLIP_PATCH
+    gctBOOL             isPosition;
+#endif
 }
 gcsVERTEXARRAY,
 * gcsVERTEXARRAY_PTR;
@@ -1805,7 +1882,13 @@ gcoVERTEXARRAY_Bind(
     IN gcoINDEX IndexObject,
     IN gctPOINTER IndexMemory,
     IN OUT gcePRIMITIVE * PrimitiveType,
+#if gcdUSE_WCLIP_PATCH
+    IN OUT gctUINT * PrimitiveCount,
+    IN OUT gctFLOAT * wLimitRms,
+    IN OUT gctBOOL * wLimitDirty
+#else
     IN OUT gctUINT * PrimitiveCount
+#endif
     );
 
 gctUINT
@@ -1907,21 +1990,15 @@ gceSTATUS
 gcoHAL_GetSharedInfo(
     IN gctUINT32 Pid,
     IN gctUINT32 DataId,
-    OUT gctUINT8_PTR Data,
     IN gctSIZE_T Bytes,
-    IN gcuVIDMEM_NODE_PTR Node,
-    OUT gctUINT8_PTR NodeData,
-    IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
+    OUT gctPOINTER Data
     );
 
 gceSTATUS
 gcoHAL_SetSharedInfo(
     IN gctUINT32 DataId,
-    IN gctUINT8_PTR Data,
-    IN gctSIZE_T Bytes,
-    IN gcuVIDMEM_NODE_PTR Node,
-    IN gctUINT8_PTR NodeData,
-    IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
+    IN gctPOINTER Data,
+    IN gctSIZE_T Bytes
     );
 
 #ifdef __cplusplus
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
index 1526b0c..4bb6772 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_engine_vg_h_
 #define __gc_hal_engine_vg_h_
 
@@ -527,14 +524,14 @@ gcoHAL_CombineAddress(
 gceSTATUS
 gcoHAL_ScheduleVideoMemory(
     IN gcoHAL Hal,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gctUINT64 Node
     );
 
 /* Free linear video memory allocated with gcoHAL_AllocateLinearVideoMemory. */
 gceSTATUS
 gcoHAL_FreeVideoMemory(
     IN gcoHAL Hal,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gctUINT64 Node
     );
 
 /* Query command buffer attributes. */
@@ -550,7 +547,7 @@ gcoHAL_AllocateLinearVideoMemory(
     IN gctUINT Size,
     IN gctUINT Alignment,
     IN gcePOOL Pool,
-    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT64 * Node,
     OUT gctUINT32 * Address,
     OUT gctPOINTER * Memory
     );
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index d951c3a..a1d9ae5 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_enum_h_
 #define __gc_hal_enum_h_
 
@@ -146,6 +144,12 @@ typedef enum _gceFEATURE
 	gcvFEATURE_PE_DITHER_FIX,
     gcvFEATURE_2D_YUV_SEPARATE_STRIDE,
     gcvFEATURE_FRUSTUM_CLIP_FIX,
+    gcvFEATURE_TEXTURE_LINEAR,
+    gcvFEATURE_TEXTURE_YUV_ASSEMBLER,
+    gcvFEATURE_DYNAMIC_FREQUENCY_SCALING,
+    gcvFEATURE_BUGFIX15,
+    gcvFEATURE_2D_MIRROR_EXTENSION,
+    gcvFEATURE_ELEMENT_INDEX_UINT,
 }
 gceFEATURE;
 
@@ -177,13 +181,6 @@ typedef enum _gceCACHEOPERATION
 }
 gceCACHEOPERATION;
 
-typedef enum _gceVIDMEM_NODE_SHARED_INFO_TYPE
-{
-    gcvVIDMEM_INFO_GENERIC,
-    gcvVIDMEM_INFO_DIRTY_RECTANGLE
-}
-gceVIDMEM_NODE_SHARED_INFO_TYPE;
-
 /* Surface types. */
 typedef enum _gceSURF_TYPE
 {
@@ -347,6 +344,16 @@ typedef enum _gceSURF_FORMAT
     gcvSURF_DXT5,
     gcvSURF_CXV8U8,
     gcvSURF_ETC1,
+    gcvSURF_R11_EAC,
+    gcvSURF_SIGNED_R11_EAC,
+    gcvSURF_RG11_EAC,
+    gcvSURF_SIGNED_RG11_EAC,
+    gcvSURF_RGB8_ETC2,
+    gcvSURF_SRGB8_ETC2,
+    gcvSURF_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
+    gcvSURF_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
+    gcvSURF_RGBA8_ETC2_EAC,
+    gcvSURF_SRGB8_ALPHA8_ETC2_EAC,
 
     /* YUV formats. */
     gcvSURF_YUY2                = 500,
@@ -477,6 +484,17 @@ typedef enum _gceSURF_ALIGNMENT
 }
 gceSURF_ALIGNMENT;
 
+
+/* Surface Addressing. */
+typedef enum _gceSURF_ADDRESSING
+{
+    gcvSURF_NO_STRIDE_TILED = 0,
+    gcvSURF_NO_STRIDE_LINEAR,
+    gcvSURF_STRIDE_TILED,
+    gcvSURF_STRIDE_LINEAR
+}
+gceSURF_ADDRESSING;
+
 /* Transparency modes. */
 typedef enum _gce2D_TRANSPARENCY
 {
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
index 24edc0b..0608e43 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_buffer_h_
 #define __gc_hal_kernel_buffer_h_
 
@@ -59,11 +57,6 @@ typedef struct _gcsSTATE_DELTA
     gctUINT                     num;
 #endif
 
-    /* For dumping. */
-#if gcdDUMP
-    gcoOS                       os;
-#endif
-
     /* Main state delta ID. Every time state delta structure gets reinitialized,
        main ID is incremented. If main state ID overflows, all map entry IDs get
        reinitialized to make sure there is no potential erroneous match after
@@ -79,22 +72,22 @@ typedef struct _gcsSTATE_DELTA
     /* Number of states currently stored in the record array. */
     gctUINT                     recordCount;
 
-    /* Record array; holds all modified states. */
-    gcsSTATE_DELTA_RECORD_PTR   recordArray;
+    /* Record array; holds all modified states in gcsSTATE_DELTA_RECORD. */
+    gctUINT64                   recordArray;
 
     /* Map entry ID is used for map entry validation. If map entry ID does not
        match the main state delta ID, the entry and the corresponding state are
        considered not in use. */
-    gctUINT_PTR                 mapEntryID;
+    gctUINT64                   mapEntryID;
     gctUINT                     mapEntryIDSize;
 
     /* If the map entry ID matches the main state delta ID, index points to
        the state record in the record array. */
-    gctUINT_PTR                 mapEntryIndex;
+    gctUINT64                   mapEntryIndex;
 
-    /* Previous and next state deltas. */
-    gcsSTATE_DELTA_PTR          prev;
-    gcsSTATE_DELTA_PTR          next;
+    /* Previous and next state deltas in gcsSTATE_DELTA. */
+    gctUINT64                   prev;
+    gctUINT64                   next;
 }
 gcsSTATE_DELTA;
 
@@ -114,38 +107,38 @@ struct _gcoCMDBUF
     gctBOOL                     usingFilterBlit;
     gctBOOL                     usingPalette;
 
-    /* Physical address of command buffer. */
-    gctPHYS_ADDR                physical;
+    /* Physical address of command buffer. Just a name. */
+    gctUINT32                   physical;
 
     /* Logical address of command buffer. */
-    gctPOINTER                  logical;
+    gctUINT64                   logical;
 
     /* Number of bytes in command buffer. */
-    gctSIZE_T                   bytes;
+    gctUINT                     bytes;
 
     /* Start offset into the command buffer. */
-    gctUINT32                   startOffset;
+    gctUINT                     startOffset;
 
     /* Current offset into the command buffer. */
-    gctUINT32                   offset;
+    gctUINT                     offset;
 
     /* Number of free bytes in command buffer. */
-    gctSIZE_T                   free;
+    gctUINT                     free;
 
     /* Location of the last reserved area. */
-    gctPOINTER                  lastReserve;
+    gctUINT64                   lastReserve;
     gctUINT                     lastOffset;
 
 #if gcdSECURE_USER
     /* Hint array for the current command buffer. */
     gctUINT                     hintArraySize;
-    gctUINT32_PTR               hintArray;
-    gctUINT32_PTR               hintArrayTail;
+    gctUINT64                   hintArray;
+    gctUINT64                   hintArrayTail;
 #endif
 
 #if gcmIS_DEBUG(gcdDEBUG_CODE)
     /* Last load state command location and hardware address. */
-    gctUINT32_PTR               lastLoadStatePtr;
+    gctUINT64                   lastLoadStatePtr;
     gctUINT32                   lastLoadStateAddress;
     gctUINT32                   lastLoadStateCount;
 #endif
@@ -153,8 +146,8 @@ struct _gcoCMDBUF
 
 typedef struct _gcsQUEUE
 {
-    /* Pointer to next gcsQUEUE structure. */
-    gcsQUEUE_PTR                next;
+    /* Pointer to next gcsQUEUE structure in gcsQUEUE. */
+    gctUINT64                   next;
 
     /* Event information. */
     gcsHAL_INTERFACE            iface;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
index e64f7e7..9e32878 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /*
 **	Include file for the local memory management.
 */
@@ -176,7 +174,7 @@ Prefix##_CAllocate##TypeName( \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
 	gcmERR_RETURN(gcfMEM_FSMemPoolGetANode(MemPool, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -233,7 +231,7 @@ gceSTATUS \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
 	gcmERR_RETURN(gcfMEM_VSMemPoolGetANode(MemPool, Size, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size)); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -276,7 +274,7 @@ Prefix##_CAllocate##TypeName( \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
 	gcmERR_RETURN(gcfMEM_AFSMemPoolGetANode(MemPool, Count, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -323,7 +321,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							gcmSIZEOF(Type), \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -370,7 +368,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							Size, \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size)); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -417,7 +415,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							Count * gcmSIZEOF(Type), \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index 33fddfb..9e2a8db 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_options_h_
 #define __gc_hal_options_h_
 
@@ -43,15 +41,6 @@
 #endif
 
 /*
-    NO_USER_DIRECT_ACCESS_FROM_KERNEL
-
-        This define enables the Linux kernel behavior accessing user memory.
-*/
-#ifndef NO_USER_DIRECT_ACCESS_FROM_KERNEL
-#   define NO_USER_DIRECT_ACCESS_FROM_KERNEL    0
-#endif
-
-/*
     VIVANTE_PROFILER
 
         This define enables the profiler.
@@ -60,6 +49,10 @@
 #   define VIVANTE_PROFILER                     0
 #endif
 
+#ifndef VIVANTE_PROFILER_PERDRAW
+#   define  VIVANTE_PROFILER_PERDRAW    0
+#endif
+
 /*
     gcdUSE_VG
 
@@ -121,6 +114,30 @@
 #define COMMAND_PROCESSOR_VERSION               1
 
 /*
+    gcdDUMP_KEY
+
+        Set this to a string that appears in 'cat /proc/<pid>/cmdline'. E.g. 'camera'.
+        HAL will create dumps for the processes matching this key.
+*/
+#ifndef gcdDUMP_KEY
+#   define gcdDUMP_KEY                          "process"
+#endif
+
+/*
+    gcdDUMP_PATH
+
+        The dump file location. Some processes cannot write to the sdcard.
+        Try apps' data dir, e.g. /data/data/com.android.launcher
+*/
+#ifndef gcdDUMP_PATH
+#if defined(ANDROID)
+#   define gcdDUMP_PATH                         "/mnt/sdcard/"
+#else
+#   define gcdDUMP_PATH                         "./"
+#endif
+#endif
+
+/*
     gcdDUMP
 
         When set to 1, a dump of all states and memory uploads, as well as other
@@ -153,11 +170,12 @@
 #endif
 
 /*
-    gcdENABLE_FSCALE_VAL_ADJUST
-        When non-zero, FSCALE_VAL when gcvPOWER_ON can be adjusted externally.
- */
-#ifndef gcdENABLE_FSCALE_VAL_ADJUST
-#   define gcdENABLE_FSCALE_VAL_ADJUST          1
+    gcdVIRTUAL_COMMAND_BUFFER
+        When set to 1, user command buffer and context buffer will be allocated
+        from gcvPOOL_VIRTUAL.
+*/
+#ifndef gcdVIRTUAL_COMMAND_BUFFER
+#   define gcdVIRTUAL_COMMAND_BUFFER            0
 #endif
 
 /*
@@ -267,14 +285,28 @@
 #endif
 
 /*
+    gcdMIRROR_PAGETABLE
+
+        Enable it when GPUs with old MMU and new MMU exist at same SoC. It makes
+        each GPU use same virtual address to access same physical memory.
+*/
+#ifndef gcdMIRROR_PAGETABLE
+#   define gcdMIRROR_PAGETABLE                  0
+#endif
+
+/*
     gcdMMU_SIZE
 
         Size of the MMU page table in bytes.  Each 4 bytes can hold 4kB worth of
         virtual data.
 */
 #ifndef gcdMMU_SIZE
+#if gcdMIRROR_PAGETABLE
+#   define gcdMMU_SIZE                          0x200000
+#else
 #   define gcdMMU_SIZE                          (2048 << 10)
 #endif
+#endif
 
 /*
     gcdSECURE_USER
@@ -334,6 +366,17 @@
 #endif
 
 /*
+    gcdUSER_HEAP_ALLOCATOR
+
+        Set to 1 to enable user mode heap allocator for fast memory allocation
+        and destroying. Otherwise, memory allocation/destroying in user mode
+        will be directly managed by system. Only for linux for now.
+*/
+#ifndef gcdUSER_HEAP_ALLOCATOR
+#   define gcdUSER_HEAP_ALLOCATOR               1
+#endif
+
+/*
     gcdHEAP_SIZE
 
         Set the allocation size for the internal heaps.  Each time a heap is
@@ -348,15 +391,6 @@
 #endif
 
 /*
-    gcdPOWER_MANAGEMENT
-
-        This define enables the power management code.
-*/
-#ifndef gcdPOWER_MANAGEMENT
-#   define gcdPOWER_MANAGEMENT                  1
-#endif
-
-/*
     gcdPOWER_SUSNPEND_WHEN_IDLE
 
         Set to 1 to make GPU enter gcvPOWER_SUSPEND when idle detected,
@@ -385,10 +419,10 @@
         If the value is 0, no timeout will be checked for.
 */
 #ifndef gcdGPU_TIMEOUT
-#   if gcdFPGA_BUILD
+#if gcdFPGA_BUILD
 #       define gcdGPU_TIMEOUT                   0
 #   else
-#       define gcdGPU_TIMEOUT                   (2000 * 5)
+#       define gcdGPU_TIMEOUT                   20000
 #   endif
 #endif
 
@@ -683,31 +717,13 @@
 
         Support swap with a specific rectangle.
 
-        Set the rectangle with eglSetSwapRectangleANDROID api.
+        Set the rectangle with eglSetSwapRectangleVIV api.
 */
 #ifndef gcdSUPPORT_SWAP_RECTANGLE
 #   define gcdSUPPORT_SWAP_RECTANGLE            0
 #endif
 
 /*
-    gcdDEFER_RESOLVES
-
-        Support deferred resolves for 3D apps.
-*/
-#ifndef gcdDEFER_RESOLVES
-#   define gcdDEFER_RESOLVES                    0
-#endif
-
-/*
-    gcdCOPYBLT_OPTIMIZATION
-
-        Combine dirty areas resulting from Android's copyBlt.
-*/
-#ifndef gcdCOPYBLT_OPTIMIZATION
-#   define gcdCOPYBLT_OPTIMIZATION              0
-#endif
-
-/*
     gcdGPU_LINEAR_BUFFER_ENABLED
 
         Use linear buffer for GPU apps so HWC can do 2D composition.
@@ -745,6 +761,10 @@
 #   define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    0
 #endif
 
+#ifndef gcdENABLE_PE_DITHER_FIX
+#   define gcdENABLE_PE_DITHER_FIX              1
+#endif
+
 #ifndef gcdSHARED_PAGETABLE
 #   define gcdSHARED_PAGETABLE                  1
 #endif
@@ -773,7 +793,22 @@
         limited by gcdCONTIGUOUS_SIZE_LIMIT.
  */
 #ifndef gcdCONTIGUOUS_SIZE_LIMIT
-#   define gcdCONTIGUOUS_SIZE_LIMIT             4096
+#   define gcdCONTIGUOUS_SIZE_LIMIT             0
+#endif
+
+#ifndef gcdDISALBE_EARLY_EARLY_Z
+#   define gcdDISALBE_EARLY_EARLY_Z             1
+#endif
+
+/*
+    gcdLINK_QUEUE_SIZE
+
+        When non-zero, driver maintains a queue to record information of
+        latest lined context buffer and command buffer. Data in this queue
+        is be used to debug.
+*/
+#ifndef gcdLINK_QUEUE_SIZE
+#   define gcdLINK_QUEUE_SIZE                  0
 #endif
 
 /*  gcdALPHA_KILL_IN_SHADER
@@ -798,4 +833,37 @@
 #   define gcdUSE_WCLIP_PATCH                   1
 #endif
 
+#ifndef gcdHZ_L2_DISALBE
+#   define gcdHZ_L2_DISALBE                     1
+#endif
+
+#ifndef gcdBUGFIX15_DISABLE
+#   define gcdBUGFIX15_DISABLE                  1
+#endif
+
+#ifndef gcdDISABLE_HZ_FAST_CLEAR
+#   define gcdDISABLE_HZ_FAST_CLEAR             1
+#endif
+
+#ifndef gcdUSE_NPOT_PATCH
+#define gcdUSE_NPOT_PATCH                       1
+#endif
+
+
+#ifndef gcdSYNC
+#   define gcdSYNC                              1
+#endif
+
+/*
+    gcdDVFS
+
+        When non-zero, software will make use of dynamic voltage and
+        frequency feature.
+ */
+#ifndef gcdDVFS
+#   define gcdDVFS                               0
+#   define gcdDVFS_ANAYLSE_WINDOW                4
+#   define gcdDVFS_POLLING_TIME                  (gcdDVFS_ANAYLSE_WINDOW * 4)
+#endif
+
 #endif /* __gc_hal_options_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index 62ebb0d..3e450ba 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -578,6 +578,8 @@ extern "C" {
 #define VPG_ES11_TIME   0x170000
 #define VPG_ES20_TIME   0x180000
 #define VPG_FRAME       0x190000
+#define VPG_ES11_DRAW 0x200000
+#define VPG_ES20_DRAW 0x210000
 #define VPG_END         0xff0000
 
 /* Info. */
@@ -1093,6 +1095,12 @@ extern "C" {
 #define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
 #define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
 
+
+#define VPG_ES20_DRAW_NO  (VPG_ES20_DRAW + 1)
+#define VPG_ES11_DRAW_NO  (VPG_ES11_DRAW + 1)
+
+#define VPG_FRAME_USEVBO (VPG_FRAME + 1)
+
 #endif
 
 
@@ -1292,6 +1300,13 @@ gcoPROFILER_EndFrame(
     IN gcoHAL Hal
     );
 
+/* Call to signal end of draw. */
+gceSTATUS
+gcoPROFILER_EndDraw(
+    IN gcoHAL Hal,
+    IN gctBOOL FirstDraw
+    );
+
 /* Increase profile counter Enum by Value. */
 gceSTATUS
 gcoPROFILER_Count(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
index e3ceadf..bc4171e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_raster_h_
 #define __gc_hal_raster_h_
 
@@ -954,7 +952,7 @@ gceSTATUS
 gco2D_SetStateU32(
     IN gco2D Engine,
     IN gce2D_STATE State,
-    IN OUT gctUINT32_PTR Value
+    IN gctUINT32 Value
     );
 
 #ifdef __cplusplus
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
index ed6718d..6c10fbf 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_rename_h_
 #define __gc_hal_rename_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
index 1e85458..82336e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_statistics_h_
 #define __gc_hal_statistics_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index 4e06377..5c0877d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_types_h_
 #define __gc_hal_types_h_
 
@@ -146,6 +144,7 @@ typedef unsigned char           gctUINT8;
 typedef unsigned short          gctUINT16;
 typedef unsigned int            gctUINT32;
 typedef unsigned long long      gctUINT64;
+typedef unsigned long           gctUINTPTR_T;
 
 typedef gctUINT *               gctUINT_PTR;
 typedef gctUINT8 *              gctUINT8_PTR;
@@ -587,13 +586,13 @@ gceSTATUS;
 #if gcmIS_DEBUG(gcdDEBUG_CODE)
 
 #   define gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count) \
-        CommandBuffer->lastLoadStatePtr     = Memory; \
+        CommandBuffer->lastLoadStatePtr     = gcmPTR_TO_UINT64(Memory); \
         CommandBuffer->lastLoadStateAddress = Address; \
         CommandBuffer->lastLoadStateCount   = Count
 
 #   define gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address) \
         gcmASSERT( \
-            (gctUINT) (Memory  - CommandBuffer->lastLoadStatePtr - 1) \
+            (gctUINT) (Memory  - gcmUINT64_TO_TYPE(CommandBuffer->lastLoadStatePtr, gctUINT32_PTR) - 1) \
             == \
             (gctUINT) (Address - CommandBuffer->lastLoadStateAddress) \
             ); \
@@ -622,10 +621,10 @@ gceSTATUS;
 #   define gcmBEGINSECUREUSER() \
         __secure_user_offset__ = reserve->lastOffset; \
         \
-        __secure_user_hintArray__ = reserve->hintArrayTail
+        __secure_user_hintArray__ = gcmUINT64_TO_PTR(reserve->hintArrayTail)
 
 #   define gcmENDSECUREUSER() \
-        reserve->hintArrayTail = __secure_user_hintArray__
+        reserve->hintArrayTail = gcmPTR_TO_UINT64(__secure_user_hintArray__)
 
 #   define gcmSKIPSECUREUSER() \
         __secure_user_offset__ += gcmSIZEOF(gctUINT32)
@@ -681,7 +680,7 @@ gceSTATUS;
         Hardware->buffer, ReserveSize, gcvTRUE, &CommandBuffer \
         )); \
     \
-    Memory = (gctUINT32_PTR) CommandBuffer->lastReserve; \
+    Memory =  gcmUINT64_TO_PTR(CommandBuffer->lastReserve); \
     \
     StateDelta = Hardware->delta; \
     \
@@ -693,7 +692,7 @@ gceSTATUS;
     gcmENDSECUREUSER(); \
     \
     gcmASSERT( \
-        ((gctUINT8_PTR) CommandBuffer->lastReserve) + ReserveSize \
+        gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT8_PTR) + ReserveSize \
         == \
          (gctUINT8_PTR) Memory \
         ); \
@@ -703,7 +702,8 @@ gceSTATUS;
 
 #define gcmBEGINSTATEBATCH(CommandBuffer, Memory, FixedPoint, Address, Count) \
 { \
-    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    gcmASSERT(((Memory - gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT32_PTR)) & 1) == 0); \
+    gcmASSERT((gctUINT32)Count <= 1024); \
     \
     gcmVERIFYLOADSTATEDONE(CommandBuffer); \
     \
@@ -722,7 +722,7 @@ gceSTATUS;
 { \
     gcmVERIFYLOADSTATEDONE(CommandBuffer); \
     \
-    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    gcmASSERT(((Memory - gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT32_PTR)) & 1) == 0); \
 }
 
 /*----------------------------------------------------------------------------*/
@@ -889,19 +889,25 @@ gceSTATUS;
     gcmPTR2INT(& (((struct s *) 0)->field)) \
 )
 
+#define gcmSWAB32(x) ((gctUINT32)( \
+        (((gctUINT32)(x) & (gctUINT32)0x000000FFUL) << 24) | \
+        (((gctUINT32)(x) & (gctUINT32)0x0000FF00UL) << 8)  | \
+        (((gctUINT32)(x) & (gctUINT32)0x00FF0000UL) >> 8)  | \
+        (((gctUINT32)(x) & (gctUINT32)0xFF000000UL) >> 24)))
+
 /*******************************************************************************
 ***** Database ****************************************************************/
 
 typedef struct _gcsDATABASE_COUNTERS
 {
     /* Number of currently allocated bytes. */
-    gctSIZE_T                   bytes;
+    gctUINT64                   bytes;
 
     /* Maximum number of bytes allocated (memory footprint). */
-    gctSIZE_T                   maxBytes;
+    gctUINT64                   maxBytes;
 
     /* Total number of bytes allocated. */
-    gctSIZE_T                   totalBytes;
+    gctUINT64                   totalBytes;
 }
 gcsDATABASE_COUNTERS;
 
@@ -970,6 +976,25 @@ typedef struct _gcsHAL_FRAME_INFO
 }
 gcsHAL_FRAME_INFO;
 
+#if gcdLINK_QUEUE_SIZE
+typedef struct _gckLINKDATA * gckLINKDATA;
+struct _gckLINKDATA
+{
+    gctUINT32                   start;
+    gctUINT32                   end;
+    gctINT                      pid;
+};
+
+typedef struct _gckLINKQUEUE * gckLINKQUEUE;
+struct _gckLINKQUEUE
+{
+    struct _gckLINKDATA         data[gcdLINK_QUEUE_SIZE];
+    gctUINT32                   rear;
+    gctUINT32                   front;
+    gctUINT32                   count;
+};
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index f98742e..03cb4d6 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_version_h_
 #define __gc_hal_version_h_
 
@@ -30,7 +28,7 @@
 
 #define gcvVERSION_PATCH        9
 
-#define gcvVERSION_BUILD        1478
+#define gcvVERSION_BUILD     6622
 
 #define gcvVERSION_DATE      __DATE__
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
index 8731137..2a910e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_vg_h_
 #define __gc_hal_vg_h_
 
@@ -555,6 +552,12 @@ gckVGHARDWARE_QueryPowerManagementState(
     );
 
 gceSTATUS
+gckVGHARDWARE_SetPowerManagement(
+    IN gckVGHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    );
+
+gceSTATUS
 gckVGHARDWARE_SetPowerOffTimeout(
     IN gckVGHARDWARE  Hardware,
     IN gctUINT32    Timeout
@@ -588,7 +591,7 @@ typedef struct _gcsCMDBUFFER
     /* The user sets this to the node of the container buffer whitin which
        this particular command buffer resides. The kernel sets this to the
        node of the internally allocated buffer. */
-    gcuVIDMEM_NODE_PTR          node;
+    gctUINT64                   node;
 
     /* Command buffer hardware address. */
     gctUINT32                   address;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
index a6754fe..339dff4 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_debug_h_
 #define __gc_hal_kernel_debug_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
index 5a21a94..6bdc5a6 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -167,7 +167,7 @@ static gcsDebugFileSystem gc_dbgfs ;
 static caddr_t
 _ReadFromNode (
                 gcsDebugFileSystemNode* Node ,
-                int *Length ,
+                size_t *Length ,
                 loff_t *Offset
                 )
 {
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
index e0b6142..78d8199 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include <stdarg.h>
 
 #ifndef __gc_hal_kernel_debugfs_h_
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index eba81b64..4d48bd5 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 #include <linux/pagemap.h>
 #include <linux/seq_file.h>
@@ -28,6 +26,7 @@
 #include <linux/mman.h>
 #include <linux/slab.h>
 #include <mach/hardware.h>
+#include <linux/pm_runtime.h>
 
 #define _GC_OBJ_ZONE    gcvZONE_DEVICE
 
@@ -304,6 +303,8 @@ gckGALDEVICE_Construct(
     IN gctUINT32 PhysSize,
     IN gctINT Signal,
     IN gctUINT LogFileSize,
+    IN struct device *pdev,
+    IN gctINT PowerManagement,
     OUT gckGALDEVICE *Device
     )
 {
@@ -318,6 +319,7 @@ gckGALDEVICE_Construct(
     gctINT32 i;
     gceHARDWARE_TYPE type;
     gckDB sharedDB = gcvNULL;
+    gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("IrqLine=%d RegisterMemBase=0x%08x RegisterMemSize=%u "
                    "IrqLine2D=%d RegisterMemBase2D=0x%08x RegisterMemSize2D=%u "
@@ -331,7 +333,7 @@ gckGALDEVICE_Construct(
                    PhysBaseAddr, PhysSize, Signal);
 
     /* Allocate device structure. */
-    device = kmalloc(sizeof(struct _gckGALDEVICE), GFP_KERNEL | __GFP_NOWARN);
+    device = kmalloc(sizeof(struct _gckGALDEVICE), GFP_KERNEL);
 
     if (!device)
     {
@@ -358,8 +360,15 @@ gckGALDEVICE_Construct(
 	 	gckDebugFileSystemSetCurrentNode(device->dbgnode);
 	}
     }
+#ifdef CONFIG_PM
+    /*Init runtime pm for gpu*/
+    pm_runtime_enable(pdev);
+    device->pmdev = pdev;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     /*get gpu regulator*/
-    device->gpu_regulator = regulator_get(NULL, "cpu_vddgpu");
+    device->gpu_regulator = regulator_get(pdev, "cpu_vddgpu");
     if (IS_ERR(device->gpu_regulator)) {
 	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
 		"%s(%d): Failed to get gpu regulator  %s/%s \n",
@@ -367,13 +376,14 @@ gckGALDEVICE_Construct(
 		PARENT_FILE, DEBUG_FILE);
 	gcmkONERROR(gcvSTATUS_NOT_FOUND);
     }
-
+#endif
     /*Initialize the clock structure*/
     if (IrqLine != -1) {
-        device->clk_3d_core = clk_get(NULL, "gpu3d_clk");
+        device->clk_3d_core = clk_get(pdev, "gpu3d_clk");
         if (!IS_ERR(device->clk_3d_core)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
             if (cpu_is_mx6q()) {
-	            device->clk_3d_shader = clk_get(NULL, "gpu3d_shader_clk");
+	            device->clk_3d_shader = clk_get(pdev, "gpu3d_shader_clk");
 	            if (IS_ERR(device->clk_3d_shader)) {
 	                IrqLine = -1;
 	                clk_put(device->clk_3d_core);
@@ -381,7 +391,18 @@ gckGALDEVICE_Construct(
 	                device->clk_3d_shader = NULL;
 	                gckOS_Print("galcore: clk_get gpu3d_shader_clk failed, disable 3d!\n");
 	            }
-            }
+	          }
+#else
+	            device->clk_3d_axi = clk_get(pdev, "gpu3d_axi_clk");
+	            device->clk_3d_shader = clk_get(pdev, "gpu3d_shader_clk");
+	            if (IS_ERR(device->clk_3d_shader)) {
+	                IrqLine = -1;
+	                clk_put(device->clk_3d_core);
+	                device->clk_3d_core = NULL;
+	                device->clk_3d_shader = NULL;
+	                gckOS_Print("galcore: clk_get gpu3d_shader_clk failed, disable 3d!\n");
+	            }
+#endif
         } else {
             IrqLine = -1;
             device->clk_3d_core = NULL;
@@ -389,7 +410,7 @@ gckGALDEVICE_Construct(
         }
     }
     if ((IrqLine2D != -1) || (IrqLineVG != -1)) {
-        device->clk_2d_core = clk_get(NULL, "gpu2d_clk");
+        device->clk_2d_core = clk_get(pdev, "gpu2d_clk");
         if (IS_ERR(device->clk_2d_core)) {
             IrqLine2D = -1;
             IrqLineVG = -1;
@@ -397,7 +418,7 @@ gckGALDEVICE_Construct(
             gckOS_Print("galcore: clk_get 2d core clock failed, disable 2d/vg!\n");
         } else {
 	    if (IrqLine2D != -1) {
-                device->clk_2d_axi = clk_get(NULL, "gpu2d_axi_clk");
+                device->clk_2d_axi = clk_get(pdev, "gpu2d_axi_clk");
                 if (IS_ERR(device->clk_2d_axi)) {
                     device->clk_2d_axi = NULL;
                     IrqLine2D = -1;
@@ -405,7 +426,7 @@ gckGALDEVICE_Construct(
                 }
             }
             if (IrqLineVG != -1) {
-                device->clk_vg_axi = clk_get(NULL, "openvg_axi_clk");
+                device->clk_vg_axi = clk_get(pdev, "openvg_axi_clk");
                 if (IS_ERR(device->clk_vg_axi)) {
                     IrqLineVG = -1;
 	                device->clk_vg_axi = NULL;
@@ -516,6 +537,9 @@ gckGALDEVICE_Construct(
             device->kernels[gcvCORE_MAJOR]->hardware, FastClear, Compression
             ));
 
+        gcmkONERROR(gckHARDWARE_SetPowerManagement(
+            device->kernels[gcvCORE_MAJOR]->hardware, PowerManagement
+            ));
 
 #if COMMAND_PROCESSOR_VERSION == 1
         /* Start the command queue. */
@@ -571,6 +595,10 @@ gckGALDEVICE_Construct(
             device
             ));
 
+        gcmkONERROR(gckHARDWARE_SetPowerManagement(
+            device->kernels[gcvCORE_2D]->hardware, PowerManagement
+            ));
+
 #if COMMAND_PROCESSOR_VERSION == 1
         /* Start the command queue. */
         gcmkONERROR(gckCOMMAND_Start(device->kernels[gcvCORE_2D]->command));
@@ -602,6 +630,11 @@ gckGALDEVICE_Construct(
             device->coreMapping[gcvHARDWARE_VG] = gcvCORE_VG;
         }
 
+
+        gcmkONERROR(gckVGHARDWARE_SetPowerManagement(
+            device->kernels[gcvCORE_VG]->vg->hardware,
+            PowerManagement
+            ));
 #endif
     }
     else
@@ -669,6 +702,16 @@ gckGALDEVICE_Construct(
     }
 
 
+    /* Grab the first availiable kernel */
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+    {
+        if (device->irqLines[i] != -1)
+        {
+            kernel = device->kernels[i];
+            break;
+        }
+    }
+
     /* Set up the internal memory region. */
     if (device->internalSize > 0)
     {
@@ -694,7 +737,8 @@ gckGALDEVICE_Construct(
                 gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
 
-            device->internalPhysical = (gctPHYS_ADDR) physical;
+            device->internalPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) physical;
+            device->internalPhysicalName = gcmPTR_TO_NAME(device->internalPhysical);
             physical += device->internalSize;
         }
     }
@@ -724,7 +768,8 @@ gckGALDEVICE_Construct(
                 gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
             }
 
-            device->externalPhysical = (gctPHYS_ADDR) physical;
+            device->externalPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) physical;
+            device->externalPhysicalName = gcmPTR_TO_NAME(device->externalPhysical);
             physical += device->externalSize;
         }
     }
@@ -749,6 +794,7 @@ gckGALDEVICE_Construct(
 
                 if (gcmIS_SUCCESS(status))
                 {
+                    device->contiguousPhysicalName = gcmPTR_TO_NAME(device->contiguousPhysical);
                     status = gckVIDMEM_Construct(
                         device->os,
                         physAddr | device->systemMemoryBaseAddress,
@@ -769,6 +815,7 @@ gckGALDEVICE_Construct(
                         device->contiguousPhysical
                         ));
 
+                    gcmRELEASE_NAME(device->contiguousPhysicalName);
                     device->contiguousBase     = gcvNULL;
                     device->contiguousPhysical = gcvNULL;
                 }
@@ -840,7 +887,8 @@ gckGALDEVICE_Construct(
                 }
 #endif
 
-                device->contiguousPhysical = (gctPHYS_ADDR) ContiguousBase;
+                device->contiguousPhysical = gcvNULL;
+                device->contiguousPhysicalName = 0;
                 device->contiguousSize     = ContiguousSize;
                 device->contiguousMapped   = gcvTRUE;
             }
@@ -885,11 +933,38 @@ gckGALDEVICE_Destroy(
 {
     gctINT i;
     gceSTATUS status = gcvSTATUS_OK;
+    gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("Device=0x%x", Device);
 
     if (Device != gcvNULL)
     {
+        /* Grab the first availiable kernel */
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+        {
+            if (Device->irqLines[i] != -1)
+            {
+                kernel = Device->kernels[i];
+                break;
+            }
+        }
+        if (Device->internalPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->internalPhysicalName);
+            Device->internalPhysicalName = 0;
+        }
+        if (Device->externalPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->externalPhysicalName);
+            Device->externalPhysicalName = 0;
+        }
+        if (Device->contiguousPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->contiguousPhysicalName);
+            Device->contiguousPhysicalName = 0;
+        }
+
+
         for (i = 0; i < gcdMAX_GPU_COUNT; i++)
         {
             if (Device->kernels[i] != gcvNULL)
@@ -1000,6 +1075,12 @@ gckGALDEVICE_Destroy(
         }
 
         /*Disable clock*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+        if (Device->clk_3d_axi) {
+           clk_put(Device->clk_3d_axi);
+           Device->clk_3d_axi = NULL;
+        }
+#endif
         if (Device->clk_3d_core) {
            clk_put(Device->clk_3d_core);
            Device->clk_3d_core = NULL;
@@ -1021,7 +1102,17 @@ gckGALDEVICE_Destroy(
            Device->clk_vg_axi = NULL;
         }
 
+#ifdef CONFIG_PM
+        if(Device->pmdev)
+            pm_runtime_disable(Device->pmdev);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        if (Device->gpu_regulator) {
+           regulator_put(Device->gpu_regulator);
+           Device->gpu_regulator = NULL;
+        }
+#endif
 
         /* Destroy the gckOS object. */
         if (Device->os != gcvNULL)
@@ -1550,6 +1641,11 @@ gckGALDEVICE_Start(
     {
         /* Setup the ISR routine. */
         gcmkONERROR(gckGALDEVICE_Setup_ISR_VG(Device));
+
+        /* Switch to SUSPEND power state. */
+        gcmkONERROR(gckVGHARDWARE_SetPowerManagementState(
+            Device->kernels[gcvCORE_VG]->vg->hardware, gcvPOWER_OFF_BROADCAST
+            ));
     }
 
     gcmkFOOTER_NO();
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index c159898..dde4f03 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_device_h_
 #define __gc_hal_kernel_device_h_
 
@@ -37,15 +35,18 @@ typedef struct _gckGALDEVICE
     /* Attributes. */
     gctSIZE_T           internalSize;
     gctPHYS_ADDR        internalPhysical;
+    gctUINT32           internalPhysicalName;
     gctPOINTER          internalLogical;
     gckVIDMEM           internalVidMem;
     gctSIZE_T           externalSize;
     gctPHYS_ADDR        externalPhysical;
+    gctUINT32           externalPhysicalName;
     gctPOINTER          externalLogical;
     gckVIDMEM           externalVidMem;
     gckVIDMEM           contiguousVidMem;
     gctPOINTER          contiguousBase;
     gctPHYS_ADDR        contiguousPhysical;
+    gctUINT32           contiguousPhysicalName;
     gctSIZE_T           contiguousSize;
     gctBOOL             contiguousMapped;
     gctPOINTER          contiguousMappedUser;
@@ -85,13 +86,17 @@ typedef struct _gckGALDEVICE
     /* Clock management.*/
     struct clk         *clk_3d_core;
     struct clk         *clk_3d_shader;
+    struct clk		   *clk_3d_axi;
     struct clk         *clk_2d_core;
     struct clk         *clk_2d_axi;
     struct clk         *clk_vg_axi;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     /*Power management.*/
     struct regulator      *gpu_regulator;
-
+#endif
+	/*Run time pm*/
+	struct device		*pmdev;
 }
 * gckGALDEVICE;
 
@@ -164,6 +169,8 @@ gceSTATUS gckGALDEVICE_Construct(
     IN gctUINT32 PhysSize,
     IN gctINT Signal,
     IN gctUINT LogFileSize,
+    IN struct device *pdev,
+    IN gctINT PowerManagement,
     OUT gckGALDEVICE *Device
     );
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index b326463..bacd531 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *    Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
 *
 *    This program is free software; you can redistribute it and/or modify
@@ -20,12 +20,9 @@
 *****************************************************************************/
 
 
-
-
 #include <linux/device.h>
 #include <linux/slab.h>
-#include <mach/viv_gpu.h>
-
+#include <linux/notifier.h>
 #include "gc_hal_kernel_linux.h"
 #include "gc_hal_driver.h"
 
@@ -41,12 +38,47 @@
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
 #    include <linux/resmem_account.h>
-#endif
+#    include <linux/kernel.h>
+#    include <linux/mm.h>
+#    include <linux/oom.h>
+#    include <linux/sched.h>
+#    include <linux/notifier.h>
+
+struct task_struct *lowmem_deathpending;
+
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data);
+
+static struct notifier_block task_nb = {
+	.notifier_call	= task_notify_func,
+};
 
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data)
+{
+	struct task_struct *task = data;
+
+	if (task == lowmem_deathpending)
+		lowmem_deathpending = NULL;
+
+	return NOTIFY_OK;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+#include <mach/viv_gpu.h>
+#else
+#include <linux/pm_runtime.h>
+#include <mach/busfreq.h>
+#endif
 /* Zone used for header/footer. */
 #define _GC_OBJ_ZONE    gcvZONE_DRIVER
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+extern int register_thermal_notifier(struct notifier_block *nb);
+extern int unregister_thermal_notifier(struct notifier_block *nb);
+#endif
+
 MODULE_DESCRIPTION("Vivante Graphics Driver");
 MODULE_LICENSE("GPL");
 
@@ -99,6 +131,9 @@ module_param(fastClear, int, 0644);
 static int compression = -1;
 module_param(compression, int, 0644);
 
+static int powerManagement = 1;
+module_param(powerManagement, int, 0644);
+
 static int signal = 48;
 module_param(signal, int, 0644);
 
@@ -114,6 +149,9 @@ module_param(logFileSize,uint, 0644);
 static int showArgs = 0;
 module_param(showArgs, int, 0644);
 
+int gpu3DMinClock = 0;
+module_param(gpu3DMinClock, int, 0644);
+
 #if ENABLE_GPU_CLOCK_BY_DRIVER
     unsigned long coreClock = 156000000;
     module_param(coreClock, ulong, 0644);
@@ -146,6 +184,9 @@ static struct file_operations driver_fops =
     .open       = drv_open,
     .release    = drv_release,
     .unlocked_ioctl = drv_ioctl,
+#ifdef HAVE_COMPAT_IOCTL
+    .compat_ioctl = drv_ioctl,
+#endif
     .mmap       = drv_mmap,
 };
 
@@ -196,7 +237,7 @@ int drv_open(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
-    data = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL | __GFP_NOWARN);
+    data = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL);
 
     if (data == gcvNULL)
     {
@@ -458,7 +499,7 @@ long drv_ioctl(
     }
 
     copyLen = copy_from_user(
-        &iface, drvArgs.InputBuffer, sizeof(gcsHAL_INTERFACE)
+        &iface, gcmUINT64_TO_PTR(drvArgs.InputBuffer), sizeof(gcsHAL_INTERFACE)
         );
 
     if (copyLen != 0)
@@ -536,25 +577,26 @@ long drv_ioctl(
 
     if (gcmIS_SUCCESS(status) && (iface.command == gcvHAL_LOCK_VIDEO_MEMORY))
     {
+        gcuVIDMEM_NODE_PTR node = gcmUINT64_TO_PTR(iface.u.LockVideoMemory.node);
         /* Special case for mapped memory. */
         if ((data->mappedMemory != gcvNULL)
-        &&  (iface.u.LockVideoMemory.node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+        &&  (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         )
         {
             /* Compute offset into mapped memory. */
             gctUINT32 offset
-                = (gctUINT8 *) iface.u.LockVideoMemory.memory
+                = (gctUINT8 *) gcmUINT64_TO_PTR(iface.u.LockVideoMemory.memory)
                 - (gctUINT8 *) device->contiguousBase;
 
             /* Compute offset into user-mapped region. */
             iface.u.LockVideoMemory.memory =
-                (gctUINT8 *) data->mappedMemory + offset;
+                gcmPTR_TO_UINT64((gctUINT8 *) data->mappedMemory + offset);
         }
     }
 
     /* Copy data back to the user. */
     copyLen = copy_to_user(
-        drvArgs.OutputBuffer, &iface, sizeof(gcsHAL_INTERFACE)
+        gcmUINT64_TO_PTR(drvArgs.OutputBuffer), &iface, sizeof(gcsHAL_INTERFACE)
         );
 
     if (copyLen != 0)
@@ -582,7 +624,7 @@ static int drv_mmap(
     struct vm_area_struct* vma
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
     gcsHAL_PRIVATE_DATA_PTR data;
     gckGALDEVICE device;
 
@@ -627,7 +669,7 @@ static int drv_mmap(
 
 #if !gcdPAGED_MEMORY_CACHEABLE
     vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-    vma->vm_flags    |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND;
+    vma->vm_flags    |= gcdVM_FLAGS;
 #endif
     vma->vm_pgoff     = 0;
 
@@ -650,7 +692,7 @@ static int drv_mmap(
         ret = io_remap_pfn_range(
             vma,
             vma->vm_start,
-            (gctUINT32) device->contiguousPhysical >> PAGE_SHIFT,
+            device->requestedContiguousBase >> PAGE_SHIFT,
             size,
             vma->vm_page_prot
             );
@@ -670,11 +712,12 @@ static int drv_mmap(
         }
 
         data->mappedMemory = (gctPOINTER) vma->vm_start;
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return 0;
     }
 
-    /* Success. */
-    gcmkFOOTER_NO();
-    return 0;
 
 OnError:
     gcmkFOOTER();
@@ -685,7 +728,7 @@ OnError:
 #if !USE_PLATFORM_DRIVER
 static int __init drv_init(void)
 #else
-static int drv_init(void)
+static int drv_init(struct device *pdev)
 #endif
 {
     int ret;
@@ -741,6 +784,9 @@ static int drv_init(void)
     }
 #endif
 
+    printk(KERN_INFO "Galcore version %d.%d.%d.%d\n",
+        gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH, gcvVERSION_BUILD);
+
     if (showArgs)
     {
         printk("galcore options:\n");
@@ -770,7 +816,8 @@ static int drv_init(void)
         printk("  signal            = %d\n",      signal);
         printk("  baseAddress       = 0x%08lX\n", baseAddress);
         printk("  physSize          = 0x%08lX\n", physSize);
-	printk(" logFileSize         = %d KB \n",     logFileSize);
+        printk("  logFileSize       = %d KB \n",  logFileSize);
+        printk("  powerManagement   = %d\n",      powerManagement);
 #if ENABLE_GPU_CLOCK_BY_DRIVER
         printk("  coreClock       = %lu\n",     coreClock);
 #endif
@@ -792,6 +839,8 @@ static int drv_init(void)
         contiguousBase, contiguousSize,
         bankSize, fastClear, compression, baseAddress, physSize, signal,
         logFileSize,
+        pdev,
+        powerManagement,
         &device
         ));
 
@@ -819,6 +868,7 @@ static int drv_init(void)
     }
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+    task_free_register(&task_nb);
     viv_gpu_resmem_handler.data = device->kernels[gcvCORE_MAJOR];
     register_reserved_memory_account(&viv_gpu_resmem_handler);
 #endif
@@ -904,6 +954,7 @@ static void drv_exit(void)
     gcmkHEADER();
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+    task_free_unregister(&task_nb);
     unregister_reserved_memory_account(&viv_gpu_resmem_handler);
 #endif
 
@@ -949,12 +1000,44 @@ static void drv_exit(void)
 #   define DEVICE_NAME "galcore"
 #endif
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+static int thermal_hot_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+    static gctUINT orgFscale, minFscale, maxFscale;
+    static gctBOOL bAlreadyTooHot = gcvFALSE;
+    gckHARDWARE hardware = galDevice->kernels[gcvCORE_MAJOR]->hardware;
+
+    if (event && !bAlreadyTooHot) {
+        gckHARDWARE_GetFscaleValue(hardware,&orgFscale,&minFscale, &maxFscale);
+        gckHARDWARE_SetFscaleValue(hardware, minFscale);
+        bAlreadyTooHot = gcvTRUE;
+        gckOS_Print("System is too hot. GPU3D will work at %d/64 clock.\n", minFscale);
+    } else if (!event && bAlreadyTooHot) {
+        gckHARDWARE_SetFscaleValue(hardware, orgFscale);
+        gckOS_Print("Hot alarm is canceled. GPU3D clock will return to %d/64\n", orgFscale);
+        bAlreadyTooHot = gcvFALSE;
+    }
+    return NOTIFY_OK;
+}
+
+static struct notifier_block thermal_hot_pm_notifier = {
+    .notifier_call = thermal_hot_pm_notify,
+    };
+#endif
+
+
+
 static int __devinit gpu_probe(struct platform_device *pdev)
 {
     int ret = -ENODEV;
     struct resource* res;
-    struct viv_gpu_platform_data *pdata;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	struct device_node *dn =pdev->dev.of_node;
+	const u32 *prop;
+#else
+	struct viv_gpu_platform_data *pdata;
+#endif
     gcmkHEADER();
 
     res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phys_baseaddr");
@@ -994,35 +1077,53 @@ static int __devinit gpu_probe(struct platform_device *pdev)
         registerMemSizeVG = res->end - res->start + 1;
     }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	prop = of_get_property(dn, "contiguousbase", NULL);
+	if(prop)
+		contiguousBase = *prop;
+	of_property_read_u32(dn,"contiguoussize", (u32 *)&contiguousSize);
+#else
     pdata = pdev->dev.platform_data;
     if (pdata) {
         contiguousBase = pdata->reserved_mem_base;
         contiguousSize = pdata->reserved_mem_size;
      }
-
-    ret = drv_init();
+#endif
+    if (contiguousSize == 0)
+       gckOS_Print("Warning: No contiguous memory is reserverd for gpu.!\n ");
+    ret = drv_init(&pdev->dev);
 
     if (!ret)
     {
         platform_set_drvdata(pdev, galDevice);
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+        if(galDevice->kernels[gcvCORE_MAJOR])
+            register_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
         gcmkFOOTER_NO();
         return ret;
     }
-
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    unregister_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
     gcmkFOOTER_ARG(KERN_INFO "Failed to register gpu driver: %d\n", ret);
     return ret;
 }
 
-static int __devinit gpu_remove(struct platform_device *pdev)
+static int __devexit gpu_remove(struct platform_device *pdev)
 {
     gcmkHEADER();
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    if(galDevice->kernels[gcvCORE_MAJOR])
+        unregister_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
     drv_exit();
     gcmkFOOTER_NO();
     return 0;
 }
 
-static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state)
+static int gpu_suspend(struct platform_device *dev, pm_message_t state)
 {
     gceSTATUS status;
     gckGALDEVICE device;
@@ -1072,7 +1173,7 @@ static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state
     return 0;
 }
 
-static int __devinit gpu_resume(struct platform_device *dev)
+static int gpu_resume(struct platform_device *dev)
 {
     gceSTATUS status;
     gckGALDEVICE device;
@@ -1143,15 +1244,59 @@ static int __devinit gpu_resume(struct platform_device *dev)
     return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+static const struct of_device_id mxs_gpu_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-gpu", },
+	{/* sentinel */}
+};
+MODULE_DEVICE_TABLE(of, mxs_gpu_dt_ids);
+
+#ifdef CONFIG_PM
+static int gpu_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static int gpu_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static int gpu_system_suspend(struct device *dev)
+{
+	pm_message_t state={0};
+	return gpu_suspend(to_platform_device(dev), state);
+}
+
+static int gpu_system_resume(struct device *dev)
+{
+	return gpu_resume(to_platform_device(dev));
+}
+
+static const struct dev_pm_ops gpu_pm_ops = {
+	SET_RUNTIME_PM_OPS(gpu_runtime_suspend, gpu_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(gpu_system_suspend, gpu_system_resume)
+};
+#endif
+#endif
+
 static struct platform_driver gpu_driver = {
     .probe      = gpu_probe,
-    .remove     = gpu_remove,
+    .remove     = __devexit_p(gpu_remove),
 
     .suspend    = gpu_suspend,
     .resume     = gpu_resume,
 
     .driver     = {
         .name   = DEVICE_NAME,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+		.of_match_table = mxs_gpu_dt_ids,
+#if CONFIG_PM
+		.pm		= &gpu_pm_ops,
+#endif
+#endif
     }
 };
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
index cba2040..22c4071 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
@@ -65,15 +63,15 @@ gckKERNEL_QueryVideoMemory(
 
     /* Get internal memory size and physical address. */
     Interface->u.QueryVideoMemory.internalSize = device->internalSize;
-    Interface->u.QueryVideoMemory.internalPhysical = device->internalPhysical;
+    Interface->u.QueryVideoMemory.internalPhysical = device->internalPhysicalName;
 
     /* Get external memory size and physical address. */
     Interface->u.QueryVideoMemory.externalSize = device->externalSize;
-    Interface->u.QueryVideoMemory.externalPhysical = device->externalPhysical;
+    Interface->u.QueryVideoMemory.externalPhysical = device->externalPhysicalName;
 
     /* Get contiguous memory size and physical address. */
     Interface->u.QueryVideoMemory.contiguousSize = device->contiguousSize;
-    Interface->u.QueryVideoMemory.contiguousPhysical = device->contiguousPhysical;
+    Interface->u.QueryVideoMemory.contiguousPhysical = device->contiguousPhysicalName;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -181,7 +179,10 @@ gckKERNEL_MapMemory(
     OUT gctPOINTER * Logical
     )
 {
-    return gckOS_MapMemory(Kernel->os, Physical, Bytes, Logical);
+    gckKERNEL kernel = Kernel;
+    gctPHYS_ADDR physical = gcmNAME_TO_PTR(Physical);
+
+    return gckOS_MapMemory(Kernel->os, physical, Bytes, Logical);
 }
 
 /*******************************************************************************
@@ -216,7 +217,10 @@ gckKERNEL_UnmapMemory(
     IN gctPOINTER Logical
     )
 {
-    return gckOS_UnmapMemory(Kernel->os, Physical, Bytes, Logical);
+    gckKERNEL kernel = Kernel;
+    gctPHYS_ADDR physical = gcmNAME_TO_PTR(Physical);
+
+    return gckOS_UnmapMemory(Kernel->os, physical, Bytes, Logical);
 }
 
 /*******************************************************************************
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
index a6ed03f..3c148f6 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_linux_h_
 #define __gc_hal_kernel_linux_h_
 
@@ -75,6 +73,12 @@
 
 #define GetPageCount(size, offset) 	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,7,0)
+#define gcdVM_FLAGS (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP)
+#else
+#define gcdVM_FLAGS (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED)
+#endif
+
 static inline gctINT
 GetOrder(
 	IN gctINT numPages
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
index a4cb717..992aeff 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 gctINT
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index a44180b..e7edc39 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 #include <linux/pagemap.h>
@@ -38,7 +36,12 @@
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
 #include <linux/math64.h>
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#include <mach/common.h>
+#endif
 #include <linux/delay.h>
+#include <linux/pm_runtime.h>
+
 
 #define _GC_OBJ_ZONE    gcvZONE_OS
 
@@ -52,6 +55,7 @@ const char * _PLATFORM = "\n\0$PLATFORM$Linux$\n";
 #endif
 
 #define USER_SIGNAL_TABLE_LEN_INIT  64
+#define gcdSUPPRESS_OOM_MESSAGE 1
 
 #define MEMORY_LOCK(os) \
     gcmkVERIFY_OK(gckOS_AcquireMutex( \
@@ -82,6 +86,12 @@ const char * _PLATFORM = "\n\0$PLATFORM$Linux$\n";
 #define gcmkNONPAGED_MEMROY_PROT(x) pgprot_noncached(x)
 #endif
 
+#if gcdSUPPRESS_OOM_MESSAGE
+#define gcdNOWARN __GFP_NOWARN
+#else
+#define gcdNOWARN 0
+#endif
+
 #define gcdINFINITE_TIMEOUT     (60 * 1000)
 #define gcdDETECT_TIMEOUT       0
 #define gcdDETECT_DMA_ADDRESS   1
@@ -213,18 +223,6 @@ typedef struct _gcsPageInfo
 }
 gcsPageInfo;
 
-typedef struct _gcsiDEBUG_REGISTERS * gcsiDEBUG_REGISTERS_PTR;
-typedef struct _gcsiDEBUG_REGISTERS
-{
-    gctSTRING       module;
-    gctUINT         index;
-    gctUINT         shift;
-    gctUINT         data;
-    gctUINT         count;
-    gctUINT32       signature;
-}
-gcsiDEBUG_REGISTERS;
-
 typedef struct _gcsOSTIMER * gcsOSTIMER_PTR;
 typedef struct _gcsOSTIMER
 {
@@ -237,318 +235,6 @@ typedef struct _gcsOSTIMER
 ******************************* Private Functions ******************************
 \******************************************************************************/
 
-static gceSTATUS
-_VerifyDMA(
-    IN gckOS Os,
-    IN gceCORE Core,
-    gctUINT32_PTR Address1,
-    gctUINT32_PTR Address2,
-    gctUINT32_PTR State1,
-    gctUINT32_PTR State2
-    )
-{
-    gceSTATUS status;
-    gctUINT32 i;
-
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State1));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address1));
-
-    for (i = 0; i < 500; i += 1)
-    {
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State2));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address2));
-
-        if (*Address1 != *Address2)
-        {
-            break;
-        }
-
-#if gcdDETECT_DMA_STATE
-        if (*State1 != *State2)
-        {
-            break;
-        }
-#endif
-    }
-
-OnError:
-    return status;
-}
-
-static gceSTATUS
-_DumpDebugRegisters(
-    IN gckOS Os,
-    IN gcsiDEBUG_REGISTERS_PTR Descriptor
-    )
-{
-    gceSTATUS status;
-    gctUINT32 select;
-    gctUINT32 data;
-    gctUINT i;
-
-    gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
-
-    gcmkPRINT_N(4, "  %s debug registers:\n", Descriptor->module);
-
-    for (i = 0; i < Descriptor->count; i += 1)
-    {
-        select = i << Descriptor->shift;
-
-        gcmkONERROR(gckOS_WriteRegister(Os, Descriptor->index, select));
-#if !gcdENABLE_RECOVERY
-        gcmkONERROR(gckOS_Delay(Os, 1000));
-#endif
-        gcmkONERROR(gckOS_ReadRegister(Os, Descriptor->data, &data));
-
-        gcmkPRINT_N(12, "    [0x%02X] 0x%08X\n", i, data);
-    }
-
-    select = 0xF << Descriptor->shift;
-
-    for (i = 0; i < 500; i += 1)
-    {
-        gcmkONERROR(gckOS_WriteRegister(Os, Descriptor->index, select));
-#if !gcdENABLE_RECOVERY
-        gcmkONERROR(gckOS_Delay(Os, 1000));
-#endif
-        gcmkONERROR(gckOS_ReadRegister(Os, Descriptor->data, &data));
-
-        if (data == Descriptor->signature)
-        {
-            break;
-        }
-    }
-
-    if (i == 500)
-    {
-        gcmkPRINT_N(4, "    failed to obtain the signature (read 0x%08X).\n", data);
-    }
-    else
-    {
-        gcmkPRINT_N(8, "    signature = 0x%08X (%d read attempt(s))\n", data, i + 1);
-    }
-
-OnError:
-    /* Return the error. */
-    gcmkFOOTER();
-    return status;
-}
-
-static gceSTATUS
-_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
-    )
-{
-    static gctCONST_STRING _cmdState[] =
-    {
-        "PAR_IDLE_ST", "PAR_DEC_ST", "PAR_ADR0_ST", "PAR_LOAD0_ST",
-        "PAR_ADR1_ST", "PAR_LOAD1_ST", "PAR_3DADR_ST", "PAR_3DCMD_ST",
-        "PAR_3DCNTL_ST", "PAR_3DIDXCNTL_ST", "PAR_INITREQDMA_ST",
-        "PAR_DRAWIDX_ST", "PAR_DRAW_ST", "PAR_2DRECT0_ST", "PAR_2DRECT1_ST",
-        "PAR_2DDATA0_ST", "PAR_2DDATA1_ST", "PAR_WAITFIFO_ST", "PAR_WAIT_ST",
-        "PAR_LINK_ST", "PAR_END_ST", "PAR_STALL_ST"
-    };
-
-    static gctCONST_STRING _cmdDmaState[] =
-    {
-        "CMD_IDLE_ST", "CMD_START_ST", "CMD_REQ_ST", "CMD_END_ST"
-    };
-
-    static gctCONST_STRING _cmdFetState[] =
-    {
-        "FET_IDLE_ST", "FET_RAMVALID_ST", "FET_VALID_ST"
-    };
-
-    static gctCONST_STRING _reqDmaState[] =
-    {
-        "REQ_IDLE_ST", "REQ_WAITIDX_ST", "REQ_CAL_ST"
-    };
-
-    static gctCONST_STRING _calState[] =
-    {
-        "CAL_IDLE_ST", "CAL_LDADR_ST", "CAL_IDXCALC_ST"
-    };
-
-    static gctCONST_STRING _veReqState[] =
-    {
-        "VER_IDLE_ST", "VER_CKCACHE_ST", "VER_MISS_ST"
-    };
-
-    static gcsiDEBUG_REGISTERS _dbgRegs[] =
-    {
-        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
-        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
-        { "FE", 0x470,  0, 0x450, 16, 0xBABEF00D },
-        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
-        { "DE", 0x470,  8, 0x458, 16, 0xBABEF00D },
-        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
-        { "PA", 0x474,  0, 0x460, 16, 0x0000AAAA },
-        { "SE", 0x474,  8, 0x464, 16, 0x5E5E5E5E },
-        { "MC", 0x478,  0, 0x468, 16, 0x12345678 },
-        { "HI", 0x478,  8, 0x46C, 16, 0xAAAAAAAA }
-    };
-
-    static gctUINT32 _otherRegs[] =
-    {
-        0x040, 0x044, 0x04C, 0x050, 0x054, 0x058, 0x05C, 0x060,
-        0x43c, 0x440, 0x444, 0x414,
-    };
-
-    gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
-    gckGALDEVICE device;
-    gckKERNEL kernel;
-    gctUINT32 idle, axi;
-    gctUINT32 dmaAddress1, dmaAddress2;
-    gctUINT32 dmaState1, dmaState2;
-    gctUINT32 dmaLow, dmaHigh;
-    gctUINT32 cmdState, cmdDmaState, cmdFetState;
-    gctUINT32 dmaReqState, calState, veReqState;
-    gctUINT i;
-
-    gcmkHEADER_ARG("Os=0x%X, Core=%d", Os, Core);
-
-    gcmkONERROR(gckOS_AcquireMutex(Os, Os->debugLock, gcvINFINITE));
-    acquired = gcvTRUE;
-
-    /* Extract the pointer to the gckGALDEVICE class. */
-    device = (gckGALDEVICE) Os->device;
-
-    /* TODO: Kernel shortcut. */
-    kernel = device->kernels[Core];
-    gcmkPRINT_N(4, "GPU[%d]:\n",Core);
-
-    if (kernel == gcvNULL)
-    {
-        gcmkFOOTER();
-        return gcvSTATUS_OK;
-    }
-
-    /* Reset register values. */
-    idle        = axi         =
-    dmaState1   = dmaState2   =
-    dmaAddress1 = dmaAddress2 =
-    dmaLow      = dmaHigh     = 0;
-
-    /* Verify whether DMA is running. */
-    gcmkONERROR(_VerifyDMA(
-        Os, kernel->core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
-        ));
-
-    cmdState    =  dmaState2        & 0x1F;
-    cmdDmaState = (dmaState2 >>  8) & 0x03;
-    cmdFetState = (dmaState2 >> 10) & 0x03;
-    dmaReqState = (dmaState2 >> 12) & 0x03;
-    calState    = (dmaState2 >> 14) & 0x03;
-    veReqState  = (dmaState2 >> 16) & 0x03;
-
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x004, &idle));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x00C, &axi));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x668, &dmaLow));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x66C, &dmaHigh));
-
-    gcmkPRINT_N(0, "**************************\n");
-    gcmkPRINT_N(0, "***   GPU STATE DUMP   ***\n");
-    gcmkPRINT_N(0, "**************************\n");
-
-    gcmkPRINT_N(4, "  axi      = 0x%08X\n", axi);
-
-    gcmkPRINT_N(4, "  idle     = 0x%08X\n", idle);
-    if ((idle & 0x00000001) == 0) gcmkPRINT_N(0, "    FE not idle\n");
-    if ((idle & 0x00000002) == 0) gcmkPRINT_N(0, "    DE not idle\n");
-    if ((idle & 0x00000004) == 0) gcmkPRINT_N(0, "    PE not idle\n");
-    if ((idle & 0x00000008) == 0) gcmkPRINT_N(0, "    SH not idle\n");
-    if ((idle & 0x00000010) == 0) gcmkPRINT_N(0, "    PA not idle\n");
-    if ((idle & 0x00000020) == 0) gcmkPRINT_N(0, "    SE not idle\n");
-    if ((idle & 0x00000040) == 0) gcmkPRINT_N(0, "    RA not idle\n");
-    if ((idle & 0x00000080) == 0) gcmkPRINT_N(0, "    TX not idle\n");
-    if ((idle & 0x00000100) == 0) gcmkPRINT_N(0, "    VG not idle\n");
-    if ((idle & 0x00000200) == 0) gcmkPRINT_N(0, "    IM not idle\n");
-    if ((idle & 0x00000400) == 0) gcmkPRINT_N(0, "    FP not idle\n");
-    if ((idle & 0x00000800) == 0) gcmkPRINT_N(0, "    TS not idle\n");
-    if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
-
-    if (
-        (dmaAddress1 == dmaAddress2)
-
-#if gcdDETECT_DMA_STATE
-     && (dmaState1 == dmaState2)
-#endif
-    )
-    {
-        gcmkPRINT_N(0, "  DMA appears to be stuck at this address:\n");
-        gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
-    }
-    else
-    {
-        if (dmaAddress1 == dmaAddress2)
-        {
-            gcmkPRINT_N(0, "  DMA address is constant, but state is changing:\n");
-            gcmkPRINT_N(4, "    0x%08X\n", dmaState1);
-            gcmkPRINT_N(4, "    0x%08X\n", dmaState2);
-        }
-        else
-        {
-            gcmkPRINT_N(0, "  DMA is running; known addresses are:\n");
-            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
-            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress2);
-        }
-    }
-
-    gcmkPRINT_N(4, "  dmaLow   = 0x%08X\n", dmaLow);
-    gcmkPRINT_N(4, "  dmaHigh  = 0x%08X\n", dmaHigh);
-    gcmkPRINT_N(4, "  dmaState = 0x%08X\n", dmaState2);
-    gcmkPRINT_N(8, "    command state       = %d (%s)\n", cmdState,    _cmdState   [cmdState]);
-    gcmkPRINT_N(8, "    command DMA state   = %d (%s)\n", cmdDmaState, _cmdDmaState[cmdDmaState]);
-    gcmkPRINT_N(8, "    command fetch state = %d (%s)\n", cmdFetState, _cmdFetState[cmdFetState]);
-    gcmkPRINT_N(8, "    DMA request state   = %d (%s)\n", dmaReqState, _reqDmaState[dmaReqState]);
-    gcmkPRINT_N(8, "    cal state           = %d (%s)\n", calState,    _calState   [calState]);
-    gcmkPRINT_N(8, "    VE request state    = %d (%s)\n", veReqState,  _veReqState [veReqState]);
-
-    for (i = 0; i < gcmCOUNTOF(_dbgRegs); i += 1)
-    {
-        gcmkONERROR(_DumpDebugRegisters(Os, &_dbgRegs[i]));
-    }
-
-    if (kernel->hardware->identity.chipFeatures & (1 << 4))
-    {
-        gctUINT32 read0, read1, write;
-
-        read0 = read1 = write = 0;
-
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x43C, &read0));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x440, &read1));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x444, &write));
-
-        gcmkPRINT_N(4, "  read0    = 0x%08X\n", read0);
-        gcmkPRINT_N(4, "  read1    = 0x%08X\n", read1);
-        gcmkPRINT_N(4, "  write    = 0x%08X\n", write);
-    }
-
-    gcmkPRINT_N(0, "  Other Registers:\n");
-    for (i = 0; i < gcmCOUNTOF(_otherRegs); i += 1)
-    {
-        gctUINT32 read;
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, _otherRegs[i], &read));
-        gcmkPRINT_N(12, "    [0x%04X] 0x%08X\n", _otherRegs[i], read);
-    }
-
-    /* Dump call stack. */
-    dump_stack();
-
-OnError:
-    if (acquired)
-    {
-        /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->debugLock));
-    }
-
-    /* Return the error. */
-    gcmkFOOTER();
-    return status;
-}
-
 static gctINT
 _GetProcessID(
     void
@@ -582,7 +268,7 @@ _CreateMdl(
 
     gcmkHEADER_ARG("ProcessID=%d", ProcessID);
 
-    mdl = (PLINUX_MDL)kmalloc(sizeof(struct _LINUX_MDL), GFP_KERNEL | __GFP_NOWARN);
+    mdl = (PLINUX_MDL)kzalloc(sizeof(struct _LINUX_MDL), GFP_KERNEL | gcdNOWARN);
     if (mdl == gcvNULL)
     {
         gcmkFOOTER_NO();
@@ -643,7 +329,7 @@ _CreateMdlMap(
 
     gcmkHEADER_ARG("Mdl=0x%X ProcessID=%d", Mdl, ProcessID);
 
-    mdlMap = (PLINUX_MDL_MAP)kmalloc(sizeof(struct _LINUX_MDL_MAP), GFP_KERNEL | __GFP_NOWARN);
+    mdlMap = (PLINUX_MDL_MAP)kmalloc(sizeof(struct _LINUX_MDL_MAP), GFP_KERNEL | gcdNOWARN);
     if (mdlMap == gcvNULL)
     {
         gcmkFOOTER_NO();
@@ -802,7 +488,7 @@ _NonContiguousAlloc(
 
     size = NumPages * sizeof(struct page *);
 
-    pages = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);
+    pages = kmalloc(size, GFP_KERNEL | gcdNOWARN);
 
     if (!pages)
     {
@@ -817,7 +503,7 @@ _NonContiguousAlloc(
 
     for (i = 0; i < NumPages; i++)
     {
-        p = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_NOWARN);
+        p = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN);
 
         if (!p)
         {
@@ -1083,7 +769,7 @@ _AllocateIntegerId(
     int result;
 
 again:
-    if (idr_pre_get(&Database->idr, GFP_KERNEL | __GFP_NOWARN) == 0)
+    if (idr_pre_get(&Database->idr, GFP_KERNEL | gcdNOWARN) == 0)
     {
         return gcvSTATUS_OUT_OF_MEMORY;
     }
@@ -1190,6 +876,60 @@ _UnmapUserLogical(
 #endif
 }
 
+gceSTATUS
+_QueryProcessPageTable(
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    )
+{
+    spinlock_t *lock;
+    gctUINTPTR_T logical = (gctUINTPTR_T)Logical;
+    pgd_t *pgd;
+    pud_t *pud;
+    pmd_t *pmd;
+    pte_t *pte;
+
+    if (!current->mm)
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pgd = pgd_offset(current->mm, logical);
+    if (pgd_none(*pgd) || pgd_bad(*pgd))
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pud = pud_offset(pgd, logical);
+    if (pud_none(*pud) || pud_bad(*pud))
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pmd = pmd_offset(pud, logical);
+    if (pmd_none(*pmd) || pmd_bad(*pmd))
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pte = pte_offset_map_lock(current->mm, pmd, logical, &lock);
+    if (!pte)
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    if (!pte_present(*pte))
+    {
+        pte_unmap_unlock(pte, lock);
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    *Address = (pte_pfn(*pte) << PAGE_SHIFT) | (logical & ~PAGE_MASK);
+    pte_unmap_unlock(pte, lock);
+
+    return gcvSTATUS_OK;
+}
+
 /*******************************************************************************
 **
 **  gckOS_Construct
@@ -1221,7 +961,7 @@ gckOS_Construct(
     gcmkVERIFY_ARGUMENT(Os != gcvNULL);
 
     /* Allocate the gckOS object. */
-    os = (gckOS) kmalloc(gcmSIZEOF(struct _gckOS), GFP_KERNEL | __GFP_NOWARN);
+    os = (gckOS) kmalloc(gcmSIZEOF(struct _gckOS), GFP_KERNEL | gcdNOWARN);
 
     if (os == gcvNULL)
     {
@@ -1408,39 +1148,66 @@ gckOS_Destroy(
     return gcvSTATUS_OK;
 }
 
-#ifdef NO_DMA_COHERENT
 static gctSTRING
 _CreateKernelVirtualMapping(
-    IN struct page * Page,
-    IN gctINT NumPages
+    IN PLINUX_MDL Mdl
     )
 {
     gctSTRING addr = 0;
+    gctINT numPages = Mdl->numPages;
 
 #if gcdNONPAGED_MEMORY_CACHEABLE
-    addr = page_address(Page);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+    if (Mdl->contiguous)
+    {
+        addr = page_address(Mdl->u.contiguousPages);
+    }
+    else
+    {
+        addr = vmap(Mdl->u.nonContiguousPages,
+                    numPages,
+                    0,
+                    PAGE_KERNEL);
+
+        /* Trigger a page fault. */
+        memset(addr, 0, numPages * PAGE_SIZE);
+    }
+#else
     struct page ** pages;
+    gctBOOL free = gcvFALSE;
     gctINT i;
 
-    pages = kmalloc(sizeof(struct page *) * NumPages, GFP_KERNEL | __GFP_NOWARN);
-
-    if (!pages)
+    if (Mdl->contiguous)
     {
-        return gcvNULL;
-    }
+        pages = kmalloc(sizeof(struct page *) * numPages, GFP_KERNEL | gcdNOWARN);
 
-    for (i = 0; i < NumPages; i++)
+        if (!pages)
+        {
+            return gcvNULL;
+        }
+
+        for (i = 0; i < numPages; i++)
+        {
+            pages[i] = nth_page(Mdl->u.contiguousPages, i);
+        }
+
+        free = gcvTRUE;
+    }
+    else
     {
-        pages[i] = nth_page(Page, i);
+        pages = Mdl->u.nonContiguousPages;
     }
 
     /* ioremap() can't work on system memory since 2.6.38. */
-    addr = vmap(pages, NumPages, 0, gcmkNONPAGED_MEMROY_PROT(PAGE_KERNEL));
+    addr = vmap(pages, numPages, 0, gcmkNONPAGED_MEMROY_PROT(PAGE_KERNEL));
+
+    /* Trigger a page fault. */
+    memset(addr, 0, numPages * PAGE_SIZE);
+
+    if (free)
+    {
+        kfree(pages);
+    }
 
-    kfree(pages);
-#else
-    addr = gcmkIOREMAP(page_to_phys(Page), NumPages * PAGE_SIZE);
 #endif
 
     return addr;
@@ -1452,14 +1219,31 @@ _DestoryKernelVirtualMapping(
     )
 {
 #if !gcdNONPAGED_MEMORY_CACHEABLE
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
     vunmap(Addr);
-#   else
-    iounmap(Addr);
-#   endif
 #endif
 }
-#endif
+
+gceSTATUS
+gckOS_CreateKernelVirtualMapping(
+    IN gctPHYS_ADDR Physical,
+    OUT gctSIZE_T * PageCount,
+    OUT gctPOINTER * Logical
+    )
+{
+    *PageCount = ((PLINUX_MDL)Physical)->numPages;
+    *Logical = _CreateKernelVirtualMapping((PLINUX_MDL)Physical);
+
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_DestroyKernelVirtualMapping(
+    IN gctPOINTER Logical
+    )
+{
+    _DestoryKernelVirtualMapping((gctSTRING)Logical);
+    return gcvSTATUS_OK;
+}
 
 /*******************************************************************************
 **
@@ -1608,7 +1392,7 @@ gckOS_AllocateMemory(
     }
     else
     {
-        memory = (gctPOINTER) kmalloc(Bytes, GFP_KERNEL | __GFP_NOWARN);
+        memory = (gctPOINTER) kmalloc(Bytes, GFP_KERNEL | gcdNOWARN);
     }
 
     if (memory == gcvNULL)
@@ -1732,6 +1516,14 @@ gckOS_MapMemory(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (char *)vm_mmap(gcvNULL,
+                    0L,
+                    mdl->numPages * PAGE_SIZE,
+                    PROT_READ | PROT_WRITE,
+                    MAP_SHARED,
+                    0);
+#else
         down_write(&current->mm->mmap_sem);
 
         mdlMap->vmaAddr = (char *)do_mmap_pgoff(gcvNULL,
@@ -1741,6 +1533,9 @@ gckOS_MapMemory(
                     MAP_SHARED,
                     0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         if (IS_ERR(mdlMap->vmaAddr))
         {
             gcmkTRACE(
@@ -1759,14 +1554,14 @@ gckOS_MapMemory(
 
             mdlMap->vmaAddr = gcvNULL;
 
-            up_write(&current->mm->mmap_sem);
-
             MEMORY_UNLOCK(Os);
 
             gcmkFOOTER_ARG("status=%d", gcvSTATUS_OUT_OF_MEMORY);
             return gcvSTATUS_OUT_OF_MEMORY;
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (!mdlMap->vma)
@@ -1812,7 +1607,7 @@ gckOS_MapMemory(
 #else
 #if !gcdPAGED_MEMORY_CACHEABLE
         mdlMap->vma->vm_page_prot = gcmkPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
-        mdlMap->vma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED;
+        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
 #   endif
         mdlMap->vma->vm_pgoff = 0;
 
@@ -2116,7 +1911,7 @@ gckOS_AllocateNonPagedMemory(
         addr = dma_alloc_coherent(gcvNULL,
                 mdl->numPages * PAGE_SIZE,
                 &mdl->dmaHandle,
-                GFP_KERNEL | __GFP_NOWARN);
+                GFP_KERNEL | gcdNOWARN);
     }
 #else
     size    = mdl->numPages * PAGE_SIZE;
@@ -2127,7 +1922,7 @@ gckOS_AllocateNonPagedMemory(
     if (page == gcvNULL)
 #endif
     {
-        page = alloc_pages(GFP_KERNEL | __GFP_NOWARN, order);
+        page = alloc_pages(GFP_KERNEL | gcdNOWARN, order);
     }
 
     if (page == gcvNULL)
@@ -2136,17 +1931,21 @@ gckOS_AllocateNonPagedMemory(
     }
 
     vaddr           = (gctPOINTER)page_address(page);
-    addr            = _CreateKernelVirtualMapping(page, mdl->numPages);
+    mdl->contiguous = gcvTRUE;
+    mdl->u.contiguousPages = page;
+    addr            = _CreateKernelVirtualMapping(mdl);
     mdl->dmaHandle  = virt_to_phys(vaddr);
     mdl->kaddr      = vaddr;
     mdl->u.contiguousPages = page;
 
+#if !defined(CONFIG_PPC)
     /* Cache invalidate. */
     dma_sync_single_for_device(
                 gcvNULL,
                 page_to_phys(page),
                 bytes,
                 DMA_FROM_DEVICE);
+#endif
 
     while (size > 0)
     {
@@ -2186,6 +1985,14 @@ gckOS_AllocateNonPagedMemory(
         /* Only after mmap this will be valid. */
 
         /* We need to map this to user space. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (gctSTRING) vm_mmap(gcvNULL,
+                0L,
+                mdl->numPages * PAGE_SIZE,
+                PROT_READ | PROT_WRITE,
+                MAP_SHARED,
+                0);
+#else
         down_write(&current->mm->mmap_sem);
 
         mdlMap->vmaAddr = (gctSTRING) do_mmap_pgoff(gcvNULL,
@@ -2195,6 +2002,9 @@ gckOS_AllocateNonPagedMemory(
                 MAP_SHARED,
                 0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         if (IS_ERR(mdlMap->vmaAddr))
         {
             gcmkTRACE_ZONE(
@@ -2205,11 +2015,11 @@ gckOS_AllocateNonPagedMemory(
 
             mdlMap->vmaAddr = gcvNULL;
 
-            up_write(&current->mm->mmap_sem);
-
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (mdlMap->vma == gcvNULL)
@@ -2244,7 +2054,7 @@ gckOS_AllocateNonPagedMemory(
         }
 #else
         mdlMap->vma->vm_page_prot = gcmkNONPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
-        mdlMap->vma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED;
+        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
         mdlMap->vma->vm_pgoff = 0;
 
         if (remap_pfn_range(mdlMap->vma,
@@ -2624,12 +2434,18 @@ gckOS_GetPhysicalAddress(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
-    /* Get current process ID. */
-    processID = _GetProcessID();
+    /* Query page table of current process first. */
+    status = _QueryProcessPageTable(Logical, Address);
 
-    /* Route through other function. */
-    gcmkONERROR(
-        gckOS_GetPhysicalAddressProcess(Os, Logical, processID, Address));
+    if (gcmIS_ERROR(status))
+    {
+        /* Get current process ID. */
+        processID = _GetProcessID();
+
+        /* Route through other function. */
+        gcmkONERROR(
+            gckOS_GetPhysicalAddressProcess(Os, Logical, processID, Address));
+    }
 
     /* Success. */
     gcmkFOOTER_ARG("*Address=0x%08x", *Address);
@@ -3438,7 +3254,7 @@ gckOS_AtomicExchangePtr(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
     /* Exchange the pair of pointers. */
-    *OldValue = (gctPOINTER) atomic_xchg((atomic_t *) Target, (int) NewValue);
+    *OldValue = (gctPOINTER)(gctUINTPTR_T) atomic_xchg((atomic_t *) Target, (int)(gctUINTPTR_T) NewValue);
 
     /* Success. */
     gcmkFOOTER_ARG("*OldValue=0x%X", *OldValue);
@@ -4039,6 +3855,9 @@ gckOS_AllocatePagedMemoryEx(
     gctSIZE_T bytes;
     gctBOOL locked = gcvFALSE;
     gceSTATUS status;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+    gctPOINTER addr = gcvNULL;
+#endif
 
     gcmkHEADER_ARG("Os=0x%X Contiguous=%d Bytes=%lu", Os, Contiguous, Bytes);
 
@@ -4064,13 +3883,27 @@ gckOS_AllocatePagedMemoryEx(
     {
         /* Get contiguous pages, and suppress warning (stack dump) from kernel when
            we run out of memory. */
-        mdl->u.contiguousPages =
-            alloc_pages(GFP_KERNEL | __GFP_NOWARN, GetOrder(numPages));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        addr =
+            alloc_pages_exact(numPages * PAGE_SIZE, GFP_KERNEL | gcdNOWARN | __GFP_NORETRY);
+
+        mdl->u.contiguousPages = addr
+                               ? virt_to_page(addr)
+                               : gcvNULL;
 
+        mdl->exact = gcvTRUE;
+#else
+        mdl->u.contiguousPages =
+            alloc_pages(GFP_KERNEL | gcdNOWARN | __GFP_NORETRY, GetOrder(numPages));
+#endif
         if (mdl->u.contiguousPages == gcvNULL)
         {
             mdl->u.contiguousPages =
-                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | __GFP_NOWARN, GetOrder(numPages));
+                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN, GetOrder(numPages));
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+            mdl->exact = gcvFALSE;
+#endif
         }
     }
     else
@@ -4108,7 +3941,7 @@ gckOS_AllocatePagedMemoryEx(
         {
             gcmkVERIFY_OK(
                 gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)page_to_phys(page),
+                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(page),
                                  page_address(page),
                                  PAGE_SIZE));
         }
@@ -4215,7 +4048,16 @@ gckOS_FreePagedMemory(
 
     if (mdl->contiguous)
     {
-        __free_pages(mdl->u.contiguousPages, GetOrder(mdl->numPages));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        if (mdl->exact == gcvTRUE)
+        {
+            free_pages_exact(page_address(mdl->u.contiguousPages), mdl->numPages * PAGE_SIZE);
+        }
+        else
+#endif
+        {
+            __free_pages(mdl->u.contiguousPages, GetOrder(mdl->numPages));
+        }
     }
     else
     {
@@ -4330,6 +4172,14 @@ gckOS_LockPages(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (gctSTRING)vm_mmap(gcvNULL,
+                        0L,
+                        mdl->numPages * PAGE_SIZE,
+                        PROT_READ | PROT_WRITE,
+                        MAP_SHARED,
+                        0);
+#else
         down_write(&current->mm->mmap_sem);
 
         mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
@@ -4339,18 +4189,19 @@ gckOS_LockPages(
                         MAP_SHARED,
                         0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         gcmkTRACE_ZONE(
             gcvLEVEL_INFO, gcvZONE_OS,
             "%s(%d): vmaAddr->0x%X for phys_addr->0x%X",
             __FUNCTION__, __LINE__,
-            (gctUINT32) mdlMap->vmaAddr,
-            (gctUINT32) mdl
+            (gctUINT32)(gctUINTPTR_T)mdlMap->vmaAddr,
+            (gctUINT32)(gctUINTPTR_T)mdl
             );
 
         if (IS_ERR(mdlMap->vmaAddr))
         {
-            up_write(&current->mm->mmap_sem);
-
             gcmkTRACE_ZONE(
                 gcvLEVEL_INFO, gcvZONE_OS,
                 "%s(%d): do_mmap_pgoff error",
@@ -4365,6 +4216,8 @@ gckOS_LockPages(
             return gcvSTATUS_OUT_OF_MEMORY;
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (mdlMap->vma == gcvNULL)
@@ -4385,7 +4238,7 @@ gckOS_LockPages(
             return gcvSTATUS_OUT_OF_RESOURCES;
         }
 
-        mdlMap->vma->vm_flags |= VM_RESERVED;
+        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
 #if !gcdPAGED_MEMORY_CACHEABLE
         if (Cacheable == gcvFALSE)
         {
@@ -4441,10 +4294,10 @@ gckOS_LockPages(
                         gcvLEVEL_INFO, gcvZONE_OS,
                         "%s(%d): gctPHYS_ADDR->0x%X Logical->0x%X Unable to map addr->0x%X to start->0x%X",
                         __FUNCTION__, __LINE__,
-                        (gctUINT32) Physical,
-                        (gctUINT32) *Logical,
-                        (gctUINT32) addr,
-                        (gctUINT32) start
+                        (gctUINT32)(gctUINTPTR_T)Physical,
+                        (gctUINT32)(gctUINTPTR_T)*Logical,
+                        (gctUINT32)(gctUINTPTR_T)addr,
+                        (gctUINT32)(gctUINTPTR_T)start
                         );
 
                     mdlMap->vmaAddr = gcvNULL;
@@ -4571,8 +4424,8 @@ gckOS_MapPagesEx(
         gcvLEVEL_INFO, gcvZONE_OS,
         "%s(%d): Physical->0x%X PageCount->0x%X PagedMemory->?%d",
         __FUNCTION__, __LINE__,
-        (gctUINT32) Physical,
-        (gctUINT32) PageCount,
+        (gctUINT32)(gctUINTPTR_T)Physical,
+        (gctUINT32)(gctUINTPTR_T)PageCount,
         mdl->pagedMem
         );
 
@@ -5028,20 +4881,18 @@ gckOS_MapUserPointer(
     OUT gctPOINTER * KernelPointer
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu", Os, Pointer, Size);
-
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
-{
     gctPOINTER buf = gcvNULL;
     gctUINT32 len;
 
+    gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu", Os, Pointer, Size);
+
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
     gcmkVERIFY_ARGUMENT(Size > 0);
     gcmkVERIFY_ARGUMENT(KernelPointer != gcvNULL);
 
-    buf = kmalloc(Size, GFP_KERNEL | __GFP_NOWARN);
+    buf = kmalloc(Size, GFP_KERNEL | gcdNOWARN);
     if (buf == gcvNULL)
     {
         gcmkTRACE(
@@ -5073,10 +4924,6 @@ gckOS_MapUserPointer(
     }
 
     *KernelPointer = buf;
-}
-#else
-    *KernelPointer = Pointer;
-#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
     gcmkFOOTER_ARG("*KernelPointer=0x%X", *KernelPointer);
     return gcvSTATUS_OK;
@@ -5114,12 +4961,11 @@ gckOS_UnmapUserPointer(
     IN gctPOINTER KernelPointer
     )
 {
+    gctUINT32 len;
+
     gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu KernelPointer=0x%X",
                    Os, Pointer, Size, KernelPointer);
 
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
-{
-    gctUINT32 len;
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
@@ -5142,8 +4988,6 @@ gckOS_UnmapUserPointer(
         gcmkFOOTER_ARG("status=%d", gcvSTATUS_GENERIC_IO);
         return gcvSTATUS_GENERIC_IO;
     }
-}
-#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -5183,13 +5027,8 @@ gckOS_QueryNeedCopy(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(NeedCopy != gcvNULL);
 
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
     /* We need to copy data. */
     *NeedCopy = gcvTRUE;
-#else
-    /* No need to copy data. */
-    *NeedCopy = gcvFALSE;
-#endif
 
     /* Success. */
     gcmkFOOTER_ARG("*NeedCopy=%d", *NeedCopy);
@@ -5351,7 +5190,6 @@ gckOS_WriteMemory(
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
     /* Write memory. */
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
     if (access_ok(VERIFY_WRITE, Address, 4))
     {
         /* User address. */
@@ -5361,7 +5199,6 @@ gckOS_WriteMemory(
         }
     }
     else
-#endif
     {
         /* Kernel address. */
         *(gctUINT32 *)Address = Data;
@@ -5430,7 +5267,7 @@ OnError:
     gctSIZE_T pageCount, i, j;
     gctUINT32_PTR pageTable;
     gctUINT32 address = 0, physical = ~0U;
-    gctUINT32 start, end, memory;
+    gctUINTPTR_T start, end, memory;
     gctUINT32 offset;
     gctINT result = 0;
 
@@ -5446,7 +5283,7 @@ OnError:
 
     do
     {
-        memory = (gctUINT32) Memory;
+        memory = (gctUINTPTR_T) Memory;
 
         /* Get the number of required pages. */
         end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
@@ -5470,7 +5307,7 @@ OnError:
         MEMORY_MAP_LOCK(Os);
 
         /* Allocate the Info struct. */
-        info = (gcsPageInfo_PTR)kmalloc(sizeof(gcsPageInfo), GFP_KERNEL | __GFP_NOWARN);
+        info = (gcsPageInfo_PTR)kmalloc(sizeof(gcsPageInfo), GFP_KERNEL | gcdNOWARN);
 
         if (info == gcvNULL)
         {
@@ -5479,7 +5316,7 @@ OnError:
         }
 
         /* Allocate the array of page addresses. */
-        pages = (struct page **)kmalloc(pageCount * sizeof(struct page *), GFP_KERNEL | __GFP_NOWARN);
+        pages = (struct page **)kmalloc(pageCount * sizeof(struct page *), GFP_KERNEL | gcdNOWARN);
 
         if (pages == gcvNULL)
         {
@@ -5595,7 +5432,7 @@ OnError:
             {
                 /* Flush(clean) the data cache. */
                 gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)page_to_phys(pages[i]),
+                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(pages[i]),
                                  (gctPOINTER)(memory & PAGE_MASK) + i*PAGE_SIZE,
                                  PAGE_SIZE));
             }
@@ -5604,7 +5441,7 @@ OnError:
         {
             /* Flush(clean) the data cache. */
             gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                             (gctPOINTER)(physical & PAGE_MASK),
+                             (gctPOINTER)(gctUINTPTR_T)(physical & PAGE_MASK),
                              (gctPOINTER)(memory & PAGE_MASK),
                              PAGE_SIZE * pageCount));
         }
@@ -5844,7 +5681,7 @@ OnError:
     return status;
 #else
 {
-    gctUINT32 memory, start, end;
+    gctUINTPTR_T memory, start, end;
     gcsPageInfo_PTR info;
     gctSIZE_T pageCount, i;
     struct page **pages;
@@ -5877,7 +5714,7 @@ OnError:
             return gcvSTATUS_OK;
         }
 
-        memory = (gctUINT32) Memory;
+        memory = (gctUINTPTR_T)Memory;
         end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
         start = memory >> PAGE_SHIFT;
         pageCount = end - start;
@@ -6183,7 +6020,7 @@ _HandleOuterCache(
     else
     {
         /* Non contiguous virtual memory */
-        vaddr = (gctPOINTER)gcmALIGN_BASE((gctUINT32)Logical, PAGE_SIZE);
+        vaddr = (gctPOINTER)gcmALIGN_BASE((gctUINTPTR_T)Logical, PAGE_SIZE);
         pageNum = GetPageCount(Bytes, 0);
 
         for (i = 0; i < pageNum; i += 1)
@@ -6282,6 +6119,10 @@ gckOS_CacheClean(
 
     dma_cache_wback((unsigned long) Logical, Bytes);
 
+#elif defined(CONFIG_PPC)
+
+    /* TODO */
+
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6359,6 +6200,8 @@ gckOS_CacheInvalidate(
 
 #elif defined(CONFIG_MIPS)
     dma_cache_inv((unsigned long) Logical, Bytes);
+#elif defined(CONFIG_PPC)
+    /* TODO */
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6431,6 +6274,8 @@ gckOS_CacheFlush(
 
 #elif defined(CONFIG_MIPS)
     dma_cache_wback_inv((unsigned long) Logical, Bytes);
+#elif defined(CONFIG_PPC)
+    /* TODO */
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6554,14 +6399,14 @@ gckOS_Broadcast(
     case gcvBROADCAST_GPU_STUCK:
         gcmkTRACE_N(gcvLEVEL_ERROR, 0, "gcvBROADCAST_GPU_STUCK\n");
 #if !gcdENABLE_RECOVERY
-        gcmkONERROR(_DumpGPUState(Os, Hardware->core));
+        gcmkONERROR(gckHARDWARE_DumpGPUState(Hardware));
 #endif
         gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
         break;
 
     case gcvBROADCAST_AXI_BUS_ERROR:
         gcmkTRACE_N(gcvLEVEL_ERROR, 0, "gcvBROADCAST_AXI_BUS_ERROR\n");
-        gcmkONERROR(_DumpGPUState(Os, Hardware->core));
+        gcmkONERROR(gckHARDWARE_DumpGPUState(Hardware));
         gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
         break;
     }
@@ -6690,7 +6535,7 @@ gckOS_CreateSemaphore(
     gcmkVERIFY_ARGUMENT(Semaphore != gcvNULL);
 
     /* Allocate the semaphore structure. */
-    sem = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | __GFP_NOWARN);
+    sem = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | gcdNOWARN);
     if (sem == gcvNULL)
     {
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
@@ -6976,6 +6821,9 @@ gckOS_SetGPUPower(
 {
     struct clk *clk_3dcore = Os->device->clk_3d_core;
     struct clk *clk_3dshader = Os->device->clk_3d_shader;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+    struct clk *clk_3d_axi = Os->device->clk_3d_axi;
+#endif
     struct clk *clk_2dcore = Os->device->clk_2d_core;
     struct clk *clk_2d_axi = Os->device->clk_2d_axi;
     struct clk *clk_vg_axi = Os->device->clk_vg_axi;
@@ -7002,10 +6850,21 @@ gckOS_SetGPUPower(
         }
 #endif
     }
-	if((Power == gcvTRUE) && (oldPowerState == gcvFALSE) &&
-		!IS_ERR(Os->device->gpu_regulator))
+	if((Power == gcvTRUE) && (oldPowerState == gcvFALSE))
+	{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        if(!IS_ERR(Os->device->gpu_regulator))
             regulator_enable(Os->device->gpu_regulator);
+#else
+        imx_gpc_power_up_pu(true);
+#endif
+
+#ifdef CONFIG_PM
+		pm_runtime_get_sync(Os->device->pmdev);
+#endif
+	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     if (Clock == gcvTRUE) {
         if (oldClockState == gcvFALSE) {
             switch (Core) {
@@ -7047,9 +6906,77 @@ gckOS_SetGPUPower(
             }
         }
     }
-	if((Power == gcvFALSE) && (oldPowerState == gcvTRUE) &&
-		!IS_ERR(Os->device->gpu_regulator))
+#else
+    if (Clock == gcvTRUE) {
+        if (oldClockState == gcvFALSE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_prepare(clk_3dcore);
+                clk_enable(clk_3dcore);
+                clk_prepare(clk_3dshader);
+                clk_enable(clk_3dshader);
+                clk_prepare(clk_3d_axi);
+                clk_enable(clk_3d_axi);
+                break;
+            case gcvCORE_2D:
+                clk_prepare(clk_2dcore);
+                clk_enable(clk_2dcore);
+                clk_prepare(clk_2d_axi);
+                clk_enable(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_prepare(clk_2dcore);
+                clk_enable(clk_2dcore);
+                clk_prepare(clk_vg_axi);
+                clk_enable(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    } else {
+        if (oldClockState == gcvTRUE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_disable(clk_3dshader);
+                clk_unprepare(clk_3dshader);
+                clk_disable(clk_3dcore);
+                clk_unprepare(clk_3dcore);
+                clk_disable(clk_3d_axi);
+                clk_unprepare(clk_3d_axi);
+                break;
+           case gcvCORE_2D:
+                clk_disable(clk_2dcore);
+                clk_unprepare(clk_2dcore);
+                clk_disable(clk_2d_axi);
+                clk_unprepare(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_disable(clk_2dcore);
+                clk_unprepare(clk_2dcore);
+                clk_disable(clk_vg_axi);
+                clk_unprepare(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+#endif
+	if((Power == gcvFALSE) && (oldPowerState == gcvTRUE))
+	{
+#ifdef CONFIG_PM
+		pm_runtime_put_sync(Os->device->pmdev);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        if(!IS_ERR(Os->device->gpu_regulator))
             regulator_disable(Os->device->gpu_regulator);
+#else
+        imx_gpc_power_up_pu(false);
+#endif
+
+	}
     /* TODO: Put your code here. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -7079,10 +7006,10 @@ gckOS_ResetGPU(
     IN gceCORE Core
     )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
 #define SRC_SCR_OFFSET 0
 #define BP_SRC_SCR_GPU3D_RST 1
 #define BP_SRC_SCR_GPU2D_RST 4
-
     void __iomem *src_base = IO_ADDRESS(SRC_BASE_ADDR);
     gctUINT32 bit_offset,val;
 
@@ -7106,6 +7033,137 @@ gckOS_ResetGPU(
     }
 
     gcmkFOOTER_NO();
+#else
+    imx_src_reset_gpu((int)Core);
+#endif
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_PrepareGPUFrequency
+**
+**  Prepare to set GPU frequency and voltage.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose frequency and voltage will be set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_PrepareGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_FinishGPUFrequency
+**
+**  Finish GPU frequency setting.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose frequency and voltage is set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_FinishGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_QueryGPUFrequency
+**
+**  Query the current frequency of the GPU.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**      gctUINT32 * Frequency
+**          Pointer to a gctUINT32 to obtain current frequency, in MHz.
+**
+**      gctUINT8 * Scale
+**          Pointer to a gctUINT8 to obtain current scale(1 - 64).
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_QueryGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gctUINT32 * Frequency,
+    OUT gctUINT8 * Scale
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_SetGPUFrequency
+**
+**  Set frequency and voltage of the GPU.
+**
+**      1. DVFS manager gives the target scale of full frequency, BSP must find
+**         a real frequency according to this scale and board's configure.
+**
+**      2. BSP should find a suitable voltage for this frequency.
+**
+**      3. BSP must make sure setting take effect before this function returns.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**      gctUINT8 Scale
+**          Target scale of full frequency, range is [1, 64]. 1 means 1/64 of
+**          full frequency and 64 means 64/64 of full frequency.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_SetGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT8 Scale
+    )
+{
     return gcvSTATUS_OK;
 }
 
@@ -7231,7 +7289,7 @@ gckOS_CreateSignal(
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
     /* Create an event structure. */
-    signal = (gcsSIGNAL_PTR) kmalloc(sizeof(gcsSIGNAL), GFP_KERNEL | __GFP_NOWARN);
+    signal = (gcsSIGNAL_PTR) kmalloc(sizeof(gcsSIGNAL), GFP_KERNEL | gcdNOWARN);
 
     if (signal == gcvNULL)
     {
@@ -7239,7 +7297,7 @@ gckOS_CreateSignal(
     }
 
     /* Save the process ID. */
-    signal->process = (gctHANDLE) _GetProcessID();
+    signal->process = (gctHANDLE)(gctUINTPTR_T) _GetProcessID();
     signal->manualReset = ManualReset;
     signal->hardware = gcvNULL;
     init_completion(&signal->obj);
@@ -7247,7 +7305,7 @@ gckOS_CreateSignal(
 
     gcmkONERROR(_AllocateIntegerId(&Os->signalDB, signal, &signal->id));
 
-    *Signal = (gctSIGNAL)signal->id;
+    *Signal = (gctSIGNAL)(gctUINTPTR_T)signal->id;
 
     gcmkFOOTER_ARG("*Signal=0x%X", *Signal);
     return gcvSTATUS_OK;
@@ -7279,7 +7337,7 @@ gckOS_SignalQueryHardware(
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
     gcmkVERIFY_ARGUMENT(Hardware != gcvNULL);
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
     *Hardware = signal->hardware;
 
@@ -7306,7 +7364,7 @@ gckOS_SignalSetHardware(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
     signal->hardware = Hardware;
 
@@ -7354,9 +7412,9 @@ gckOS_DestroySignal(
     gcmkONERROR(gckOS_AcquireMutex(Os, Os->signalMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    gcmkASSERT(signal->id == (gctUINT32)Signal);
+    gcmkASSERT(signal->id == (gctUINT32)(gctUINTPTR_T)Signal);
 
     if (atomic_dec_and_test(&signal->ref))
     {
@@ -7426,9 +7484,9 @@ gckOS_Signal(
     gcmkONERROR(gckOS_AcquireMutex(Os, Os->signalMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    gcmkASSERT(signal->id == (gctUINT32)Signal);
+    gcmkASSERT(signal->id == (gctUINT32)(gctUINTPTR_T)Signal);
 
     if (State)
     {
@@ -7475,7 +7533,7 @@ gckOS_SetSignalVG(
     struct task_struct * userTask;
     struct siginfo info;
 
-    userTask = FIND_TASK_BY_PID((pid_t) Process);
+    userTask = FIND_TASK_BY_PID((pid_t)(gctUINTPTR_T) Process);
 
     if (userTask != gcvNULL)
     {
@@ -7554,7 +7612,7 @@ gckOS_UserSignal(
     gctSIGNAL signal;
 
     gcmkHEADER_ARG("Os=0x%X Signal=0x%X Process=%d",
-                   Os, Signal, (gctINT32) Process);
+                   Os, Signal, (gctINT32)(gctUINTPTR_T)Process);
 
     /* Map the signal into kernel space. */
     gcmkONERROR(gckOS_MapSignal(Os, Signal, Process, &signal));
@@ -7612,9 +7670,9 @@ gckOS_WaitSignal(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
-    gcmkASSERT(signal->id == (gctUINT32)Signal);
+    gcmkASSERT(signal->id == (gctUINT32)(gctUINTPTR_T)Signal);
 
     might_sleep();
 
@@ -7786,7 +7844,7 @@ gckOS_MapSignal(
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
     gcmkVERIFY_ARGUMENT(MappedSignal != gcvNULL);
 
-    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)Signal, (gctPOINTER)&signal));
+    gcmkONERROR(_QueryIntegerId(&Os->signalDB, (gctUINT32)(gctUINTPTR_T)Signal, (gctPOINTER)&signal));
 
     if(atomic_inc_return(&signal->ref) <= 1)
     {
@@ -7857,8 +7915,14 @@ gckOS_CreateUserSignal(
     OUT gctINT * SignalID
     )
 {
+    gceSTATUS status;
+    gctSIZE_T signal;
+
     /* Create a new signal. */
-    return gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) SignalID);
+    status = gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) &signal);
+    *SignalID = (gctINT) signal;
+
+    return status;
 }
 
 /*******************************************************************************
@@ -7885,7 +7949,7 @@ gckOS_DestroyUserSignal(
     IN gctINT SignalID
     )
 {
-    return gckOS_DestroySignal(Os, (gctSIGNAL)SignalID);
+    return gckOS_DestroySignal(Os, (gctSIGNAL)(gctUINTPTR_T)SignalID);
 }
 
 /*******************************************************************************
@@ -7917,7 +7981,7 @@ gckOS_WaitUserSignal(
     IN gctUINT32 Wait
     )
 {
-    return gckOS_WaitSignal(Os, (gctSIGNAL)SignalID, Wait);
+    return gckOS_WaitSignal(Os, (gctSIGNAL)(gctUINTPTR_T)SignalID, Wait);
 }
 
 /*******************************************************************************
@@ -7949,7 +8013,7 @@ gckOS_SignalUserSignal(
     IN gctBOOL State
     )
 {
-    return gckOS_Signal(Os, (gctSIGNAL)SignalID, State);
+    return gckOS_Signal(Os, (gctSIGNAL)(gctUINTPTR_T)SignalID, State);
 }
 
 #if gcdENABLE_VG
@@ -7970,7 +8034,7 @@ gckOS_CreateSemaphoreVG(
     do
     {
         /* Allocate the semaphore structure. */
-    	newSemaphore = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | __GFP_NOWARN);
+    	newSemaphore = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | gcdNOWARN);
     	if (newSemaphore == gcvNULL)
     	{
         	gcmkERR_BREAK(gcvSTATUS_OUT_OF_MEMORY);
@@ -8082,7 +8146,7 @@ gckOS_SetSignal(
     struct task_struct * userTask;
     struct siginfo info;
 
-    userTask = FIND_TASK_BY_PID((pid_t) Process);
+    userTask = FIND_TASK_BY_PID((pid_t)(gctUINTPTR_T) Process);
 
     if (userTask != gcvNULL)
     {
@@ -8216,41 +8280,6 @@ gckOS_VerifyThread(
 }
 #endif
 
-/*******************************************************************************
-**
-**  gckOS_DumpGPUState
-**
-**  Dump GPU state.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to the gckOS object.
-**
-**      gceCORE Core
-**          The core type of kernel.
-**
-**  OUTPUT:
-**
-**      Nothing.
-*/
-gceSTATUS
-gckOS_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
-    )
-{
-    gcmkHEADER_ARG("Os=0x%X Core=%d", Os, Core);
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-
-    _DumpGPUState(Os, Core);
-
-    gcmkFOOTER_NO();
-    /* Success. */
-    return gcvSTATUS_OK;
-}
-
 /******************************************************************************\
 ******************************** Software Timer ********************************
 \******************************************************************************/
@@ -8325,7 +8354,7 @@ OnError:
 
 /*******************************************************************************
 **
-**  gckOS_DestoryTimer
+**  gckOS_DestroyTimer
 **
 **  Destory a software timer.
 **
@@ -8342,7 +8371,7 @@ OnError:
 **      Nothing.
 */
 gceSTATUS
-gckOS_DestoryTimer(
+gckOS_DestroyTimer(
     IN gckOS Os,
     IN gctPOINTER Timer
     )
@@ -8454,3 +8483,49 @@ gckOS_StopTimer(
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
+
+
+gceSTATUS
+gckOS_DumpCallStack(
+    IN gckOS Os
+    )
+{
+    gcmkHEADER_ARG("Os=0x%X", Os);
+
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    dump_stack();
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+
+gceSTATUS
+gckOS_GetProcessNameByPid(
+    IN gctINT Pid,
+    IN gctSIZE_T Length,
+    OUT gctUINT8_PTR String
+    )
+{
+    struct task_struct *task;
+
+    /* Get the task_struct of the task with pid. */
+    rcu_read_lock();
+
+    task = FIND_TASK_BY_PID(Pid);
+
+    if (task == gcvNULL)
+    {
+        rcu_read_unlock();
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    /* Get name of process. */
+    strncpy(String, task->comm, Length);
+
+    rcu_read_unlock();
+
+    return gcvSTATUS_OK;
+}
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
index 577fb38..006632c 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_os_h_
 #define __gc_hal_kernel_os_h_
 
@@ -56,6 +54,9 @@ typedef struct _LINUX_MDL
     gctINT                  numPages;
     gctINT                  pagedMem;
     gctBOOL                 contiguous;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+    gctBOOL                 exact;
+#endif
     dma_addr_t              dmaHandle;
     PLINUX_MDL_MAP          maps;
     struct _LINUX_MDL *     prev;
@@ -71,10 +72,10 @@ FindMdlMap(
 
 typedef struct _DRIVER_ARGS
 {
-    gctPOINTER              InputBuffer;
-    gctUINT32               InputBufferSize;
-    gctPOINTER              OutputBuffer;
-    gctUINT32               OutputBufferSize;
+    gctUINT64               InputBuffer;
+    gctUINT64               InputBufferSize;
+    gctUINT64               OutputBuffer;
+    gctUINT64               OutputBufferSize;
 }
 DRIVER_ARGS;
 
diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 011fc33..1764623 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -381,11 +381,11 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
 		hdmi_writeb(val, HDMI_MC_CLKDIS);
 		hdmi_writeb(0x02, HDMI_CEC_CTRL);
+		val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
+		hdmi_writeb(val, HDMI_CEC_POLARITY);
 		val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ARB_LOST;
 		hdmi_writeb(val, HDMI_CEC_MASK);
 		hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
-		val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
-		hdmi_writeb(val, HDMI_CEC_POLARITY);
 		mutex_lock(&hdmi_cec_data.lock);
 		hdmi_cec_data.cec_state = true;
 		mutex_unlock(&hdmi_cec_data.lock);
diff --git a/drivers/mxc/ipu/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu/ipu_calc_stripes_sizes.c
index b6230e81..0700b94 100644
--- a/drivers/mxc/ipu/ipu_calc_stripes_sizes.c
+++ b/drivers/mxc/ipu/ipu_calc_stripes_sizes.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,7 +21,7 @@
 
 #include <linux/module.h>
 #include <linux/ipu.h>
-#include <asm/div64.h>
+#include <linux/math64.h>
 
 #define BPP_32 0
 #define BPP_16 3
@@ -30,21 +30,13 @@
 #define BPP_12 4
 #define BPP_18 2
 
-static u64 _do_div(u64 a, u32 b)
-{
-	u64 div;
-	div = a;
-	do_div(div, b);
-	return div;
-}
-
 static u32 truncate(u32 up, /* 0: down; else: up */
 					u64 a, /* must be non-negative */
 					u32 b)
 {
 	u32 d;
 	u64 div;
-	div = _do_div(a, b);
+	div = div_u64(a, b);
 	d = b * (div >> 32);
 	if (up && (a > (((u64)d) << 32)))
 		return d+b;
@@ -227,9 +219,9 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 	    || (output_frame_width < 4))
 		return 1;
 
-	irr_opt = _do_div((((u64)(input_frame_width - 1)) << 32),
+	irr_opt = div_u64((((u64)(input_frame_width - 1)) << 32),
 			  (output_frame_width - 1));
-	rr_opt = _do_div((((u64)(output_frame_width - 1)) << 32),
+	rr_opt = div_u64((((u64)(output_frame_width - 1)) << 32),
 			 (input_frame_width - 1));
 
 	if ((input_m == 0) || (output_m == 0) || (input_f == 0) || (output_f == 0)
@@ -262,7 +254,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			left->output_width = right->output_width = right->output_column =
 				output_frame_width >> 1;
 			left->input_column = right->input_column = 0;
-			div = _do_div(((((u64)irr_steps) << 32) *
+			div = div_u64(((((u64)irr_steps) << 32) *
 				       (right->input_width - 1)), (right->output_width - 1));
 			left->irr = right->irr = truncate(0, div, 1);
 		} else { /* with overlap */
@@ -272,7 +264,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* this is the maximal inw which allows the same resizing ratio */
 			/* in both stripes */
 			onw = truncate(1, (inw * rr_opt), output_f);
-			div = _do_div((((u64)(irr_steps * inw)) <<
+			div = div_u64((((u64)(irr_steps * inw)) <<
 				       32), onw);
 			left->irr = right->irr = truncate(0, div, 1);
 			left->output_width = right->output_width =
@@ -280,14 +272,14 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* These are valid assignments for output_width, */
 			/* assuming output_f is a multiple of output_m */
 			div = (((u64)(left->output_width-1) * (left->irr)) << 32);
-			div = (((u64)1) << 32) + _do_div(div, irr_steps);
+			div = (((u64)1) << 32) + div_u64(div, irr_steps);
 
 			left->input_width = right->input_width = truncate(1, div, input_m);
 
-			div = _do_div((((u64)((right->output_width - 1) * right->irr)) <<
+			div = div_u64((((u64)((right->output_width - 1) * right->irr)) <<
 				       32), irr_steps);
 			difwr = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
-			div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+			div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 			left->input_column = truncate(0, div, input_f);
 
 
@@ -312,13 +304,13 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		/* in both stripes */
 		onw = truncate(1, inw * rr_opt, output_f);
 		do {
-			div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+			div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 			left->irr = truncate(0, div, 1);
-			div = _do_div((((u64)(onw * left->irr)) << 32),
+			div = div_u64((((u64)(onw * left->irr)) << 32),
 				      irr_steps);
 			dinw = (((u64)inw) << 32) - div;
 
-			div = _do_div((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
+			div = div_u64((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
 				       32), irr_steps);
 
 			difwl = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
@@ -338,7 +330,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 
 		inw = inw_best;
 		onw = truncate(1, inw * rr_opt, output_f);
-		div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+		div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 		left->irr = truncate(0, div, 1);
 
 		left->output_width = onw;
@@ -349,18 +341,18 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		right->input_width = truncate(1, ((u64)(input_frame_width - inw)) <<
 					      32, input_m);
 
-		div = _do_div((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
+		div = div_u64((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
 			       32), (right->output_width - 1));
 		right->irr = truncate(0, div, 1);
 		temp = truncate(0, ((u64)left->irr) * ((((u64)1) << 32) + dirr), 1);
 		if (temp < right->irr)
 			right->irr = temp;
-		div = _do_div(((u64)((right->output_width - 1) * right->irr) <<
+		div = div_u64(((u64)((right->output_width - 1) * right->irr) <<
 			       32), irr_steps);
 		difwr = (u64)(input_frame_width - 1 - inw) - div;
 
 
-		div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+		div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 		left->input_column = truncate(0, div, input_f);
 
 		/* This splits the truncated input columns evenly */
diff --git a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
index 4cee1df..3a27195 100644
--- a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
+++ b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,7 +21,7 @@
 
 #include <linux/module.h>
 #include <mach/ipu-v3.h>
-#include <asm/div64.h>
+#include <linux/math64.h>
 
 #define BPP_32 0
 #define BPP_16 3
@@ -30,21 +30,13 @@
 #define BPP_12 4
 #define BPP_18 2
 
-static u64 _do_div(u64 a, u32 b)
-{
-	u64 div;
-	div = a;
-	do_div(div, b);
-	return div;
-}
-
 static u32 truncate(u32 up, /* 0: down; else: up */
 					u64 a, /* must be non-negative */
 					u32 b)
 {
 	u32 d;
 	u64 div;
-	div = _do_div(a, b);
+	div = div_u64(a, b);
 	d = b * (div >> 32);
 	if (up && (a > (((u64)d) << 32)))
 		return d+b;
@@ -229,9 +221,9 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 	if ((input_frame_width < 4) || (output_frame_width < 4))
 		return 1;
 
-	irr_opt = _do_div((((u64)(input_frame_width - 1)) << 32),
+	irr_opt = div_u64((((u64)(input_frame_width - 1)) << 32),
 			  (output_frame_width - 1));
-	rr_opt = _do_div((((u64)(output_frame_width - 1)) << 32),
+	rr_opt = div_u64((((u64)(output_frame_width - 1)) << 32),
 			 (input_frame_width - 1));
 
 	if ((input_m == 0) || (output_m == 0) || (input_f == 0) || (output_f == 0)
@@ -265,7 +257,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 				output_frame_width >> 1;
 			left->input_column = 0;
 			left->output_column = 0;
-			div = _do_div(((((u64)irr_steps) << 32) *
+			div = div_u64(((((u64)irr_steps) << 32) *
 				       (right->input_width - 1)), (right->output_width - 1));
 			left->irr = right->irr = truncate(0, div, 1);
 		} else { /* with overlap */
@@ -275,7 +267,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* this is the maximal inw which allows the same resizing ratio */
 			/* in both stripes */
 			onw = truncate(1, (inw * rr_opt), output_f);
-			div = _do_div((((u64)(irr_steps * inw)) <<
+			div = div_u64((((u64)(irr_steps * inw)) <<
 				       32), onw);
 			left->irr = right->irr = truncate(0, div, 1);
 			left->output_width = right->output_width =
@@ -283,14 +275,14 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* These are valid assignments for output_width, */
 			/* assuming output_f is a multiple of output_m */
 			div = (((u64)(left->output_width-1) * (left->irr)) << 32);
-			div = (((u64)1) << 32) + _do_div(div, irr_steps);
+			div = (((u64)1) << 32) + div_u64(div, irr_steps);
 
 			left->input_width = right->input_width = truncate(1, div, input_m);
 
-			div = _do_div((((u64)((right->output_width - 1) * right->irr)) <<
+			div = div_u64((((u64)((right->output_width - 1) * right->irr)) <<
 				       32), irr_steps);
 			difwr = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
-			div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+			div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 			left->input_column = truncate(0, div, input_f);
 
 
@@ -315,13 +307,13 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		/* in both stripes */
 		onw = truncate(1, inw * rr_opt, output_f);
 		do {
-			div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+			div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 			left->irr = truncate(0, div, 1);
-			div = _do_div((((u64)(onw * left->irr)) << 32),
+			div = div_u64((((u64)(onw * left->irr)) << 32),
 				      irr_steps);
 			dinw = (((u64)inw) << 32) - div;
 
-			div = _do_div((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
+			div = div_u64((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
 				       32), irr_steps);
 
 			difwl = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
@@ -341,7 +333,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 
 		inw = inw_best;
 		onw = truncate(1, inw * rr_opt, output_f);
-		div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+		div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 		left->irr = truncate(0, div, 1);
 
 		left->output_width = onw;
@@ -352,18 +344,18 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		right->input_width = truncate(1, ((u64)(input_frame_width - inw)) <<
 					      32, input_m);
 
-		div = _do_div((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
+		div = div_u64((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
 			       32), (right->output_width - 1));
 		right->irr = truncate(0, div, 1);
 		temp = truncate(0, ((u64)left->irr) * ((((u64)1) << 32) + dirr), 1);
 		if (temp < right->irr)
 			right->irr = temp;
-		div = _do_div(((u64)((right->output_width - 1) * right->irr) <<
+		div = div_u64(((u64)((right->output_width - 1) * right->irr) <<
 			       32), irr_steps);
 		difwr = (u64)(input_frame_width - 1 - inw) - div;
 
 
-		div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+		div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 		left->input_column = truncate(0, div, input_f);
 
 		/* This splits the truncated input columns evenly */
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
index f463836..3e2acf2 100644
--- a/drivers/mxc/ipu3/ipu_capture.c
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -98,6 +98,7 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;
 		break;
 	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_GENERIC_16:
 		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
 		break;
 	case IPU_PIX_FMT_RGB565:
@@ -129,10 +130,6 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 
 	ipu_csi_write(ipu, csi, data, CSI_SENS_CONF);
 
-	/* Setup the mclk */
-	if (cfg_param.mclk > 0)
-		_ipu_csi_mclk_set(ipu, cfg_param.mclk, csi);
-
 	/* Setup sensor frame size */
 	ipu_csi_write(ipu, csi, (width - 1) | (height - 1) << 16, CSI_SENS_FRM_SIZE);
 
@@ -144,29 +141,30 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		if (width == 720 && height == 625) {
 			/* PAL case */
 			/*
-			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
-			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
+			 * Field0BlankEnd = 0x6, Field0BlankStart = 0x2,
+			 * Field0ActiveEnd = 0x4, Field0ActiveStart = 0
 			 */
-			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_1);
+			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_1);
 			/*
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 * Field1BlankEnd = 0x7, Field1BlankStart = 0x3,
+			 * Field1ActiveEnd = 0x5, Field1ActiveStart = 0x1
 			 */
-			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_2);
+			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_2);
+
 			ipu_csi_write(ipu, csi, 0xFF0000, CSI_CCIR_CODE_3);
 
 		} else if (width == 720 && height == 525) {
 			/* NTSC case */
 			/*
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
-			 */
-			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_1);
-			/*
 			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
 			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
 			 */
-			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_2);
+			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_1);
+			/*
+			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
+			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 */
+			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_2);
 			ipu_csi_write(ipu, csi, 0xFF0000, CSI_CCIR_CODE_3);
 		} else {
 			dev_err(ipu->dev, "Unsupported CCIR656 interlaced "
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index 92703f3..c2b5717 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -44,7 +44,8 @@ static struct ipu_soc ipu_array[MXC_IPU_MAX_NUM];
 int g_ipu_hw_rev;
 
 /* Static functions */
-static irqreturn_t ipu_irq_handler(int irq, void *desc);
+static irqreturn_t ipu_sync_irq_handler(int irq, void *desc);
+static irqreturn_t ipu_err_irq_handler(int irq, void *desc);
 
 static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
 {
@@ -109,6 +110,17 @@ static inline int _ipu_is_primary_disp_chan(uint32_t dma_chan)
 		(dma_chan == 28) || (dma_chan == 41));
 }
 
+static inline int _ipu_is_sync_irq(uint32_t irq)
+{
+	/* sync interrupt register number */
+	int reg_num = irq / 32 + 1;
+
+	return ((reg_num == 1)  || (reg_num == 2)  || (reg_num == 3)  ||
+		(reg_num == 4)  || (reg_num == 7)  || (reg_num == 8)  ||
+		(reg_num == 11) || (reg_num == 12) || (reg_num == 13) ||
+		(reg_num == 14) || (reg_num == 15));
+}
+
 #define idma_is_valid(ch)	(ch != NO_DMA)
 #define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
 #define idma_is_set(ipu, reg, dma)	(ipu_idmac_read(ipu, reg(dma)) & idma_mask(dma))
@@ -162,8 +174,18 @@ static int __devinit ipu_clk_setup_enable(struct ipu_soc *ipu,
 	clk_debug_register(&ipu->pixel_clk[0]);
 	clk_debug_register(&ipu->pixel_clk[1]);
 
-	if (!plat_data->bypass_reset)
-		clk_enable(ipu->ipu_clk);
+	/*
+	 * Enable ipu hsp clock anyway, so that we
+	 * may keep the clock on until user space
+	 * triggers frame buffer set_par(), i.e., any
+	 * ipu interface which enables/disables ipu
+	 * hsp clock with pair(called in IPUv3 fb
+	 * driver or mxc v4l2 driver<probed after fb
+	 * driver>) cannot eventually disables the
+	 * clock to damage the channel setup by
+	 * bootloader.
+	 */
+	clk_enable(ipu->ipu_clk);
 
 	ipu->pixel_clk[0].parent = ipu->ipu_clk;
 	ipu->pixel_clk[1].parent = ipu->ipu_clk;
@@ -202,6 +224,12 @@ void _ipu_put(struct ipu_soc *ipu)
 	clk_disable(ipu->ipu_clk);
 }
 
+void ipu_disable_hsp_clk(struct ipu_soc *ipu)
+{
+	_ipu_put(ipu);
+}
+EXPORT_SYMBOL(ipu_disable_hsp_clk);
+
 /*!
  * This function is called by the driver framework to initialize the IPU
  * hardware.
@@ -242,19 +270,17 @@ static int __devinit ipu_probe(struct platform_device *pdev)
 		goto failed_get_res;
 	}
 
-	if (request_irq(ipu->irq_sync, ipu_irq_handler, 0, pdev->name, ipu) != 0) {
+	ret = request_irq(ipu->irq_sync, ipu_sync_irq_handler, 0,
+			  pdev->name, ipu);
+	if (ret) {
 		dev_err(ipu->dev, "request SYNC interrupt failed\n");
-		ret = -EBUSY;
 		goto failed_req_irq_sync;
 	}
-	/* Some platforms have 2 IPU interrupts */
-	if (ipu->irq_err >= 0) {
-		if (request_irq
-		    (ipu->irq_err, ipu_irq_handler, 0, pdev->name, ipu) != 0) {
-			dev_err(ipu->dev, "request ERR interrupt failed\n");
-			ret = -EBUSY;
-			goto failed_req_irq_err;
-		}
+	ret = request_irq(ipu->irq_err, ipu_err_irq_handler, 0,
+			  pdev->name, ipu);
+	if (ret) {
+		dev_err(ipu->dev, "request ERR interrupt failed\n");
+		goto failed_req_irq_err;
 	}
 
 	ipu_base = res->start;
@@ -368,8 +394,7 @@ failed_clk_setup:
 	iounmap(ipu->disp_base[1]);
 	iounmap(ipu->vdi_reg);
 failed_ioremap:
-	if (ipu->irq_sync)
-		free_irq(ipu->irq_err, ipu);
+	free_irq(ipu->irq_err, ipu);
 failed_req_irq_err:
 	free_irq(ipu->irq_sync, ipu);
 failed_req_irq_sync:
@@ -383,10 +408,8 @@ int __devexit ipu_remove(struct platform_device *pdev)
 
 	unregister_ipu_device(ipu, pdev->id);
 
-	if (ipu->irq_sync)
-		free_irq(ipu->irq_sync, ipu);
-	if (ipu->irq_err)
-		free_irq(ipu->irq_err, ipu);
+	free_irq(ipu->irq_sync, ipu);
+	free_irq(ipu->irq_err, ipu);
 
 	clk_put(ipu->ipu_clk);
 
@@ -1153,10 +1176,17 @@ int32_t ipu_init_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 			rot_mode);
 	} else if (_ipu_is_smfc_chan(dma_chan)) {
 		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
-		if ((pixel_fmt == IPU_PIX_FMT_GENERIC) &&
-			((_ipu_ch_param_get_bpp(ipu, dma_chan) == 5) ||
-			(_ipu_ch_param_get_bpp(ipu, dma_chan) == 3)))
+		/*
+		 * This is different from IPUv3 spec, but it is confirmed
+		 * in IPUforum that SMFC burst size should be NPB[6:3]
+		 * when IDMAC works in 16-bit generic data mode.
+		 */
+		if (pixel_fmt == IPU_PIX_FMT_GENERIC)
+			/* 8 bits per pixel */
 			burst_size = burst_size >> 4;
+		else if (pixel_fmt == IPU_PIX_FMT_GENERIC_16)
+			/* 16 bits per pixel */
+			burst_size = burst_size >> 3;
 		else
 			burst_size = burst_size >> 2;
 		_ipu_smfc_set_burst_size(ipu, channel, burst_size-1);
@@ -2179,7 +2209,8 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 				}
 			}
 		}
-	} else if (wait_for_stop && !_ipu_is_smfc_chan(out_dma)) {
+	} else if (wait_for_stop && !_ipu_is_smfc_chan(out_dma) &&
+		   channel != CSI_PRP_VF_MEM && channel != CSI_PRP_ENC_MEM) {
 		while (idma_is_set(ipu, IDMAC_CHA_BUSY, in_dma) ||
 		       idma_is_set(ipu, IDMAC_CHA_BUSY, out_dma) ||
 			(ipu->sec_chan_en[IPU_CHAN_ID(channel)] &&
@@ -2187,7 +2218,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 			(ipu->thrd_chan_en[IPU_CHAN_ID(channel)] &&
 			idma_is_set(ipu, IDMAC_CHA_BUSY, thrd_dma))) {
 			uint32_t irq = 0xffffffff;
-			int timeout = 50;
+			int timeout = 50000;
 
 			if (idma_is_set(ipu, IDMAC_CHA_BUSY, out_dma))
 				irq = out_dma;
@@ -2213,7 +2244,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 			while (((ipu_cm_read(ipu, IPUIRQ_2_STATREG(irq))
 				& IPUIRQ_2_MASK(irq)) == 0) &&
 				(idma_is_set(ipu, IDMAC_CHA_BUSY, irq))) {
-				msleep(10);
+				udelay(10);
 				timeout -= 10;
 				if (timeout <= 0) {
 					ipu_dump_registers(ipu);
@@ -2221,6 +2252,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 					break;
 				}
 			}
+			dev_dbg(ipu->dev, "wait_time:%d\n", 50000 - timeout);
 
 		}
 	}
@@ -2371,42 +2403,17 @@ int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi)
 }
 EXPORT_SYMBOL(ipu_disable_csi);
 
-static irqreturn_t ipu_irq_handler(int irq, void *desc)
+static irqreturn_t ipu_sync_irq_handler(int irq, void *desc)
 {
 	struct ipu_soc *ipu = desc;
 	int i;
-	uint32_t line;
-	uint32_t bit;
+	uint32_t line, bit, int_stat, int_ctrl;
 	irqreturn_t result = IRQ_NONE;
-	uint32_t int_stat;
-	uint32_t int_ctrl;
-	const int err_reg[] = { 5, 6, 9, 10, 0 };
 	const int int_reg[] = { 1, 2, 3, 4, 11, 12, 13, 14, 15, 0 };
 
 	spin_lock(&ipu->int_reg_spin_lock);
 
-	for (i = 0;; i++) {
-		if (err_reg[i] == 0)
-			break;
-
-		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(err_reg[i]));
-		int_stat &= ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i]));
-		if (int_stat) {
-			ipu_cm_write(ipu, int_stat, IPU_INT_STAT(err_reg[i]));
-			dev_warn(ipu->dev,
-				"IPU Warning - IPU_INT_STAT_%d = 0x%08X\n",
-				err_reg[i], int_stat);
-			/* Disable interrupts so we only get error once */
-			int_stat =
-			    ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i])) & ~int_stat;
-			ipu_cm_write(ipu, int_stat, IPU_INT_CTRL(err_reg[i]));
-		}
-	}
-
-	for (i = 0;; i++) {
-		if (int_reg[i] == 0)
-			break;
-
+	for (i = 0; int_reg[i] != 0; i++) {
 		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(int_reg[i]));
 		int_ctrl = ipu_cm_read(ipu, IPU_INT_CTRL(int_reg[i]));
 		int_stat &= int_ctrl;
@@ -2432,6 +2439,35 @@ static irqreturn_t ipu_irq_handler(int irq, void *desc)
 	return result;
 }
 
+static irqreturn_t ipu_err_irq_handler(int irq, void *desc)
+{
+	struct ipu_soc *ipu = desc;
+	int i;
+	uint32_t int_stat;
+	const int err_reg[] = { 5, 6, 9, 10, 0 };
+
+	spin_lock(&ipu->int_reg_spin_lock);
+
+	for (i = 0; err_reg[i] != 0; i++) {
+		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(err_reg[i]));
+		int_stat &= ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i]));
+		if (int_stat) {
+			ipu_cm_write(ipu, int_stat, IPU_INT_STAT(err_reg[i]));
+			dev_warn(ipu->dev,
+				"IPU Warning - IPU_INT_STAT_%d = 0x%08X\n",
+				err_reg[i], int_stat);
+			/* Disable interrupts so we only get error once */
+			int_stat = ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i])) &
+					~int_stat;
+			ipu_cm_write(ipu, int_stat, IPU_INT_CTRL(err_reg[i]));
+		}
+	}
+
+	spin_unlock(&ipu->int_reg_spin_lock);
+
+	return IRQ_HANDLED;
+}
+
 /*!
  * This function enables the interrupt for the specified interrupt line.
  * The interrupt lines are defined in \b ipu_irq_line enum.
@@ -2439,23 +2475,40 @@ static irqreturn_t ipu_irq_handler(int irq, void *desc)
  * @param	ipu		ipu handler
  * @param       irq             Interrupt line to enable interrupt for.
  *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
  */
-void ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq)
+int ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq)
 {
 	uint32_t reg;
 	unsigned long lock_flags;
+	int ret = 0;
 
 	_ipu_get(ipu);
 
 	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (ipu->irq_list[irq].handler == NULL)) {
+		dev_err(ipu->dev, "handler hasn't been registered on sync "
+				  "irq %d\n", irq);
+		ret = -EACCES;
+		goto out;
+	}
+
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
 	reg |= IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
-
+out:
 	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
+
+	return ret;
 }
 EXPORT_SYMBOL(ipu_enable_irq);
 
@@ -2567,6 +2620,7 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 {
 	uint32_t reg;
 	unsigned long lock_flags;
+	int ret = 0;
 
 	BUG_ON(irq >= IPU_IRQ_COUNT);
 
@@ -2577,8 +2631,19 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 	if (ipu->irq_list[irq].handler != NULL) {
 		dev_err(ipu->dev,
 			"handler already installed on irq %d\n", irq);
-		spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (handler == NULL)) {
+		dev_err(ipu->dev, "handler is NULL for sync irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
 	}
 
 	ipu->irq_list[irq].handler = handler;
@@ -2592,12 +2657,12 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
 	reg |= IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
-
+out:
 	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(ipu_request_irq);
 
@@ -2772,6 +2837,7 @@ uint32_t bytes_per_pixel(uint32_t fmt)
 	case IPU_PIX_FMT_YUV444P:
 		return 1;
 		break;
+	case IPU_PIX_FMT_GENERIC_16:	/* generic data */
 	case IPU_PIX_FMT_RGB565:
 	case IPU_PIX_FMT_YUYV:
 	case IPU_PIX_FMT_UYVY:
@@ -2779,6 +2845,7 @@ uint32_t bytes_per_pixel(uint32_t fmt)
 		break;
 	case IPU_PIX_FMT_BGR24:
 	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
 		return 3;
 		break;
 	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
index be17251..ce34775 100644
--- a/drivers/mxc/ipu3/ipu_device.c
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -680,6 +680,11 @@ static void dump_check_warn(struct device *dev, int warn)
 
 static int set_crop(struct ipu_crop *crop, int width, int height, int fmt)
 {
+	if ((width == 0) || (height == 0)) {
+		pr_err("Invalid param: width=%d, height=%d\n", width, height);
+		return -EINVAL;
+	}
+
 	if ((IPU_PIX_FMT_TILED_NV12 == fmt) ||
 		(IPU_PIX_FMT_TILED_NV12F == fmt)) {
 		if (crop->w || crop->h) {
@@ -719,6 +724,12 @@ static int set_crop(struct ipu_crop *crop, int width, int height, int fmt)
 		crop->h -= crop->h%8;
 	}
 
+	if ((crop->w == 0) || (crop->h == 0)) {
+		pr_err("Invalid crop param: crop.w=%d, crop.h=%d\n",
+			crop->w, crop->h);
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -733,26 +744,28 @@ static void update_offset(unsigned int fmt,
 	case IPU_PIX_FMT_YUV420P:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
-			+ ((width/2 * pos_y/2) + pos_x/2);
-		*voff = *uoff + (width/2 * height/2);
+			+ (width/2) * (pos_y/2) + pos_x/2;
+		/* In case height is odd, round up to even */
+		*voff = *uoff + (width/2) * ((height+1)/2);
 		break;
 	case IPU_PIX_FMT_YVU420P:
 		*off = pos_y * width + pos_x;
 		*voff = (width * (height - pos_y) - pos_x)
-			+ ((width/2 * pos_y/2) + pos_x/2);
-		*uoff = *voff + (width/2 * height/2);
+			+ (width/2) * (pos_y/2) + pos_x/2;
+		/* In case height is odd, round up to even */
+		*uoff = *voff + (width/2) * ((height+1)/2);
 		break;
 	case IPU_PIX_FMT_YVU422P:
 		*off = pos_y * width + pos_x;
 		*voff = (width * (height - pos_y) - pos_x)
-			+ ((width * pos_y)/2 + pos_x/2);
-		*uoff = *voff + (width * height)/2;
+			+ (width/2) * pos_y + pos_x/2;
+		*uoff = *voff + (width/2) * height;
 		break;
 	case IPU_PIX_FMT_YUV422P:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
-			+ (width * pos_y)/2 + pos_x/2;
-		*voff = *uoff + (width * height)/2;
+			+ (width/2) * pos_y + pos_x/2;
+		*voff = *uoff + (width/2) * height;
 		break;
 	case IPU_PIX_FMT_YUV444P:
 		*off = pos_y * width + pos_x;
@@ -762,7 +775,7 @@ static void update_offset(unsigned int fmt,
 	case IPU_PIX_FMT_NV12:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
-			+ width * pos_y/2 + pos_x;
+			+ width * (pos_y/2) + pos_x;
 		break;
 	case IPU_PIX_FMT_TILED_NV12:
 		/*
@@ -799,6 +812,7 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 	struct stripe_param down_stripe;
 	u32 iw, ih, ow, oh;
 	u32 max_width;
+	int ret;
 
 	if (t->output.rotate >= IPU_ROTATE_90_RIGHT)
 		return IPU_CHECK_ERR_SPLIT_WITH_ROT;
@@ -809,12 +823,26 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 	ow = t->output.crop.w;
 	oh = t->output.crop.h;
 
+	memset(&left_stripe, 0, sizeof(left_stripe));
+	memset(&right_stripe, 0, sizeof(right_stripe));
+	memset(&up_stripe, 0, sizeof(up_stripe));
+	memset(&down_stripe, 0, sizeof(down_stripe));
+
 	if (t->set.split_mode & RL_SPLIT) {
+		/*
+		 * We do want equal strips: initialize stripes in case
+		 * calc_stripes returns before actually doing the calculation
+		 */
+		left_stripe.input_width = iw / 2;
+		left_stripe.output_width = ow / 2;
+		right_stripe.input_column = iw / 2;
+		right_stripe.output_column = ow / 2;
+
 		if (vdi_split)
 			max_width = soc_max_vdi_in_width();
 		else
 			max_width = soc_max_out_width();
-		ipu_calc_stripes_sizes(iw,
+		ret = ipu_calc_stripes_sizes(iw,
 				ow,
 				max_width,
 				(((unsigned long long)1) << 32), /* 32bit for fractional*/
@@ -823,6 +851,9 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 				t->output.format,
 				&left_stripe,
 				&right_stripe);
+		if (ret)
+			dev_dbg(t->dev, "Warn: no:0x%x,calc_stripes ret:%d\n",
+				 t->task_no, ret);
 		t->set.sp_setting.iw = left_stripe.input_width;
 		t->set.sp_setting.ow = left_stripe.output_width;
 		t->set.sp_setting.outh_resize_ratio = left_stripe.irr;
@@ -846,7 +877,15 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 		return IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER;
 
 	if (t->set.split_mode & UD_SPLIT) {
-		ipu_calc_stripes_sizes(ih,
+		/*
+		 * We do want equal strips: initialize stripes in case
+		 * calc_stripes returns before actually doing the calculation
+		 */
+		up_stripe.input_width = ih / 2;
+		up_stripe.output_width = oh / 2;
+		down_stripe.input_column = ih / 2;
+		down_stripe.output_column = oh / 2;
+		ret = ipu_calc_stripes_sizes(ih,
 				oh,
 				soc_max_out_height(),
 				(((unsigned long long)1) << 32), /* 32bit for fractional*/
@@ -855,6 +894,9 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 				t->output.format,
 				&up_stripe,
 				&down_stripe);
+		if (ret)
+			dev_err(t->dev, "Warn: no:0x%x,calc_stripes ret:%d\n",
+				 t->task_no, ret);
 		t->set.sp_setting.ih = up_stripe.input_width;
 		t->set.sp_setting.oh = up_stripe.output_width;
 		t->set.sp_setting.outv_resize_ratio = up_stripe.irr;
@@ -1856,6 +1898,7 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	int out_uoff = 0, out_voff = 0, out_rot;
 	int out_w = 0, out_h = 0, out_stride;
 	int out_fmt;
+	u32 vdi_frame_idx = 0;
 
 	memset(&params, 0, sizeof(params));
 
@@ -1899,8 +1942,9 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		params.mem_prp_vf_mem.graphics_combine_en = 1;
 		if (t->overlay.alpha.mode == IPU_ALPHA_MODE_GLOBAL)
 			params.mem_prp_vf_mem.global_alpha_en = 1;
-		else
+		else if (t->overlay.alpha.loc_alp_paddr)
 			params.mem_prp_vf_mem.alpha_chan_en = 1;
+		/* otherwise, alpha bending per pixel is used. */
 		params.mem_prp_vf_mem.alpha = t->overlay.alpha.gvalue;
 		if (t->overlay.colorkey.enable) {
 			params.mem_prp_vf_mem.key_color_en = 1;
@@ -1908,6 +1952,19 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		}
 	}
 
+	if (t->input.deinterlace.enable) {
+		if (t->input.deinterlace.field_fmt & IPU_DEINTERLACE_FIELD_MASK)
+			params.mem_prp_vf_mem.field_fmt =
+				IPU_DEINTERLACE_FIELD_BOTTOM;
+		else
+			params.mem_prp_vf_mem.field_fmt =
+				IPU_DEINTERLACE_FIELD_TOP;
+
+		if (t->input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN)
+			vdi_frame_idx = t->input.deinterlace.field_fmt &
+						IPU_DEINTERLACE_RATE_FRAME1;
+	}
+
 	if (t->set.mode & VDOA_MODE)
 		ipu->vdoa_en = 1;
 
@@ -1921,13 +1978,6 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	}
 
 	if (deinterlace_3_field(t)) {
-		if (IPU_DEINTERLACE_FIELD_TOP == t->input.deinterlace.field_fmt)
-			params.mem_prp_vf_mem.field_fmt = V4L2_FIELD_INTERLACED_TB;
-		else if (IPU_DEINTERLACE_FIELD_BOTTOM == t->input.deinterlace.field_fmt)
-			params.mem_prp_vf_mem.field_fmt = V4L2_FIELD_INTERLACED_BT;
-		else
-			dev_err(t->dev, "ERR[no-0x%x]invalid field fmt:0x%x!\n",
-				t->task_no, t->input.deinterlace.field_fmt);
 		ret = ipu_init_channel(ipu, t->set.vdi_ic_p_chan, &params);
 		if (ret < 0) {
 			t->state = STATE_INIT_CHAN_FAIL;
@@ -1949,13 +1999,57 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	} else {
 		if ((deinterlace_3_field(t)) &&
 			(IPU_PIX_FMT_TILED_NV12F != t->input.format)) {
-				inbuf_p = t->input.paddr + t->set.istride +
-						t->set.i_off;
-				inbuf = t->input.paddr_n + t->set.i_off;
-				inbuf_n = t->input.paddr_n + t->set.istride +
-						t->set.i_off;
-		} else
-			inbuf = t->input.paddr + t->set.i_off;
+			if (params.mem_prp_vf_mem.field_fmt ==
+				IPU_DEINTERLACE_FIELD_TOP) {
+				if (vdi_frame_idx) {
+					inbuf_p = t->input.paddr + t->set.istride +
+							t->set.i_off;
+					inbuf = t->input.paddr_n + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.istride +
+							t->set.i_off;
+					params.mem_prp_vf_mem.field_fmt =
+						IPU_DEINTERLACE_FIELD_BOTTOM;
+				} else {
+					inbuf_p = t->input.paddr + t->set.i_off;
+					inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.i_off;
+				}
+			} else {
+				if (vdi_frame_idx) {
+					inbuf_p = t->input.paddr + t->set.i_off;
+					inbuf = t->input.paddr_n + t->set.istride + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.i_off;
+					params.mem_prp_vf_mem.field_fmt =
+						IPU_DEINTERLACE_FIELD_TOP;
+				} else {
+					inbuf_p = t->input.paddr + t->set.istride +
+							t->set.i_off;
+					inbuf = t->input.paddr + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.istride +
+							t->set.i_off;
+				}
+			}
+		} else {
+			if (t->input.deinterlace.enable) {
+				if (params.mem_prp_vf_mem.field_fmt ==
+					IPU_DEINTERLACE_FIELD_TOP) {
+					if (vdi_frame_idx) {
+						inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+						params.mem_prp_vf_mem.field_fmt =
+							IPU_DEINTERLACE_FIELD_BOTTOM;
+					} else
+						inbuf = t->input.paddr + t->set.i_off;
+				} else {
+					if (vdi_frame_idx) {
+						inbuf = t->input.paddr + t->set.i_off;
+						params.mem_prp_vf_mem.field_fmt =
+							IPU_DEINTERLACE_FIELD_TOP;
+					} else
+						inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+				}
+			} else
+				inbuf = t->input.paddr + t->set.i_off;
+		}
 
 		if (t->overlay_en)
 			ovbuf = t->overlay.paddr + t->set.ov_off;
@@ -2243,6 +2337,9 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	u32 task_no;
 	u32 i, offset_addr;
 	unsigned char  *base_off;
+	u32 pixwidth;
+	u32 crop_width;
+
 	struct ipu_task_entry *parent = t->parent;
 
 	if (!parent) {
@@ -2252,21 +2349,30 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	stripe_mode = t->task_no & 0xf;
 	task_no = t->task_no >> 4;
 
-	base_off = (char *) __va(t->output.paddr);
+	pixwidth = fmt_to_bpp(t->output.format)/8;
+	crop_width = t->output.crop.w * pixwidth;
+
+	if (pfn_valid(t->output.paddr >> PAGE_SHIFT))
+		base_off = page_address(pfn_to_page(t->output.paddr >> PAGE_SHIFT));
+	else
+		base_off = (char *)ioremap_nocache(t->output.paddr,
+				t->output.width * t->output.height *
+				pixwidth);
+
 	if (base_off == NULL) {
 		dev_err(t->dev, "ERR[0x%p]Falied get vitual address\n", t);
 		return;
 	}
 
 	vdi_save_lines = (t->output.crop.h - t->set.sp_setting.ud_split_line)/2;
-	vdi_size = vdi_save_lines * t->output.crop.w * 2;
+	vdi_size = vdi_save_lines * t->output.crop.w * pixwidth;
 
 	if (vdi_save_lines <= 0) {
 		dev_err(t->dev, "[0x%p] vdi_save_line error\n", (void *)t);
 		return;
 	}
 
-	/*check vditmpbuf buffer have alloced or buffer size is changed */
+	/* Check vditmpbuf buffer have alloced or buffer size is changed */
 	if ((vdi_save_lines != parent->old_save_lines) ||
 		(vdi_size != parent->old_size)) {
 		if (parent->vditmpbuf[0] != NULL)
@@ -2298,120 +2404,93 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	if ((stripe_mode == UP_STRIPE) ||
 			(stripe_mode == (UP_STRIPE | LEFT_STRIPE))) {
 		if (!parent->buf0filled) {
-			offset_addr = t->set.o_off +
-				t->set.sp_setting.ud_split_line*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_size);
-			outer_flush_range(t->output.paddr + offset_addr,
-				t->output.paddr + offset_addr + vdi_size);
+			offset_addr = t->set.o_off * pixwidth +
+				t->set.sp_setting.ud_split_line * t->set.ostride ;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[0] + i*t->output.crop.w*2,
+				memcpy(parent->vditmpbuf[0] + i * crop_width,
 					base_off + offset_addr +
-					i*t->set.ostride, t->output.crop.w*2);
+					i * t->set.ostride, crop_width);
 			parent->buf0filled = true;
 		} else {
-			offset_addr = t->set.o_off + (t->output.crop.h -
+			offset_addr = t->set.o_off * pixwidth + (t->output.crop.h -
 					vdi_save_lines) * t->set.ostride;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[0] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + i*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + i*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[0] + i * crop_width,
+						crop_width);
+
 			parent->buf0filled = false;
 		}
 	}
-	/*Down stripe or Down&Left stripe*/
+	/* Down stripe or Down&Left stripe */
 	else if ((stripe_mode == DOWN_STRIPE) ||
 			(stripe_mode == (DOWN_STRIPE | LEFT_STRIPE))) {
 		if (!parent->buf0filled) {
-			offset_addr = t->set.o_off + vdi_save_lines*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_size);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_size);
+			offset_addr = t->set.o_off * pixwidth +
+				vdi_save_lines * t->set.ostride;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[0] + i*t->output.crop.w*2,
-						base_off + offset_addr + i*t->set.ostride,
-						t->output.crop.w*2);
+				memcpy(parent->vditmpbuf[0] + i * crop_width,
+						base_off + offset_addr + i * t->set.ostride,
+						crop_width);
 			parent->buf0filled = true;
+
 		} else {
-			offset_addr = t->set.o_off;
+			offset_addr = t->set.o_off * pixwidth;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[0] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + i*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + i*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[0] + i * crop_width,
+						crop_width);
+
 			parent->buf0filled = false;
 		}
 	}
-	/*Up&Right stripe*/
+	/* Up&Right stripe */
 	else if (stripe_mode == (UP_STRIPE | RIGHT_STRIPE)) {
 		if (!parent->buf1filled) {
-			offset_addr = t->set.o_off +
-				t->set.sp_setting.ud_split_line*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_size);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_size);
+			offset_addr = t->set.o_off * pixwidth +
+				t->set.sp_setting.ud_split_line * t->set.ostride;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						base_off + offset_addr + i*t->set.ostride,
-						t->output.crop.w*2);
+				memcpy(parent->vditmpbuf[1] + i * crop_width,
+						base_off + offset_addr + i * t->set.ostride,
+						crop_width);
 			parent->buf1filled = true;
 		} else {
-			offset_addr = t->set.o_off +
-				(t->output.crop.h - vdi_save_lines)*t->set.ostride;
+			offset_addr = t->set.o_off * pixwidth +
+				(t->output.crop.h - vdi_save_lines) * t->set.ostride;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + i*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + i*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[1] + i * crop_width,
+						crop_width);
+
 			parent->buf1filled = false;
 		}
 	}
-	/*Down stripe or Down&Right stript*/
+	/* Down stripe or Down&Right stript */
 	else if (stripe_mode == (DOWN_STRIPE | RIGHT_STRIPE)) {
 		if (!parent->buf1filled) {
-			offset_addr = t->set.o_off + vdi_save_lines*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_save_lines*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_save_lines*t->set.ostride);
+			offset_addr = t->set.o_off * pixwidth +
+				vdi_save_lines * t->set.ostride;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						base_off + offset_addr + i*t->set.ostride,
-						t->output.crop.w*2);
+				memcpy(parent->vditmpbuf[1] + i * crop_width,
+						base_off + offset_addr + i * t->set.ostride,
+						crop_width);
 			parent->buf1filled = true;
 		} else {
-			offset_addr = t->set.o_off;
+			offset_addr = t->set.o_off * pixwidth;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_save_lines*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_save_lines*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[1] + i * crop_width,
+						crop_width);
+
 			parent->buf1filled = false;
 		}
 	}
+	if (!pfn_valid(t->output.paddr >> PAGE_SHIFT))
+		iounmap(base_off);
 }
 
 static void do_task_release(struct ipu_task_entry *t, int fail)
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index 35b7819..87fa001 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -61,7 +61,7 @@ static unsigned long _ipu_pixel_clk_get_rate(struct clk *clk)
 {
 	struct ipu_soc *ipu = pixelclk2ipu(clk);
 	u32 div;
-	u64 final_rate = clk_get_rate(clk->parent) * 16;
+	u64 final_rate = (unsigned long long)clk_get_rate(clk->parent) * 16;
 
 	_ipu_get(ipu);
 	div = ipu_di_read(ipu, clk->id, DI_BS_CLKGEN0);
@@ -1297,6 +1297,10 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 	msleep(5);
 	/* Get integer portion of divider */
 	div = clk_get_rate(clk_get_parent(&ipu->pixel_clk[disp])) / rounded_pixel_clk;
+	if (!div) {
+		dev_err(ipu->dev, "invalid pixel clk div = 0\n");
+		return -EINVAL;
+	}
 
 	mutex_lock(&ipu->mutex_lock);
 
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
index b0b79ad..0f528d0 100644
--- a/drivers/mxc/ipu3/ipu_ic.c
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -69,6 +69,7 @@ void _ipu_vdi_set_motion(struct ipu_soc *ipu, ipu_motion_sel motion_sel)
 		reg |= VDI_C_MOT_SEL_LOW;
 
 	ipu_vdi_write(ipu, reg, VDI_C);
+	dev_dbg(ipu->dev, "VDI_C = \t0x%08X\n", reg);
 }
 
 void ic_dump_register(struct ipu_soc *ipu)
@@ -215,10 +216,10 @@ void _ipu_vdi_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_param
 	}
 	ipu_vdi_write(ipu, reg, VDI_C);
 
-	if (params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_TB)
-		_ipu_vdi_set_top_field_man(ipu, false);
-	else if (params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_BT)
+	if (params->mem_prp_vf_mem.field_fmt == IPU_DEINTERLACE_FIELD_TOP)
 		_ipu_vdi_set_top_field_man(ipu, true);
+	else if (params->mem_prp_vf_mem.field_fmt == IPU_DEINTERLACE_FIELD_BOTTOM)
+		_ipu_vdi_set_top_field_man(ipu, false);
 
 	_ipu_vdi_set_motion(ipu, params->mem_prp_vf_mem.motion_sel);
 
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
index 68c6654..6d0a470 100644
--- a/drivers/mxc/ipu3/ipu_param_mem.h
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -285,6 +285,13 @@ static inline void _ipu_ch_param_init(struct ipu_soc *ipu, int ch,
 		ipu_ch_param_set_field(&params, 1, 78, 7, 63);	/* burst size */
 
 		break;
+	case IPU_PIX_FMT_GENERIC_16:
+		/* Represents 16-bit generic data */
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 6);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		break;
 	case IPU_PIX_FMT_GENERIC_32:
 		/*Represents 32-bit Generic data */
 		break;
@@ -477,13 +484,17 @@ static inline void _ipu_ch_param_init(struct ipu_soc *ipu, int ch,
 	dev_dbg(ipu->dev, "initializing idma ch %d @ %p\n", ch, ipu_ch_param_addr(ipu, ch));
 	fill_cpmem(ipu, ch, &params);
 	if (addr2) {
-		ipu_ch_param_set_field(&params, 1, 0, 29, addr2 >> 3);
-		ipu_ch_param_set_field(&params, 1, 29, 29, 0);
-
 		sub_ch = __ipu_ch_get_third_buf_cpmem_num(ch);
 		if (sub_ch <= 0)
 			return;
 
+		ipu_ch_param_set_field(&params, 1, 0, 29, addr2 >> 3);
+		ipu_ch_param_set_field(&params, 1, 29, 29, 0);
+		if (addr2%8)
+			dev_warn(ipu->dev,
+				 "IDMAC%d's sub-CPMEM entry%d EBA0 is not "
+				 "8-byte aligned\n", ch, sub_ch);
+
 		dev_dbg(ipu->dev, "initializing idma ch %d @ %p sub cpmem\n", ch,
 					ipu_ch_param_addr(ipu, sub_ch));
 		fill_cpmem(ipu, sub_ch, &params);
@@ -691,6 +702,7 @@ static inline void _ipu_ch_offset_update(struct ipu_soc *ipu,
 
 	switch (pixel_fmt) {
 	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_GENERIC_16:
 	case IPU_PIX_FMT_GENERIC_32:
 	case IPU_PIX_FMT_RGB565:
 	case IPU_PIX_FMT_BGR24:
diff --git a/drivers/mxc/mlb/mxc_mlb150.c b/drivers/mxc/mlb/mxc_mlb150.c
index e3ecbe2..fa75d09 100755
--- a/drivers/mxc/mlb/mxc_mlb150.c
+++ b/drivers/mxc/mlb/mxc_mlb150.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,161 +37,173 @@
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/sched.h>
+#include <linux/circ_buf.h>
 
 #define DRIVER_NAME "mxc_mlb150"
 
 /*!
  * MLB module memory map registers define
  */
-#define MLB150_REG_MLBC0		0x0
-#define MLB150_MLBC0_MLBEN		(0x1)
-#define MLB150_MLBC0_MLBCLK_MASK	(0x7 << 2)
-#define MLB150_MLBC0_MLBCLK_SHIFT	(2)
-#define MLB150_MLBC0_MLBPEN		(0x1 << 5)
-#define MLB150_MLBC0_MLBLK		(0x1 << 7)
-#define MLB150_MLBC0_ASYRETRY		(0x1 << 12)
-#define MLB150_MLBC0_CTLRETRY		(0x1 << 12)
-#define MLB150_MLBC0_FCNT_MASK		(0x7 << 15)
-#define MLB150_MLBC0_FCNT_SHIFT		(15)
-
-#define MLB150_REG_MLBPC0		0x8
-#define MLB150_MLBPC0_MCLKHYS		(0x1 << 11)
-
-#define MLB150_REG_MS0			0xC
-#define MLB150_REG_MS1			0x14
-
-#define MLB150_REG_MSS			0x20
-#define MLB150_MSS_RSTSYSCMD		(0x1)
-#define MLB150_MSS_LKSYSCMD		(0x1 << 1)
-#define MLB150_MSS_ULKSYSCMD		(0x1 << 2)
-#define MLB150_MSS_CSSYSCMD		(0x1 << 3)
-#define MLB150_MSS_SWSYSCMD		(0x1 << 4)
-#define MLB150_MSS_SERVREQ		(0x1 << 5)
-
-#define MLB150_REG_MSD			0x24
-
-#define MLB150_REG_MIEN			0x2C
-#define MLB150_MIEN_ISOC_PE		(0x1)
-#define MLB150_MIEN_ISOC_BUFO		(0x1 << 1)
-#define MLB150_MIEN_SYNC_PE		(0x1 << 16)
-#define MLB150_MIEN_ARX_DONE		(0x1 << 17)
-#define MLB150_MIEN_ARX_PE		(0x1 << 18)
-#define MLB150_MIEN_ARX_BREAK		(0x1 << 19)
-#define MLB150_MIEN_ATX_DONE		(0x1 << 20)
-#define MLB150_MIEN_ATX_PE		(0x1 << 21)
-#define MLB150_MIEN_ATX_BREAK		(0x1 << 22)
-#define MLB150_MIEN_CRX_DONE		(0x1 << 24)
-#define MLB150_MIEN_CRX_PE		(0x1 << 25)
-#define MLB150_MIEN_CRX_BREAK		(0x1 << 26)
-#define MLB150_MIEN_CTX_DONE		(0x1 << 27)
-#define MLB150_MIEN_CTX_PE		(0x1 << 28)
-#define MLB150_MIEN_CTX_BREAK		(0x1 << 29)
-
-#define MLB150_REG_MLBPC2		0x34
-#define MLB150_REG_MLBPC1		0x38
-#define MLB150_MLBPC1_VAL		(0x00000888)
-
-#define MLB150_REG_MLBC1		0x3C
-#define MLB150_MLBC1_LOCK		(0x1 << 6)
-#define MLB150_MLBC1_CLKM		(0x1 << 7)
-#define MLB150_MLBC1_NDA_MASK		(0xFF << 8)
-#define MLB150_MLBC1_NDA_SHIFT		(8)
-
-#define MLB150_REG_HCTL			0x80
-#define MLB150_HCTL_RST0		(0x1)
-#define MLB150_HCTL_RST1		(0x1 << 1)
-#define MLB150_HCTL_EN			(0x1 << 15)
-
-#define MLB150_REG_HCMR0		0x88
-#define MLB150_REG_HCMR1		0x8C
-#define MLB150_REG_HCER0		0x90
-#define MLB150_REG_HCER1		0x94
-#define MLB150_REG_HCBR0		0x98
-#define MLB150_REG_HCBR1		0x9C
-
-#define MLB150_REG_MDAT0		0xC0
-#define MLB150_REG_MDAT1		0xC4
-#define MLB150_REG_MDAT2		0xC8
-#define MLB150_REG_MDAT3		0xCC
-
-#define MLB150_REG_MDWE0		0xD0
-#define MLB150_REG_MDWE1		0xD4
-#define MLB150_REG_MDWE2		0xD8
-#define MLB150_REG_MDWE3		0xDC
-
-#define MLB150_REG_MCTL			0xE0
-#define MLB150_MCTL_XCMP		(0x1)
-
-#define MLB150_REG_MADR			0xE4
-#define MLB150_MADR_WNR			(0x1 << 31)
-#define MLB150_MADR_TB			(0x1 << 30)
-#define MLB150_MADR_ADDR_MASK		(0x7f << 8)
-#define MLB150_MADR_ADDR_SHIFT		(0)
-
-#define MLB150_REG_ACTL			0x3C0
-#define MLB150_ACTL_MPB			(0x1 << 4)
-#define MLB150_ACTL_DMAMODE		(0x1 << 2)
-#define MLB150_ACTL_SMX			(0x1 << 1)
-#define MLB150_ACTL_SCE			(0x1)
-
-#define MLB150_REG_ACSR0		0x3D0
-#define MLB150_REG_ACSR1		0x3D4
-#define MLB150_REG_ACMR0		0x3D8
-#define MLB150_REG_ACMR1		0x3DC
-
-#define MLB150_REG_CAT_MDATn(ch) (MLB150_REG_MDAT0 + ((ch % 8) >> 1) * 4)
-#define MLB150_REG_CAT_MDWEn(ch) (MLB150_REG_MDWE0 + ((ch % 8) >> 1) * 4)
-
-#define MLB150_LOGIC_CH_NUM		(64)
-#define MLB150_BUF_CDT_OFFSET		(0x0)
-#define MLB150_BUF_ADT_OFFSET		(0x40)
-#define MLB150_BUF_CAT_MLB_OFFSET	(0x80)
-#define MLB150_BUF_CAT_HBI_OFFSET	(0x88)
-#define MLB150_BUF_CTR_END_OFFSET	(0x8F)
-
-#define MLB150_CAT_MODE_RX		(0x1 << 0)
-#define MLB150_CAT_MODE_TX		(0x1 << 1)
-#define MLB150_CAT_MODE_INBOUND_DMA	(0x1 << 8)
-#define MLB150_CAT_MODE_OUTBOUND_DMA	(0x1 << 9)
-
-#define MLB150_CH_SYNC_BUF_DEP		(128 * 4 * 4)
-#define MLB150_CH_CTRL_BUF_DEP		(64)
-#define MLB150_CH_ASYNC_BUF_DEP		(2048)
-#define MLB150_CH_ISOC_BLK_SIZE		(196)
-#define MLB150_CH_ISOC_BLK_NUM		(3)
-#define MLB150_CH_ISOC_BUF_DEP		(MLB150_CH_ISOC_BLK_SIZE * MLB150_CH_ISOC_BLK_NUM)
-
-#define MLB150_CH_SYNC_DBR_BUF_OFFSET	(0x0)
-#define MLB150_CH_CTRL_DBR_BUF_OFFSET	(MLB150_CH_SYNC_DBR_BUF_OFFSET + 2 * MLB150_CH_SYNC_BUF_DEP)
-#define MLB150_CH_ASYNC_DBR_BUF_OFFSET	(MLB150_CH_CTRL_DBR_BUF_OFFSET + 2 * MLB150_CH_CTRL_BUF_DEP)
-#define MLB150_CH_ISOC_DBR_BUF_OFFSET	(MLB150_CH_ASYNC_DBR_BUF_OFFSET + 2 * MLB150_CH_ASYNC_BUF_DEP)
-
-static u32 mlb150_ch_packet_buf_size[4] = {
-	MLB150_CH_SYNC_BUF_DEP,
-	MLB150_CH_CTRL_BUF_DEP,
-	MLB150_CH_ASYNC_BUF_DEP,
-	MLB150_CH_ISOC_BUF_DEP
-};
-
-#define MLB150_DBR_BUF_START 0x00000
-
-#define MLB150_CDT_LEN			(16)
-#define MLB150_ADT_LEN			(16)
-#define MLB150_CAT_LEN			(2)
-
-#define MLB150_CDT_SZ		(MLB150_CDT_LEN * MLB150_LOGIC_CH_NUM)
-#define MLB150_ADT_SZ		(MLB150_ADT_LEN * MLB150_LOGIC_CH_NUM)
-#define MLB150_CAT_SZ		(MLB150_CAT_LEN * MLB150_LOGIC_CH_NUM * 2)
-
-#define MLB150_CDT_BASE(base)		(base + MLB150_BUF_CDT_OFFSET)
-#define MLB150_ADT_BASE(base)		(base + MLB150_BUF_ADT_OFFSET)
-#define MLB150_CAT_MLB_BASE(base)	(base + MLB150_BUF_CAT_MLB_OFFSET)
-#define MLB150_CAT_HBI_BASE(base)	(base + MLB150_BUF_CAT_HBI_OFFSET)
-
-#define MLB150_CDTn_ADDR(base, n)	(base + MLB150_BUF_CDT_OFFSET + n * MLB150_CDT_LEN)
-#define MLB150_ADTn_ADDR(base, n)	(base + MLB150_BUF_ADT_OFFSET + n * MLB150_ADT_LEN)
-#define MLB150_CATn_MLB_ADDR(base, n)	(base + MLB150_BUF_CAT_MLB_OFFSET + n * MLB150_CAT_LEN)
-#define MLB150_CATn_HBI_ADDR(base, n)	(base + MLB150_BUF_CAT_HBI_OFFSET + n * MLB150_CAT_LEN)
+#define REG_MLBC0		0x0
+#define MLBC0_MLBEN		(0x1)
+#define MLBC0_MLBCLK_MASK	(0x7 << 2)
+#define MLBC0_MLBCLK_SHIFT	(2)
+#define MLBC0_MLBPEN		(0x1 << 5)
+#define MLBC0_MLBLK		(0x1 << 7)
+#define MLBC0_ASYRETRY		(0x1 << 12)
+#define MLBC0_CTLRETRY		(0x1 << 12)
+#define MLBC0_FCNT_MASK		(0x7 << 15)
+#define MLBC0_FCNT_SHIFT	(15)
+
+#define REG_MLBPC0		0x8
+#define MLBPC0_MCLKHYS		(0x1 << 11)
+
+#define REG_MS0			0xC
+#define REG_MS1			0x14
+
+#define REG_MSS			0x20
+#define MSS_RSTSYSCMD		(0x1)
+#define MSS_LKSYSCMD		(0x1 << 1)
+#define MSS_ULKSYSCMD		(0x1 << 2)
+#define MSS_CSSYSCMD		(0x1 << 3)
+#define MSS_SWSYSCMD		(0x1 << 4)
+#define MSS_SERVREQ		(0x1 << 5)
+
+#define REG_MSD			0x24
+
+#define REG_MIEN		0x2C
+#define MIEN_ISOC_PE		(0x1)
+#define MIEN_ISOC_BUFO		(0x1 << 1)
+#define MIEN_SYNC_PE		(0x1 << 16)
+#define MIEN_ARX_DONE		(0x1 << 17)
+#define MIEN_ARX_PE		(0x1 << 18)
+#define MIEN_ARX_BREAK		(0x1 << 19)
+#define MIEN_ATX_DONE		(0x1 << 20)
+#define MIEN_ATX_PE		(0x1 << 21)
+#define MIEN_ATX_BREAK		(0x1 << 22)
+#define MIEN_CRX_DONE		(0x1 << 24)
+#define MIEN_CRX_PE		(0x1 << 25)
+#define MIEN_CRX_BREAK		(0x1 << 26)
+#define MIEN_CTX_DONE		(0x1 << 27)
+#define MIEN_CTX_PE		(0x1 << 28)
+#define MIEN_CTX_BREAK		(0x1 << 29)
+
+#define REG_MLBPC2		0x34
+#define REG_MLBPC1		0x38
+#define MLBPC1_VAL		(0x00000888)
+
+#define REG_MLBC1		0x3C
+#define MLBC1_LOCK		(0x1 << 6)
+#define MLBC1_CLKM		(0x1 << 7)
+#define MLBC1_NDA_MASK		(0xFF << 8)
+#define MLBC1_NDA_SHIFT		(8)
+
+#define REG_HCTL		0x80
+#define HCTL_RST0		(0x1)
+#define HCTL_RST1		(0x1 << 1)
+#define HCTL_EN			(0x1 << 15)
+
+#define REG_HCMR0		0x88
+#define REG_HCMR1		0x8C
+#define REG_HCER0		0x90
+#define REG_HCER1		0x94
+#define REG_HCBR0		0x98
+#define REG_HCBR1		0x9C
+
+#define REG_MDAT0		0xC0
+#define REG_MDAT1		0xC4
+#define REG_MDAT2		0xC8
+#define REG_MDAT3		0xCC
+
+#define REG_MDWE0		0xD0
+#define REG_MDWE1		0xD4
+#define REG_MDWE2		0xD8
+#define REG_MDWE3		0xDC
+
+#define REG_MCTL		0xE0
+#define MCTL_XCMP		(0x1)
+
+#define REG_MADR		0xE4
+#define MADR_WNR		(0x1 << 31)
+#define MADR_TB			(0x1 << 30)
+#define MADR_ADDR_MASK		(0x7f << 8)
+#define MADR_ADDR_SHIFT		(0)
+
+#define REG_ACTL		0x3C0
+#define ACTL_MPB		(0x1 << 4)
+#define ACTL_DMAMODE		(0x1 << 2)
+#define ACTL_SMX		(0x1 << 1)
+#define ACTL_SCE		(0x1)
+
+#define REG_ACSR0		0x3D0
+#define REG_ACSR1		0x3D4
+#define REG_ACMR0		0x3D8
+#define REG_ACMR1		0x3DC
+
+#define REG_CAT_MDATn(ch) (REG_MDAT0 + ((ch % 8) >> 1) * 4)
+#define REG_CAT_MDWEn(ch) (REG_MDWE0 + ((ch % 8) >> 1) * 4)
+
+#define INT_AHB0_CH_START	(0)
+#define INT_AHB1_CH_START	(32)
+
+#define LOGIC_CH_NUM		(64)
+#define BUF_CDT_OFFSET		(0x0)
+#define BUF_ADT_OFFSET		(0x40)
+#define BUF_CAT_MLB_OFFSET	(0x80)
+#define BUF_CAT_HBI_OFFSET	(0x88)
+#define BUF_CTR_END_OFFSET	(0x8F)
+
+#define CAT_MODE_RX		(0x1 << 0)
+#define CAT_MODE_TX		(0x1 << 1)
+#define CAT_MODE_INBOUND_DMA	(0x1 << 8)
+#define CAT_MODE_OUTBOUND_DMA	(0x1 << 9)
+
+#define CH_SYNC_DEFAULT_QUAD	(1)
+#define CH_SYNC_MAX_QUAD	(15)
+#define CH_SYNC_CDT_BUF_DEP	(CH_SYNC_DEFAULT_QUAD * 4 * 4)
+#define CH_SYNC_ADT_BUF_MULTI	(4)
+#define CH_SYNC_ADT_BUF_DEP	(CH_SYNC_CDT_BUF_DEP * CH_SYNC_ADT_BUF_MULTI)
+#define CH_SYNC_BUF_SZ		(CH_SYNC_MAX_QUAD * 4 * 4 * CH_SYNC_ADT_BUF_MULTI)
+#define CH_CTRL_CDT_BUF_DEP	(64)
+#define CH_CTRL_ADT_BUF_DEP	(CH_CTRL_CDT_BUF_DEP)
+#define CH_CTRL_BUF_SZ		(CH_CTRL_ADT_BUF_DEP)
+#define CH_ASYNC_MDP_PACKET_LEN	(1024)
+#define CH_ASYNC_MEP_PACKET_LEN	(1536)
+#define CH_ASYNC_CDT_BUF_DEP	(CH_ASYNC_MEP_PACKET_LEN)
+#define CH_ASYNC_ADT_BUF_DEP	(CH_ASYNC_CDT_BUF_DEP)
+#define CH_ASYNC_BUF_SZ		(CH_ASYNC_ADT_BUF_DEP)
+#define CH_ISOC_BLK_SIZE_188	(188)
+#define CH_ISOC_BLK_SIZE_196	(196)
+#define CH_ISOC_BLK_SIZE	(CH_ISOC_BLK_SIZE_188)
+#define CH_ISOC_BLK_NUM		(5)
+#define CH_ISOC_CDT_BUF_DEP	(CH_ISOC_BLK_SIZE * CH_ISOC_BLK_NUM)
+#define CH_ISOC_ADT_BUF_DEP	(CH_ISOC_CDT_BUF_DEP)
+#define CH_ISOC_BUF_SZ		(1024)
+
+#define CH_SYNC_DBR_BUF_OFFSET	(0x0)
+#define CH_CTRL_DBR_BUF_OFFSET	(CH_SYNC_DBR_BUF_OFFSET + 2 * (CH_SYNC_MAX_QUAD * 4 * 4))
+#define CH_ASYNC_DBR_BUF_OFFSET	(CH_CTRL_DBR_BUF_OFFSET + 2 * CH_CTRL_CDT_BUF_DEP)
+#define CH_ISOC_DBR_BUF_OFFSET	(CH_ASYNC_DBR_BUF_OFFSET + 2 * CH_ASYNC_CDT_BUF_DEP)
+
+#define DBR_BUF_START 0x00000
+
+#define CDT_LEN			(16)
+#define ADT_LEN			(16)
+#define CAT_LEN			(2)
+
+#define CDT_SZ			(CDT_LEN * LOGIC_CH_NUM)
+#define ADT_SZ			(ADT_LEN * LOGIC_CH_NUM)
+#define CAT_SZ			(CAT_LEN * LOGIC_CH_NUM * 2)
+
+#define CDT_BASE(base)		(base + BUF_CDT_OFFSET)
+#define ADT_BASE(base)		(base + BUF_ADT_OFFSET)
+#define CAT_MLB_BASE(base)	(base + BUF_CAT_MLB_OFFSET)
+#define CAT_HBI_BASE(base)	(base + BUF_CAT_HBI_OFFSET)
+
+#define CDTn_ADDR(base, n)	(base + BUF_CDT_OFFSET + n * CDT_LEN)
+#define ADTn_ADDR(base, n)	(base + BUF_ADT_OFFSET + n * ADT_LEN)
+#define CATn_MLB_ADDR(base, n)	(base + BUF_CAT_MLB_OFFSET + n * CAT_LEN)
+#define CATn_HBI_ADDR(base, n)	(base + BUF_CAT_HBI_OFFSET + n * CAT_LEN)
 
 #define CAT_CL_SHIFT		(0x0)
 #define CAT_CT_SHIFT		(8)
@@ -246,11 +258,6 @@ static u32 mlb150_ch_packet_buf_size[4] = {
 #define ADT_MEP1		(0x1 << 11)
 #define ADT_MEP2		(0x1 << 27)
 
-#define MLB_CONTROL_TX_CHANN	(0 << 4)
-#define MLB_CONTROL_RX_CHANN	(1 << 4)
-#define MLB_ASYNC_TX_CHANN	(2 << 4)
-#define MLB_ASYNC_RX_CHANN	(3 << 4)
-
 #define MLB_MINOR_DEVICES	4
 #define MLB_CONTROL_DEV_NAME	"ctrl"
 #define MLB_ASYNC_DEV_NAME	"async"
@@ -259,16 +266,8 @@ static u32 mlb150_ch_packet_buf_size[4] = {
 
 #define TX_CHANNEL		0
 #define RX_CHANNEL		1
-#define PING_BUF_MAX_SIZE	(2 * 1024)
-#define PONG_BUF_MAX_SIZE	(2 * 1024)
-/* max package data size */
-#define ASYNC_PACKET_SIZE	1024
-#define CTRL_PACKET_SIZE	64
-#define TRANS_RING_NODES	10
 
-#define MLB_IRAM_SIZE		(MLB_MINOR_DEVICES * (PING_BUF_MAX_SIZE + PONG_BUF_MAX_SIZE))
-#define _get_txchan(dev)	mlb_devinfo[dev].channels[TX_CHANNEL]
-#define _get_rxchan(dev)	mlb_devinfo[dev].channels[RX_CHANNEL]
+#define TRANS_RING_NODES	(1 << 3)
 
 enum MLB_CTYPE {
 	MLB_CTYPE_SYNC,
@@ -277,71 +276,34 @@ enum MLB_CTYPE {
 	MLB_CTYPE_ISOC,
 };
 
-enum MLB150_CLK_SPEED {
-	MLB150_CLK_256FS,
-	MLB150_CLK_512FS,
-	MLB150_CLK_1024FS,
-	MLB150_CLK_2048FS,
-	MLB150_CLK_3072FS,
-	MLB150_CLK_4096FS,
-	MLB150_CLK_6144FS,
-	MLB150_CLK_8192FS,
+enum CLK_SPEED {
+	CLK_256FS,
+	CLK_512FS,
+	CLK_1024FS,
+	CLK_2048FS,
+	CLK_3072FS,
+	CLK_4096FS,
+	CLK_6144FS,
+	CLK_8192FS,
 };
 
-/*!
- * Ring buffer
- */
-#define MLB_RING_BUF_INIT(r)	{	\
-	r->wpos = 0;	\
-	r->rpos = 0;	\
-}
-
-#define MLB_RING_BUF_IS_FULL(r) (((r->wpos + 1) % TRANS_RING_NODES) == r->rpos)
-#define MLB_RING_BUF_IS_EMPTY(r) (r->rpos == r->wpos)
-#define MLB_RING_BUF_ENQUE(r, buf) {	\
-	memcpy(r->node[r->wpos].data, buf, r->node.size);	\
-	r->wpos = (r->wpos + 1) % TRANS_RING_NODES;	\
-}
-#define MLB_RING_BUF_DEQUE(r, buf) {	\
-	memcpy(buf, r->node[r->rpos].data, r->node.size);	\
-	r->rpos = (r->rpos + 1) % TRANS_RING_NODES;	\
-}
-
 struct mlb_ringbuf {
-	u32 wpos;
-	u32 rpos;
-	u32 size;
-	/* Last buffer is for package drop */
-	u8  *virt_bufs[TRANS_RING_NODES + 1];
-	u32 phy_addrs[TRANS_RING_NODES + 1];
+	s8 *virt_bufs[TRANS_RING_NODES];
+	u32 phy_addrs[TRANS_RING_NODES];
+	s32 head;
+	s32 tail;
+	s32 unit_size;
+	s32 total_size;
+	rwlock_t rb_lock ____cacheline_aligned; /* ring index lock */
 };
 
 struct mlb_channel_info {
-
-	/* channel address */
-	s32 address;
+	/* Input MLB channel address */
+	u32 address;
+	/* Internal AHB channel label */
+	u32 cl;
 	/* DBR buf head */
 	u32 dbr_buf_head;
-	/* ping buffer head */
-	u32 ping_buf_head;
-	/* pong buffer head */
-	u32 pong_buf_head;
-	/* ping buffer physical head */
-	u32 ping_phy_head;
-	/* pong buffer physical head */
-	u32 pong_phy_head;
-	/* channel buffer size */
-	u32 buf_size;
-	/* channel buffer current ptr */
-	u32 buf_ptr;
-	/* channel buffer phy addr */
-	u32 buf_phy_addr;
-	/* packet start indicator */
-	u32 ps_ind;
-	/* packet remain size */
-	u32 pkt_remain_size;
-	/* buffer spin lock */
-	rwlock_t buf_lock;
 };
 
 struct mlb_dev_info {
@@ -351,11 +313,14 @@ struct mlb_dev_info {
 	/* channel type */
 	const unsigned int channel_type;
 	/* ch fps */
-	enum MLB150_CLK_SPEED fps;
+	enum CLK_SPEED fps;
 	/* channel info for tx/rx */
 	struct mlb_channel_info channels[2];
-	/* rx ring buffer */
-	struct mlb_ringbuf rx_bufs;
+	/* ring buffer */
+	u8 *rbuf_base_virt;
+	u32 rbuf_base_phy;
+	struct mlb_ringbuf rx_rbuf;
+	struct mlb_ringbuf tx_rbuf;
 	/* exception event */
 	unsigned long ex_event;
 	/* tx busy indicator */
@@ -365,37 +330,109 @@ struct mlb_dev_info {
 	/* device open count */
 	atomic_t opencnt;
 	/* wait queue head for channel */
-	wait_queue_head_t rd_wq;
-	wait_queue_head_t wt_wq;
+	wait_queue_head_t rx_wq;
+	wait_queue_head_t tx_wq;
+	/* TX OK */
+	s32 tx_ok;
 	/* spinlock for event access */
 	spinlock_t event_lock;
+	/* Block size for isoc mode
+	 * This variable can be configured in ioctl */
+	u32 isoc_blksz;
+	/* Quads number for sync mode
+	 * This variable can be confifured in ioctl */
+	u32 sync_quad;
+	/* Buffer depth in cdt */
+	u32 cdt_buf_dep;
+	/* Buffer depth in adt */
+	u32 adt_buf_dep;
+	/* Buffer size to hold data */
+	u32 buf_size;
+};
+
+struct mlb_data {
+	struct mlb_dev_info *devinfo;
+	struct clk *clk_mlb3p;
+	struct clk *clk_mlb6p;
+	struct cdev cdev;
+	struct class *class;	/* device class */
+	dev_t firstdev;
+#ifdef CONFIG_REGULATOR
+	struct regulator *nvcc;
+#endif
+	u32 membase;	/* mlb module base address */
+	u32 irq_ahb0;
+	u32 irq_ahb1;
+	u32 irq_mlb;
 };
 
+/* For optimization, we use fixed channel label for
+ * input channels of each mode */
+/* SYNC: CL = 0 for RX, CL = 64 for TX
+ * CTRL: CL = 1 for RX, CL = 65 for TX
+ * ASYNC: CL = 2 for RX, CL = 66 for TX
+ * ISOC: CL = 3 for RX, CL = 67 for TX
+ * */
+#define SYNC_RX_CL_AHB0		0
+#define CTRL_RX_CL_AHB0		1
+#define ASYNC_RX_CL_AHB0	2
+#define ISOC_RX_CL_AHB0		3
+#define SYNC_TX_CL_AHB0		4
+#define CTRL_TX_CL_AHB0		5
+#define ASYNC_TX_CL_AHB0	6
+#define ISOC_TX_CL_AHB0		7
+
+#define SYNC_RX_CL_AHB1		32
+#define CTRL_RX_CL_AHB1		33
+#define ASYNC_RX_CL_AHB1	34
+#define ISOC_RX_CL_AHB1		35
+#define SYNC_TX_CL_AHB1		36
+#define CTRL_TX_CL_AHB1		37
+#define ASYNC_TX_CL_AHB1	38
+#define ISOC_TX_CL_AHB1		39
+
+#define SYNC_RX_CL	SYNC_RX_CL_AHB0
+#define CTRL_RX_CL	CTRL_RX_CL_AHB0
+#define ASYNC_RX_CL	ASYNC_RX_CL_AHB0
+#define ISOC_RX_CL	ISOC_RX_CL_AHB0
+
+#define SYNC_TX_CL	SYNC_TX_CL_AHB0
+#define CTRL_TX_CL	CTRL_TX_CL_AHB0
+#define ASYNC_TX_CL	ASYNC_TX_CL_AHB0
+#define ISOC_TX_CL	ISOC_TX_CL_AHB0
+
 static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	{
 	.dev_name = MLB_SYNC_DEV_NAME,
 	.channel_type = MLB_CTYPE_SYNC,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_SYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_SYNC_DBR_BUF_OFFSET,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[0].channels[0].
-					buf_lock),
+			.cl = SYNC_TX_CL,
+			.dbr_buf_head = CH_SYNC_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_SYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_SYNC_DBR_BUF_OFFSET
-					+ MLB150_CH_SYNC_BUF_DEP,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[0].channels[1].
-					buf_lock),
+			.cl = SYNC_RX_CL,
+			.dbr_buf_head = CH_SYNC_DBR_BUF_OFFSET
+					+ CH_SYNC_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_SYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[0].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_SYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[0].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_SYNC_CDT_BUF_DEP,
+	.adt_buf_dep = CH_SYNC_ADT_BUF_DEP,
+	.buf_size = CH_SYNC_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[0].event_lock),
 	},
 	{
@@ -403,25 +440,32 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	.channel_type = MLB_CTYPE_CTRL,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_CTRL_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_CTRL_DBR_BUF_OFFSET,
-			.buf_lock =
-			__RW_LOCK_UNLOCKED(mlb_devinfo[1].channels[0].
-					buf_lock),
+			.cl = CTRL_TX_CL,
+			.dbr_buf_head = CH_CTRL_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_CTRL_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_CTRL_DBR_BUF_OFFSET
-					+ MLB150_CH_CTRL_BUF_DEP,
-			.buf_lock =
-			__RW_LOCK_UNLOCKED(mlb_devinfo[1].channels[1].
-					buf_lock),
+			.cl = CTRL_RX_CL,
+			.dbr_buf_head = CH_CTRL_DBR_BUF_OFFSET
+					+ CH_CTRL_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_CTRL_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[1].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_CTRL_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[1].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_CTRL_CDT_BUF_DEP,
+	.adt_buf_dep = CH_CTRL_ADT_BUF_DEP,
+	.buf_size = CH_CTRL_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[1].event_lock),
 	},
 	{
@@ -429,25 +473,32 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	.channel_type = MLB_CTYPE_ASYNC,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_ASYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ASYNC_DBR_BUF_OFFSET,
-			.buf_lock =
-			__RW_LOCK_UNLOCKED(mlb_devinfo[2].channels[0].
-					buf_lock),
+			.cl = ASYNC_TX_CL,
+			.dbr_buf_head = CH_ASYNC_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_ASYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ASYNC_DBR_BUF_OFFSET
-					+ MLB150_CH_ASYNC_BUF_DEP,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[2].channels[1].
-					buf_lock),
+			.cl = ASYNC_RX_CL,
+			.dbr_buf_head = CH_ASYNC_DBR_BUF_OFFSET
+					+ CH_ASYNC_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_ASYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[2].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_ASYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[2].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_ASYNC_CDT_BUF_DEP,
+	.adt_buf_dep = CH_ASYNC_ADT_BUF_DEP,
+	.buf_size = CH_ASYNC_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[2].event_lock),
 	},
 	{
@@ -455,171 +506,98 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	.channel_type = MLB_CTYPE_ISOC,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_ISOC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ISOC_DBR_BUF_OFFSET,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[3].channels[0].
-					buf_lock),
+			.cl = ISOC_TX_CL,
+			.dbr_buf_head = CH_ISOC_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_ISOC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ISOC_DBR_BUF_OFFSET
-					+ MLB150_CH_ISOC_BUF_DEP,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[3].channels[1].
-					buf_lock),
+			.cl = ISOC_RX_CL,
+			.dbr_buf_head = CH_ISOC_DBR_BUF_OFFSET
+					+ CH_ISOC_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_ISOC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[3].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_ISOC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[3].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_ISOC_CDT_BUF_DEP,
+	.adt_buf_dep = CH_ISOC_ADT_BUF_DEP,
+	.buf_size = CH_ISOC_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[3].event_lock),
+	.isoc_blksz = CH_ISOC_BLK_SIZE_188,
 	},
 };
 
-static struct regulator *reg_nvcc;	/* NVCC_MLB regulator */
-static struct clk *mlb_clk;
-static struct clk *mlb_pll_clk;
-static dev_t dev;
-static struct class *mlb_class;	/* device class */
-static struct device *class_dev;
-static u32 mlb_base;	/* mlb module base address */
-static u32 ahb0_irq, ahb1_irq, mlb_irq;
+static u32 mlb_base;
 
 DEFINE_SPINLOCK(ctr_lock);
 
 #ifdef DEBUG
-
 #define DUMP_REG(reg) pr_debug(#reg": 0x%08x\n", __raw_readl(mlb_base + reg))
 
 static void mlb150_dev_dump_reg(void)
 {
 	pr_debug("mxc_mlb150: Dump registers:\n");
-	DUMP_REG(MLB150_REG_MLBC0);
-	DUMP_REG(MLB150_REG_MLBPC0);
-	DUMP_REG(MLB150_REG_MS0);
-	DUMP_REG(MLB150_REG_MS1);
-	DUMP_REG(MLB150_REG_MSS);
-	DUMP_REG(MLB150_REG_MSD);
-	DUMP_REG(MLB150_REG_MIEN);
-	DUMP_REG(MLB150_REG_MLBPC2);
-	DUMP_REG(MLB150_REG_MLBPC1);
-	DUMP_REG(MLB150_REG_MLBC1);
-	DUMP_REG(MLB150_REG_HCTL);
-	DUMP_REG(MLB150_REG_HCMR0);
-	DUMP_REG(MLB150_REG_HCMR1);
-	DUMP_REG(MLB150_REG_HCER0);
-	DUMP_REG(MLB150_REG_HCER1);
-	DUMP_REG(MLB150_REG_HCBR0);
-	DUMP_REG(MLB150_REG_HCBR1);
-	DUMP_REG(MLB150_REG_MDAT0);
-	DUMP_REG(MLB150_REG_MDAT1);
-	DUMP_REG(MLB150_REG_MDAT2);
-	DUMP_REG(MLB150_REG_MDAT3);
-	DUMP_REG(MLB150_REG_MDWE0);
-	DUMP_REG(MLB150_REG_MDWE1);
-	DUMP_REG(MLB150_REG_MDWE2);
-	DUMP_REG(MLB150_REG_MDWE3);
-	DUMP_REG(MLB150_REG_MCTL);
-	DUMP_REG(MLB150_REG_MADR);
-	DUMP_REG(MLB150_REG_ACTL);
-	DUMP_REG(MLB150_REG_ACSR0);
-	DUMP_REG(MLB150_REG_ACSR1);
-	DUMP_REG(MLB150_REG_ACMR0);
-	DUMP_REG(MLB150_REG_ACMR1);
+	DUMP_REG(REG_MLBC0);
+	DUMP_REG(REG_MLBPC0);
+	DUMP_REG(REG_MS0);
+	DUMP_REG(REG_MS1);
+	DUMP_REG(REG_MSS);
+	DUMP_REG(REG_MSD);
+	DUMP_REG(REG_MIEN);
+	DUMP_REG(REG_MLBPC2);
+	DUMP_REG(REG_MLBPC1);
+	DUMP_REG(REG_MLBC1);
+	DUMP_REG(REG_HCTL);
+	DUMP_REG(REG_HCMR0);
+	DUMP_REG(REG_HCMR1);
+	DUMP_REG(REG_HCER0);
+	DUMP_REG(REG_HCER1);
+	DUMP_REG(REG_HCBR0);
+	DUMP_REG(REG_HCBR1);
+	DUMP_REG(REG_MDAT0);
+	DUMP_REG(REG_MDAT1);
+	DUMP_REG(REG_MDAT2);
+	DUMP_REG(REG_MDAT3);
+	DUMP_REG(REG_MDWE0);
+	DUMP_REG(REG_MDWE1);
+	DUMP_REG(REG_MDWE2);
+	DUMP_REG(REG_MDWE3);
+	DUMP_REG(REG_MCTL);
+	DUMP_REG(REG_MADR);
+	DUMP_REG(REG_ACTL);
+	DUMP_REG(REG_ACSR0);
+	DUMP_REG(REG_ACSR1);
+	DUMP_REG(REG_ACMR0);
+	DUMP_REG(REG_ACMR1);
 }
 
 static void mlb150_dev_dump_hex(const u8 *buf, u32 len)
 {
-	u32 i, remain, round_len;
-
-	pr_debug("buf: 0x%08x, len: %d\n", (u32)buf, len);
-	remain = len & 0x7;
-	round_len = len - remain;
-	for (i = 0; i < round_len; i += 8) {
-		pr_debug("%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			*(buf + i),
-			*(buf + i + 1),
-			*(buf + i + 2),
-			*(buf + i + 3),
-			*(buf + i + 4),
-			*(buf + i + 5),
-			*(buf + i + 6),
-			*(buf + i + 7));
-	}
-
-	if (remain) {
-		i = round_len;
-		switch (remain) {
-		case 1:
-			pr_debug("%02x\n",
-				*(buf + i));
-			break;
-		case 2:
-			pr_debug("%02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1));
-			break;
-		case 3:
-			pr_debug("%02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2));
-			break;
-		case 4:
-			pr_debug("%02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3));
-			break;
-		case 5:
-			pr_debug("%02x %02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3),
-				*(buf + i + 4));
-			break;
-		case 6:
-			pr_debug("%02x %02x %02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3),
-				*(buf + i + 4),
-				*(buf + i + 5));
-			break;
-		case 7:
-			pr_debug("%02x %02x %02x %02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3),
-				*(buf + i + 4),
-				*(buf + i + 5),
-				*(buf + i + 6));
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (i % 8 != 0)
-		pr_debug("\n");
+	print_hex_dump(KERN_DEBUG, "CTR DUMP:",
+			DUMP_PREFIX_OFFSET, 8, 1, buf, len, 0);
 }
 #endif
 
 static inline void mlb150_dev_enable_ctr_write(u32 mdat0_bits_en,
 		u32 mdat1_bits_en, u32 mdat2_bits_en, u32 mdat3_bits_en)
 {
-	__raw_writel(mdat0_bits_en, mlb_base + MLB150_REG_MDWE0);
-	__raw_writel(mdat1_bits_en, mlb_base + MLB150_REG_MDWE1);
-	__raw_writel(mdat2_bits_en, mlb_base + MLB150_REG_MDWE2);
-	__raw_writel(mdat3_bits_en, mlb_base + MLB150_REG_MDWE3);
+	__raw_writel(mdat0_bits_en, mlb_base + REG_MDWE0);
+	__raw_writel(mdat1_bits_en, mlb_base + REG_MDWE1);
+	__raw_writel(mdat2_bits_en, mlb_base + REG_MDWE2);
+	__raw_writel(mdat3_bits_en, mlb_base + REG_MDWE3);
 }
 
+#ifdef DEBUG
 static inline u8 mlb150_dev_dbr_read(u32 dbr_addr)
 {
 	s32 timeout = 1000;
@@ -627,20 +605,22 @@ static inline u8 mlb150_dev_dbr_read(u32 dbr_addr)
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(MLB150_MADR_TB | dbr_addr,
-		mlb_base + MLB150_REG_MADR);
+	__raw_writel(MADR_TB | dbr_addr,
+		mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(0 == timeout))
+	if (0 == timeout) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		return -ETIME;
+	}
 
-	dbr_val = __raw_readl(mlb_base + MLB150_REG_MDAT0) & 0x000000ff;
+	dbr_val = __raw_readl(mlb_base + REG_MDAT0) & 0x000000ff;
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
 	return dbr_val;
@@ -653,49 +633,76 @@ static inline s32 mlb150_dev_dbr_write(u32 dbr_addr, u8 dbr_val)
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(mdat0, mlb_base + MLB150_REG_MDAT0);
+	__raw_writel(mdat0, mlb_base + REG_MDAT0);
 
-	__raw_writel(MLB150_MADR_WNR | MLB150_MADR_TB | dbr_addr,
-			mlb_base + MLB150_REG_MADR);
+	__raw_writel(MADR_WNR | MADR_TB | dbr_addr,
+			mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(timeout <= 0))
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		return -ETIME;
+	}
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
 	return 0;
 }
 
+static inline s32 mlb150_dev_dbr_dump(u32 addr, u32 size)
+{
+	u8 *dump_buf = NULL;
+	u8 *buf_ptr = NULL;
+	s32 i;
+
+	dump_buf = kzalloc(size, GFP_KERNEL);
+	if (!dump_buf) {
+		pr_err("can't allocate enough memory\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0, buf_ptr = dump_buf;
+			i < size; ++i, ++buf_ptr)
+		*buf_ptr = mlb150_dev_dbr_read(addr + i);
+
+	mlb150_dev_dump_hex(dump_buf, size);
+
+	kfree(dump_buf);
+
+	return 0;
+}
+#endif
+
 static s32 mlb150_dev_ctr_read(u32 ctr_offset, u32 *ctr_val)
 {
 	s32 timeout = 1000;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(ctr_offset, mlb_base + MLB150_REG_MADR);
+	__raw_writel(ctr_offset, mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(timeout <= 0)) {
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		pr_debug("mxc_mlb150: Read CTR timeout\n");
 		return -ETIME;
 	}
 
-	ctr_val[0] = __raw_readl(mlb_base + MLB150_REG_MDAT0);
-	ctr_val[1] = __raw_readl(mlb_base + MLB150_REG_MDAT1);
-	ctr_val[2] = __raw_readl(mlb_base + MLB150_REG_MDAT2);
-	ctr_val[3] = __raw_readl(mlb_base + MLB150_REG_MDAT3);
+	ctr_val[0] = __raw_readl(mlb_base + REG_MDAT0);
+	ctr_val[1] = __raw_readl(mlb_base + REG_MDAT1);
+	ctr_val[2] = __raw_readl(mlb_base + REG_MDAT2);
+	ctr_val[3] = __raw_readl(mlb_base + REG_MDAT3);
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
@@ -709,25 +716,26 @@ static s32 mlb150_dev_ctr_write(u32 ctr_offset, const u32 *ctr_val)
 
 	spin_lock_irqsave(&ctr_lock, flags);
 
-	__raw_writel(ctr_val[0], mlb_base + MLB150_REG_MDAT0);
-	__raw_writel(ctr_val[1], mlb_base + MLB150_REG_MDAT1);
-	__raw_writel(ctr_val[2], mlb_base + MLB150_REG_MDAT2);
-	__raw_writel(ctr_val[3], mlb_base + MLB150_REG_MDAT3);
+	__raw_writel(ctr_val[0], mlb_base + REG_MDAT0);
+	__raw_writel(ctr_val[1], mlb_base + REG_MDAT1);
+	__raw_writel(ctr_val[2], mlb_base + REG_MDAT2);
+	__raw_writel(ctr_val[3], mlb_base + REG_MDAT3);
 
-	__raw_writel(MLB150_MADR_WNR | ctr_offset,
-			mlb_base + MLB150_REG_MADR);
+	__raw_writel(MADR_WNR | ctr_offset,
+			mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(timeout <= 0)) {
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		pr_debug("mxc_mlb150: Write CTR timeout\n");
 		return -ETIME;
 	}
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
@@ -743,6 +751,13 @@ static s32 mlb150_dev_ctr_write(u32 ctr_offset, const u32 *ctr_val)
 				return 0;
 			else {
 				pr_debug("mxc_mlb150: ctr write failed\n");
+				pr_debug("offset: 0x%x\n", ctr_offset);
+				pr_debug("Write: 0x%x 0x%x 0x%x 0x%x\n",
+						ctr_val[3], ctr_val[2],
+						ctr_val[1], ctr_val[0]);
+				pr_debug("Read: 0x%x 0x%x 0x%x 0x%x\n",
+						ctr_rd[3], ctr_rd[2],
+						ctr_rd[1], ctr_rd[0]);
 				return -EBADE;
 			}
 		} else {
@@ -755,69 +770,88 @@ static s32 mlb150_dev_ctr_write(u32 ctr_offset, const u32 *ctr_val)
 	return 0;
 }
 
-static s32 mlb150_dev_get_adt_sts(u32 ch)
+#ifdef DEBUG
+static s32 mlb150_dev_cat_read(u32 ctr_offset, u32 ch, u16 *cat_val)
 {
-	s32 timeout = 1000;
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(MLB150_BUF_ADT_OFFSET + ch,
-			mlb_base + MLB150_REG_MADR);
-
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
-			timeout--)
-		;
+	u16 ctr_val[8] = { 0 };
 
-	if (unlikely(timeout <= 0)) {
-		pr_debug("mxc_mlb150: Read CTR timeout\n");
+	if (mlb150_dev_ctr_read(ctr_offset, (u32 *)ctr_val))
 		return -ETIME;
-	}
-
-	reg = __raw_readl(mlb_base + MLB150_REG_MDAT1);
-
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
-	spin_unlock_irqrestore(&ctr_lock, flags);
 
-#ifdef DEBUG_ADT
-	pr_debug("mxc_mlb150: Get ch %d adt sts: 0x%08x\n", ch, reg);
-#endif
+	/*
+	 * Use u16 array to get u32 array value,
+	 * need to convert
+	 * */
+	cat_val = ctr_val[ch % 8];
 
-	return reg;
+	 return 0;
 }
+#endif
 
 static s32 mlb150_dev_cat_write(u32 ctr_offset, u32 ch, const u16 cat_val)
 {
 	u16 ctr_val[8] = { 0 };
 
-	if (unlikely(mlb150_dev_ctr_read(ctr_offset, (u32 *)ctr_val)))
+	if (mlb150_dev_ctr_read(ctr_offset, (u32 *)ctr_val))
 		return -ETIME;
 
 	ctr_val[ch % 8] = cat_val;
-	if (unlikely(mlb150_dev_ctr_write(ctr_offset, (u32 *)ctr_val)))
+	if (mlb150_dev_ctr_write(ctr_offset, (u32 *)ctr_val))
 		return -ETIME;
 
 	return 0;
 }
 
 #define mlb150_dev_cat_mlb_read(ch, cat_val)	\
-	mlb150_dev_cat_read(MLB150_BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_read(BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
 #define mlb150_dev_cat_mlb_write(ch, cat_val)	\
-	mlb150_dev_cat_write(MLB150_BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_write(BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
 #define mlb150_dev_cat_hbi_read(ch, cat_val)	\
-	mlb150_dev_cat_read(MLB150_BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_read(BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
 #define mlb150_dev_cat_hbi_write(ch, cat_val)	\
-	mlb150_dev_cat_write(MLB150_BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_write(BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
 
 #define mlb150_dev_cdt_read(ch, cdt_val)	\
-	mlb150_dev_ctr_read(MLB150_BUF_CDT_OFFSET + ch, cdt_val)
+	mlb150_dev_ctr_read(BUF_CDT_OFFSET + ch, cdt_val)
 #define mlb150_dev_cdt_write(ch, cdt_val)	\
-	mlb150_dev_ctr_write(MLB150_BUF_CDT_OFFSET + ch, cdt_val)
+	mlb150_dev_ctr_write(BUF_CDT_OFFSET + ch, cdt_val)
 #define mlb150_dev_adt_read(ch, adt_val)	\
-	mlb150_dev_ctr_read(MLB150_BUF_ADT_OFFSET + ch, adt_val)
+	mlb150_dev_ctr_read(BUF_ADT_OFFSET + ch, adt_val)
 #define mlb150_dev_adt_write(ch, adt_val)	\
-	mlb150_dev_ctr_write(MLB150_BUF_ADT_OFFSET + ch, adt_val)
+	mlb150_dev_ctr_write(BUF_ADT_OFFSET + ch, adt_val)
+
+static s32 mlb150_dev_get_adt_sts(u32 ch)
+{
+	s32 timeout = 1000;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&ctr_lock, flags);
+	__raw_writel(BUF_ADT_OFFSET + ch,
+			mlb_base + REG_MADR);
+
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
+			timeout--)
+		;
+
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
+		pr_debug("mxc_mlb150: Read CTR timeout\n");
+		return -ETIME;
+	}
+
+	reg = __raw_readl(mlb_base + REG_MDAT1);
+
+	__raw_writel(0, mlb_base + REG_MCTL);
+	spin_unlock_irqrestore(&ctr_lock, flags);
+
+#ifdef DEBUG_ADT
+	pr_debug("mxc_mlb150: Get ch %d adt sts: 0x%08x\n", ch, reg);
+#endif
+
+	return reg;
+}
 
 #ifdef DEBUG
 static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
@@ -826,8 +860,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	u32 ctr_val[4] = { 0 };
 
 	pr_debug("mxc_mlb150: CDT Table");
-	for (i = MLB150_BUF_CDT_OFFSET + ch_start;
-			i < MLB150_BUF_CDT_OFFSET + ch_end;
+	for (i = BUF_CDT_OFFSET + ch_start;
+			i < BUF_CDT_OFFSET + ch_end;
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -835,8 +869,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	}
 
 	pr_debug("mxc_mlb150: ADT Table");
-	for (i = MLB150_BUF_ADT_OFFSET + ch_start;
-			i < MLB150_BUF_ADT_OFFSET + ch_end;
+	for (i = BUF_ADT_OFFSET + ch_start;
+			i < BUF_ADT_OFFSET + ch_end;
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -844,8 +878,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	}
 
 	pr_debug("mxc_mlb150: CAT MLB Table");
-	for (i = MLB150_BUF_CAT_MLB_OFFSET + (ch_start >> 3);
-			i < MLB150_BUF_CAT_MLB_OFFSET + (ch_end >> 3) + 1;
+	for (i = BUF_CAT_MLB_OFFSET + (ch_start >> 3);
+			i <= BUF_CAT_MLB_OFFSET + ((ch_end + 8) >> 3);
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -853,8 +887,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	}
 
 	pr_debug("mxc_mlb150: CAT HBI Table");
-	for (i = MLB150_BUF_CAT_HBI_OFFSET + (ch_start >> 3);
-			i < MLB150_BUF_CAT_HBI_OFFSET + (ch_end >> 3) + 1;
+	for (i = BUF_CAT_HBI_OFFSET + (ch_start >> 3);
+			i <= BUF_CAT_HBI_OFFSET + ((ch_end + 8) >> 3);
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -868,12 +902,25 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
  */
 static inline s32 mlb150_dev_enable_dma_irq(u32 enable)
 {
+	u32 ch_rx_mask = (1 << SYNC_RX_CL_AHB0) | (1 << CTRL_RX_CL_AHB0)
+			| (1 << ASYNC_RX_CL_AHB0) | (1 << ISOC_RX_CL_AHB0)
+			| (1 << SYNC_TX_CL_AHB0) | (1 << CTRL_TX_CL_AHB0)
+			| (1 << ASYNC_TX_CL_AHB0) | (1 << ISOC_TX_CL_AHB0);
+	u32 ch_tx_mask = (1 << (SYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (SYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_TX_CL_AHB1 - INT_AHB1_CH_START));
+
 	if (enable) {
-		__raw_writel(0xffffffff, mlb_base + MLB150_REG_ACMR0);
-		__raw_writel(0xffffffff, mlb_base + MLB150_REG_ACMR1);
+		__raw_writel(ch_rx_mask, mlb_base + REG_ACMR0);
+		__raw_writel(ch_tx_mask, mlb_base + REG_ACMR1);
 	} else {
-		__raw_writel(0x0, mlb_base + MLB150_REG_ACMR0);
-		__raw_writel(0x0, mlb_base + MLB150_REG_ACMR1);
+		__raw_writel(0x0, mlb_base + REG_ACMR0);
+		__raw_writel(0x0, mlb_base + REG_ACMR1);
 	}
 
 	return 0;
@@ -892,10 +939,10 @@ static s32 mlb150_dev_init_ir_amba_ahb(void)
 	 * ACTL.SCE = 0, hardware clears on read
 	 * ACTL.SCE = 1, software writes a '1' to clear */
 	/* We only support DMA MODE 1 */
-	reg = __raw_readl(mlb_base + MLB150_REG_ACTL);
-	reg |= MLB150_ACTL_DMAMODE;
-#ifdef MLB150_MULTIPLE_PACKAGE_MODE
-	reg |= MLB150_REG_ACTL_MPB;
+	reg = __raw_readl(mlb_base + REG_ACTL);
+	reg |= ACTL_DMAMODE;
+#ifdef MULTIPLE_PACKAGE_MODE
+	reg |= REG_ACTL_MPB;
 #endif
 
 	/* Step 3. Select 1 or 2 interrupt signals:
@@ -903,11 +950,9 @@ static s32 mlb150_dev_init_ir_amba_ahb(void)
 	 *	and another interrupt for channels 32 - 63 on ahb_init[1]
 	 * ACTL.SMX = 1: singel interrupt all channels on ahb_init[0]
 	 * */
-	/*
-	reg |= MLB150_ACTL_SMX;
-	*/
+	reg &= ~ACTL_SMX;
 
-	__raw_writel(reg, mlb_base + MLB150_REG_ACTL);
+	__raw_writel(reg, mlb_base + REG_ACTL);
 
 	return 0;
 }
@@ -916,155 +961,111 @@ static inline s32 mlb150_dev_enable_ir_mlb(u32 enable)
 {
 	/* Step 1, Select the MSn to be cleared by software,
 	 * writing a '0' to the appropriate bits */
-	__raw_writel(0, mlb_base + MLB150_REG_MS0);
-	__raw_writel(0, mlb_base + MLB150_REG_MS1);
+	__raw_writel(0, mlb_base + REG_MS0);
+	__raw_writel(0, mlb_base + REG_MS1);
 
 	/* Step 1, Program MIEN to enable protocol error
 	 * interrupts for all active MLB channels */
 	if (enable)
-		__raw_writel(MLB150_MIEN_CTX_PE |
-			MLB150_MIEN_CRX_PE | MLB150_MIEN_ATX_PE |
-			MLB150_MIEN_ARX_PE | MLB150_MIEN_SYNC_PE |
-			MLB150_MIEN_ISOC_PE,
-			mlb_base + MLB150_REG_MIEN);
+		__raw_writel(MIEN_CTX_PE |
+			MIEN_CRX_PE | MIEN_ATX_PE |
+			MIEN_ARX_PE | MIEN_SYNC_PE |
+			MIEN_ISOC_PE,
+			mlb_base + REG_MIEN);
 	else
-		__raw_writel(0, mlb_base + MLB150_REG_MIEN);
+		__raw_writel(0, mlb_base + REG_MIEN);
 
 	return 0;
 }
 
-static inline int mlb150_enable_pll(void)
+static inline int mlb150_enable_pll(struct mlb_data *drvdata)
 {
 	u32 c0_val;
 
-	__raw_writel(MLB150_MLBPC1_VAL,
-			mlb_base + MLB150_REG_MLBPC1);
+	__raw_writel(MLBPC1_VAL,
+			drvdata->membase + REG_MLBPC1);
 
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-	if (c0_val & MLB150_MLBC0_MLBPEN) {
-		c0_val &= ~MLB150_MLBC0_MLBPEN;
+	c0_val = __raw_readl(drvdata->membase + REG_MLBC0);
+	if (c0_val & MLBC0_MLBPEN) {
+		c0_val &= ~MLBC0_MLBPEN;
 		__raw_writel(c0_val,
-				mlb_base + MLB150_REG_MLBC0);
+				drvdata->membase + REG_MLBC0);
 	}
 
-	clk_enable(mlb_pll_clk);
+	clk_enable(drvdata->clk_mlb6p);
 
-	c0_val |= (MLB150_MLBC0_MLBPEN);
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
+	c0_val |= (MLBC0_MLBPEN);
+	__raw_writel(c0_val, drvdata->membase + REG_MLBC0);
 
 	return 0;
 }
 
-static inline int mlb150_disable_pll(void)
+static inline int mlb150_disable_pll(struct mlb_data *drvdata)
 {
 	u32 c0_val;
 
-	clk_disable(mlb_pll_clk);
+	clk_disable(drvdata->clk_mlb6p);
 
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
+	c0_val = __raw_readl(drvdata->membase + REG_MLBC0);
 
-	__raw_writel(0x0, mlb_base + MLB150_REG_MLBPC1);
+	__raw_writel(0x0, drvdata->membase + REG_MLBPC1);
 
-	c0_val &= ~MLB150_MLBC0_MLBPEN;
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
+	c0_val &= ~MLBC0_MLBPEN;
+	__raw_writel(c0_val, drvdata->membase + REG_MLBC0);
 
 	return 0;
 }
 
-static void mlb150_dev_init(void)
-{
-	u32 c0_val, hctl_val;
-
-	/* Disable EN bits */
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-	c0_val &= ~MLB150_MLBC0_MLBEN;
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
-
-	hctl_val = __raw_readl(mlb_base + MLB150_REG_HCTL);
-	hctl_val &= ~MLB150_HCTL_EN;
-	__raw_writel(hctl_val, mlb_base + MLB150_REG_HCTL);
-
-	/* Step 1, Configure the MediaLB interface */
-	/* Select pin mode and clock, 3-pin and 256fs */
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-	c0_val &= ~(MLB150_MLBC0_MLBPEN | MLB150_MLBC0_MLBCLK_MASK);
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
-
-	c0_val |= MLB150_MLBC0_MLBEN;
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
-
-	/* Step 2, Configure the HBI interface */
-	__raw_writel(0xffffffff, mlb_base + MLB150_REG_HCMR0);
-	__raw_writel(0xffffffff, mlb_base + MLB150_REG_HCMR1);
-	__raw_writel(MLB150_HCTL_EN, mlb_base + MLB150_REG_HCTL);
-
-	mlb150_dev_init_ir_amba_ahb();
-
-	mlb150_dev_enable_ir_mlb(1);
-}
-
 static s32 mlb150_dev_reset_cdt(void)
 {
 	int i = 0;
 	u32 ctr_val[4] = { 0 };
 
-	for (i = 0; i < (MLB150_LOGIC_CH_NUM); ++i)
-		mlb150_dev_ctr_write(MLB150_BUF_CDT_OFFSET + i, ctr_val);
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+
+	for (i = 0; i < (LOGIC_CH_NUM); ++i)
+		mlb150_dev_ctr_write(BUF_CDT_OFFSET + i, ctr_val);
 
 	return 0;
 }
 
-static s32 mlb150_dev_init_ch_cdt(u32 ch, enum MLB_CTYPE ctype, u32 ch_func)
+static s32 mlb150_dev_init_ch_cdt(struct mlb_dev_info *pdevinfo, u32 ch,
+		enum MLB_CTYPE ctype, u32 ch_func)
 {
 	u32 cdt_val[4] = { 0 };
 
 	/* a. Set the 14-bit base address (BA) */
 	pr_debug("mxc_mlb150: ctype: %d, ch: %d, dbr_buf_head: 0x%08x",
-		ctype, ch, mlb_devinfo[ctype].channels[ch_func].dbr_buf_head);
-	cdt_val[3] = (mlb_devinfo[ctype].channels[ch_func].dbr_buf_head)
+		ctype, ch, pdevinfo->channels[ch_func].dbr_buf_head);
+	cdt_val[3] = (pdevinfo->channels[ch_func].dbr_buf_head)
 			<< CDT_BA_SHIFT;
 
 	/* b. Set the 12-bit or 13-bit buffer depth (BD)
 	 * BD = buffer depth in bytes - 1 */
-	switch (ctype) {
-	case MLB_CTYPE_SYNC:
-		/* For synchronous channels: (BD + 1) = 4 * m * bpf */
-		cdt_val[3] |= (MLB150_CH_SYNC_BUF_DEP - 1) << CDT_BD_SHIFT;
-		break;
-	case MLB_CTYPE_CTRL:
-		/* For control channels: (BD + 1) >= max packet length (64) */
-		/* BD */
-		cdt_val[3] |= ((MLB150_CH_CTRL_BUF_DEP - 1) << CDT_BD_SHIFT);
-		break;
-	case MLB_CTYPE_ASYNC:
-		/* For asynchronous channels: (BD + 1) >= max packet length
-		 * 1024 for a MOST Data packet (MDP);
-		 * 1536 for a MOST Ethernet Packet (MEP) */
-		cdt_val[3] |= ((MLB150_CH_ASYNC_BUF_DEP - 1) << CDT_BD_SHIFT);
-		break;
-	case MLB_CTYPE_ISOC:
-		/* For isochronous channels: (BD + 1) mod (BS + 1) = 0 */
-		/* BS */
-		cdt_val[1] |= (MLB150_CH_ISOC_BLK_SIZE - 1);
-		/* BD */
-		cdt_val[3] |= (MLB150_CH_ISOC_BUF_DEP - 1)
-				<< CDT_BD_SHIFT;
-		break;
-	default:
-		break;
-	}
+	/* For synchronous channels: (BD + 1) = 4 * m * bpf */
+	/* For control channels: (BD + 1) >= max packet length (64) */
+	/* For asynchronous channels: (BD + 1) >= max packet length
+	 * 1024 for a MOST Data packet (MDP);
+	 * 1536 for a MOST Ethernet Packet (MEP) */
+	/* For isochronous channels: (BD + 1) mod (BS + 1) = 0 */
+	/* BS */
+	if (MLB_CTYPE_ISOC == ctype)
+		cdt_val[1] |= (pdevinfo->isoc_blksz - 1);
+	/* BD */
+	cdt_val[3] |= (pdevinfo->cdt_buf_dep - 1) << CDT_BD_SHIFT;
 
 	pr_debug("mxc_mlb150: Set CDT val of channel %d, type: %d: "
 		"0x%08x 0x%08x 0x%08x 0x%08x\n",
 		ch, ctype, cdt_val[3], cdt_val[2], cdt_val[1], cdt_val[0]);
 
-	if (unlikely(mlb150_dev_cdt_write(ch, cdt_val)))
+	if (mlb150_dev_cdt_write(ch, cdt_val))
 		return -ETIME;
 
 #ifdef DEBUG_CTR
 	{
 		u32 cdt_rd[4] = { 0 };
-		if (likely(!mlb150_dev_cdt_read(ch, cdt_rd))) {
+		if (!mlb150_dev_cdt_read(ch, cdt_rd)) {
 			pr_debug("mxc_mlb150: CDT val of channel %d: "
 				"0x%08x 0x%08x 0x%08x 0x%08x\n",
 				ch, cdt_rd[3], cdt_rd[2], cdt_rd[1], cdt_rd[0]);
@@ -1089,31 +1090,32 @@ static s32 mlb150_dev_init_ch_cdt(u32 ch, enum MLB_CTYPE ctype, u32 ch_func)
 	return 0;
 }
 
-static s32 mlb150_dev_init_ch_cat(u32 ch, u32 cat_mode, enum MLB_CTYPE ctype)
+static s32 mlb150_dev_init_ch_cat(u32 ch, u32 cl,
+		u32 cat_mode, enum MLB_CTYPE ctype)
 {
 	u16 cat_val = 0;
 #ifdef DEBUG_CTR
 	u16 cat_rd = 0;
 #endif
 
-	cat_val = CAT_CE | (ctype << CAT_CT_SHIFT) | ch;
+	cat_val = CAT_CE | (ctype << CAT_CT_SHIFT) | cl;
 
-	if (cat_mode & MLB150_CAT_MODE_OUTBOUND_DMA)
+	if (cat_mode & CAT_MODE_OUTBOUND_DMA)
 		cat_val |= CAT_RNW;
 
 	if (MLB_CTYPE_SYNC == ctype)
 		cat_val |= CAT_MT;
 
-	pr_debug("mxc_mlb150: set CAT val of channel %d, type: %d: 0x%04x\n",
+	switch (cat_mode) {
+	case CAT_MODE_RX | CAT_MODE_INBOUND_DMA:
+	case CAT_MODE_TX | CAT_MODE_OUTBOUND_DMA:
+		pr_debug("mxc_mlb150: set CAT val of channel %d, type: %d: 0x%04x\n",
 			ch, ctype, cat_val);
 
-	switch (cat_mode) {
-	case MLB150_CAT_MODE_RX | MLB150_CAT_MODE_INBOUND_DMA:
-	case MLB150_CAT_MODE_TX | MLB150_CAT_MODE_OUTBOUND_DMA:
-		if (unlikely(mlb150_dev_cat_mlb_write(ch, cat_val)))
+		if (mlb150_dev_cat_mlb_write(ch, cat_val))
 			return -ETIME;
 #ifdef DEBUG_CTR
-		if (likely(!mlb150_dev_cat_mlb_read(ch, &cat_rd)))
+		if (!mlb150_dev_cat_mlb_read(ch, &cat_rd))
 			pr_debug("mxc_mlb150: CAT val of mlb channel %d: 0x%04x",
 					ch, cat_rd);
 		else {
@@ -1123,17 +1125,20 @@ static s32 mlb150_dev_init_ch_cat(u32 ch, u32 cat_mode, enum MLB_CTYPE ctype)
 		}
 #endif
 		break;
-	case MLB150_CAT_MODE_TX | MLB150_CAT_MODE_INBOUND_DMA:
-	case MLB150_CAT_MODE_RX | MLB150_CAT_MODE_OUTBOUND_DMA:
-		if (unlikely(mlb150_dev_cat_hbi_write(ch, cat_val)))
+	case CAT_MODE_TX | CAT_MODE_INBOUND_DMA:
+	case CAT_MODE_RX | CAT_MODE_OUTBOUND_DMA:
+		pr_debug("mxc_mlb150: set CAT val of channel %d, type: %d: 0x%04x\n",
+			cl, ctype, cat_val);
+
+		if (mlb150_dev_cat_hbi_write(cl, cat_val))
 			return -ETIME;
 #ifdef DEBUG_CTR
-		if (likely(!mlb150_dev_cat_hbi_read(ch, &cat_rd)))
+		if (!mlb150_dev_cat_hbi_read(cl, &cat_rd))
 			pr_debug("mxc_mlb150: CAT val of hbi channel %d: 0x%04x",
-					ch, cat_rd);
+					cl, cat_rd);
 		else {
 			pr_debug("mxc_mlb150: Read CAT of hbi channel %d failed\n",
-					ch);
+					cl);
 				return -EBADE;
 		}
 #endif
@@ -1161,37 +1166,43 @@ static s32 mlb150_dev_reset_cat(void)
 	int i = 0;
 	u32 ctr_val[4] = { 0 };
 
-	for (i = 0; i < (MLB150_LOGIC_CH_NUM >> 3); ++i) {
-		mlb150_dev_ctr_write(MLB150_BUF_CAT_MLB_OFFSET + i, ctr_val);
-		mlb150_dev_ctr_write(MLB150_BUF_CAT_HBI_OFFSET + i, ctr_val);
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+
+	for (i = 0; i < (LOGIC_CH_NUM >> 3); ++i) {
+		mlb150_dev_ctr_write(BUF_CAT_MLB_OFFSET + i, ctr_val);
+		mlb150_dev_ctr_write(BUF_CAT_HBI_OFFSET + i, ctr_val);
 	}
 
 	return 0;
 }
 
-static s32 mlb150_dev_init_rfb(u32 rx_ch, u32 tx_ch, enum MLB_CTYPE ctype)
+static s32 mlb150_dev_init_rfb(struct mlb_dev_info *pdevinfo, u32 rx_ch,
+		u32 tx_ch, enum MLB_CTYPE ctype)
 {
+	u32 rx_cl = pdevinfo->channels[RX_CHANNEL].cl;
+	u32 tx_cl = pdevinfo->channels[TX_CHANNEL].cl;
 	/* Step 1, Initialize all bits of CAT to '0' */
 	mlb150_dev_reset_cat();
 	mlb150_dev_reset_cdt();
 
 	/* Step 2, Initialize logical channel */
 	/* Step 3, Program the CDT for channel N */
-	mlb150_dev_init_ch_cdt(rx_ch, ctype, RX_CHANNEL);
-	mlb150_dev_init_ch_cdt(tx_ch, ctype, TX_CHANNEL);
+	mlb150_dev_init_ch_cdt(pdevinfo, rx_cl, ctype, RX_CHANNEL);
+	mlb150_dev_init_ch_cdt(pdevinfo, tx_cl, ctype, TX_CHANNEL);
 
 	/* Step 4&5, Program the CAT for the inbound and outbound DMA */
-	mlb150_dev_init_ch_cat(rx_ch,
-			MLB150_CAT_MODE_RX | MLB150_CAT_MODE_INBOUND_DMA,
+	mlb150_dev_init_ch_cat(rx_ch, rx_cl,
+			CAT_MODE_RX | CAT_MODE_INBOUND_DMA,
 			ctype);
-	mlb150_dev_init_ch_cat(rx_ch,
-			MLB150_CAT_MODE_RX | MLB150_CAT_MODE_OUTBOUND_DMA,
+	mlb150_dev_init_ch_cat(rx_ch, rx_cl,
+			CAT_MODE_RX | CAT_MODE_OUTBOUND_DMA,
 			ctype);
-	mlb150_dev_init_ch_cat(tx_ch,
-			MLB150_CAT_MODE_TX | MLB150_CAT_MODE_INBOUND_DMA,
+	mlb150_dev_init_ch_cat(tx_ch, tx_cl,
+			CAT_MODE_TX | CAT_MODE_INBOUND_DMA,
 			ctype);
-	mlb150_dev_init_ch_cat(tx_ch,
-			MLB150_CAT_MODE_TX | MLB150_CAT_MODE_OUTBOUND_DMA,
+	mlb150_dev_init_ch_cat(tx_ch, tx_cl,
+			CAT_MODE_TX | CAT_MODE_OUTBOUND_DMA,
 			ctype);
 
 	return 0;
@@ -1202,14 +1213,82 @@ static s32 mlb150_dev_reset_adt(void)
 	int i = 0;
 	u32 ctr_val[4] = { 0 };
 
-	for (i = 0; i < (MLB150_LOGIC_CH_NUM); ++i)
-		mlb150_dev_ctr_write(MLB150_BUF_ADT_OFFSET + i, ctr_val);
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+
+	for (i = 0; i < (LOGIC_CH_NUM); ++i)
+		mlb150_dev_ctr_write(BUF_ADT_OFFSET + i, ctr_val);
+
+	return 0;
+}
+
+static s32 mlb150_dev_reset_whole_ctr(void)
+{
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+	mlb150_dev_reset_cdt();
+	mlb150_dev_reset_adt();
+	mlb150_dev_reset_cat();
+
+	return 0;
+}
+
+#define CLR_REG(reg)  __raw_writel(0x0, mlb_base + reg)
+
+static s32 mlb150_dev_reset_all_regs(void)
+{
+	CLR_REG(REG_MLBC0);
+	CLR_REG(REG_MLBPC0);
+	CLR_REG(REG_MS0);
+	CLR_REG(REG_MS1);
+	CLR_REG(REG_MSS);
+	CLR_REG(REG_MSD);
+	CLR_REG(REG_MIEN);
+	CLR_REG(REG_MLBPC2);
+	CLR_REG(REG_MLBPC1);
+	CLR_REG(REG_MLBC1);
+	CLR_REG(REG_HCTL);
+	CLR_REG(REG_HCMR0);
+	CLR_REG(REG_HCMR1);
+	CLR_REG(REG_HCER0);
+	CLR_REG(REG_HCER1);
+	CLR_REG(REG_HCBR0);
+	CLR_REG(REG_HCBR1);
+	CLR_REG(REG_MDAT0);
+	CLR_REG(REG_MDAT1);
+	CLR_REG(REG_MDAT2);
+	CLR_REG(REG_MDAT3);
+	CLR_REG(REG_MDWE0);
+	CLR_REG(REG_MDWE1);
+	CLR_REG(REG_MDWE2);
+	CLR_REG(REG_MDWE3);
+	CLR_REG(REG_MCTL);
+	CLR_REG(REG_MADR);
+	CLR_REG(REG_ACTL);
+	CLR_REG(REG_ACSR0);
+	CLR_REG(REG_ACSR1);
+	CLR_REG(REG_ACMR0);
+	CLR_REG(REG_ACMR1);
 
 	return 0;
 }
 
-static inline s32 mlb150_dev_set_ch_amba_ahb(u32 ch, enum MLB_CTYPE ctype,
-					u32 dne_sts, u32 buf_addr)
+static inline s32 mlb150_dev_pipo_start(struct mlb_ringbuf *rbuf,
+						u32 ahb_ch, u32 buf_addr)
+{
+	u32 ctr_val[4] = { 0 };
+
+	ctr_val[1] |= ADT_RDY1;
+	ctr_val[2] = buf_addr;
+
+	if (mlb150_dev_adt_write(ahb_ch, ctr_val))
+		return -ETIME;
+
+	return 0;
+}
+
+static inline s32 mlb150_dev_pipo_next(u32 ahb_ch, enum MLB_CTYPE ctype,
+				u32 dne_sts, u32 buf_addr)
 {
 	u32 ctr_val[4] = { 0 };
 
@@ -1229,54 +1308,38 @@ static inline s32 mlb150_dev_set_ch_amba_ahb(u32 ch, enum MLB_CTYPE ctype,
 		ctr_val[2] = buf_addr;
 	}
 
-#ifdef DEBUG_ADT
-	pr_debug("mxc_mlb150: Set ADT val of channel %d, ctype: %d: "
-		"0x%08x 0x%08x 0x%08x 0x%08x\n",
-		ch, ctype, ctr_val[3], ctr_val[2], ctr_val[1], ctr_val[0]);
-#endif
-
-	if (unlikely(mlb150_dev_adt_write(ch, ctr_val)))
+	if (mlb150_dev_adt_write(ahb_ch, ctr_val))
 		return -ETIME;
 
-#ifdef DEBUG_ADT_N
-	{
-		u32 ctr_rd[4] = { 0 };
-		if (likely(!mlb150_dev_adt_read(ch, ctr_rd))) {
-			pr_debug("mxc_mlb150: ADT val of channel %d: "
-				"0x%08x 0x%08x 0x%08x 0x%08x\n",
-				ch, ctr_rd[3], ctr_rd[2],
-				ctr_rd[1], ctr_rd[0]);
-			if (ctr_rd[3] == ctr_val[3] &&
-				ctr_rd[2] == ctr_val[2] &&
-				ctr_rd[1] == ctr_val[1] &&
-				ctr_rd[0] == ctr_val[0]) {
-				pr_debug("mxc_mlb150: set adt succeed!\n");
-				return 0;
-			} else {
-				pr_debug("mxc_mlb150: set adt failed!\n");
-				return -EBADE;
-			}
-		} else {
-			pr_debug("mxc_mlb150: Read ADT val of channel %d failed\n",
-					ch);
-			return -EBADE;
-		}
-	}
-#endif
+	return 0;
+}
+
+static inline s32 mlb150_dev_pipo_stop(struct mlb_ringbuf *rbuf, u32 ahb_ch)
+{
+	u32 ctr_val[4] = { 0 };
+	unsigned long flags;
+
+	write_lock_irqsave(&rbuf->rb_lock, flags);
+	rbuf->head = rbuf->tail = 0;
+	write_unlock_irqrestore(&rbuf->rb_lock, flags);
 
-      return 0;
+	if (mlb150_dev_adt_write(ahb_ch, ctr_val))
+		return -ETIME;
+
+	return 0;
 }
 
-static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
+static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_dev_info *pdevinfo,
+					struct mlb_channel_info *chinfo,
 					enum MLB_CTYPE ctype)
 {
 	u32 ctr_val[4] = { 0 };
 
 	/* a. Set the 32-bit base address (BA1) */
-	ctr_val[3] = chinfo->pong_phy_head;
-	ctr_val[2] = chinfo->ping_phy_head;
-	ctr_val[1] = (chinfo->buf_size - 1) << ADT_BD1_SHIFT;
-	ctr_val[1] |= (chinfo->buf_size - 1) << ADT_BD2_SHIFT;
+	ctr_val[3] = 0;
+	ctr_val[2] = 0;
+	ctr_val[1] = (pdevinfo->adt_buf_dep - 1) << ADT_BD1_SHIFT;
+	ctr_val[1] |= (pdevinfo->adt_buf_dep - 1) << ADT_BD2_SHIFT;
 	if (MLB_CTYPE_ASYNC == ctype ||
 		MLB_CTYPE_CTRL == ctype) {
 		ctr_val[1] |= ADT_PS1;
@@ -1287,19 +1350,19 @@ static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
 
 	pr_debug("mxc_mlb150: Set ADT val of channel %d, ctype: %d: "
 		"0x%08x 0x%08x 0x%08x 0x%08x\n",
-		chinfo->address, ctype, ctr_val[3], ctr_val[2],
+		chinfo->cl, ctype, ctr_val[3], ctr_val[2],
 		ctr_val[1], ctr_val[0]);
 
-	if (unlikely(mlb150_dev_adt_write(chinfo->address, ctr_val)))
+	if (mlb150_dev_adt_write(chinfo->cl, ctr_val))
 		return -ETIME;
 
 #ifdef DEBUG_CTR
 	{
 		u32 ctr_rd[4] = { 0 };
-		if (likely(!mlb150_dev_adt_read(chinfo->address, ctr_rd))) {
+		if (!mlb150_dev_adt_read(chinfo->cl, ctr_rd)) {
 			pr_debug("mxc_mlb150: ADT val of channel %d: "
 				"0x%08x 0x%08x 0x%08x 0x%08x\n",
-				chinfo->address, ctr_rd[3], ctr_rd[2],
+				chinfo->cl, ctr_rd[3], ctr_rd[2],
 				ctr_rd[1], ctr_rd[0]);
 			if (ctr_rd[3] == ctr_val[3] &&
 				ctr_rd[2] == ctr_val[2] &&
@@ -1313,7 +1376,7 @@ static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
 			}
 		} else {
 			pr_debug("mxc_mlb150: Read ADT val of channel %d failed\n",
-					chinfo->address);
+					chinfo->cl);
 			return -EBADE;
 		}
 	}
@@ -1322,263 +1385,364 @@ static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
 	return 0;
 }
 
-static s32 mlb150_dev_init_amba_ahb(struct mlb_channel_info *rx_chinfo,
-		struct mlb_channel_info *tx_chinfo, enum MLB_CTYPE ctype)
+static s32 mlb150_dev_init_amba_ahb(struct mlb_dev_info *pdevinfo,
+					enum MLB_CTYPE ctype)
 {
+	struct mlb_channel_info *tx_chinfo = &pdevinfo->channels[TX_CHANNEL];
+	struct mlb_channel_info *rx_chinfo = &pdevinfo->channels[RX_CHANNEL];
+
 	/* Step 1, Initialize all bits of the ADT to '0' */
 	mlb150_dev_reset_adt();
 
 	/* Step 2, Select a logic channel */
 	/* Step 3, Program the AMBA AHB block ping page for channel N */
 	/* Step 4, Program the AMBA AHB block pong page for channel N */
-	mlb150_dev_init_ch_amba_ahb(rx_chinfo, ctype);
-	mlb150_dev_init_ch_amba_ahb(tx_chinfo, ctype);
+	mlb150_dev_init_ch_amba_ahb(pdevinfo, rx_chinfo, ctype);
+	mlb150_dev_init_ch_amba_ahb(pdevinfo, tx_chinfo, ctype);
 
 	return 0;
 }
 
-static s32 mlb150_dev_unmute_syn_ch(u32 rx_ch, u32 tx_ch)
+static void mlb150_dev_exit(void)
+{
+	u32 c0_val, hctl_val;
+
+	/* Disable EN bits */
+	c0_val = __raw_readl(mlb_base + REG_MLBC0);
+	c0_val &= ~(MLBC0_MLBEN | MLBC0_MLBPEN);
+	__raw_writel(c0_val, mlb_base + REG_MLBC0);
+
+	hctl_val = __raw_readl(mlb_base + REG_HCTL);
+	hctl_val &= ~HCTL_EN;
+	__raw_writel(hctl_val, mlb_base + REG_HCTL);
+
+	__raw_writel(0x0, mlb_base + REG_HCMR0);
+	__raw_writel(0x0, mlb_base + REG_HCMR1);
+
+	mlb150_dev_enable_dma_irq(0);
+	mlb150_dev_enable_ir_mlb(0);
+}
+
+static void mlb150_dev_init(void)
+{
+	u32 c0_val;
+	u32 ch_rx_mask = (1 << SYNC_RX_CL_AHB0) | (1 << CTRL_RX_CL_AHB0)
+			| (1 << ASYNC_RX_CL_AHB0) | (1 << ISOC_RX_CL_AHB0)
+			| (1 << SYNC_TX_CL_AHB0) | (1 << CTRL_TX_CL_AHB0)
+			| (1 << ASYNC_TX_CL_AHB0) | (1 << ISOC_TX_CL_AHB0);
+	u32 ch_tx_mask = (1 << (SYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (SYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_TX_CL_AHB1 - INT_AHB1_CH_START));
+
+	/* Disable EN bits */
+	mlb150_dev_exit();
+
+	/* Step 1. Initialize CTR and registers
+	 * a. Set all bit of the CTR (CAT, CDT, and ADT) to 0. */
+	mlb150_dev_reset_whole_ctr();
+
+	/* a. Set all bit of the CTR (CAT, CDT, and ADT) to 0. */
+	mlb150_dev_reset_all_regs();
+
+	/* Step 2, Configure the MediaLB interface */
+	/* Select pin mode and clock, 3-pin and 256fs */
+	c0_val = __raw_readl(mlb_base + REG_MLBC0);
+	c0_val &= ~(MLBC0_MLBPEN | MLBC0_MLBCLK_MASK);
+	__raw_writel(c0_val, mlb_base + REG_MLBC0);
+
+	c0_val |= MLBC0_MLBEN;
+	__raw_writel(c0_val, mlb_base + REG_MLBC0);
+
+	/* Step 3, Configure the HBI interface */
+	__raw_writel(ch_rx_mask, mlb_base + REG_HCMR0);
+	__raw_writel(ch_tx_mask, mlb_base + REG_HCMR1);
+	__raw_writel(HCTL_EN, mlb_base + REG_HCTL);
+
+	mlb150_dev_init_ir_amba_ahb();
+
+	mlb150_dev_enable_ir_mlb(1);
+}
+
+static s32 mlb150_dev_unmute_syn_ch(u32 rx_ch, u32 rx_cl, u32 tx_ch, u32 tx_cl)
 {
 	u32 timeout = 10000;
 
 	/* Check that MediaLB clock is running (MLBC1.CLKM = 0)
 	 * If MLBC1.CLKM = 1, clear the register bit, wait one
 	 * APB or I/O clock cycle and repeat the check */
-	while ((__raw_readl(mlb_base + MLB150_REG_MLBC1) & MLB150_MLBC1_CLKM)
+	while ((__raw_readl(mlb_base + REG_MLBC1) & MLBC1_CLKM)
 			|| timeout--)
-		__raw_writel(~MLB150_MLBC1_CLKM, mlb_base + MLB150_REG_MLBC1);
+		__raw_writel(~MLBC1_CLKM, mlb_base + REG_MLBC1);
 
-	if (unlikely(0 == timeout))
+	if (0 == timeout)
 		return -ETIME;
 
 	timeout = 10000;
 	/* Poll for MLB lock (MLBC0.MLBLK = 1) */
-	while (!(__raw_readl(mlb_base + MLB150_REG_MLBC0) & MLB150_MLBC0_MLBLK)
+	while (!(__raw_readl(mlb_base + REG_MLBC0) & MLBC0_MLBLK)
 			|| timeout--)
 		;
 
-	if (unlikely(0 == timeout))
+	if (0 == timeout)
 		return -ETIME;
 
 	/* Unmute synchronous channel(s) */
-	mlb150_dev_cat_mlb_write(rx_ch, CAT_CE | rx_ch);
+	mlb150_dev_cat_mlb_write(rx_ch, CAT_CE | rx_cl);
 	mlb150_dev_cat_mlb_write(tx_ch,
-			CAT_CE | tx_ch | CAT_RNW);
-	mlb150_dev_cat_hbi_write(rx_ch,
-			CAT_CE | rx_ch | CAT_RNW);
-	mlb150_dev_cat_hbi_write(tx_ch, CAT_CE | tx_ch);
+			CAT_CE | tx_cl | CAT_RNW);
+	mlb150_dev_cat_hbi_write(rx_cl,
+			CAT_CE | rx_cl | CAT_RNW);
+	mlb150_dev_cat_hbi_write(tx_cl, CAT_CE | tx_cl);
 
 	return 0;
 }
 
-static void mlb150_dev_exit(void)
+/* In case the user calls channel shutdown, but rx or tx is not completed yet */
+static s32 mlb150_trans_complete_check(struct mlb_dev_info *pdevinfo)
 {
-	mlb150_dev_enable_dma_irq(0);
-	mlb150_dev_enable_ir_mlb(0);
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	s32 timeout = 1024;
+
+	while (timeout--) {
+		read_lock(&tx_rbuf->rb_lock);
+		if (!CIRC_CNT(tx_rbuf->head, tx_rbuf->tail, TRANS_RING_NODES)) {
+			read_unlock(&tx_rbuf->rb_lock);
+			break;
+		} else
+			read_unlock(&tx_rbuf->rb_lock);
+	}
 
-	__raw_writel(0, mlb_base + MLB150_REG_HCTL);
-	__raw_writel(0, mlb_base + MLB150_REG_MLBC0);
-}
+	if (timeout <= 0) {
+		pr_debug("TX complete check timeout!\n");
+		return -ETIME;
+	}
 
-/*!
- * MLB receive start function
- *
- * load phy_head to next buf register to start next rx
- * here use single-packet buffer, set start=end
- */
-static inline void mlb_start_rx(u32 ch, s32 ctype, u32 dne_sts, u32 buf_addr)
-{
-	/*  Set ADT for RX */
-	mlb150_dev_set_ch_amba_ahb(ch, ctype, dne_sts, buf_addr);
-}
+	timeout = 1024;
+	while (timeout--) {
+		read_lock(&rx_rbuf->rb_lock);
+		if (!CIRC_CNT(rx_rbuf->head, rx_rbuf->tail, TRANS_RING_NODES)) {
+			read_unlock(&rx_rbuf->rb_lock);
+			break;
+		} else
+			read_unlock(&rx_rbuf->rb_lock);
+	}
 
-/*!
- * MLB transmit start function
- * make sure aquiring the rw buf_lock, when calling this
- */
-static inline void mlb_start_tx(u32 ch, s32 ctype, u32 dne_sts, u32 buf_addr)
-{
-	/*  Set ADT for TX */
-	mlb150_dev_set_ch_amba_ahb(ch, ctype, dne_sts, buf_addr);
+	if (timeout <= 0) {
+		pr_debug("RX complete check timeout!\n");
+		return -ETIME;
+	}
+
+	/* Interrupt from TX can only inform that the data is sent
+	 * to AHB bus, not mean that it is sent to MITB. Thus we add
+	 * a delay here for data to be completed sent. */
+	udelay(1000);
+
+	return 0;
 }
 
 /*!
  * Enable the MLB channel
  */
-static void mlb_channel_enable(int chan_dev_id, int on)
+static void mlb_channel_enable(struct mlb_data *drvdata,
+				int chan_dev_id, int on)
 {
-	struct mlb_dev_info *pdevinfo = &mlb_devinfo[chan_dev_id];
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_channel_info *tx_chinfo = &pdevinfo->channels[TX_CHANNEL];
+	struct mlb_channel_info *rx_chinfo = &pdevinfo->channels[RX_CHANNEL];
+	u32 tx_ch = tx_chinfo->address;
+	u32 rx_ch = rx_chinfo->address;
+	u32 tx_cl = tx_chinfo->cl;
+	u32 rx_cl = rx_chinfo->cl;
+
 	/*!
 	 * setup the direction, enable, channel type,
 	 * mode select, channel address and mask buf start
 	 */
 	if (on) {
 		u32 ctype = pdevinfo->channel_type;
-		struct mlb_channel_info *tx_chinfo = &_get_txchan(chan_dev_id);
-		struct mlb_channel_info *rx_chinfo = &_get_rxchan(chan_dev_id);
-		u32 tx_ch = tx_chinfo->address;
-		u32 rx_ch = rx_chinfo->address;
 
 		mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
 				0xffffffff, 0xffffffff);
-		mlb150_dev_init_rfb(rx_ch, tx_ch, ctype);
+		mlb150_dev_init_rfb(pdevinfo, rx_ch, tx_ch, ctype);
 
-		mlb150_dev_init_amba_ahb(rx_chinfo, tx_chinfo, ctype);
+		mlb150_dev_init_amba_ahb(pdevinfo, ctype);
 
+#ifdef DEBUG
+		mlb150_dev_dump_ctr_tbl(0, tx_chinfo->cl + 1);
+#endif
 		/* Synchronize and unmute synchrouous channel */
 		if (MLB_CTYPE_SYNC == ctype)
-			mlb150_dev_unmute_syn_ch(rx_ch, tx_ch);
+			mlb150_dev_unmute_syn_ch(rx_ch, rx_cl, tx_ch, tx_cl);
 
 		mlb150_dev_enable_ctr_write(0x0, ADT_RDY1 | ADT_DNE1 |
 				ADT_ERR1 | ADT_PS1 |
-				ADT_MEP1 | ADT_RDY2 | ADT_DNE2 | ADT_ERR2 |
-				ADT_PS2 | ADT_MEP2,
+				ADT_RDY2 | ADT_DNE2 | ADT_ERR2 | ADT_PS2,
 				0xffffffff, 0xffffffff);
 
-		if (pdevinfo->fps >= MLB150_CLK_2048FS)
-			mlb150_enable_pll();
+		if (pdevinfo->fps >= CLK_2048FS)
+			mlb150_enable_pll(drvdata);
 
 		atomic_set(&pdevinfo->on, 1);
 
 #ifdef DEBUG
 		mlb150_dev_dump_reg();
-		mlb150_dev_dump_ctr_tbl(0, tx_chinfo->address + 1);
+		mlb150_dev_dump_ctr_tbl(0, tx_chinfo->cl + 1);
 #endif
-		mlb_start_rx(rx_ch, ctype, ADT_DNE2,
-				pdevinfo->rx_bufs.phy_addrs[0]);
+		/* Init RX ADT */
+		mlb150_dev_pipo_start(&pdevinfo->rx_rbuf, rx_cl,
+					pdevinfo->rx_rbuf.phy_addrs[0]);
 	} else {
+		mlb150_dev_pipo_stop(&pdevinfo->rx_rbuf, rx_cl);
+
 		mlb150_dev_enable_dma_irq(0);
 		mlb150_dev_enable_ir_mlb(0);
 
 		mlb150_dev_reset_cat();
 
-		atomic_set(&mlb_devinfo[chan_dev_id].on, 0);
+		atomic_set(&pdevinfo->on, 0);
 
-		if (mlb_devinfo[chan_dev_id].fps >= MLB150_CLK_2048FS)
-			mlb150_disable_pll();
+		if (pdevinfo->fps >= CLK_2048FS)
+			mlb150_disable_pll(drvdata);
 	}
 }
 
 /*!
  * MLB interrupt handler
  */
-static void mlb_tx_isr(int minor)
+static void mlb_rx_isr(s32 ctype, u32 ahb_ch, struct mlb_dev_info *pdevinfo)
 {
-	struct mlb_dev_info *pdevinfo = &mlb_devinfo[minor];
-
-	pdevinfo->tx_busy = 0;
-
-	wake_up_interruptible(&pdevinfo->wt_wq);
-}
-
-static void mlb_rx_isr(int minor)
-{
-	struct mlb_dev_info *pdevinfo = &mlb_devinfo[minor];
-	struct mlb_channel_info *pchinfo = &_get_rxchan(minor);
-	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_bufs;
-	s32 wpos, rpos, adt_sts;
-	u32 rx_ring_buf = 0;
-	s32 ctype = pdevinfo->channel_type;
-	u32 ch_addr = pchinfo->address;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	s32 head, tail, adt_sts;
+	unsigned long flags;
+	u32 rx_buf_ptr;
 
 #ifdef DEBUG_RX
 	pr_debug("mxc_mlb150: mlb_rx_isr\n");
 #endif
 
-	rpos = rx_rbuf->rpos;
-	wpos = rx_rbuf->wpos;
+	write_lock_irqsave(&rx_rbuf->rb_lock, flags);
 
-#ifdef DEBUG_RX
-	pr_debug("adt_buf_ptr: 0x%08x\n", (u32)adt_buf_ptr);
-#endif
+	head = (rx_rbuf->head + 1) & (TRANS_RING_NODES - 1);
+	tail = ACCESS_ONCE(rx_rbuf->tail);
 
-	/*!
-	 * Copy packet from IRAM buf to ring buf.
-	 * if the wpos++ == rpos, drop this packet
-	 */
-	if (((wpos + 1) % TRANS_RING_NODES) != rpos) {
-		rx_ring_buf = rx_rbuf->phy_addrs[(wpos + 1) % TRANS_RING_NODES];
-#ifdef DEBUG_RX
-		if (len > mlb150_ch_packet_buf_size[ctype])
-			pr_debug("mxc_mlb150: packet overflow, "
-				"packet type: %d\n", ctype);
-#endif
+	if (CIRC_SPACE(head, tail, TRANS_RING_NODES) >= 1) {
+		rx_buf_ptr = rx_rbuf->phy_addrs[head];
 
-		/* update the ring wpos */
-		rx_rbuf->wpos = (wpos + 1) % TRANS_RING_NODES;
+		/* commit the item before incrementing the head */
+		smp_wmb();
 
-		/* wake up the reader */
-		wake_up_interruptible(&pdevinfo->rd_wq);
+		rx_rbuf->head = head;
 
-#ifdef DEBUG_RX
-		pr_debug("recv package, len:%d, rx_rdpos: %d, rx_wtpos: %d\n",
-			 len, rpos, pdevinfo->rx_bufs.wpos);
-#endif
-	} else {
-		rx_ring_buf = pdevinfo->rx_bufs.phy_addrs[TRANS_RING_NODES];
+		write_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
 
-		pr_debug
-		    ("drop package, due to no space, (%d,%d)\n",
-		     rpos, pdevinfo->rx_bufs.wpos);
+		/* wake up the reader */
+		wake_up_interruptible(&pdevinfo->rx_wq);
+	} else {
+		rx_buf_ptr = rx_rbuf->phy_addrs[head];
+		write_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
+		pr_debug("drop RX package, due to no space, (%d,%d)\n",
+				head, tail);
 	}
 
-	adt_sts = mlb150_dev_get_adt_sts(ch_addr);
-	mlb_start_rx(ch_addr, ctype, adt_sts, rx_ring_buf);
+	adt_sts = mlb150_dev_get_adt_sts(ahb_ch);
+	/*  Set ADT for RX */
+	mlb150_dev_pipo_next(ahb_ch, ctype, adt_sts, rx_buf_ptr);
+}
+
+static void mlb_tx_isr(s32 ctype, u32 ahb_ch, struct mlb_dev_info *pdevinfo)
+{
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	s32 head, tail, adt_sts;
+	u32 tx_buf_ptr;
+	unsigned long flags;
+
+	write_lock_irqsave(&tx_rbuf->rb_lock, flags);
+
+	head = ACCESS_ONCE(tx_rbuf->head);
+	tail = (tx_rbuf->tail + 1) & (TRANS_RING_NODES - 1);
+	smp_mb();
+	tx_rbuf->tail = tail;
+
+	/* check the current tx buffer is available or not */
+	if (CIRC_CNT(head, tail, TRANS_RING_NODES) >= 1) {
+		/* read index before reading contents at that index */
+		smp_read_barrier_depends();
+
+		tx_buf_ptr = tx_rbuf->phy_addrs[tail];
+
+		write_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+		wake_up_interruptible(&pdevinfo->tx_wq);
+
+		adt_sts = mlb150_dev_get_adt_sts(ahb_ch);
+		/*  Set ADT for TX */
+		mlb150_dev_pipo_next(ahb_ch, ctype, adt_sts, tx_buf_ptr);
+	} else
+		write_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
 }
 
 static irqreturn_t mlb_ahb_isr(int irq, void *dev_id)
 {
-	u32 rx_int_sts, tx_int_sts, acsr0,
-		acsr1, rx_err, tx_err, hcer0, hcer1;
-	struct mlb_dev_info *pdev = NULL;
-	struct mlb_channel_info *ptxchinfo = NULL, *prxchinfo = NULL;
-	int minor;
+	u32 acsr0, hcer0;
+	u32 ch_mask = (1 << SYNC_RX_CL) | (1 << CTRL_RX_CL)
+			| (1 << ASYNC_RX_CL) | (1 << ISOC_RX_CL)
+			| (1 << SYNC_TX_CL) | (1 << CTRL_TX_CL)
+			| (1 << ASYNC_TX_CL) | (1 << ISOC_TX_CL);
 
 	/* Step 5, Read the ACSRn registers to determine which channel or
 	 * channels are causing the interrupt */
-	acsr0 = __raw_readl(mlb_base + MLB150_REG_ACSR0);
-	acsr1 = __raw_readl(mlb_base + MLB150_REG_ACSR1);
+	acsr0 = __raw_readl(mlb_base + REG_ACSR0);
 
-	hcer0 = __raw_readl(mlb_base + MLB150_REG_HCER0);
-	hcer1 = __raw_readl(mlb_base + MLB150_REG_HCER1);
+	hcer0 = __raw_readl(mlb_base + REG_HCER0);
 
 	/* Step 6, If ACTL.SCE = 1, write the result of step 5 back to ACSR0
 	 * and ACSR1 to clear the interrupt */
-	if (MLB150_ACTL_SCE & __raw_readl(mlb_base + MLB150_REG_ACTL)) {
-		__raw_writel(acsr0, mlb_base + MLB150_REG_ACSR0);
-		__raw_writel(acsr1, mlb_base + MLB150_REG_ACSR1);
-	}
+	/* We'll not set ACTL_SCE */
+	/*
+	if (ACTL_SCE & __raw_readl(mlb_base + REG_ACTL))
+		__raw_writel(acsr0, mlb_base + REG_ACSR0);
+	*/
 
-	for (minor = 0; minor < MLB_MINOR_DEVICES; minor++) {
-		pdev = &mlb_devinfo[minor];
-		prxchinfo = &_get_rxchan(minor);
-		ptxchinfo = &_get_txchan(minor);
-
-		rx_int_sts = (prxchinfo->address < 31) ? acsr0 : acsr1;
-		tx_int_sts = (ptxchinfo->address < 31) ? acsr0 : acsr1;
-		rx_err = (prxchinfo->address < 31) ? hcer0 : hcer1;
-		tx_err = (ptxchinfo->address < 31) ? hcer0 : hcer1;
-
-		/* get tx channel interrupt status */
-		if (tx_int_sts & (1 << (ptxchinfo->address % 32))) {
-			if (!(tx_err & (1 << (ptxchinfo->address % 32))))
-				mlb_tx_isr(minor);
-			else {
-				pr_debug("tx channel %d encountered an AHB error!\n",
-					ptxchinfo->address);
-			}
-		}
+	if (ch_mask & hcer0)
+		pr_err("CH encounters an AHB error: 0x%x\n", hcer0);
 
-		/* get rx channel interrupt status */
-		if (rx_int_sts & (1 << (prxchinfo->address % 32))) {
-			if (!(rx_err & (1 << (prxchinfo->address % 32))))
-				mlb_rx_isr(minor);
-			else {
-				pr_debug("rx channel %d encountered an AHB error!\n",
-					prxchinfo->address);
-			}
-		}
-	}
+	if ((1 << SYNC_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_SYNC, SYNC_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_SYNC]);
+
+	if ((1 << CTRL_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_CTRL, CTRL_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_CTRL]);
+
+	if ((1 << ASYNC_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_ASYNC, ASYNC_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_ASYNC]);
+
+	if ((1 << ISOC_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_ISOC, ISOC_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_ISOC]);
+
+	if ((1 << SYNC_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_SYNC, SYNC_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_SYNC]);
+
+	if ((1 << CTRL_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_CTRL, CTRL_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_CTRL]);
+
+	if ((1 << ASYNC_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_ASYNC, ASYNC_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_ASYNC]);
+
+	if ((1 << ISOC_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_ASYNC, ISOC_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_ISOC]);
 
 	return IRQ_HANDLED;
 }
@@ -1587,38 +1751,41 @@ static irqreturn_t mlb_isr(int irq, void *dev_id)
 {
 	u32 rx_int_sts, tx_int_sts, ms0,
 		ms1, tx_cis, rx_cis, ctype;
-	struct mlb_dev_info *pdev;
 	int minor;
 	u32 cdt_val[4] = { 0 };
 
 	/* Step 4, Read the MSn register to determine which channel(s)
 	 * are causing the interrupt */
-	ms0 = __raw_readl(mlb_base + MLB150_REG_MS0);
-	ms1 = __raw_readl(mlb_base + MLB150_REG_MS1);
+	ms0 = __raw_readl(mlb_base + REG_MS0);
+	ms1 = __raw_readl(mlb_base + REG_MS1);
 	pr_debug("mxc_mlb150: mlb interrupt:0x%08x 0x%08x\n",
 			(u32)ms0, (u32)ms1);
 
 	for (minor = 0; minor < MLB_MINOR_DEVICES; minor++) {
-		pdev = &mlb_devinfo[minor];
+		struct mlb_dev_info *pdevinfo = &mlb_devinfo[minor];
+		u32 rx_mlb_ch = pdevinfo->channels[RX_CHANNEL].address;
+		u32 tx_mlb_ch = pdevinfo->channels[TX_CHANNEL].address;
+		u32 rx_mlb_cl = pdevinfo->channels[RX_CHANNEL].cl;
+		u32 tx_mlb_cl = pdevinfo->channels[TX_CHANNEL].cl;
+
 		tx_cis = rx_cis = 0;
 
-		ctype = pdev->channel_type;
-		rx_int_sts = (_get_rxchan(minor).address < 31) ? ms0 : ms1;
-		tx_int_sts = (_get_txchan(minor).address < 31) ? ms0 : ms1;
+		ctype = pdevinfo->channel_type;
+		rx_int_sts = (rx_mlb_ch < 31) ? ms0 : ms1;
+		tx_int_sts = (tx_mlb_ch < 31) ? ms0 : ms1;
 
 		pr_debug("mxc_mlb150: channel interrupt: "
-				"tx: 0x%08x, rx: 0x%08x\n",
-			(u32)tx_int_sts, (u32)rx_int_sts);
+				"tx %d: 0x%08x, rx %d: 0x%08x\n",
+			tx_mlb_ch, (u32)tx_int_sts, rx_mlb_ch, (u32)rx_int_sts);
 
 		/* Get tx channel interrupt status */
-		if (tx_int_sts & (1 << (_get_txchan(minor).address % 32))) {
-			mlb150_dev_cdt_read(_get_txchan(minor).address,
-					cdt_val);
-			pr_debug("mxc_mlb150: cdt_val[3]: 0x%08x, "
+		if (tx_int_sts & (1 << (tx_mlb_ch % 32))) {
+			mlb150_dev_cdt_read(tx_mlb_cl, cdt_val);
+			pr_debug("mxc_mlb150: TX_CH: %d, cdt_val[3]: 0x%08x, "
 					"cdt_val[2]: 0x%08x, "
 					"cdt_val[1]: 0x%08x, "
 					"cdt_val[0]: 0x%08x\n",
-					cdt_val[3], cdt_val[2],
+					tx_mlb_ch, cdt_val[3], cdt_val[2],
 					cdt_val[1], cdt_val[0]);
 			switch (ctype) {
 			case MLB_CTYPE_SYNC:
@@ -1652,14 +1819,18 @@ static irqreturn_t mlb_isr(int irq, void *dev_id)
 			default:
 				break;
 			}
-			mlb150_dev_cdt_write(_get_txchan(minor).address,
-					cdt_val);
+			mlb150_dev_cdt_write(tx_mlb_ch, cdt_val);
 		}
 
 		/* Get rx channel interrupt status */
-		if (rx_int_sts & (1 << (_get_rxchan(minor).address % 32))) {
-			mlb150_dev_cdt_read(_get_rxchan(minor).address,
-					cdt_val);
+		if (rx_int_sts & (1 << (rx_mlb_ch % 32))) {
+			mlb150_dev_cdt_read(rx_mlb_cl, cdt_val);
+			pr_debug("mxc_mlb150: RX_CH: %d, cdt_val[3]: 0x%08x, "
+					"cdt_val[2]: 0x%08x, "
+					"cdt_val[1]: 0x%08x, "
+					"cdt_val[0]: 0x%08x\n",
+					rx_mlb_ch, cdt_val[3], cdt_val[2],
+					cdt_val[1], cdt_val[0]);
 			switch (ctype) {
 			case MLB_CTYPE_SYNC:
 				tx_cis = (cdt_val[2] & ~CDT_SYNC_RSTS_MASK)
@@ -1685,17 +1856,16 @@ static irqreturn_t mlb_isr(int irq, void *dev_id)
 			default:
 				break;
 			}
-			mlb150_dev_cdt_write(_get_rxchan(minor).address,
-					cdt_val);
+			mlb150_dev_cdt_write(rx_mlb_ch, cdt_val);
 		}
 
 		if (!tx_cis && !rx_cis)
 			continue;
 
 		/* fill exception event */
-		spin_lock(&pdev->event_lock);
-		pdev->ex_event |= (rx_cis << 16) | tx_cis;
-		spin_unlock(&pdev->event_lock);
+		spin_lock(&pdevinfo->event_lock);
+		pdevinfo->ex_event |= (rx_cis << 16) | tx_cis;
+		spin_unlock(&pdevinfo->event_lock);
 	}
 
 	return IRQ_HANDLED;
@@ -1705,64 +1875,73 @@ static int mxc_mlb150_open(struct inode *inode, struct file *filp)
 {
 	int minor, ring_buf_size, buf_size, j, ret;
 	void __iomem *buf_addr;
-	ulong phyaddr;
-	struct mxc_mlb_platform_data *plat_data;
+	ulong phy_addr;
 	struct mlb_dev_info *pdevinfo = NULL;
 	struct mlb_channel_info *pchinfo = NULL;
-
-	plat_data = container_of(inode->i_cdev, struct mxc_mlb_platform_data,
-				cdev);
-	filp->private_data = plat_data;
+	struct mlb_data *drvdata;
 
 	minor = MINOR(inode->i_rdev);
 
-	if (unlikely(minor < 0 || minor >= MLB_MINOR_DEVICES))
+	if (minor < 0 || minor >= MLB_MINOR_DEVICES) {
+		pr_err("no device\n");
 		return -ENODEV;
+	}
 
 	/* open for each channel device */
-	if (unlikely(atomic_cmpxchg(&mlb_devinfo[minor].opencnt, 0, 1) != 0))
+	if (atomic_cmpxchg(&mlb_devinfo[minor].opencnt, 0, 1) != 0) {
+		pr_err("busy\n");
 		return -EBUSY;
+	}
+
+	/* initial MLB module */
+	mlb150_dev_init();
 
 	pdevinfo = &mlb_devinfo[minor];
-	pchinfo = &_get_txchan(minor);
+	pchinfo = &pdevinfo->channels[TX_CHANNEL];
 
-	ring_buf_size = mlb150_ch_packet_buf_size[minor];
-	buf_size = ring_buf_size * (TRANS_RING_NODES + 1) + PING_BUF_MAX_SIZE;
-	buf_addr = iram_alloc(buf_size, &phyaddr);
-	memset(buf_addr, 0, buf_size);
-	if (unlikely(buf_addr == NULL)) {
+	ring_buf_size = pdevinfo->buf_size;
+	buf_size = ring_buf_size * (TRANS_RING_NODES * 2);
+	buf_addr = iram_alloc(buf_size, &phy_addr);
+	if (buf_addr == NULL) {
 		ret = -ENOMEM;
-		dev_err(plat_data->dev, "can not alloc rx buffers\n");
+		pr_err("can not alloc rx/tx buffers: %d\n", buf_size);
 		return ret;
 	}
+	pr_debug("IRAM Range: Virt 0x%p - 0x%p, Phys 0x%x - 0x%x, size: 0x%x\n",
+			buf_addr, (buf_addr + buf_size - 1), (u32)phy_addr,
+			(u32)(phy_addr + buf_size - 1), buf_size);
+	pdevinfo->rbuf_base_virt = buf_addr;
+	pdevinfo->rbuf_base_phy = phy_addr;
+	memset(buf_addr, 0, buf_size);
 
-	dev_dbg(plat_data->dev, "ch_type: %d, RX ring buf virt base: 0x%08x "
-			"phy base: 0x%08x\n",
-			pdevinfo->channel_type, (u32)buf_addr, (u32)phyaddr);
-
-	for (j = 0; j < TRANS_RING_NODES + 1;
-		++j, buf_addr += ring_buf_size, phyaddr += ring_buf_size) {
-		pdevinfo->rx_bufs.virt_bufs[j] = buf_addr;
-		pdevinfo->rx_bufs.phy_addrs[j] = phyaddr;
-		pdevinfo->rx_bufs.size = pchinfo->buf_size;
+	for (j = 0; j < (TRANS_RING_NODES);
+		++j, buf_addr += ring_buf_size, phy_addr += ring_buf_size) {
+		pdevinfo->rx_rbuf.virt_bufs[j] = buf_addr;
+		pdevinfo->rx_rbuf.phy_addrs[j] = phy_addr;
+		pr_debug("RX Ringbuf[%d]: 0x%p 0x%x\n", j, buf_addr, (u32)phy_addr);
+	}
+	pdevinfo->rx_rbuf.unit_size = ring_buf_size;
+	pdevinfo->rx_rbuf.total_size = buf_size;
+
+	for (j = 0; j < (TRANS_RING_NODES);
+		++j, buf_addr += ring_buf_size, phy_addr += ring_buf_size) {
+		pdevinfo->tx_rbuf.virt_bufs[j] = buf_addr;
+		pdevinfo->tx_rbuf.phy_addrs[j] = phy_addr;
+		pr_debug("TX Ringbuf[%d]: 0x%p 0x%x\n", j, buf_addr, (u32)phy_addr);
 	}
 
-	/* set the virtual and physical buf head address */
-	pchinfo->ping_buf_head = pchinfo->pong_buf_head = (u32)buf_addr;
-	pchinfo->ping_phy_head = pchinfo->pong_phy_head = phyaddr;
-
-	pchinfo->buf_ptr = (u32)buf_addr;
-	pchinfo->buf_phy_addr = phyaddr;
-
-	dev_dbg(plat_data->dev, "ctype: %d, tx phy_head: 0x%08x, "
-		"buf_head: 0x%08x\n",
-		pchinfo->address,
-		(u32)pchinfo->buf_phy_addr,
-		(u32)pchinfo->buf_ptr);
+	pdevinfo->tx_rbuf.unit_size = ring_buf_size;
+	pdevinfo->tx_rbuf.total_size = buf_size;
 
 	/* reset the buffer read/write ptr */
-	pdevinfo->rx_bufs.rpos = pdevinfo->rx_bufs.wpos = 0;
+	pdevinfo->rx_rbuf.head = pdevinfo->rx_rbuf.tail = 0;
+	pdevinfo->tx_rbuf.head = pdevinfo->tx_rbuf.tail = 0;
 	pdevinfo->ex_event = 0;
+	pdevinfo->tx_ok = 0;
+
+	drvdata = container_of(inode->i_cdev, struct mlb_data, cdev);
+	drvdata->devinfo = pdevinfo;
+	filp->private_data = drvdata;
 
 	return 0;
 }
@@ -1770,26 +1949,24 @@ static int mxc_mlb150_open(struct inode *inode, struct file *filp)
 static int mxc_mlb150_release(struct inode *inode, struct file *filp)
 {
 	int minor;
-	u32 buf_size;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
 
 	minor = MINOR(inode->i_rdev);
 
 #ifdef DEBUG
 	mlb150_dev_dump_reg();
-	mlb150_dev_dump_ctr_tbl(0, _get_txchan(minor).address + 1);
-	mlb150_dev_dump_hex((const u8 *)mlb_devinfo[minor].rx_bufs.virt_bufs[0],
-			mlb_devinfo[minor].rx_bufs.size);
+	mlb150_dev_dump_ctr_tbl(0, pdevinfo->channels[TX_CHANNEL].cl + 1);
 #endif
 
 	/* clear channel settings and info */
-	mlb_channel_enable(minor, 0);
+	mlb_channel_enable(drvdata, minor, 0);
 
-	buf_size = mlb150_ch_packet_buf_size[minor] *
-			(TRANS_RING_NODES + 1) + PING_BUF_MAX_SIZE;
-	iram_free(mlb_devinfo[minor].rx_bufs.phy_addrs[0], buf_size);
+	iram_free(pdevinfo->rbuf_base_phy, rx_rbuf->total_size);
 
 	/* decrease the open count */
-	atomic_set(&mlb_devinfo[minor].opencnt, 0);
+	atomic_set(&pdevinfo->opencnt, 0);
 
 	return 0;
 }
@@ -1798,10 +1975,11 @@ static long mxc_mlb150_ioctl(struct file *filp,
 			 unsigned int cmd, unsigned long arg)
 {
 	struct inode *inode = filp->f_dentry->d_inode;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
 	void __user *argp = (void __user *)arg;
 	unsigned long flags, event;
 	int minor;
-	struct mxc_mlb_platform_data *plat_data = filp->private_data;
 
 	minor = MINOR(inode->i_rdev);
 
@@ -1814,46 +1992,75 @@ static long mxc_mlb150_ioctl(struct file *filp,
 				pr_err("mxc_mlb150: copy from user failed\n");
 				return -EFAULT;
 			}
-			_get_txchan(minor).address = (caddr >> 16) & 0xFFFF;
-			_get_rxchan(minor).address = caddr & 0xFFFF;
+			pdevinfo->channels[TX_CHANNEL].address =
+							(caddr >> 16) & 0xFFFF;
+			pdevinfo->channels[RX_CHANNEL].address = caddr & 0xFFFF;
 			pr_debug("mxc_mlb150: set ch addr, tx: %d, rx: %d\n",
-					_get_txchan(minor).address,
-					_get_rxchan(minor).address);
+					pdevinfo->channels[TX_CHANNEL].address,
+					pdevinfo->channels[RX_CHANNEL].address);
 			break;
 		}
 
 	case MLB_CHAN_STARTUP:
-		if (unlikely(atomic_read(&mlb_devinfo[minor].on))) {
-			pr_debug("mxc_mlb150: channel areadly startup\n");
+		if (atomic_read(&pdevinfo->on)) {
+			pr_debug("mxc_mlb150: channel alreadly startup\n");
 			break;
 		}
-		pr_debug("mxc_mlb150: start channel\n");
-		mlb_channel_enable(minor, 1);
+		mlb_channel_enable(drvdata, minor, 1);
 		break;
 	case MLB_CHAN_SHUTDOWN:
-		if (unlikely(atomic_read(&mlb_devinfo[minor].on) == 0)) {
+		if (atomic_read(&pdevinfo->on) == 0) {
 			pr_debug("mxc_mlb150: channel areadly shutdown\n");
 			break;
 		}
-		pr_debug("mxc_mlb150: shutdown channel\n");
-		mlb_channel_enable(minor, 0);
+		mlb150_trans_complete_check(pdevinfo);
+		mlb_channel_enable(drvdata, minor, 0);
 		break;
 	case MLB_CHAN_GETEVENT:
 		/* get and clear the ex_event */
-		spin_lock_irqsave(&mlb_devinfo[minor].event_lock, flags);
-		event = mlb_devinfo[minor].ex_event;
-		mlb_devinfo[minor].ex_event = 0;
-		spin_unlock_irqrestore(&mlb_devinfo[minor].event_lock, flags);
+		spin_lock_irqsave(&pdevinfo->event_lock, flags);
+		event = pdevinfo->ex_event;
+		pdevinfo->ex_event = 0;
+		spin_unlock_irqrestore(&pdevinfo->event_lock, flags);
 
-		pr_debug("mxc_mlb150: get event\n");
 		if (event) {
 			if (copy_to_user(argp, &event, sizeof(event))) {
 				pr_err("mxc_mlb150: copy to user failed\n");
 				return -EFAULT;
 			}
-		} else {
-			pr_debug("mxc_mlb150: no exception event now\n");
+		} else
 			return -EAGAIN;
+		break;
+	case MLB_SET_ISOC_BLKSIZE_188:
+		pdevinfo->isoc_blksz = 188;
+		pdevinfo->cdt_buf_dep = pdevinfo->adt_buf_dep =
+					pdevinfo->isoc_blksz * CH_ISOC_BLK_NUM;
+		break;
+	case MLB_SET_ISOC_BLKSIZE_196:
+		pdevinfo->isoc_blksz = 196;
+		pdevinfo->cdt_buf_dep = pdevinfo->adt_buf_dep =
+					pdevinfo->isoc_blksz * CH_ISOC_BLK_NUM;
+		break;
+	case MLB_SET_SYNC_QUAD:
+		{
+			u32 quad;
+
+			if (copy_from_user(&quad, argp, sizeof(quad))) {
+				pr_err("mxc_mlb150: get quad number "
+						"from user failed\n");
+				return -EFAULT;
+			}
+			if (quad <= 0 || quad > 3) {
+				pr_err("mxc_mlb150: Invalid Quadlets!"
+					"Quadlets in Sync mode can "
+					"only be 1, 2, 3\n");
+				return -EINVAL;
+			}
+			pdevinfo->sync_quad = quad;
+			/* Each quadlets is 4 bytes */
+			pdevinfo->cdt_buf_dep = quad * 4 * 4;
+			pdevinfo->adt_buf_dep =
+				pdevinfo->cdt_buf_dep * CH_SYNC_ADT_BUF_MULTI;
 		}
 		break;
 	case MLB_SET_FPS:
@@ -1861,43 +2068,47 @@ static long mxc_mlb150_ioctl(struct file *filp,
 			u32 fps, c0_val;
 
 			/* get fps from user space */
-			if (unlikely(copy_from_user(&fps, argp, sizeof(fps)))) {
+			if (copy_from_user(&fps, argp, sizeof(fps))) {
 				pr_err("mxc_mlb150: copy from user failed\n");
 				return -EFAULT;
 			}
 
-			if (plat_data->fps_sel)
-				plat_data->fps_sel(fps);
-
-			c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-			c0_val &= ~MLB150_MLBC0_MLBCLK_MASK;
+			c0_val = __raw_readl(mlb_base + REG_MLBC0);
+			c0_val &= ~MLBC0_MLBCLK_MASK;
 
 			/* check fps value */
 			switch (fps) {
 			case 256:
 			case 512:
 			case 1024:
-				mlb_devinfo[minor].fps = fps >> 9;
-				c0_val &= ~MLB150_MLBC0_MLBPEN;
+				pdevinfo->fps = fps >> 9;
+				c0_val &= ~MLBC0_MLBPEN;
 				c0_val |= (fps >> 9)
-					<< MLB150_MLBC0_MLBCLK_SHIFT;
+					<< MLBC0_MLBCLK_SHIFT;
+
+				if (1024 == fps) {
+					/* Invert output clock phase
+					 * in 1024 fps */
+					__raw_writel(0x1,
+						mlb_base + REG_MLBPC2);
+				}
 				break;
 			case 2048:
 			case 3072:
 			case 4096:
-				mlb_devinfo[minor].fps = (fps >> 10) + 1;
+				pdevinfo->fps = (fps >> 10) + 1;
 				c0_val |= ((fps >> 10) + 1)
-					<< MLB150_MLBC0_MLBCLK_SHIFT;
+					<< MLBC0_MLBCLK_SHIFT;
 				break;
 			case 6144:
-				mlb_devinfo[minor].fps = fps >> 10;
+				pdevinfo->fps = fps >> 10;
 				c0_val |= ((fps >> 10) + 1)
-					<< MLB150_MLBC0_MLBCLK_SHIFT;
+					<< MLBC0_MLBCLK_SHIFT;
 				break;
 			case 8192:
-				mlb_devinfo[minor].fps = (fps >> 10) - 1;
+				pdevinfo->fps = (fps >> 10) - 1;
 				c0_val |= ((fps >> 10) - 1)
-						<< MLB150_MLBC0_MLBCLK_SHIFT;
+						<< MLBC0_MLBCLK_SHIFT;
 				break;
 			default:
 				pr_debug("mxc_mlb150: invalid fps argument: %d\n",
@@ -1905,11 +2116,11 @@ static long mxc_mlb150_ioctl(struct file *filp,
 				return -EINVAL;
 			}
 
-			__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
+			__raw_writel(c0_val, mlb_base + REG_MLBC0);
 
 			pr_debug("mxc_mlb150: set fps to %d, MLBC0: 0x%08x\n",
 				fps,
-				(u32)__raw_readl(mlb_base + MLB150_REG_MLBC0));
+				(u32)__raw_readl(mlb_base + REG_MLBC0));
 
 			break;
 		}
@@ -1937,19 +2148,19 @@ static long mxc_mlb150_ioctl(struct file *filp,
 			u8 devaddr;
 
 			/* get MLB device address from user space */
-			if (unlikely(copy_from_user
-				(&devaddr, argp, sizeof(unsigned char)))) {
+			if (copy_from_user
+				(&devaddr, argp, sizeof(unsigned char))) {
 				pr_err("mxc_mlb150: copy from user failed\n");
 				return -EFAULT;
 			}
 
-			c1_val = __raw_readl(mlb_base + MLB150_REG_MLBC1);
-			c1_val &= ~MLB150_MLBC1_NDA_MASK;
-			c1_val |= devaddr << MLB150_MLBC1_NDA_SHIFT;
-			__raw_writel(c1_val, mlb_base + MLB150_REG_MLBC1);
+			c1_val = __raw_readl(mlb_base + REG_MLBC1);
+			c1_val &= ~MLBC1_NDA_MASK;
+			c1_val |= devaddr << MLBC1_NDA_SHIFT;
+			__raw_writel(c1_val, mlb_base + REG_MLBC1);
 			pr_debug("mxc_mlb150: set dev addr, dev addr: %d, "
 				"MLBC1: 0x%08x\n", devaddr,
-				(u32)__raw_readl(mlb_base + MLB150_REG_MLBC1));
+				(u32)__raw_readl(mlb_base + REG_MLBC1));
 
 			break;
 		}
@@ -1970,35 +2181,59 @@ static long mxc_mlb150_ioctl(struct file *filp,
 static ssize_t mxc_mlb150_read(struct file *filp, char __user *buf,
 			    size_t count, loff_t *f_pos)
 {
-	int minor, ret;
-	int size, rdpos;
-	struct mlb_ringbuf *rx_rbuf = NULL;
-	struct mlb_dev_info *pdevinfo = NULL;
-
-#ifdef DEBUG_RX
-	pr_debug("mxc_mlb150: mxc_mlb150_read\n");
-#endif
-
-	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+	int size;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	int head, tail;
+	unsigned long flags;
 
-	pdevinfo = &mlb_devinfo[minor];
+	read_lock_irqsave(&rx_rbuf->rb_lock, flags);
 
-	rdpos = pdevinfo->rx_bufs.rpos;
-	rx_rbuf = &pdevinfo->rx_bufs;
+	head = ACCESS_ONCE(rx_rbuf->head);
+	tail = rx_rbuf->tail;
 
 	/* check the current rx buffer is available or not */
-	if (rdpos == rx_rbuf->wpos) {
+	if (0 == CIRC_CNT(head, tail, TRANS_RING_NODES)) {
+		read_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
+
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
-		/* if !O_NONBLOCK, we wait for recv packet */
-		ret = wait_event_interruptible(pdevinfo->rd_wq,
-						(rx_rbuf->wpos != rdpos));
-		if (ret < 0)
-			return ret;
+
+		do {
+			DEFINE_WAIT(__wait);
+
+			for (;;) {
+				prepare_to_wait(&pdevinfo->rx_wq,
+						&__wait, TASK_INTERRUPTIBLE);
+
+				read_lock_irqsave(&rx_rbuf->rb_lock, flags);
+				if (CIRC_CNT(rx_rbuf->head, rx_rbuf->tail,
+						TRANS_RING_NODES) > 0) {
+					read_unlock_irqrestore(&rx_rbuf->rb_lock,
+								flags);
+					break;
+				}
+				read_unlock_irqrestore(&rx_rbuf->rb_lock,
+							flags);
+
+				if (!signal_pending(current)) {
+					schedule();
+					continue;
+				}
+				return -ERESTARTSYS;
+			}
+			finish_wait(&pdevinfo->rx_wq, &__wait);
+		} while (0);
+		read_lock_irqsave(&rx_rbuf->rb_lock, flags);
 	}
+	read_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
 
-	size = mlb150_ch_packet_buf_size[minor];
-	if (unlikely(size > count)) {
+	/* read index before reading contents at that index */
+	smp_read_barrier_depends();
+
+	size = pdevinfo->adt_buf_dep;
+	if (size > count) {
 		/* the user buffer is too small */
 		pr_warning
 			("mxc_mlb150: received data size is bigger than "
@@ -2006,14 +2241,18 @@ static ssize_t mxc_mlb150_read(struct file *filp, char __user *buf,
 		return -EINVAL;
 	}
 
-	/* copy rx buffer data to user buffer */
-	if (likely(copy_to_user(buf, rx_rbuf->virt_bufs[rdpos], size))) {
+	/* extract one item from the buffer */
+	if (copy_to_user(buf, rx_rbuf->virt_bufs[tail], size)) {
 		pr_err("mxc_mlb150: copy from user failed\n");
 		return -EFAULT;
 	}
 
-	/* update the read ptr */
-	rx_rbuf->rpos = (rdpos + 1) % TRANS_RING_NODES;
+	/* finish reading descriptor before incrementing tail */
+	smp_mb();
+
+	write_lock_irqsave(&rx_rbuf->rb_lock, flags);
+	rx_rbuf->tail = (tail + 1) & (TRANS_RING_NODES - 1);
+	write_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
 
 	*f_pos = 0;
 
@@ -2029,16 +2268,20 @@ static ssize_t mxc_mlb150_read(struct file *filp, char __user *buf,
 static ssize_t mxc_mlb150_write(struct file *filp, const char __user *buf,
 			     size_t count, loff_t *f_pos)
 {
-	s32 minor = 0, ret = 0;
+	s32 ret = 0;
 	struct mlb_channel_info *pchinfo = NULL;
-	struct mlb_dev_info *pdevinfo = NULL;
-	u32 adt_sts = 0;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	int head, tail;
+	unsigned long flags;
 
+	/*
 	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
-	pchinfo = &_get_txchan(minor);
-	pdevinfo = &mlb_devinfo[minor];
+	*/
+	pchinfo = &pdevinfo->channels[TX_CHANNEL];
 
-	if (unlikely(count > pchinfo->buf_size)) {
+	if (count > pdevinfo->buf_size) {
 		/* too many data to write */
 		pr_warning("mxc_mlb150: overflow write data\n");
 		return -EFBIG;
@@ -2046,31 +2289,76 @@ static ssize_t mxc_mlb150_write(struct file *filp, const char __user *buf,
 
 	*f_pos = 0;
 
-	/* check the current tx buffer is used or not */
-	if (1 == pdevinfo->tx_busy) {
-		if (filp->f_flags & O_NONBLOCK)
-			return -EAGAIN;
+	read_lock_irqsave(&tx_rbuf->rb_lock, flags);
 
-		ret = wait_event_interruptible(pdevinfo->wt_wq,
-				0 == pdevinfo->tx_busy);
+	head = tx_rbuf->head;
+	tail = ACCESS_ONCE(tx_rbuf->tail);
 
-		if (ret < 0)
-			goto out;
+	if (0 == CIRC_SPACE(head, tail, TRANS_RING_NODES)) {
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		do {
+			DEFINE_WAIT(__wait);
+
+			for (;;) {
+				prepare_to_wait(&pdevinfo->tx_wq,
+						&__wait, TASK_INTERRUPTIBLE);
+
+				read_lock_irqsave(&tx_rbuf->rb_lock, flags);
+				if (CIRC_SPACE(tx_rbuf->head, tx_rbuf->tail,
+							TRANS_RING_NODES) > 0) {
+					read_unlock_irqrestore(&tx_rbuf->rb_lock,
+							flags);
+					break;
+				}
+				read_unlock_irqrestore(&tx_rbuf->rb_lock,
+								flags);
+
+				if (!signal_pending(current)) {
+					schedule();
+					continue;
+				}
+				return -ERESTARTSYS;
+			}
+			finish_wait(&pdevinfo->tx_wq, &__wait);
+		} while (0);
 	}
 
-	if (copy_from_user((void *)pchinfo->buf_ptr, buf, count)) {
+	if (copy_from_user((void *)tx_rbuf->virt_bufs[head], buf, count)) {
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
 		pr_err("mxc_mlb: copy from user failed\n");
 		ret = -EFAULT;
 		goto out;
 	}
 
-	adt_sts = mlb150_dev_get_adt_sts(pchinfo->address);
-	pdevinfo->tx_busy = 1;
-	mlb_start_tx(pchinfo->address, pdevinfo->channel_type,
-			adt_sts, pchinfo->buf_phy_addr);
+	read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+	write_lock_irqsave(&tx_rbuf->rb_lock, flags);
+	smp_wmb();
+	tx_rbuf->head = (head + 1) & (TRANS_RING_NODES - 1);
+	write_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
 
-	ret = count;
+	read_lock_irqsave(&tx_rbuf->rb_lock, flags);
+	if (0 == CIRC_CNT(head, tail, TRANS_RING_NODES)) {
+		u32 tx_buf_ptr, ahb_ch;
+		s32 adt_sts;
+		u32 ctype = pdevinfo->channel_type;
+
+		/* read index before reading contents at that index */
+		smp_read_barrier_depends();
+
+		tx_buf_ptr = tx_rbuf->phy_addrs[tail];
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+		ahb_ch = pdevinfo->channels[TX_CHANNEL].cl;
+		adt_sts = mlb150_dev_get_adt_sts(ahb_ch);
 
+		/*  Set ADT for TX */
+		mlb150_dev_pipo_next(ahb_ch, ctype, adt_sts, tx_buf_ptr);
+	} else
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+	ret = count;
 out:
 	return ret;
 }
@@ -2080,23 +2368,41 @@ static unsigned int mxc_mlb150_poll(struct file *filp,
 {
 	int minor;
 	unsigned int ret = 0;
-	struct mlb_dev_info *pdevinfo = NULL;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	int head, tail;
+	unsigned long flags;
+
 
 	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
 
-	pdevinfo = &mlb_devinfo[minor];
+	poll_wait(filp, &pdevinfo->rx_wq, wait);
+	poll_wait(filp, &pdevinfo->tx_wq, wait);
 
-	poll_wait(filp, &pdevinfo->rd_wq, wait);
-	poll_wait(filp, &pdevinfo->wt_wq, wait);
+	read_lock_irqsave(&tx_rbuf->rb_lock, flags);
+
+	head = tx_rbuf->head;
+	tail = tx_rbuf->tail;
 
 	/* check the tx buffer is avaiable or not */
-	if (0 == pdevinfo->tx_busy)
+	if (CIRC_SPACE(head, tail, TRANS_RING_NODES) >= 1)
 		ret |= POLLOUT | POLLWRNORM;
 
+	read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+	read_lock_irqsave(&rx_rbuf->rb_lock, flags);
+
+	head = rx_rbuf->head;
+	tail = rx_rbuf->tail;
+
 	/* check the rx buffer filled or not */
-	if (pdevinfo->rx_bufs.rpos != pdevinfo->rx_bufs.wpos)
+	if (CIRC_CNT(head, tail, TRANS_RING_NODES) >= 1)
 		ret |= POLLIN | POLLRDNORM;
 
+	read_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
+
 	/* check the exception event */
 	if (pdevinfo->ex_event)
 		ret |= POLLIN | POLLRDNORM;
@@ -2124,175 +2430,180 @@ static const struct file_operations mxc_mlb150_fops = {
 static int __devinit mxc_mlb150_probe(struct platform_device *pdev)
 {
 	int ret, mlb_major, i;
-	struct mxc_mlb_platform_data *plat_data;
+	struct mlb_data *drvdata;
 	struct resource *res;
-	void __iomem *base;
+	struct mxc_mlb_platform_data *plat_data;
+
 
 	plat_data =
 		(struct mxc_mlb_platform_data *)pdev->dev.platform_data;
 	plat_data->dev = &pdev->dev;
+	drvdata = kzalloc(sizeof(struct mlb_data), GFP_KERNEL);
+	if (!drvdata) {
+		dev_err(&pdev->dev, "can't allocate enough memory\n");
+		return -ENOMEM;
+	}
 
 	/**
 	 * Register MLB lld as four character devices
 	 */
-	ret = alloc_chrdev_region(&dev, 0, MLB_MINOR_DEVICES, "mxc_mlb150");
-	mlb_major = MAJOR(dev);
-	dev_dbg(plat_data->dev, "MLB device major: %d\n", mlb_major);
-
-	if (unlikely(ret < 0)) {
-		dev_err(plat_data->dev, "can't get major %d\n", mlb_major);
-		goto err2;
+	ret = alloc_chrdev_region(&drvdata->firstdev, 0,
+			MLB_MINOR_DEVICES, "mxc_mlb150");
+	mlb_major = MAJOR(drvdata->firstdev);
+	dev_dbg(&pdev->dev, "MLB device major: %d\n", mlb_major);
+
+	if (ret < 0) {
+		dev_err(&pdev->dev, "can't get major %d\n", mlb_major);
+		goto err_reg;
 	}
 
-	cdev_init(&plat_data->cdev, &mxc_mlb150_fops);
-	plat_data->cdev.owner = THIS_MODULE;
+	cdev_init(&drvdata->cdev, &mxc_mlb150_fops);
+	drvdata->cdev.owner = THIS_MODULE;
 
-	ret = cdev_add(&plat_data->cdev, dev, MLB_MINOR_DEVICES);
-	if (unlikely(ret)) {
-		dev_err(plat_data->dev, "can't add cdev\n");
-		goto err2;
+	ret = cdev_add(&drvdata->cdev, drvdata->firstdev, MLB_MINOR_DEVICES);
+	if (ret) {
+		dev_err(&pdev->dev, "can't add cdev\n");
+		goto err_reg;
 	}
 
 	/* create class and device for udev information */
-	mlb_class = class_create(THIS_MODULE, "mlb150");
-	if (unlikely(IS_ERR(mlb_class))) {
-		dev_err(plat_data->dev, "failed to create mlb150 class\n");
+	drvdata->class = class_create(THIS_MODULE, "mlb150");
+	if (IS_ERR(drvdata->class)) {
+		dev_err(&pdev->dev, "failed to create device class\n");
 		ret = -ENOMEM;
-		goto err2;
+		goto err_reg;
 	}
 
 	for (i = 0; i < MLB_MINOR_DEVICES; i++) {
-		class_dev = device_create(mlb_class, NULL, MKDEV(mlb_major, i),
-					  NULL, mlb_devinfo[i].dev_name);
-		if (unlikely(IS_ERR(class_dev))) {
-			dev_err(plat_data->dev, "failed to create mlb150 %s"
+		struct device *class_dev;
+
+		class_dev = device_create(drvdata->class, NULL,
+				MKDEV(mlb_major, i),
+				NULL, mlb_devinfo[i].dev_name);
+		if (IS_ERR(class_dev)) {
+			dev_err(&pdev->dev, "failed to create mlb150 %s"
 				" class device\n", mlb_devinfo[i].dev_name);
 			ret = -ENOMEM;
-			goto err1;
+			goto err_dev;
 		}
 	}
 
-	/* get irq line */
-	/* AHB0 IRQ */
+	/* get irq */
+	/* ahb0 irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
 	if (unlikely(res == NULL)) {
-		dev_err(plat_data->dev, "No mlb150 ahb0 irq line provided\n");
-		goto err0;
+		dev_err(&pdev->dev, "No ahb0 irq line provided\n");
+		goto err_irq;
 	}
-
-	ahb0_irq = res->start;
-	dev_dbg(plat_data->dev, "ahb0_irq: %d\n", ahb0_irq);
-	if (request_irq(ahb0_irq, mlb_ahb_isr, 0, "mlb_ahb0", NULL)) {
-		dev_err(plat_data->dev, "failed to request irq\n");
-		ret = -EBUSY;
-		goto err0;
+	drvdata->irq_ahb0 = res->start;
+	dev_dbg(&pdev->dev, "ahb0_irq: %d\n", drvdata->irq_ahb0);
+	if (request_irq(drvdata->irq_ahb0, mlb_ahb_isr, 0, "mlb_ahb0", NULL)) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", drvdata->irq_ahb0);
+		goto err_irq;
 	}
 
-	/* AHB1 IRQ */
+	/* ahb1 irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 2);
 	if (unlikely(res == NULL)) {
-		dev_err(plat_data->dev, "No mlb150 ahb0 irq line provided\n");
-		goto err0;
+		dev_err(&pdev->dev, "No ahb1 irq line provided\n");
+		goto err_irq;
 	}
-
-	ahb1_irq = res->start;
-	dev_dbg(plat_data->dev, "ahb1_irq: %d\n", ahb1_irq);
-	if (request_irq(ahb1_irq, mlb_ahb_isr, 0, "mlb_ahb1", NULL)) {
-		dev_err(plat_data->dev, "failed to request irq\n");
-		ret = -EBUSY;
-		goto err0;
+	drvdata->irq_ahb1 = res->start;
+	dev_dbg(&pdev->dev, "ahb1_irq: %d\n", drvdata->irq_ahb1);
+	if (request_irq(drvdata->irq_ahb1, mlb_ahb_isr, 0, "mlb_ahb1", NULL)) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", drvdata->irq_ahb1);
+		goto err_irq;
 	}
 
-	/* MLB IRQ */
+	/* mlb irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (res == NULL) {
-		dev_err(plat_data->dev, "No mlb150 irq line provided\n");
-		goto err0;
+	if (unlikely(res == NULL)) {
+		dev_err(&pdev->dev, "No mlb irq line provided\n");
+		goto err_irq;
 	}
-
-	mlb_irq = res->start;
-	dev_dbg(plat_data->dev, "mlb_irq: %d\n", mlb_irq);
-	if (request_irq(mlb_irq, mlb_isr, 0, "mlb", NULL)) {
-		dev_err(plat_data->dev, "failed to request irq\n");
-		ret = -EBUSY;
-		goto err0;
+	drvdata->irq_mlb  = res->start;
+	dev_dbg(&pdev->dev, "mlb_irq: %d\n", drvdata->irq_mlb);
+	if (request_irq(drvdata->irq_mlb, mlb_isr, 0, "mlb", NULL)) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", drvdata->irq_mlb);
+		goto err_irq;
 	}
 
 	/* ioremap from phy mlb to kernel space */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (unlikely(res == NULL)) {
-		dev_err(plat_data->dev, "No mlb150 base address provided\n");
-		goto err0;
+	if (!res) {
+		dev_err(&pdev->dev, "can't get device resources\n");
+		ret = -ENOENT;
+		goto err_unmap;
 	}
-
-	base = ioremap(res->start, res->end - res->start);
-	dev_dbg(plat_data->dev, "mapped mlb150 base address: 0x%08x\n",
-		(u32)base);
-
-	if (unlikely(base == NULL)) {
-		dev_err(plat_data->dev,
-				"failed to do ioremap with mlb150 base\n");
-		goto err0;
+	mlb_base = (u32)ioremap(res->start, res->end - res->start);
+	dev_dbg(&pdev->dev, "mapped base address: 0x%08x\n", (u32)mlb_base);
+	if (!mlb_base) {
+		dev_err(&pdev->dev,
+			"failed to get ioremap base\n");
+		goto err_irq;
 	}
-	mlb_base = (u32)base;
-
-	dev_dbg(plat_data->dev, "mlb reg base: 0x%08x\n", mlb_base);
+	drvdata->membase = mlb_base;
 
+#ifdef CONFIG_REGULATOR
 	if (plat_data->reg_nvcc) {
 		/* power on MLB */
-		reg_nvcc = regulator_get(plat_data->dev, plat_data->reg_nvcc);
-		if (unlikely(!IS_ERR(reg_nvcc))) {
+		drvdata->nvcc = regulator_get(&pdev->dev, plat_data->reg_nvcc);
+		if (!IS_ERR(drvdata->nvcc)) {
 			/* set MAX LDO6 for NVCC to 2.5V */
-			regulator_set_voltage(reg_nvcc, 2500000, 2500000);
-			regulator_enable(reg_nvcc);
+			regulator_set_voltage(drvdata->nvcc, 2500000, 2500000);
+			regulator_enable(drvdata->nvcc);
 		}
 	}
+#endif
 
 	/* enable clock */
-	if (likely(plat_data->mlb_clk)) {
-		mlb_clk = clk_get(plat_data->dev, plat_data->mlb_clk);
-		if (unlikely(IS_ERR(mlb_clk))) {
+	if (plat_data->mlb_clk) {
+		drvdata->clk_mlb3p = clk_get(&pdev->dev, plat_data->mlb_clk);
+		if (IS_ERR(drvdata->clk_mlb3p)) {
 			dev_err(&pdev->dev, "unable to get mlb clock\n");
-			ret = PTR_ERR(mlb_clk);
-			goto err0;
+			ret = PTR_ERR(drvdata->clk_mlb3p);
+			goto err_clk;
 		}
-		clk_enable(mlb_clk);
+		clk_enable(drvdata->clk_mlb3p);
 	}
 
-	if (likely(plat_data->mlb_pll_clk)) {
-		mlb_pll_clk = clk_get(plat_data->dev, plat_data->mlb_pll_clk);
-		if (unlikely(IS_ERR(mlb_pll_clk))) {
+	if (plat_data->mlb_pll_clk) {
+		drvdata->clk_mlb6p = clk_get(&pdev->dev,
+				plat_data->mlb_pll_clk);
+		if (IS_ERR(drvdata->clk_mlb6p)) {
 			dev_err(&pdev->dev, "unable to get mlb pll clock\n");
-			ret = PTR_ERR(mlb_pll_clk);
-			goto err0;
+			ret = PTR_ERR(drvdata->clk_mlb6p);
+			goto err_clk;
 		}
 	}
 
-	/* initial MLB module */
-	mlb150_dev_init();
+	platform_set_drvdata(pdev, drvdata);
 
 	return 0;
 
-err0:
-	if (likely(ahb0_irq)) {
-		free_irq(ahb0_irq, NULL);
-		ahb0_irq = 0;
-	}
-	if (likely(ahb1_irq)) {
-		free_irq(ahb1_irq, NULL);
-		ahb1_irq = 0;
-	}
-	if (likely(mlb_irq)) {
-		free_irq(mlb_irq, NULL);
-		mlb_irq = 0;
-	}
-err1:
+err_clk:
+	if (plat_data->mlb_clk)
+		clk_disable(drvdata->clk_mlb3p);
+	if (plat_data->mlb_pll_clk)
+		clk_disable(drvdata->clk_mlb6p);
+err_irq:
+	if (drvdata->irq_ahb0)
+		free_irq(drvdata->irq_ahb0, NULL);
+	if (drvdata->irq_ahb1)
+		free_irq(drvdata->irq_ahb1, NULL);
+	if (drvdata->irq_mlb)
+		free_irq(drvdata->irq_mlb, NULL);
+err_dev:
 	for (--i; i >= 0; i--)
-		device_destroy(mlb_class, MKDEV(mlb_major, i));
+		device_destroy(drvdata->class, MKDEV(mlb_major, i));
+
+	class_destroy(drvdata->class);
+err_reg:
+	unregister_chrdev_region(drvdata->firstdev, MLB_MINOR_DEVICES);
+err_unmap:
+	iounmap((void __iomem *)drvdata->membase);
 
-	class_destroy(mlb_class);
-err2:
-	unregister_chrdev_region(dev, MLB_MINOR_DEVICES);
+	kfree(drvdata);
 
 	return ret;
 }
@@ -2301,6 +2612,7 @@ static int __devexit mxc_mlb150_remove(struct platform_device *pdev)
 {
 	int i;
 	struct mxc_mlb_platform_data *plat_data;
+	struct mlb_data *drvdata = platform_get_drvdata(pdev);
 
 	plat_data = (struct mxc_mlb_platform_data *)pdev->dev.platform_data;
 
@@ -2308,43 +2620,43 @@ static int __devexit mxc_mlb150_remove(struct platform_device *pdev)
 
 	/* disable mlb clock */
 	if (plat_data->mlb_clk) {
-		clk_disable(mlb_clk);
-		clk_put(mlb_clk);
+		clk_disable(drvdata->clk_mlb3p);
+		clk_put(drvdata->clk_mlb3p);
 	}
-
 	if (plat_data->mlb_pll_clk)
-		clk_put(mlb_pll_clk);
+		clk_put(drvdata->clk_mlb6p);
 
 	/* disable mlb power */
-	if (plat_data->reg_nvcc) {
-		regulator_disable(reg_nvcc);
-		regulator_put(reg_nvcc);
+#ifdef CONFIG_REGULATOR
+	if (drvdata->nvcc) {
+		regulator_disable(drvdata->nvcc);
+		regulator_put(drvdata->nvcc);
 	}
+#endif
 
 	/* inactive GPIO */
 	gpio_mlb_inactive();
 
 	/* iounmap */
-	if (mlb_base) {
-		iounmap((void *)mlb_base);
-		mlb_base = 0;
-	}
+	iounmap((void __iomem *)drvdata->membase);
 
-	if (ahb0_irq)
-		free_irq(ahb0_irq, NULL);
-	if (ahb1_irq)
-		free_irq(ahb1_irq, NULL);
-	if (mlb_irq)
-		free_irq(mlb_irq, NULL);
-	ahb0_irq = ahb1_irq = mlb_irq = 0;
+	if (drvdata->irq_ahb0)
+		free_irq(drvdata->irq_ahb0, NULL);
+	if (drvdata->irq_ahb1)
+		free_irq(drvdata->irq_ahb1, NULL);
+	if (drvdata->irq_mlb)
+		free_irq(drvdata->irq_mlb,  NULL);
 
 	/* destroy mlb device class */
 	for (i = MLB_MINOR_DEVICES - 1; i >= 0; i--)
-		device_destroy(mlb_class, MKDEV(MAJOR(dev), i));
-	class_destroy(mlb_class);
+		device_destroy(drvdata->class,
+				MKDEV(MAJOR(drvdata->firstdev), i));
+	class_destroy(drvdata->class);
 
 	/* Unregister the two MLB devices */
-	unregister_chrdev_region(dev, MLB_MINOR_DEVICES);
+	unregister_chrdev_region(drvdata->firstdev, MLB_MINOR_DEVICES);
+
+	kfree(drvdata);
 
 	return 0;
 }
@@ -2352,11 +2664,23 @@ static int __devexit mxc_mlb150_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int mxc_mlb150_suspend(struct platform_device *pdev, pm_message_t state)
 {
+	struct mlb_data *drvdata = platform_get_drvdata(pdev);
+
+	mlb150_dev_exit();
+
+	clk_disable(drvdata->clk_mlb3p);
+
 	return 0;
 }
 
 static int mxc_mlb150_resume(struct platform_device *pdev)
 {
+	struct mlb_data *drvdata = platform_get_drvdata(pdev);
+
+	clk_enable(drvdata->clk_mlb6p);
+
+	mlb150_dev_init();
+
 	return 0;
 }
 #else
diff --git a/drivers/mxc/thermal/cooling.c b/drivers/mxc/thermal/cooling.c
index 7019d99..605c1c4 100644
--- a/drivers/mxc/thermal/cooling.c
+++ b/drivers/mxc/thermal/cooling.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,7 +57,8 @@ cpufreq, it minor 1, and when we promote cpufreq, it add 1, so
 if it is 0, mean we didn't change the cpufreq */
 static int cpufreq_change_count;
 
-extern int thermal_hot;
+extern atomic_t thermal_on;
+extern int thermal_notifier_call_chain(unsigned long val);
 int anatop_thermal_get_cpufreq_cur(void)
 {
 	int ret = -EINVAL;
@@ -238,7 +239,8 @@ imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
 	secondary CPUs that detached by thermal driver */
 	if (cooling_cpuhotplug) {
 		if (!state) {
-			thermal_hot = 0;
+			if (atomic_read(&thermal_on))
+				thermal_notifier_call_chain(0);
 			for (i = 1; i < 4; i++) {
 				if (cpu_mask && (0x1 << i)) {
 					anatop_thermal_cpu_hotplug(true);
@@ -249,7 +251,8 @@ imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
 		}
 	} else {
 		if (!state) {
-			thermal_hot = 0;
+			if (atomic_read(&thermal_on))
+				thermal_notifier_call_chain(0);
 			if (cpufreq_change_count < 0)
 				anatop_thermal_cpufreq_up();
 			else if (cpufreq_change_count > 0)
diff --git a/drivers/mxc/thermal/thermal.c b/drivers/mxc/thermal/thermal.c
index 226be6a..cbe771d 100644
--- a/drivers/mxc/thermal/thermal.c
+++ b/drivers/mxc/thermal/thermal.c
@@ -43,7 +43,6 @@
 #include <linux/cpufreq.h>
 #include <linux/clk.h>
 #include "anatop_driver.h"
-#include <mach/hardware.h>
 
 /* register define of anatop */
 #define HW_ANADIG_ANA_MISC0	(0x00000150)
@@ -157,8 +156,7 @@ static const struct anatop_device_id thermal_device_ids[] = {
 	{ANATOP_THERMAL_HID},
 	{""},
 };
-int thermal_hot;
-EXPORT_SYMBOL(thermal_hot);
+atomic_t thermal_on = ATOMIC_INIT(1);
 
 enum {
 	DEBUG_USER_STATE = 1U << 0,
@@ -278,6 +276,7 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 	struct anatop_thermal *tz = thermal->devdata;
 	unsigned int tmp;
 	unsigned int reg;
+	unsigned int val;
 
 	if (!tz)
 		return -EINVAL;
@@ -312,11 +311,16 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 		anatop_base + HW_ANADIG_TEMPSENSE0_SET);
 
 	tmp = 0;
+	val = jiffies;
 	/* read temperature values */
 	while ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0)
-		& BM_ANADIG_TEMPSENSE0_FINISHED) == 0)
+		& BM_ANADIG_TEMPSENSE0_FINISHED) == 0) {
+		if (time_after(jiffies, (unsigned long)(val + HZ / 2))) {
+			pr_info("Thermal sensor timeout, retry!\n");
+			return 0;
+		}
 		msleep(10);
-
+	}
 	reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0);
 	tmp = (reg & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
 		>> BP_ANADIG_TEMPSENSE0_TEMP_VALUE;
@@ -340,6 +344,11 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 	*temp = (cooling_device_disable && tz->temperature >= KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET)) ?
 			KELVIN_TO_CEL(TEMP_CRITICAL - 1, KELVIN_OFFSET) : tz->temperature;
 
+	/* Set alarm threshold if necessary */
+	if ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0) &
+		BM_ANADIG_TEMPSENSE0_ALARM_VALUE) == 0)
+		anatop_update_alarm(raw_critical);
+
 	return 0;
 }
 
@@ -573,6 +582,27 @@ static int anatop_thermal_get_crit_temp(struct thermal_zone_device *thermal,
 		return -EINVAL;
 }
 
+static BLOCKING_NOTIFIER_HEAD(thermal_chain_head);
+
+int register_thermal_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&thermal_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(register_thermal_notifier);
+
+int unregister_thermal_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&thermal_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(unregister_thermal_notifier);
+
+int thermal_notifier_call_chain(unsigned long val)
+{
+	return (blocking_notifier_call_chain(&thermal_chain_head, val, NULL)
+		== NOTIFY_BAD) ? -EINVAL : 0;
+}
+EXPORT_SYMBOL_GPL(thermal_notifier_call_chain);
+
 static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 			   enum thermal_trip_type trip_type)
 {
@@ -590,7 +620,8 @@ static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 		printk(KERN_WARNING "thermal_notify: trip_critical reached!\n");
 		arch_reset(mode, cmd);
 	} else if (trip_type == THERMAL_TRIP_HOT) {
-		thermal_hot = 1;
+		if (atomic_read(&thermal_on))
+			thermal_notifier_call_chain(1);
 		printk(KERN_DEBUG "thermal_notify: trip_hot reached!\n");
 		type = ANATOP_THERMAL_NOTIFY_HOT;
 		/* if temperature increase, continue to detach secondary CPUs*/
@@ -605,7 +636,8 @@ static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 			printk(KERN_INFO "No secondary CPUs detached!\n");
 		full_run = false;
 	} else {
-		thermal_hot = 0;
+		if (atomic_read(&thermal_on))
+			thermal_notifier_call_chain(0);
 		if (!full_run) {
 			temperature_cooling = 0;
 			if (cooling_cpuhotplug)
@@ -861,7 +893,7 @@ static int anatop_thermal_counting_ratio(unsigned int fuse_data)
 	raw_hot = (fuse_data & 0xfff00) >> 8;
 	hot_temp = fuse_data & 0xff;
 
-	if (!calibration_valid && !cpu_is_mx6sl())
+	if (!calibration_valid)
 		/*
 		 * The universal equation for thermal sensor
 		 * is slope = 0.4297157 - (0.0015976 * 25C fuse),
@@ -879,7 +911,6 @@ static int anatop_thermal_counting_ratio(unsigned int fuse_data)
 	/* Init default critical temp to set alarm */
 	raw_critical = raw_25c - ratio * (KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET) - 25) / 100;
 	clk_enable(pll3_clk);
-	anatop_update_alarm(raw_critical);
 
 	return ret;
 }
@@ -898,6 +929,35 @@ static irqreturn_t anatop_thermal_alarm_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static ssize_t anatop_thermal_flag_show(struct device *dev,
+		struct device_attribute *attr, char *buf) {
+	return sprintf(buf, "read thermal_hot_flag:%d\n",
+			atomic_read(&thermal_on));
+}
+
+static ssize_t anatop_thermal_flag_store(struct device *dev,
+		struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	int ret;
+	unsigned long data;
+	ret = strict_strtoul(buf, 10, &data);
+	if (data == 0)
+		atomic_set(&thermal_on, 0);
+	else
+		atomic_set(&thermal_on, 1);
+	return count;
+}
+
+static struct device_attribute anatop_thermal_flag_dev_attr = {
+	.attr = {
+		.name = "thermal_hot_flag",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.show = anatop_thermal_flag_show,
+	.store = anatop_thermal_flag_store,
+};
+
 static int anatop_thermal_probe(struct platform_device *pdev)
 {
 	int retval = 0;
@@ -962,6 +1022,9 @@ static int anatop_thermal_probe(struct platform_device *pdev)
 
 	anatop_thermal_add(device);
 	anatop_thermal_cpufreq_init();
+	retval = device_create_file(&pdev->dev, &anatop_thermal_flag_dev_attr);
+	if (retval)
+		dev_err(&pdev->dev, "create device file failed!\n");
 	pr_info("%s: default cooling device is cpufreq!\n", __func__);
 
 	goto success;
diff --git a/drivers/mxc/vpu/mxc_vpu.c b/drivers/mxc/vpu/mxc_vpu.c
index f473fdf..8a219db 100644
--- a/drivers/mxc/vpu/mxc_vpu.c
+++ b/drivers/mxc/vpu/mxc_vpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -112,6 +112,7 @@ static int vpu_jpu_irq;
 
 static unsigned int regBk[64];
 static struct regulator *vpu_regulator;
+static unsigned int pc_before_suspend;
 
 #define	READ_REG(x)		__raw_readl(vpu_base + x)
 #define	WRITE_REG(val, x)	__raw_writel(val, vpu_base + x)
@@ -250,8 +251,17 @@ static int vpu_open(struct inode *inode, struct file *filp)
 
 	mutex_lock(&vpu_data.lock);
 
-	if (open_count++ == 0 && !IS_ERR(vpu_regulator))
-		regulator_enable(vpu_regulator);
+	if (open_count++ == 0) {
+		if (!IS_ERR(vpu_regulator))
+			regulator_enable(vpu_regulator);
+
+#ifdef CONFIG_SOC_IMX6Q
+		clk_enable(vpu_clk);
+		if (READ_REG(BIT_CUR_PC))
+			pr_debug("Not power off before vpu open!\n");
+		clk_disable(vpu_clk);
+#endif
+	}
 
 	filp->private_data = (void *)(&vpu_data);
 	mutex_unlock(&vpu_data.lock);
@@ -518,6 +528,20 @@ static long vpu_ioctl(struct file *filp, u_int cmd,
 		}
 		break;
 	}
+	case VPU_IOC_LOCK_DEV:
+		{
+			u32 lock_en;
+
+			if (get_user(lock_en, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (lock_en)
+				mutex_lock(&vpu_data.lock);
+			else
+				mutex_unlock(&vpu_data.lock);
+
+			break;
+		}
 	default:
 		{
 			printk(KERN_ERR "No such IOCTL, cmd is %d\n", cmd);
@@ -534,11 +558,69 @@ static long vpu_ioctl(struct file *filp, u_int cmd,
  */
 static int vpu_release(struct inode *inode, struct file *filp)
 {
+	int i;
+	unsigned long timeout;
 
 	mutex_lock(&vpu_data.lock);
+
 	if (open_count > 0 && !(--open_count)) {
-		if (!IS_ERR(vpu_regulator))
-			regulator_disable(vpu_regulator);
+
+		/* Wait for vpu go to idle state */
+		clk_enable(vpu_clk);
+		if (READ_REG(BIT_CUR_PC)) {
+
+			timeout = jiffies + HZ;
+			while (READ_REG(BIT_BUSY_FLAG)) {
+				msleep(1);
+				if (time_after(jiffies, timeout)) {
+					printk(KERN_WARNING "VPU timeout during release\n");
+					break;
+				}
+			}
+			clk_disable(vpu_clk);
+
+			/* Clean up interrupt */
+			cancel_work_sync(&vpu_data.work);
+			flush_workqueue(vpu_data.workqueue);
+			irq_status = 0;
+
+			clk_enable(vpu_clk);
+			if (READ_REG(BIT_BUSY_FLAG)) {
+
+				if (cpu_is_mx51() || cpu_is_mx53()) {
+					printk(KERN_ERR
+						"fatal error: can't gate/power off when VPU is busy\n");
+					clk_disable(vpu_clk);
+					mutex_unlock(&vpu_data.lock);
+					return -EFAULT;
+				}
+
+#ifdef CONFIG_SOC_IMX6Q
+				if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+					WRITE_REG(0x11, 0x10F0);
+					timeout = jiffies + HZ;
+					while (READ_REG(0x10F4) != 0x77) {
+						msleep(1);
+						if (time_after(jiffies, timeout))
+							break;
+					}
+
+					if (READ_REG(0x10F4) != 0x77) {
+						printk(KERN_ERR
+							"fatal error: can't gate/power off when VPU is busy\n");
+						WRITE_REG(0x0, 0x10F0);
+						clk_disable(vpu_clk);
+						mutex_unlock(&vpu_data.lock);
+						return -EFAULT;
+					} else {
+						if (vpu_plat->reset)
+							vpu_plat->reset();
+					}
+				}
+#endif
+			}
+		}
+		clk_disable(vpu_clk);
 
 		vpu_free_buffers();
 
@@ -547,6 +629,14 @@ static int vpu_release(struct inode *inode, struct file *filp)
 		share_mem.cpu_addr = 0;
 		vfree((void *)vshare_mem.cpu_addr);
 		vshare_mem.cpu_addr = 0;
+
+		vpu_clk_usercount = clk_get_usecount(vpu_clk);
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_disable(vpu_clk);
+
+		if (!IS_ERR(vpu_regulator))
+			regulator_disable(vpu_regulator);
+
 	}
 	mutex_unlock(&vpu_data.lock);
 
@@ -716,9 +806,16 @@ static int vpu_dev_probe(struct platform_device *pdev)
 		goto err_out_class;
 	vpu_regulator = regulator_get(NULL, "cpu_vddvpu");
 	if (IS_ERR(vpu_regulator)) {
-		printk(KERN_ERR
-			"%s: failed to get vpu regulator\n", __func__);
-		goto err_out_class;
+		if (!(cpu_is_mx51() || cpu_is_mx53())) {
+			printk(KERN_ERR
+				"%s: failed to get vpu regulator\n", __func__);
+			goto err_out_class;
+		} else {
+			/* regulator_get will return error on MX5x,
+			 * just igore it everywhere*/
+			printk(KERN_WARNING
+				"%s: failed to get vpu regulator\n", __func__);
+		}
 	}
 
 #ifdef MXC_VPU_HAS_JPU
@@ -778,140 +875,154 @@ static int vpu_suspend(struct platform_device *pdev, pm_message_t state)
 	int i;
 	unsigned long timeout;
 
-	if (!IS_ERR(vpu_regulator))
-		regulator_enable(vpu_regulator);
-	/* Wait for vpu go to idle state, suspect vpu cannot be changed
-	   to idle state after about 1 sec */
-	if (open_count > 0) {
+	mutex_lock(&vpu_data.lock);
+	if (open_count == 0) {
+		/* VPU is released (all instances are freed),
+		 * clock is already off, context is no longer needed,
+		 * power is already off on MX6,
+		 * gate power on MX51 */
+		if (cpu_is_mx51()) {
+			if (vpu_plat->pg)
+				vpu_plat->pg(1);
+		}
+	} else {
+		/* Wait for vpu go to idle state, suspect vpu cannot be changed
+		   to idle state after about 1 sec */
 		timeout = jiffies + HZ;
 		clk_enable(vpu_clk);
 		while (READ_REG(BIT_BUSY_FLAG)) {
 			msleep(1);
-			if (time_after(jiffies, timeout))
-				goto out;
+			if (time_after(jiffies, timeout)) {
+				clk_disable(vpu_clk);
+				mutex_unlock(&vpu_data.lock);
+				return -EAGAIN;
+			}
 		}
 		clk_disable(vpu_clk);
-	}
 
-	/* Make sure clock is disabled before suspend */
-	vpu_clk_usercount = clk_get_usecount(vpu_clk);
-	for (i = 0; i < vpu_clk_usercount; i++)
-		clk_disable(vpu_clk);
+		/* Make sure clock is disabled before suspend */
+		vpu_clk_usercount = clk_get_usecount(vpu_clk);
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_disable(vpu_clk);
 
-	if (cpu_is_mx53())
-		return 0;
+		if (cpu_is_mx53()) {
+			mutex_unlock(&vpu_data.lock);
+			return 0;
+		}
 
-	if (bitwork_mem.cpu_addr != 0) {
-		clk_enable(vpu_clk);
-		/* Save 64 registers from BIT_CODE_BUF_ADDR */
-		for (i = 0; i < 64; i++)
-			regBk[i] = READ_REG(BIT_CODE_BUF_ADDR + (i * 4));
-		clk_disable(vpu_clk);
-	}
+		if (bitwork_mem.cpu_addr != 0) {
+			clk_enable(vpu_clk);
+			/* Save 64 registers from BIT_CODE_BUF_ADDR */
+			for (i = 0; i < 64; i++)
+				regBk[i] = READ_REG(BIT_CODE_BUF_ADDR + (i * 4));
+			pc_before_suspend = READ_REG(BIT_CUR_PC);
+			clk_disable(vpu_clk);
+		}
 
-	if (vpu_plat->pg)
-		vpu_plat->pg(1);
+		if (vpu_plat->pg)
+			vpu_plat->pg(1);
 
-	/* If VPU is working before suspend, disable
-	 * regulator to make usecount right. */
-	if (open_count > 0) {
+		/* If VPU is working before suspend, disable
+		 * regulator to make usecount right. */
 		if (!IS_ERR(vpu_regulator))
 			regulator_disable(vpu_regulator);
 	}
 
-	if (!IS_ERR(vpu_regulator))
-		regulator_disable(vpu_regulator);
+	mutex_unlock(&vpu_data.lock);
 	return 0;
-
-out:
-	clk_disable(vpu_clk);
-	if (!IS_ERR(vpu_regulator))
-		regulator_disable(vpu_regulator);
-	return -EAGAIN;
-
 }
 
 static int vpu_resume(struct platform_device *pdev)
 {
 	int i;
 
-	if (cpu_is_mx53())
-		goto recover_clk;
-
-	if (!IS_ERR(vpu_regulator))
-		regulator_enable(vpu_regulator);
-	if (vpu_plat->pg)
-		vpu_plat->pg(0);
+	mutex_lock(&vpu_data.lock);
+	if (open_count == 0) {
+		/* VPU is released (all instances are freed),
+		 * clock should be kept off, context is no longer needed,
+		 * power should be kept off on MX6,
+		 * disable power gating on MX51 */
+		if (cpu_is_mx51()) {
+			if (vpu_plat->pg)
+				vpu_plat->pg(0);
+		}
+	} else {
+		if (cpu_is_mx53())
+			goto recover_clk;
 
-	/* If VPU is working before suspend, enable
-	 * regulator to make usecount right. */
-	if (open_count > 0) {
+		/* If VPU is working before suspend, enable
+		 * regulator to make usecount right. */
 		if (!IS_ERR(vpu_regulator))
 			regulator_enable(vpu_regulator);
-	}
 
-	if (bitwork_mem.cpu_addr != 0) {
-		u32 *p = (u32 *) bitwork_mem.cpu_addr;
-		u32 data, pc;
-		u16 data_hi;
-		u16 data_lo;
+		if (vpu_plat->pg)
+			vpu_plat->pg(0);
 
-		clk_enable(vpu_clk);
+		if (bitwork_mem.cpu_addr != 0) {
+			u32 *p = (u32 *) bitwork_mem.cpu_addr;
+			u32 data, pc;
+			u16 data_hi;
+			u16 data_lo;
 
-		/* reset VPU in case of voltage change */
-		if (vpu_plat->reset)
-			vpu_plat->reset();
+			clk_enable(vpu_clk);
 
-		pc = READ_REG(BIT_CUR_PC);
-		if (pc) {
-			clk_disable(vpu_clk);
-			goto recover_clk;
-		}
+			pc = READ_REG(BIT_CUR_PC);
+			if (pc) {
+				printk(KERN_WARNING "Not power off after suspend (PC=0x%x)\n", pc);
+				clk_disable(vpu_clk);
+				goto recover_clk;
+			}
 
-		/* Restore registers */
-		for (i = 0; i < 64; i++)
-			WRITE_REG(regBk[i], BIT_CODE_BUF_ADDR + (i * 4));
-
-		WRITE_REG(0x0, BIT_RESET_CTRL);
-		WRITE_REG(0x0, BIT_CODE_RUN);
-		/* MX6 RTL has a bug not to init MBC_SET_SUBBLK_EN on reset */
-		WRITE_REG(0x0, MBC_SET_SUBBLK_EN);
-
-		/*
-		 * Re-load boot code, from the codebuffer in external RAM.
-		 * Thankfully, we only need 4096 bytes, same for all platforms.
-		 */
-		for (i = 0; i < 2048; i += 4) {
-			data = p[(i / 2) + 1];
-			data_hi = (data >> 16) & 0xFFFF;
-			data_lo = data & 0xFFFF;
-			WRITE_REG((i << 16) | data_hi, BIT_CODE_DOWN);
-			WRITE_REG(((i + 1) << 16) | data_lo,
-				  BIT_CODE_DOWN);
-
-			data = p[i / 2];
-			data_hi = (data >> 16) & 0xFFFF;
-			data_lo = data & 0xFFFF;
-			WRITE_REG(((i + 2) << 16) | data_hi,
-				  BIT_CODE_DOWN);
-			WRITE_REG(((i + 3) << 16) | data_lo,
-				  BIT_CODE_DOWN);
-		}
+			/* Restore registers */
+			for (i = 0; i < 64; i++)
+				WRITE_REG(regBk[i], BIT_CODE_BUF_ADDR + (i * 4));
 
-		WRITE_REG(0x1, BIT_BUSY_FLAG);
-		WRITE_REG(0x1, BIT_CODE_RUN);
-		while (READ_REG(BIT_BUSY_FLAG))
-			;
-		clk_disable(vpu_clk);
-	}
+			WRITE_REG(0x0, BIT_RESET_CTRL);
+			WRITE_REG(0x0, BIT_CODE_RUN);
+			/* MX6 RTL has a bug not to init MBC_SET_SUBBLK_EN on reset */
+#ifdef CONFIG_SOC_IMX6Q
+			WRITE_REG(0x0, MBC_SET_SUBBLK_EN);
+#endif
+
+			/*
+			 * Re-load boot code, from the codebuffer in external RAM.
+			 * Thankfully, we only need 4096 bytes, same for all platforms.
+			 */
+			for (i = 0; i < 2048; i += 4) {
+				data = p[(i / 2) + 1];
+				data_hi = (data >> 16) & 0xFFFF;
+				data_lo = data & 0xFFFF;
+				WRITE_REG((i << 16) | data_hi, BIT_CODE_DOWN);
+				WRITE_REG(((i + 1) << 16) | data_lo,
+						BIT_CODE_DOWN);
+
+				data = p[i / 2];
+				data_hi = (data >> 16) & 0xFFFF;
+				data_lo = data & 0xFFFF;
+				WRITE_REG(((i + 2) << 16) | data_hi,
+						BIT_CODE_DOWN);
+				WRITE_REG(((i + 3) << 16) | data_lo,
+						BIT_CODE_DOWN);
+			}
+
+			if (pc_before_suspend) {
+				WRITE_REG(0x1, BIT_BUSY_FLAG);
+				WRITE_REG(0x1, BIT_CODE_RUN);
+				while (READ_REG(BIT_BUSY_FLAG))
+					;
+			} else {
+				printk(KERN_WARNING "PC=0 before suspend\n");
+			}
+			clk_disable(vpu_clk);
+		}
 
 recover_clk:
-	/* Recover vpu clock */
-	for (i = 0; i < vpu_clk_usercount; i++)
-		clk_enable(vpu_clk);
-	if (!IS_ERR(vpu_regulator))
-		regulator_disable(vpu_regulator);
+		/* Recover vpu clock */
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_enable(vpu_clk);
+	}
 
+	mutex_unlock(&vpu_data.lock);
 	return 0;
 }
 #else
@@ -958,6 +1069,16 @@ static void __exit vpu_exit(void)
 	vpu_free_dma_buffer(&pic_para_mem);
 	vpu_free_dma_buffer(&user_data_mem);
 
+	/* reset VPU state */
+	if (!IS_ERR(vpu_regulator))
+		regulator_enable(vpu_regulator);
+	clk_enable(vpu_clk);
+	if (vpu_plat->reset)
+		vpu_plat->reset();
+	clk_disable(vpu_clk);
+	if (!IS_ERR(vpu_regulator))
+		regulator_disable(vpu_regulator);
+
 	clk_put(vpu_clk);
 
 	platform_driver_unregister(&mxcvpu_driver);
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index d0f8c7e..f0123ef 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -315,16 +315,24 @@ EXPORT_SYMBOL_GPL(can_put_echo_skb);
  * is handled in the device driver. The driver must protect
  * access to priv->echo_skb, if necessary.
  */
-void can_get_echo_skb(struct net_device *dev, unsigned int idx)
+unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx)
 {
 	struct can_priv *priv = netdev_priv(dev);
 
 	BUG_ON(idx >= priv->echo_skb_max);
 
 	if (priv->echo_skb[idx]) {
+		struct sk_buff *skb = priv->echo_skb[idx];
+		struct can_frame *cf = (struct can_frame *)skb->data;
+		u8 dlc = cf->can_dlc;
+
 		netif_rx(priv->echo_skb[idx]);
 		priv->echo_skb[idx] = NULL;
+
+		return dlc;
 	}
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(can_get_echo_skb);
 
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 920b8a0..d3b1342 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -126,7 +126,8 @@
 	(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)
 
 /* FLEXCAN interrupt flag register (IFLAG) bits */
-#define FLEXCAN_TX_BUF_ID		8
+#define FLEXCAN_RESERVED_BUF_ID		8
+#define FLEXCAN_TX_BUF_ID		13
 #define FLEXCAN_IFLAG_BUF(x)		BIT(x)
 #define FLEXCAN_IFLAG_RX_FIFO_OVERFLOW	BIT(7)
 #define FLEXCAN_IFLAG_RX_FIFO_WARN	BIT(6)
@@ -284,7 +285,6 @@ static int flexcan_get_berr_counter(const struct net_device *dev,
 static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	const struct flexcan_priv *priv = netdev_priv(dev);
-	struct net_device_stats *stats = &dev->stats;
 	struct flexcan_regs __iomem *regs = priv->base;
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	u32 can_id;
@@ -314,13 +314,15 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		writel(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[1]);
 	}
 
+	can_put_echo_skb(skb, dev, 0);
+
 	writel(can_id, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_id);
 	writel(ctrl, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);
 
-	kfree_skb(skb);
-
-	/* tx_packets is incremented in flexcan_irq */
-	stats->tx_bytes += cf->can_dlc;
+	if (priv->version == FLEXCAN_VER_10_0_12) {
+		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
+		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
+	}
 
 	return NETDEV_TX_OK;
 }
@@ -633,7 +635,7 @@ static irqreturn_t flexcan_irq(int irq, void *dev_id)
 
 	/* transmission complete interrupt */
 	if (reg_iflag1 & (1 << FLEXCAN_TX_BUF_ID)) {
-		/* tx_bytes is incremented in flexcan_start_xmit */
+		stats->tx_bytes += can_get_echo_skb(dev, 0);
 		stats->tx_packets++;
 		writel((1 << FLEXCAN_TX_BUF_ID), &regs->iflag1);
 		netif_wake_queue(dev);
@@ -722,13 +724,14 @@ static int flexcan_chip_start(struct net_device *dev)
 	 * enable warning int
 	 * choose format C
 	 * enable self wakeup
+	 * disable local echo
 	 *
 	 */
 	reg_mcr = readl(&regs->mcr);
 	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |
 		FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |
 		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_WAK_MSK |
-		FLEXCAN_MCR_SLF_WAK;
+		FLEXCAN_MCR_SLF_WAK | FLEXCAN_MCR_SRX_DIS;
 	dev_dbg(dev->dev.parent, "%s: writing mcr=0x%08x", __func__, reg_mcr);
 	writel(reg_mcr, &regs->mcr);
 
@@ -1008,7 +1011,7 @@ static int __devinit flexcan_probe(struct platform_device *pdev)
 		goto failed_map;
 	}
 
-	dev = alloc_candev(sizeof(struct flexcan_priv), 0);
+	dev = alloc_candev(sizeof(struct flexcan_priv), 1);
 	if (!dev) {
 		err = -ENOMEM;
 		goto failed_alloc;
@@ -1016,7 +1019,7 @@ static int __devinit flexcan_probe(struct platform_device *pdev)
 
 	dev->netdev_ops = &flexcan_netdev_ops;
 	dev->irq = irq;
-	dev->flags |= IFF_ECHO; /* we support local echo in hardware */
+	dev->flags |= IFF_ECHO;
 
 	priv = netdev_priv(dev);
 	priv->can.clock.freq = clk_get_rate(clk);
diff --git a/drivers/net/fec.c b/drivers/net/fec.c
index fd73765..71e0abc 100755
--- a/drivers/net/fec.c
+++ b/drivers/net/fec.c
@@ -19,7 +19,7 @@
  * Copyright (c) 2004-2006 Macq Electronique SA.
  *
  * Support for FEC IEEE 1588.
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  */
 
 #include <linux/module.h>
@@ -27,6 +27,7 @@
 #include <linux/string.h>
 #include <linux/ptrace.h>
 #include <linux/errno.h>
+#include <linux/gpio.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -69,11 +70,13 @@
 #define FEC_QUIRK_ENET_MAC		(1 << 0)
 /* Controller needs driver to swap frame */
 #define FEC_QUIRK_SWAP_FRAME		(1 << 1)
+/* ENET IP errata ticket TKT168103 */
+#define FEC_QUIRK_BUG_TKT168103		(1 << 2)
 
 static struct platform_device_id fec_devtype[] = {
 	{
 		.name = "enet",
-		.driver_data = FEC_QUIRK_ENET_MAC,
+		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_BUG_TKT168103,
 	},
 	{
 		.name = "fec",
@@ -81,7 +84,8 @@ static struct platform_device_id fec_devtype[] = {
 	},
 	{
 		.name = "imx28-fec",
-		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_SWAP_FRAME,
+		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_SWAP_FRAME |
+				FEC_QUIRK_BUG_TKT168103,
 	},
 	{ }
 };
@@ -192,6 +196,7 @@ struct fec_enet_private {
 	struct net_device *netdev;
 
 	struct clk *clk;
+	struct clk *mdc_clk;
 
 	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
 	unsigned char *tx_bounce[TX_RING_SIZE];
@@ -228,6 +233,7 @@ struct fec_enet_private {
 	int	link;
 	int	full_duplex;
 	struct	completion mdio_done;
+	struct delayed_work fixup_trigger_tx;
 
 	struct  fec_ptp_private *ptp_priv;
 	uint    ptimer_present;
@@ -277,13 +283,44 @@ static void *swap_buffer(void *bufaddr, int len)
 	return bufaddr;
 }
 
+static inline
+void *fec_enet_get_pre_txbd(struct net_device *ndev)
+{
+	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct bufdesc *bdp = fep->cur_tx;
+
+	if (bdp == fep->tx_bd_base)
+		return bdp + TX_RING_SIZE;
+	else
+		return bdp - 1;
+
+}
+
+/* MTIP enet IP have one IC issue recorded at PDM ticket:TKT168103
+ * The TDAR bit after being set by software is not acted upon by the
+ * ENET module due to the timing of when the ENET state machine
+ * clearing the TDAR bit occurring coincident or momentarily after
+ * the software sets the bit.
+ * This forces ENET module to check the Transmit buffer descriptor
+ * and take action if the “ready” flag is set. Otherwise the ENET
+ * returns to idle mode.
+ */
+static void fixup_trigger_tx_func(struct work_struct *work)
+{
+	struct fec_enet_private *fep =
+			container_of(work, struct fec_enet_private,
+					fixup_trigger_tx.work);
+
+	writel(0, fep->hwp + FEC_X_DES_ACTIVE);
+}
+
 static netdev_tx_t
 fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	const struct platform_device_id *id_entry =
 				platform_get_device_id(fep->pdev);
-	struct bufdesc *bdp;
+	struct bufdesc *bdp, *bdp_pre;
 	void *bufaddr;
 	unsigned short	status;
 	unsigned long   estatus;
@@ -299,7 +336,6 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	/* Fill in a Tx ring entry */
 	bdp = fep->cur_tx;
-
 	status = bdp->cbd_sc;
 
 	if (status & BD_ENET_TX_READY) {
@@ -372,6 +408,12 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	/* Trigger transmission start */
 	writel(0, fep->hwp + FEC_X_DES_ACTIVE);
 
+	bdp_pre = fec_enet_get_pre_txbd(ndev);
+	if ((id_entry->driver_data & FEC_QUIRK_BUG_TKT168103) &&
+		!(bdp_pre->cbd_sc & BD_ENET_TX_READY))
+		schedule_delayed_work(&fep->fixup_trigger_tx,
+					 msecs_to_jiffies(1));
+
 	/* If this was the last BD in the ring, start at the beginning again. */
 	if (status & BD_ENET_TX_WRAP)
 		bdp = fep->tx_bd_base;
@@ -594,7 +636,7 @@ static int fec_rx_poll(struct napi_struct *napi, int budget)
 		data = (__u8 *)__va(bdp->cbd_bufaddr);
 
 		if (bdp->cbd_bufaddr)
-			dma_unmap_single(&ndev->dev, bdp->cbd_bufaddr,
+			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
 				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
 
 		if (id_entry->driver_data & FEC_QUIRK_SWAP_FRAME)
@@ -622,7 +664,7 @@ static int fec_rx_poll(struct napi_struct *napi, int budget)
 			netif_receive_skb(skb);
 		}
 
-		bdp->cbd_bufaddr = dma_map_single(&ndev->dev, data,
+		bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, data,
 				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
 rx_processing_done:
 		/* Clear the status flags for this buffer */
@@ -1098,9 +1140,8 @@ static int fec_enet_mii_init(struct platform_device *pdev)
 	/*
 	 * Set MII speed to 2.5 MHz (= clk_get_rate() / 2 * phy_speed)
 	 */
-	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk),
+	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->mdc_clk),
 					(FEC_ENET_MII_CLK << 2)) << 1;
-
 	/* set hold time to 2 internal clock cycle */
 	if (cpu_is_mx6q() || cpu_is_mx6dl())
 		fep->phy_speed |= FEC_ENET_HOLD_TIME;
@@ -1200,7 +1241,9 @@ static struct ethtool_ops fec_enet_ethtool_ops = {
 static int fec_enet_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct fec_ptp_private *priv = fep->ptp_priv;
 	struct phy_device *phydev = fep->phy_dev;
+	int retVal = 0;
 
 	if (!netif_running(ndev))
 		return -EINVAL;
@@ -1208,7 +1251,16 @@ static int fec_enet_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
 	if (!phydev)
 		return -ENODEV;
 
-	return phy_mii_ioctl(phydev, rq, cmd);
+	if ((cmd >= PTP_ENBL_TXTS_IOCTL) &&
+			(cmd <= PTP_FLUSH_TIMESTAMP)) {
+		if (fep->ptimer_present)
+			retVal = fec_ptp_ioctl(priv, rq, cmd);
+		else
+			retVal = -ENODEV;
+	} else
+		retVal = phy_mii_ioctl(phydev, rq, cmd);
+
+	return retVal;
 }
 
 static void fec_enet_free_buffers(struct net_device *ndev)
@@ -1815,18 +1867,31 @@ fec_probe(struct platform_device *pdev)
 	if (pdata)
 		fep->phy_interface = pdata->phy;
 
-	/* This device has up to three irqs on some platforms */
-	for (i = 0; i < 3; i++) {
-		irq = platform_get_irq(pdev, i);
-		if (i && irq < 0)
-			break;
-		ret = request_irq(irq, fec_enet_interrupt, IRQF_DISABLED, pdev->name, ndev);
-		if (ret) {
-			while (--i >= 0) {
-				irq = platform_get_irq(pdev, i);
-				free_irq(irq, ndev);
-			}
+	if (pdata->gpio_irq > 0) {
+		gpio_request(pdata->gpio_irq, "gpio_enet_irq");
+		gpio_direction_input(pdata->gpio_irq);
+
+		irq = gpio_to_irq(pdata->gpio_irq);
+		ret = request_irq(irq, fec_enet_interrupt,
+				IRQF_TRIGGER_RISING,
+				 pdev->name, ndev);
+		if (ret)
 			goto failed_irq;
+	} else {
+		/* This device has up to three irqs on some platforms */
+		for (i = 0; i < 3; i++) {
+			irq = platform_get_irq(pdev, i);
+			if (i && irq < 0)
+				break;
+			ret = request_irq(irq, fec_enet_interrupt,
+					IRQF_DISABLED, pdev->name, ndev);
+			if (ret) {
+				while (--i >= 0) {
+					irq = platform_get_irq(pdev, i);
+					free_irq(irq, ndev);
+				}
+				goto failed_irq;
+			}
 		}
 	}
 
@@ -1835,6 +1900,11 @@ fec_probe(struct platform_device *pdev)
 		ret = PTR_ERR(fep->clk);
 		goto failed_clk;
 	}
+	fep->mdc_clk = clk_get(&pdev->dev, "fec_mdc_clk");
+	if (IS_ERR(fep->mdc_clk)) {
+		ret = PTR_ERR(fep->mdc_clk);
+		goto failed_clk;
+	}
 	clk_enable(fep->clk);
 
 	ret = fec_enet_init(ndev);
@@ -1861,6 +1931,8 @@ fec_probe(struct platform_device *pdev)
 	netif_carrier_off(ndev);
 	clk_disable(fep->clk);
 
+	INIT_DELAYED_WORK(&fep->fixup_trigger_tx, fixup_trigger_tx_func);
+
 	ret = register_netdev(ndev);
 	if (ret)
 		goto failed_register;
@@ -1876,11 +1948,16 @@ failed_mii_init:
 failed_init:
 	clk_disable(fep->clk);
 	clk_put(fep->clk);
+	clk_put(fep->mdc_clk);
 failed_clk:
-	for (i = 0; i < 3; i++) {
-		irq = platform_get_irq(pdev, i);
-		if (irq > 0)
-			free_irq(irq, ndev);
+	if (pdata->gpio_irq < 0)
+		free_irq(irq, ndev);
+	else {
+		for (i = 0; i < 3; i++) {
+			irq = platform_get_irq(pdev, i);
+			if (irq > 0)
+				free_irq(irq, ndev);
+		}
 	}
 failed_irq:
 	iounmap(fep->hwp);
@@ -1899,10 +1976,12 @@ fec_drv_remove(struct platform_device *pdev)
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	struct resource *r;
 
+	cancel_delayed_work_sync(&fep->fixup_trigger_tx);
 	fec_stop(ndev);
 	fec_enet_mii_remove(fep);
 	clk_disable(fep->clk);
 	clk_put(fep->clk);
+	clk_put(fep->mdc_clk);
 	iounmap((void __iomem *)ndev->base_addr);
 	if (fep->ptimer_present)
 		fec_ptp_cleanup(fep->ptp_priv);
diff --git a/drivers/net/fec_1588.c b/drivers/net/fec_1588.c
index 43b6094..74fa168 100644
--- a/drivers/net/fec_1588.c
+++ b/drivers/net/fec_1588.c
@@ -26,18 +26,11 @@
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/vmalloc.h>
-#include <linux/spinlock.h>
 #include <linux/ip.h>
 #include <linux/udp.h>
 #include "fec.h"
 #include "fec_1588.h"
 
-static DECLARE_WAIT_QUEUE_HEAD(ptp_rx_ts_wait);
-static DECLARE_WAIT_QUEUE_HEAD(ptp_tx_ts_wait);
-
-#define PTP_GET_RX_TIMEOUT      (HZ)
-#define PTP_GET_TX_TIMEOUT      (HZ)
-
 #if defined(CONFIG_ARCH_MX28)
 static struct fec_ptp_private *ptp_private[2];
 #elif defined(CONFIG_ARCH_MX6)
@@ -45,15 +38,16 @@ static struct fec_ptp_private *ptp_private[1];
 #endif
 
 /* Alloc the ring resource */
-static int fec_ptp_init_circ(struct circ_buf *ptp_buf, int size)
+static int fec_ptp_init_circ(struct fec_ptp_circular *buf, int size)
 {
-	ptp_buf->buf = vmalloc(size * sizeof(struct fec_ptp_data_t));
+	buf->data_buf = (struct fec_ptp_ts_data *)
+		vmalloc(size * sizeof(struct fec_ptp_ts_data));
 
-	if (!ptp_buf->buf)
+	if (!buf->data_buf)
 		return 1;
-	ptp_buf->head = 0;
-	ptp_buf->tail = 0;
-
+	buf->front = 0;
+	buf->end = 0;
+	buf->size = size;
 	return 0;
 }
 
@@ -62,15 +56,16 @@ static inline int fec_ptp_calc_index(int size, int curr_index, int offset)
 	return (curr_index + offset) % size;
 }
 
-static int fec_ptp_is_empty(struct circ_buf *buf)
+static int fec_ptp_is_empty(struct fec_ptp_circular *buf)
 {
-	return (buf->head == buf->tail);
+	return (buf->front == buf->end);
 }
 
-static int fec_ptp_nelems(struct circ_buf *buf, int size)
+static int fec_ptp_nelems(struct fec_ptp_circular *buf)
 {
-	const int front = buf->head;
-	const int end = buf->tail;
+	const int front = buf->front;
+	const int end = buf->end;
+	const int size = buf->size;
 	int n_items;
 
 	if (end > front)
@@ -83,73 +78,76 @@ static int fec_ptp_nelems(struct circ_buf *buf, int size)
 	return n_items;
 }
 
-static int fec_ptp_is_full(struct circ_buf *buf, int size)
+static int fec_ptp_is_full(struct fec_ptp_circular *buf)
 {
-	if (fec_ptp_nelems(buf, size) ==
-				(size - 1))
+	if (fec_ptp_nelems(buf) == (buf->size - 1))
 		return 1;
 	else
 		return 0;
 }
 
-static int fec_ptp_insert(struct circ_buf *ptp_buf,
-			  struct fec_ptp_data_t *data,
-			  struct fec_ptp_private *priv,
-			  int size)
-{
-	struct fec_ptp_data_t *tmp;
-
-	if (fec_ptp_is_full(ptp_buf, size))
-		return 1;
+static int fec_ptp_insert(struct fec_ptp_circular *ptp_buf,
+			  struct fec_ptp_ts_data *data)
 
-	spin_lock(&priv->ptp_lock);
-	tmp = (struct fec_ptp_data_t *)(ptp_buf->buf) + ptp_buf->tail;
+{
+	struct fec_ptp_ts_data *tmp;
 
-	tmp->key = data->key;
-	memcpy(tmp->spid, data->spid, 10);
-	tmp->ts_time.sec = data->ts_time.sec;
-	tmp->ts_time.nsec = data->ts_time.nsec;
+	if (fec_ptp_is_full(ptp_buf))
+		ptp_buf->end = fec_ptp_calc_index(ptp_buf->size,
+						ptp_buf->end, 1);
 
-	ptp_buf->tail = fec_ptp_calc_index(size, ptp_buf->tail, 1);
-	spin_unlock(&priv->ptp_lock);
+	tmp = (ptp_buf->data_buf + ptp_buf->end);
+	memcpy(tmp, data, sizeof(struct fec_ptp_ts_data));
+	ptp_buf->end = fec_ptp_calc_index(ptp_buf->size, ptp_buf->end, 1);
 
 	return 0;
 }
 
-static int fec_ptp_find_and_remove(struct circ_buf *ptp_buf,
-				   struct fec_ptp_data_t *data,
-				   struct fec_ptp_private *priv,
-				   int size)
+static int fec_ptp_find_and_remove(struct fec_ptp_circular *ptp_buf,
+			struct fec_ptp_ident *ident, struct ptp_time *ts)
 {
 	int i;
-	int end = ptp_buf->tail;
-	unsigned long flags;
-	struct fec_ptp_data_t *tmp;
+	int size = ptp_buf->size, end = ptp_buf->end;
+	struct fec_ptp_ident *tmp_ident;
 
 	if (fec_ptp_is_empty(ptp_buf))
 		return 1;
 
-	i = ptp_buf->head;
+	i = ptp_buf->front;
 	while (i != end) {
-		tmp = (struct fec_ptp_data_t *)(ptp_buf->buf) + i;
-		if (tmp->key == data->key &&
-				!memcmp(tmp->spid, data->spid, 10))
-			break;
+		tmp_ident = &(ptp_buf->data_buf + i)->ident;
+		if (tmp_ident->version == ident->version) {
+			if (tmp_ident->message_type == ident->message_type) {
+				if ((tmp_ident->netw_prot == ident->netw_prot)
+				|| (ident->netw_prot ==
+					FEC_PTP_PROT_DONTCARE)) {
+					if (tmp_ident->seq_id ==
+							ident->seq_id) {
+						int ret =
+						memcmp(tmp_ident->spid,
+							ident->spid,
+							PTP_SOURCE_PORT_LENGTH);
+						if (0 == ret)
+							break;
+					}
+				}
+			}
+		}
+		/* get next */
 		i = fec_ptp_calc_index(size, i, 1);
 	}
 
-	spin_lock_irqsave(&priv->ptp_lock, flags);
+	/* not found ? */
 	if (i == end) {
-		ptp_buf->head = end;
-		spin_unlock_irqrestore(&priv->ptp_lock, flags);
+		/* buffer full ? */
+		if (fec_ptp_is_full(ptp_buf))
+			/* drop one in front */
+			ptp_buf->front =
+			fec_ptp_calc_index(size, ptp_buf->front, 1);
+
 		return 1;
 	}
-
-	data->ts_time.sec = tmp->ts_time.sec;
-	data->ts_time.nsec = tmp->ts_time.nsec;
-
-	ptp_buf->head = fec_ptp_calc_index(size, i, 1);
-	spin_unlock_irqrestore(&priv->ptp_lock, flags);
+	*ts = (ptp_buf->data_buf + i)->ts;
 
 	return 0;
 }
@@ -211,7 +209,6 @@ void fec_ptp_stop(struct fec_ptp_private *priv)
 	writel(FEC_T_CTRL_RESTART, fpp->hwp + FEC_ATIME_CTRL);
 	priv->ptp_active = 0;
 	priv->ptp_slave = 0;
-
 }
 
 static void fec_get_curr_cnt(struct fec_ptp_private *priv,
@@ -263,22 +260,100 @@ static void fec_set_1588cnt(struct fec_ptp_private *priv,
 	spin_unlock_irqrestore(&priv->cnt_lock, flags);
 }
 
+/**
+ * Parse packets if they are PTP.
+ * The PTP header can be found in an IPv4, IPv6 or in an IEEE802.3
+ * ethernet frame. The function returns the position of the PTP packet
+ * or NULL, if no PTP found
+ */
+u8 *fec_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
+{
+	u8 *position = skb->data + ETH_ALEN + ETH_ALEN;
+	u8 *ptp_loc = NULL;
+
+	*eth_type = *((u16 *)position);
+	/* Check if outer vlan tag is here */
+	if (*eth_type == ETH_P_8021Q) {
+		position += FEC_VLAN_TAG_LEN;
+		*eth_type = *((u16 *)position);
+	}
+
+	/* set position after ethertype */
+	position += FEC_ETHTYPE_LEN;
+	if (ETH_P_1588 == *eth_type) {
+		ptp_loc = position;
+		/* IEEE1588 event message which needs timestamping */
+		if ((ptp_loc[0] & 0xF) <= 3) {
+			if (skb->len >=
+			((ptp_loc - skb->data) + PTP_HEADER_SZE))
+				return ptp_loc;
+		}
+	} else if (ETH_P_IP == ntohs(*eth_type)) {
+		u8 *ip_header, *prot, *udp_header;
+		u8 ip_version, ip_hlen;
+		ip_header = position;
+		ip_version = ip_header[0] >> 4; /* correct IP version? */
+		if (0x04 == ip_version) { /* IPv4 */
+			prot = ip_header + 9; /* protocol */
+			if (FEC_PACKET_TYPE_UDP == *prot) {
+				u16 udp_dstPort;
+				/* retrieve the size of the ip-header
+				 * with the first byte of the ip-header:
+				 * version ( 4 bits) + Internet header
+				 * length (4 bits)
+				 */
+				ip_hlen   = (*ip_header & 0xf) * 4;
+				udp_header = ip_header + ip_hlen;
+				udp_dstPort = *((u16 *)(udp_header + 2));
+				/* check the destination port address
+				 * ( 319 (0x013F) = PTP event port )
+				 */
+				if (ntohs(udp_dstPort) == PTP_EVENT_PORT) {
+					ptp_loc = udp_header + 8;
+					/* long enough ? */
+					if (skb->len >= ((ptp_loc - skb->data)
+							+ PTP_HEADER_SZE))
+						return ptp_loc;
+				}
+			}
+		}
+	} else if (ETH_P_IPV6 == ntohs(*eth_type)) {
+		u8 *ip_header, *udp_header, *prot;
+		u8 ip_version;
+		ip_header = position;
+		ip_version = ip_header[0] >> 4;
+		if (0x06 == ip_version) {
+			prot = ip_header + 6;
+			if (FEC_PACKET_TYPE_UDP == *prot) {
+				u16 udp_dstPort;
+				udp_header = ip_header + 40;
+				udp_dstPort = *((u16 *)(udp_header + 2));
+				/* check the destination port address
+				 * ( 319 (0x013F) = PTP event port )
+				 */
+				if (ntohs(udp_dstPort) == PTP_EVENT_PORT) {
+					ptp_loc = udp_header + 8;
+					/* long enough ? */
+					if (skb->len >= ((ptp_loc - skb->data)
+							+ PTP_HEADER_SZE))
+						return ptp_loc;
+				}
+			}
+		}
+	}
+
+	return NULL; /* no PTP frame */
+}
+
 /* Set the BD to ptp */
 int fec_ptp_do_txstamp(struct sk_buff *skb)
 {
-	struct iphdr *iph;
-	struct udphdr *udph;
-
-	if (skb->len > 44) {
-		/* Check if port is 319 for PTP Event, and check for UDP */
-		iph = ip_hdr(skb);
-		if (iph == NULL || iph->protocol != FEC_PACKET_TYPE_UDP)
-			return 0;
-
-		udph = udp_hdr(skb);
-		if (udph != NULL && ntohs(udph->dest) == 319)
-			return 1;
-	}
+	u8 *ptp_loc;
+	u16 eth_type;
+
+	ptp_loc = fec_ptp_parse_packet(skb, &eth_type);
+	if (ptp_loc != NULL)
+		return 1;
 
 	return 0;
 }
@@ -287,288 +362,113 @@ void fec_ptp_store_txstamp(struct fec_ptp_private *priv,
 			   struct sk_buff *skb,
 			   struct bufdesc *bdp)
 {
-	int msg_type, seq_id, control;
-	struct fec_ptp_data_t tmp_tx_time;
+	struct fec_ptp_ts_data tmp_tx_time;
 	struct fec_ptp_private *fpp;
-	unsigned char *sp_id;
-	unsigned short portnum;
+	u8 *ptp_loc;
+	u16 eth_type;
 
 	if (!priv->ptp_slave)
 		fpp = priv;
 	else
 		fpp = ptp_private[0];
 
-	seq_id = *((u16 *)(skb->data + FEC_PTP_SEQ_ID_OFFS));
-	control = *((u8 *)(skb->data + FEC_PTP_CTRL_OFFS));
-	sp_id = skb->data + FEC_PTP_SPORT_ID_OFFS;
-	portnum = ntohs(*((unsigned short *)(sp_id + 8)));
-
-	tmp_tx_time.key = ntohs(seq_id);
-	memcpy(tmp_tx_time.spid, sp_id, 8);
-	memcpy(tmp_tx_time.spid + 8, (unsigned char *)&portnum, 2);
-	tmp_tx_time.ts_time.sec = fpp->prtc;
-	tmp_tx_time.ts_time.nsec = bdp->ts;
-
-	switch (control) {
-
-	case PTP_MSG_SYNC:
-		fec_ptp_insert(&(priv->tx_time_sync), &tmp_tx_time, priv,
-				DEFAULT_PTP_TX_BUF_SZ);
-		break;
-
-	case PTP_MSG_DEL_REQ:
-		fec_ptp_insert(&(priv->tx_time_del_req), &tmp_tx_time, priv,
-				DEFAULT_PTP_TX_BUF_SZ);
-		break;
-
-	/* clear transportSpecific field*/
-	case PTP_MSG_ALL_OTHER:
-		msg_type = (*((u8 *)(skb->data +
-				FEC_PTP_MSG_TYPE_OFFS))) & 0x0F;
-		switch (msg_type) {
-		case PTP_MSG_P_DEL_REQ:
-			fec_ptp_insert(&(priv->tx_time_pdel_req), &tmp_tx_time,
-					priv, DEFAULT_PTP_TX_BUF_SZ);
+	ptp_loc = fec_ptp_parse_packet(skb, &eth_type);
+	if (ptp_loc != NULL) {
+		/* store identification data */
+		switch (ntohs(eth_type)) {
+		case ETH_P_IP:
+			tmp_tx_time.ident.netw_prot = FEC_PTP_PROT_IPV4;
 			break;
-		case PTP_MSG_P_DEL_RESP:
-			fec_ptp_insert(&(priv->tx_time_pdel_resp), &tmp_tx_time,
-					priv, DEFAULT_PTP_TX_BUF_SZ);
+		case ETH_P_IPV6:
+			tmp_tx_time.ident.netw_prot = FEC_PTP_PROT_IPV6;
 			break;
-		default:
+		case ETH_P_1588:
+			tmp_tx_time.ident.netw_prot = FEC_PTP_PROT_802_3;
 			break;
+		default:
+			return;
 		}
-		break;
-	default:
-		break;
+		tmp_tx_time.ident.version = (*(ptp_loc + 1)) & 0X0F;
+		tmp_tx_time.ident.message_type = (*(ptp_loc)) & 0x0F;
+		tmp_tx_time.ident.seq_id =
+			ntohs(*((u16 *)(ptp_loc + PTP_HEADER_SEQ_OFFS)));
+		memcpy(tmp_tx_time.ident.spid, &ptp_loc[PTP_SPID_OFFS],
+						PTP_SOURCE_PORT_LENGTH);
+		/* store tx timestamp */
+		tmp_tx_time.ts.sec = fpp->prtc;
+		tmp_tx_time.ts.nsec = bdp->ts;
+		/* insert timestamp in circular buffer */
+		fec_ptp_insert(&(priv->tx_timestamps), &tmp_tx_time);
 	}
-
-	wake_up_interruptible(&ptp_tx_ts_wait);
 }
 
 void fec_ptp_store_rxstamp(struct fec_ptp_private *priv,
 			   struct sk_buff *skb,
 			   struct bufdesc *bdp)
 {
-	int msg_type, seq_id, control;
-	struct fec_ptp_data_t tmp_rx_time;
+	struct fec_ptp_ts_data tmp_rx_time;
 	struct fec_ptp_private *fpp;
-	struct iphdr *iph;
-	struct udphdr *udph;
-	unsigned char *sp_id;
-	unsigned short portnum;
+	u8 *ptp_loc;
+	u16 eth_type;
 
 	if (!priv->ptp_slave)
 		fpp = priv;
 	else
 		fpp = ptp_private[0];
 
-	/* Check for UDP, and Check if port is 319 for PTP Event */
-	iph = (struct iphdr *)(skb->data + FEC_PTP_IP_OFFS);
-	if (iph->protocol != FEC_PACKET_TYPE_UDP)
-		return;
-
-	udph = (struct udphdr *)(skb->data + FEC_PTP_UDP_OFFS);
-	if (ntohs(udph->dest) != 319)
-		return;
-
-	seq_id = *((u16 *)(skb->data + FEC_PTP_SEQ_ID_OFFS));
-	control = *((u8 *)(skb->data + FEC_PTP_CTRL_OFFS));
-	sp_id = skb->data + FEC_PTP_SPORT_ID_OFFS;
-	portnum = ntohs(*((unsigned short *)(sp_id + 8)));
-
-	tmp_rx_time.key = ntohs(seq_id);
-	memcpy(tmp_rx_time.spid, sp_id, 8);
-	memcpy(tmp_rx_time.spid + 8, (unsigned char *)&portnum, 2);
-	tmp_rx_time.ts_time.sec = fpp->prtc;
-	tmp_rx_time.ts_time.nsec = bdp->ts;
-
-	switch (control) {
-
-	case PTP_MSG_SYNC:
-		fec_ptp_insert(&(priv->rx_time_sync), &tmp_rx_time, priv,
-				DEFAULT_PTP_RX_BUF_SZ);
-		break;
-
-	case PTP_MSG_DEL_REQ:
-		fec_ptp_insert(&(priv->rx_time_del_req), &tmp_rx_time, priv,
-				DEFAULT_PTP_RX_BUF_SZ);
-		break;
-
-	/* clear transportSpecific field*/
-	case PTP_MSG_ALL_OTHER:
-		msg_type = (*((u8 *)(skb->data +
-				FEC_PTP_MSG_TYPE_OFFS))) & 0x0F;
-		switch (msg_type) {
-		case PTP_MSG_P_DEL_REQ:
-			fec_ptp_insert(&(priv->rx_time_pdel_req), &tmp_rx_time,
-					priv, DEFAULT_PTP_RX_BUF_SZ);
+	ptp_loc = fec_ptp_parse_packet(skb, &eth_type);
+	if (ptp_loc != NULL) {
+		/* store identification data */
+		tmp_rx_time.ident.version = (*(ptp_loc + 1)) & 0X0F;
+		tmp_rx_time.ident.message_type = (*(ptp_loc)) & 0x0F;
+		switch (ntohs(eth_type)) {
+		case ETH_P_IP:
+			tmp_rx_time.ident.netw_prot = FEC_PTP_PROT_IPV4;
 			break;
-		case PTP_MSG_P_DEL_RESP:
-			fec_ptp_insert(&(priv->rx_time_pdel_resp), &tmp_rx_time,
-					priv, DEFAULT_PTP_RX_BUF_SZ);
+		case ETH_P_IPV6:
+			tmp_rx_time.ident.netw_prot = FEC_PTP_PROT_IPV6;
 			break;
-		default:
+		case ETH_P_1588:
+			tmp_rx_time.ident.netw_prot = FEC_PTP_PROT_802_3;
 			break;
+		default:
+			return;
 		}
-		break;
-	default:
-		break;
+		tmp_rx_time.ident.seq_id =
+			ntohs(*((u16 *)(ptp_loc + PTP_HEADER_SEQ_OFFS)));
+		memcpy(tmp_rx_time.ident.spid, &ptp_loc[PTP_SPID_OFFS],
+						PTP_SOURCE_PORT_LENGTH);
+		/* store rx timestamp */
+		tmp_rx_time.ts.sec = fpp->prtc;
+		tmp_rx_time.ts.nsec = bdp->ts;
+
+		/* insert timestamp in circular buffer */
+		fec_ptp_insert(&(fpp->rx_timestamps), &tmp_rx_time);
 	}
-
-	wake_up_interruptible(&ptp_rx_ts_wait);
 }
 
 static uint8_t fec_get_tx_timestamp(struct fec_ptp_private *priv,
-				    struct ptp_ts_data *pts,
+				    struct fec_ptp_ts_data *pts,
 				    struct ptp_time *tx_time)
 {
-	struct fec_ptp_data_t tmp;
-	int flag;
-	u8 mode;
-
-	tmp.key = pts->seq_id;
-	memcpy(tmp.spid, pts->spid, 10);
-	mode = pts->message_type;
-
-	switch (mode) {
-	case PTP_MSG_SYNC:
-		flag = fec_ptp_find_and_remove(&(priv->tx_time_sync), &tmp,
-						priv, DEFAULT_PTP_TX_BUF_SZ);
-		break;
-	case PTP_MSG_DEL_REQ:
-		flag = fec_ptp_find_and_remove(&(priv->tx_time_del_req), &tmp,
-						priv, DEFAULT_PTP_TX_BUF_SZ);
-		break;
+	int ret = 0;
 
-	case PTP_MSG_P_DEL_REQ:
-		flag = fec_ptp_find_and_remove(&(priv->tx_time_pdel_req), &tmp,
-						priv, DEFAULT_PTP_TX_BUF_SZ);
-		break;
-	case PTP_MSG_P_DEL_RESP:
-		flag = fec_ptp_find_and_remove(&(priv->tx_time_pdel_resp), &tmp,
-						priv, DEFAULT_PTP_TX_BUF_SZ);
-		break;
-
-	default:
-		flag = 1;
-		printk(KERN_ERR "ERROR\n");
-		break;
-	}
-
-	if (!flag) {
-		tx_time->sec = tmp.ts_time.sec;
-		tx_time->nsec = tmp.ts_time.nsec;
-		return 0;
-	} else {
-		wait_event_interruptible_timeout(ptp_tx_ts_wait, 0,
-					PTP_GET_TX_TIMEOUT);
-
-		switch (mode) {
-		case PTP_MSG_SYNC:
-			flag = fec_ptp_find_and_remove(&(priv->tx_time_sync),
-					&tmp, priv, DEFAULT_PTP_TX_BUF_SZ);
-			break;
-		case PTP_MSG_DEL_REQ:
-			flag = fec_ptp_find_and_remove(&(priv->tx_time_del_req),
-					&tmp, priv, DEFAULT_PTP_TX_BUF_SZ);
-			break;
-		case PTP_MSG_P_DEL_REQ:
-			flag = fec_ptp_find_and_remove(
-				&(priv->tx_time_pdel_req), &tmp, priv,
-				DEFAULT_PTP_TX_BUF_SZ);
-			break;
-		case PTP_MSG_P_DEL_RESP:
-			flag = fec_ptp_find_and_remove(
-				&(priv->tx_time_pdel_resp), &tmp, priv,
-				DEFAULT_PTP_TX_BUF_SZ);
-			break;
-		}
-
-		if (flag == 0) {
-			tx_time->sec = tmp.ts_time.sec;
-			tx_time->nsec = tmp.ts_time.nsec;
-			return 0;
-		}
+	ret = fec_ptp_find_and_remove(&(priv->tx_timestamps),
+					&pts->ident, tx_time);
 
-		return -1;
-	}
+	return ret;
 }
 
 static uint8_t fec_get_rx_timestamp(struct fec_ptp_private *priv,
-				    struct ptp_ts_data *pts,
+				    struct fec_ptp_ts_data *pts,
 				    struct ptp_time *rx_time)
 {
-	struct fec_ptp_data_t tmp;
-	int flag;
-	u8 mode;
-
-	tmp.key = pts->seq_id;
-	memcpy(tmp.spid, pts->spid, 10);
-	mode = pts->message_type;
-
-	switch (mode) {
-	case PTP_MSG_SYNC:
-		flag = fec_ptp_find_and_remove(&(priv->rx_time_sync), &tmp,
-				priv, DEFAULT_PTP_RX_BUF_SZ);
-		break;
-	case PTP_MSG_DEL_REQ:
-		flag = fec_ptp_find_and_remove(&(priv->rx_time_del_req), &tmp,
-				priv, DEFAULT_PTP_RX_BUF_SZ);
-		break;
-
-	case PTP_MSG_P_DEL_REQ:
-		flag = fec_ptp_find_and_remove(&(priv->rx_time_pdel_req), &tmp,
-				priv, DEFAULT_PTP_RX_BUF_SZ);
-		break;
-	case PTP_MSG_P_DEL_RESP:
-		flag = fec_ptp_find_and_remove(&(priv->rx_time_pdel_resp), &tmp,
-				priv, DEFAULT_PTP_RX_BUF_SZ);
-		break;
-
-	default:
-		flag = 1;
-		printk(KERN_ERR "ERROR\n");
-		break;
-	}
+	int ret = 0;
 
-	if (!flag) {
-		rx_time->sec = tmp.ts_time.sec;
-		rx_time->nsec = tmp.ts_time.nsec;
-		return 0;
-	} else {
-		wait_event_interruptible_timeout(ptp_rx_ts_wait, 0,
-					PTP_GET_RX_TIMEOUT);
+	ret = fec_ptp_find_and_remove(&(priv->rx_timestamps),
+					&pts->ident, rx_time);
 
-		switch (mode) {
-		case PTP_MSG_SYNC:
-			flag = fec_ptp_find_and_remove(&(priv->rx_time_sync),
-				&tmp, priv, DEFAULT_PTP_RX_BUF_SZ);
-			break;
-		case PTP_MSG_DEL_REQ:
-			flag = fec_ptp_find_and_remove(
-				&(priv->rx_time_del_req), &tmp, priv,
-				DEFAULT_PTP_RX_BUF_SZ);
-			break;
-		case PTP_MSG_P_DEL_REQ:
-			flag = fec_ptp_find_and_remove(
-				&(priv->rx_time_pdel_req), &tmp, priv,
-				DEFAULT_PTP_RX_BUF_SZ);
-			break;
-		case PTP_MSG_P_DEL_RESP:
-			flag = fec_ptp_find_and_remove(
-				&(priv->rx_time_pdel_resp), &tmp, priv,
-				DEFAULT_PTP_RX_BUF_SZ);
-			break;
-		}
-
-		if (flag == 0) {
-			rx_time->sec = tmp.ts_time.sec;
-			rx_time->nsec = tmp.ts_time.nsec;
-			return 0;
-		}
-
-		return -1;
-	}
+	return ret;
 }
 
 static void fec_handle_ptpdrift(struct ptp_set_comp *comp,
@@ -593,13 +493,14 @@ static void fec_handle_ptpdrift(struct ptp_set_comp *comp,
 		adj_inc = 1;
 
 		if (ndrift > (FEC_ATIME_CLK / FEC_T_INC_CLK)) {
-			adj_inc = FEC_T_INC_CLK / 2;
-		} else if (ndrift > (FEC_ATIME_CLK / (FEC_T_INC_CLK * 4))) {
-			adj_inc = FEC_T_INC_CLK / 4;
-			adj_period = 2;
+			adj_inc = FEC_T_INC_CLK / FEC_PTP_SPINNER_2;
+		} else if (ndrift > (FEC_ATIME_CLK /
+			(FEC_T_INC_CLK * FEC_PTP_SPINNER_4))) {
+			adj_inc = FEC_T_INC_CLK / FEC_PTP_SPINNER_4;
+			adj_period = FEC_PTP_SPINNER_2;
 		} else {
-			adj_inc = 4;
-			adj_period = 4;
+			adj_inc = FEC_PTP_SPINNER_4;
+			adj_period = FEC_PTP_SPINNER_4;
 		}
 
 		for (i = 1; i < adj_inc; i++) {
@@ -647,86 +548,79 @@ static void fec_set_drift(struct fec_ptp_private *priv,
 	writel(tc.corr_period, fpp->hwp + FEC_ATIME_CORR);
 }
 
-static int ptp_open(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int ptp_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static long ptp_ioctl(
-	struct file *file,
-	unsigned int cmd,
-	unsigned long arg)
+int fec_ptp_ioctl(struct fec_ptp_private *priv, struct ifreq *ifr, int cmd)
 {
-	struct ptp_rtc_time *cnt;
 	struct ptp_rtc_time curr_time;
 	struct ptp_time rx_time, tx_time;
-	struct ptp_ts_data *p_ts;
-	struct ptp_set_comp *p_comp;
-	struct fec_ptp_private *priv;
-	unsigned int minor = MINOR(file->f_path.dentry->d_inode->i_rdev);
+	struct fec_ptp_ts_data p_ts;
+	struct fec_ptp_ts_data *p_ts_user;
+	struct ptp_set_comp p_comp;
+	u32 freq_compensation;
 	int retval = 0;
 
-	priv = (struct fec_ptp_private *) ptp_private[minor];
-
 	switch (cmd) {
+	case PTP_ENBL_TXTS_IOCTL:
+	case PTP_DSBL_TXTS_IOCTL:
+	case PTP_ENBL_RXTS_IOCTL:
+	case PTP_DSBL_RXTS_IOCTL:
+		break;
 	case PTP_GET_RX_TIMESTAMP:
-		p_ts = (struct ptp_ts_data *)arg;
-		retval = fec_get_rx_timestamp(priv, p_ts, &rx_time);
-		if (retval == 0 &&
-			copy_to_user((void __user *)(&(p_ts->ts)), &rx_time,
-					sizeof(rx_time)))
-			retval = -EFAULT;
+		p_ts_user = (struct fec_ptp_ts_data *)ifr->ifr_data;
+		if (0 != copy_from_user(&p_ts.ident,
+			&p_ts_user->ident, sizeof(p_ts.ident)))
+			return -EINVAL;
+		if (fec_get_rx_timestamp(priv, &p_ts, &rx_time) != 0)
+			return -EAGAIN;
+		if (copy_to_user((void __user *)(&p_ts_user->ts),
+			&rx_time, sizeof(rx_time)))
+			return -EFAULT;
 		break;
 	case PTP_GET_TX_TIMESTAMP:
-		p_ts = (struct ptp_ts_data *)arg;
-		fec_get_tx_timestamp(priv, p_ts, &tx_time);
-		if (copy_to_user((void __user *)(&(p_ts->ts)), &tx_time,
-				sizeof(tx_time)))
+		p_ts_user = (struct fec_ptp_ts_data *)ifr->ifr_data;
+		if (0 != copy_from_user(&p_ts.ident,
+			&p_ts_user->ident, sizeof(p_ts.ident)))
+			return -EINVAL;
+		retval = fec_get_tx_timestamp(priv, &p_ts, &tx_time);
+		if (retval == 0 &&
+			copy_to_user((void __user *)(&p_ts_user->ts),
+				&tx_time, sizeof(tx_time)))
 			retval = -EFAULT;
 		break;
 	case PTP_GET_CURRENT_TIME:
 		fec_get_curr_cnt(priv, &curr_time);
-		if (copy_to_user((void __user *)arg, &curr_time,
-			sizeof(curr_time)))
-			retval = -EFAULT;;
+		if (0 != copy_to_user(ifr->ifr_data,
+					&(curr_time.rtc_time),
+					sizeof(struct ptp_time)))
+			return -EFAULT;
 		break;
 	case PTP_SET_RTC_TIME:
-		cnt = (struct ptp_rtc_time *)arg;
-		fec_set_1588cnt(priv, cnt);
+		if (0 != copy_from_user(&(curr_time.rtc_time),
+					ifr->ifr_data,
+					sizeof(struct ptp_time)))
+			return -EINVAL;
+		fec_set_1588cnt(priv, &curr_time);
 		break;
 	case PTP_FLUSH_TIMESTAMP:
-		/* reset sync buffer */
-		priv->rx_time_sync.head = 0;
-		priv->rx_time_sync.tail = 0;
-		priv->tx_time_sync.head = 0;
-		priv->tx_time_sync.tail = 0;
-		/* reset delay_req buffer */
-		priv->rx_time_del_req.head = 0;
-		priv->rx_time_del_req.tail = 0;
-		priv->tx_time_del_req.head = 0;
-		priv->tx_time_del_req.tail = 0;
-		/* reset pdelay_req buffer */
-		priv->rx_time_pdel_req.head = 0;
-		priv->rx_time_pdel_req.tail = 0;
-		priv->tx_time_pdel_req.head = 0;
-		priv->tx_time_pdel_req.tail = 0;
-		/* reset pdelay_resp buffer */
-		priv->rx_time_pdel_resp.head = 0;
-		priv->rx_time_pdel_resp.tail = 0;
-		priv->tx_time_pdel_resp.head = 0;
-		priv->tx_time_pdel_resp.tail = 0;
+		/* reset tx-timestamping buffer */
+		priv->tx_timestamps.front = 0;
+		priv->tx_timestamps.end = 0;
+		priv->tx_timestamps.size = (DEFAULT_PTP_TX_BUF_SZ + 1);
+		/* reset rx-timestamping buffer */
+		priv->rx_timestamps.front = 0;
+		priv->rx_timestamps.end = 0;
+		priv->rx_timestamps.size = (DEFAULT_PTP_RX_BUF_SZ + 1);
 		break;
 	case PTP_SET_COMPENSATION:
-		p_comp = (struct ptp_set_comp *)arg;
-		fec_set_drift(priv, p_comp);
+		if (0 != copy_from_user(&p_comp, ifr->ifr_data,
+			sizeof(struct ptp_set_comp)))
+			return -EINVAL;
+		fec_set_drift(priv, &p_comp);
 		break;
 	case PTP_GET_ORIG_COMP:
-		((struct ptp_get_comp *)arg)->dw_origcomp = FEC_PTP_ORIG_COMP;
+		freq_compensation = FEC_PTP_ORIG_COMP;
+		if (copy_to_user(ifr->ifr_data, &freq_compensation,
+					sizeof(freq_compensation)) > 0)
+			return -EFAULT;
 		break;
 	default:
 		return -EINVAL;
@@ -734,76 +628,32 @@ static long ptp_ioctl(
 	return retval;
 }
 
-static const struct file_operations ptp_fops = {
-	.owner	= THIS_MODULE,
-	.llseek	= NULL,
-	.read	= NULL,
-	.write	= NULL,
-	.unlocked_ioctl = ptp_ioctl,
-	.open	= ptp_open,
-	.release = ptp_release,
-};
-
-static int init_ptp(void)
-{
-	if (register_chrdev(PTP_MAJOR, "ptp", &ptp_fops))
-		printk(KERN_ERR "Unable to register PTP device as char\n");
-	else
-		printk(KERN_INFO "Register PTP device as char /dev/ptp\n");
-
-	return 0;
-}
-
-static void ptp_free(void)
-{
-	/*unregister the PTP device*/
-	unregister_chrdev(PTP_MAJOR, "ptp");
-}
-
 /*
  * Resource required for accessing 1588 Timer Registers.
  */
 int fec_ptp_init(struct fec_ptp_private *priv, int id)
 {
-	fec_ptp_init_circ(&(priv->rx_time_sync), DEFAULT_PTP_RX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->rx_time_del_req), DEFAULT_PTP_RX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->rx_time_pdel_req), DEFAULT_PTP_RX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->rx_time_pdel_resp), DEFAULT_PTP_RX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->tx_time_sync), DEFAULT_PTP_TX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->tx_time_del_req), DEFAULT_PTP_TX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->tx_time_pdel_req), DEFAULT_PTP_TX_BUF_SZ);
-	fec_ptp_init_circ(&(priv->tx_time_pdel_resp), DEFAULT_PTP_TX_BUF_SZ);
-
-	spin_lock_init(&priv->ptp_lock);
+	/* initialize circular buffer for tx timestamps */
+	if (fec_ptp_init_circ(&(priv->tx_timestamps),
+			(DEFAULT_PTP_TX_BUF_SZ+1)))
+		return 1;
+	/* initialize circular buffer for rx timestamps */
+	if (fec_ptp_init_circ(&(priv->rx_timestamps),
+			(DEFAULT_PTP_RX_BUF_SZ+1)))
+		return 1;
+
 	spin_lock_init(&priv->cnt_lock);
 	ptp_private[id] = priv;
 	priv->dev_id = id;
-	if (id == 0)
-		init_ptp();
 	return 0;
 }
 EXPORT_SYMBOL(fec_ptp_init);
 
 void fec_ptp_cleanup(struct fec_ptp_private *priv)
 {
-
-	if (priv->rx_time_sync.buf)
-		vfree(priv->rx_time_sync.buf);
-	if (priv->rx_time_del_req.buf)
-		vfree(priv->rx_time_del_req.buf);
-	if (priv->rx_time_pdel_req.buf)
-		vfree(priv->rx_time_pdel_req.buf);
-	if (priv->rx_time_pdel_resp.buf)
-		vfree(priv->rx_time_pdel_resp.buf);
-	if (priv->tx_time_sync.buf)
-		vfree(priv->tx_time_sync.buf);
-	if (priv->tx_time_del_req.buf)
-		vfree(priv->tx_time_del_req.buf);
-	if (priv->tx_time_pdel_req.buf)
-		vfree(priv->tx_time_pdel_req.buf);
-	if (priv->tx_time_pdel_resp.buf)
-		vfree(priv->tx_time_pdel_resp.buf);
-
-	ptp_free();
+	if (priv->tx_timestamps.data_buf)
+		vfree(priv->tx_timestamps.data_buf);
+	if (priv->rx_timestamps.data_buf)
+		vfree(priv->rx_timestamps.data_buf);
 }
 EXPORT_SYMBOL(fec_ptp_cleanup);
diff --git a/drivers/net/fec_1588.h b/drivers/net/fec_1588.h
index 8e21519..9daf9de 100644
--- a/drivers/net/fec_1588.h
+++ b/drivers/net/fec_1588.h
@@ -41,7 +41,6 @@
 #define FEC_T_INC_CORR_MASK		0x00007f00
 #define FEC_T_INC_CORR_OFFSET		8
 
-
 #define FEC_T_INC_50MHZ			20
 #define FEC_ATIME_50MHZ			50000000
 #define FEC_T_INC_CLK			FEC_T_INC_50MHZ
@@ -51,41 +50,45 @@
 
 /* IEEE 1588 definition */
 #define FEC_ECNTRL_TS_EN	0x10
-#define PTP_MAJOR		232	/*the temporary major number
-						 *used by PTP driver, the major
-						 *number 232~239 is unassigned*/
-
-#define DEFAULT_PTP_RX_BUF_SZ		2048
-#define DEFAULT_PTP_TX_BUF_SZ		16
-#define PTP_MSG_SYNC			0x0
-#define PTP_MSG_DEL_REQ			0x1
-#define PTP_MSG_P_DEL_REQ		0x2
-#define PTP_MSG_P_DEL_RESP		0x3
-#define PTP_MSG_DEL_RESP		0x4
-#define PTP_MSG_ALL_OTHER		0x5
-
-#define PTP_GET_TX_TIMESTAMP		0x1
-#define PTP_GET_RX_TIMESTAMP		0x9
-#define PTP_SET_RTC_TIME		0x3
-#define PTP_SET_COMPENSATION		0x4
-#define PTP_GET_CURRENT_TIME		0x5
-#define PTP_FLUSH_TIMESTAMP		0x6
-#define PTP_ADJ_ADDEND			0x7
-#define PTP_GET_ORIG_COMP		0x8
-#define PTP_GET_ADDEND			0xB
-#define PTP_GET_RX_TIMESTAMP_PDELAY_REQ		0xC
-#define PTP_GET_RX_TIMESTAMP_PDELAY_RESP	0xD
-
-#define FEC_PTP_DOMAIN_DLFT		0xe0000181
-#define FEC_PTP_IP_OFFS			0xE
-#define FEC_PTP_UDP_OFFS		0x22
-#define FEC_PTP_MSG_TYPE_OFFS		0x2A
-#define FEC_PTP_SPORT_ID_OFFS		0x3E
-#define FEC_PTP_SEQ_ID_OFFS		0x48
-#define FEC_PTP_CTRL_OFFS		0x4A
+
+#define DEFAULT_PTP_RX_BUF_SZ		64
+#define DEFAULT_PTP_TX_BUF_SZ		64
+
+/* 1588stack API defines */
+#define PTP_ENBL_TXTS_IOCTL	SIOCDEVPRIVATE
+#define PTP_DSBL_TXTS_IOCTL	(SIOCDEVPRIVATE + 1)
+#define PTP_ENBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 2)
+#define PTP_DSBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 3)
+#define PTP_GET_TX_TIMESTAMP	(SIOCDEVPRIVATE + 4)
+#define PTP_GET_RX_TIMESTAMP	(SIOCDEVPRIVATE + 5)
+#define PTP_SET_RTC_TIME	(SIOCDEVPRIVATE + 6)
+#define PTP_GET_CURRENT_TIME	(SIOCDEVPRIVATE + 7)
+#define PTP_SET_COMPENSATION	(SIOCDEVPRIVATE + 9)
+#define PTP_GET_ORIG_COMP	(SIOCDEVPRIVATE + 10)
+#define PTP_FLUSH_TIMESTAMP	(SIOCDEVPRIVATE + 11)
+
+/* IEEE1588 ptp head format */
+#define PTP_CTRL_OFFS		0x52
+#define PTP_SOURCE_PORT_LENGTH	10
+#define	PTP_HEADER_SEQ_OFFS	30
+#define PTP_HEADER_CTL_OFFS	32
+#define PTP_SPID_OFFS		20
+#define PTP_HEADER_SZE		34
+#define PTP_EVENT_PORT		0x013F
+
+#define FEC_VLAN_TAG_LEN	0x04
+#define FEC_ETHTYPE_LEN		0x02
+
+/* 1588-2008 network protocol enumeration values */
+#define FEC_PTP_PROT_IPV4		1
+#define FEC_PTP_PROT_IPV6		2
+#define FEC_PTP_PROT_802_3		3
+#define FEC_PTP_PROT_DONTCARE		0xFFFF
 #define FEC_PACKET_TYPE_UDP		0x11
 
 #define FEC_PTP_ORIG_COMP		0x15555555
+#define FEC_PTP_SPINNER_2		2
+#define FEC_PTP_SPINNER_4		4
 
 /* PTP standard time representation structure */
 struct ptp_time{
@@ -93,27 +96,30 @@ struct ptp_time{
 	u32 nsec;	/* nanoseconds */
 };
 
-/* Structure for PTP Time Stamp */
-struct fec_ptp_data_t {
-	u8		spid[10];
-	int		key;
-	struct ptp_time	ts_time;
+/* struct needed to identify a timestamp */
+struct fec_ptp_ident {
+	u8	version;
+	u8	message_type;
+	u16	netw_prot;
+	u16	seq_id;
+	u8	spid[10];
 };
 
 /* interface for PTP driver command GET_TX_TIME */
-struct ptp_ts_data {
-	/* PTP version */
-	u8 version;
-	/* PTP source port ID */
-	u8 spid[10];
-	/* PTP sequence ID */
-	u16 seq_id;
-	/* PTP message type */
-	u8 message_type;
+struct fec_ptp_ts_data {
+	struct fec_ptp_ident ident;
 	/* PTP timestamp */
 	struct ptp_time ts;
 };
 
+/* circular buffer for ptp timestamps over ioctl */
+struct fec_ptp_circular {
+	int	front;
+	int	end;
+	int	size;
+	struct	fec_ptp_ts_data	*data_buf;
+};
+
 /* interface for PTP driver command SET_RTC_TIME/GET_CURRENT_TIME */
 struct ptp_rtc_time {
 	struct ptp_time rtc_time;
@@ -156,15 +162,8 @@ struct fec_ptp_private {
 	void __iomem *hwp;
 	int	dev_id;
 
-	struct	circ_buf rx_time_sync;
-	struct	circ_buf rx_time_del_req;
-	struct	circ_buf rx_time_pdel_req;
-	struct	circ_buf rx_time_pdel_resp;
-	struct	circ_buf tx_time_sync;
-	struct	circ_buf tx_time_del_req;
-	struct	circ_buf tx_time_pdel_req;
-	struct	circ_buf tx_time_pdel_resp;
-	spinlock_t ptp_lock;
+	struct fec_ptp_circular tx_timestamps;
+	struct fec_ptp_circular rx_timestamps;
 	spinlock_t cnt_lock;
 
 	u64	prtc;
@@ -190,6 +189,8 @@ extern void fec_ptp_store_txstamp(struct fec_ptp_private *priv,
 extern void fec_ptp_store_rxstamp(struct fec_ptp_private *priv,
 				  struct sk_buff *skb,
 				  struct bufdesc *bdp);
+extern int fec_ptp_ioctl(struct fec_ptp_private *priv,
+				struct ifreq *ifr, int cmd);
 #else
 static inline int fec_ptp_malloc_priv(struct fec_ptp_private **priv)
 {
@@ -215,6 +216,12 @@ static inline void fec_ptp_store_txstamp(struct fec_ptp_private *priv,
 static inline void fec_ptp_store_rxstamp(struct fec_ptp_private *priv,
 					 struct sk_buff *skb,
 					 struct bufdesc *bdp) {}
+static inline int fec_ptp_ioctl(struct fec_ptp_private *priv,
+				struct ifreq *ifr, int cmd)
+{
+	return 0;
+}
+
 #endif /* 1588 */
 
 #endif
diff --git a/drivers/power/sabresd_battery.c b/drivers/power/sabresd_battery.c
index 6489221..b84f0d4 100755
--- a/drivers/power/sabresd_battery.c
+++ b/drivers/power/sabresd_battery.c
@@ -2,7 +2,7 @@
  * sabresd_battery.c - Maxim 8903 USB/Adapter Charger Driver
  *
  * Copyright (C) 2011 Samsung Electronics
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  * Based on max8903_charger.c
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -300,12 +300,8 @@ static void max8903_battery_update_status(struct max8903_data *data)
 			temp_last = temp;
 		}
 		if (data->charger_online == 0 && temp_last != 0) {
-			if (temp < temp_last) {
-				temp_last = temp;
-				data->voltage_uV = temp;
-			} else {
-			data->voltage_uV = temp_last;
-			}
+			temp_last = temp;
+			data->voltage_uV = temp;
 		}
 		if (data->charger_online == 1 || data->usb_charger_online == 1) {
 			data->voltage_uV = temp;
diff --git a/drivers/regulator/pfuze100-regulator.c b/drivers/regulator/pfuze100-regulator.c
index 8ab80b7..bd356c4 100644
--- a/drivers/regulator/pfuze100-regulator.c
+++ b/drivers/regulator/pfuze100-regulator.c
@@ -631,9 +631,9 @@ static int pfuze100_regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 	 * 02: 8us,
 	 * 03: 16us,
 	 */
-	step_delay >>= 5;
+	step_delay >>= 6;
 	step_delay &= 0x3;
-	step_delay <<= 1;
+	step_delay = 2  <<  step_delay;
 
 	if (pfuze100_regulators[id].voltages[old_sel] <
 		pfuze100_regulators[id].voltages[new_sel])
diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index e610ec0..a512a76 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -818,8 +818,11 @@ static void imx_finish_dma(struct imx_port *sport)
  *   [2] the Aging timer expires(wait for 8 bytes long)
  *   [3] the Idle Condition Detect(enabled the UCR4_IDDMAEN).
  *
- * The [2] and [3] are similar, but [3] is better.
- * [3] can wait for 32 bytes long, so we do not use [2].
+ * [2] is trigger when a character was been sitting in the FIFO
+ * meanwhile [3] can wait for 32 bytes long when the RX line is
+ * on IDLE state and RxFIFO is empty.
+ * Bluetooth H4 is very susceptible to Rx timeouts if data is not available
+ * in a specific period of time so we use both.
  */
 static void dma_rx_callback(void *data)
 {
@@ -1060,8 +1063,8 @@ static int imx_startup(struct uart_port *port)
 	temp |= UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN;
 	if (sport->enable_dma) {
 		temp |= UCR1_RDMAEN | UCR1_TDMAEN;
-		/* ICD, wait for more than 32 frames, but it still to short. */
-		temp |= UCR1_ICD_REG(3);
+		/* ICD,await 4 idle frames also enable AGING Timer */
+		temp |= UCR1_ICD_REG(0)|UCR1_ATDMAEN;
 	}
 
 	if (USE_IRDA(sport)) {
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index f147c62..3eaea9d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1319,6 +1319,7 @@ int usb_suspend(struct device *dev, pm_message_t msg)
 	choose_wakeup(udev, msg);
 	return usb_suspend_both(udev, msg);
 }
+EXPORT_SYMBOL(usb_suspend);
 
 /* The device lock is held by the PM core */
 int usb_resume(struct device *dev, pm_message_t msg)
@@ -1353,6 +1354,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 		status = 0;
 	return status;
 }
+EXPORT_SYMBOL(usb_resume);
 
 #endif /* CONFIG_PM */
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 55a63e4..90241fa 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -156,7 +156,50 @@ EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+static u8 usb_device_white_list[] = {
+	USB_CLASS_HID,
+	USB_CLASS_HUB,
+	USB_CLASS_MASS_STORAGE
+};
+
+static inline int in_white_list(u8 interfaceclass)
+{
+	int i;
+	for (i = 0; i < sizeof(usb_device_white_list); i++)	{
+		if (interfaceclass == usb_device_white_list[i])
+			return 1;
+	}
+	return 0;
+}
+
+static inline int device_in_white_list(struct usb_device *udev)
+{
+	int i;
+	int num_configs;
+	struct usb_host_config *c;
+
+	/* for test fixture, we always return 1 */
+	if (udev->descriptor.idVendor == 0x1A0A)
+		return 1;
+
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c->desc.bNumInterfaces > 0)
+			desc = &c->intf_cache[0]->altsetting->desc;
 
+		if (desc && !in_white_list((u8)desc->bInterfaceClass))
+			continue;
+
+		return 1;
+	}
+	return 0;
+}
+#endif
 static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
@@ -1903,6 +1946,14 @@ int usb_new_device(struct usb_device *udev)
 	udev->dev.devt = MKDEV(USB_DEVICE_MAJOR,
 			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+	if (!device_in_white_list(udev)) {
+		printk(KERN_ERR "unsupported device: not in white list\n");
+		goto fail;
+	} else {
+		printk(KERN_DEBUG "supported device\n");
+	}
+#endif
 	/* Tell the world! */
 	announce_device(udev);
 
@@ -3309,6 +3360,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_set_device_state(udev, USB_STATE_POWERED);
  		udev->bus_mA = hub->mA_per_port;
 		udev->level = hdev->level + 1;
+#ifdef CONFIG_FSL_USB_TEST_MODE
+		printk(KERN_INFO "+++ %s:udev->level :%d", __func__,
+						udev->level);
+#endif
 		udev->wusb = hub_is_wusb(hub);
 
 		/* Only USB 3.0 devices are connected to SuperSpeed hubs. */
@@ -3527,6 +3582,10 @@ static void hub_events(void)
 			if (ret < 0)
 				continue;
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+			if (portstatus & USB_PORT_STAT_TEST)
+				continue;
+#endif
 			if (portchange & USB_PORT_STAT_C_CONNECTION) {
 				clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_CONNECTION);
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 32d3adc..1b5eaa0 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -80,9 +80,6 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Logitech Quickcam Pro 9000 */
 	{ USB_DEVICE(0x046d, 0x0990), .driver_info = USB_QUIRK_RESET_RESUME },
 
-	/* Logitech Quickcam E3500 */
-	{ USB_DEVICE(0x046d, 0x09a4), .driver_info = USB_QUIRK_RESET_RESUME },
-
 	/* Logitech Quickcam Vision Pro */
 	{ USB_DEVICE(0x046d, 0x09a6), .driver_info = USB_QUIRK_RESET_RESUME },
 
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 484e62e..087350a 100755
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -70,7 +70,6 @@
 #endif
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 DEFINE_MUTEX(udc_resume_mutex);
-extern void usb_debounce_id_vbus(void);
 static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
@@ -562,6 +561,8 @@ static void dr_controller_stop(struct fsl_udc *udc)
 	tmp &= ~USB_CMD_RUN_STOP;
 	fsl_writel(tmp, &dr_regs->usbcmd);
 
+	/* disable pulldown dp and dm */
+	dr_discharge_line(udc->pdata, true);
 	return;
 }
 
@@ -958,11 +959,8 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 			(unsigned)EP_MAX_LENGTH_TRANSFER);
 	if (NEED_IRAM(req->ep))
 		*length = min(*length, g_iram_size);
-#ifdef CONFIG_FSL_UTP
+
 	dtd = dma_pool_alloc_nonbufferable(udc_controller->td_pool, GFP_ATOMIC, dma);
-#else
-	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_ATOMIC, dma);
-#endif
 	if (dtd == NULL)
 		return dtd;
 
@@ -1550,6 +1548,19 @@ static void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)
 	udc->device_address = (u8) value;
 	/* Update usb state */
 	udc->usb_state = USB_STATE_ADDRESS;
+
+	/* for USB CV 3.0 test, the gap between the ACK of the set_address
+	 * and the subsequently setup packet may be very little, say 500us,
+	 * and if the latency we handle the ep completion is greater than
+	 * this gap, there is no response to the subsequent setup packet.
+	 * It will cause the CV test fail */
+	/* There is another way to set address, we can set the bit 24 to
+	 * 1 to make IC set this address instead of SW, it is more fast
+	 * and safe than SW way */
+	fsl_writel(udc->device_address << USB_DEVICE_ADDRESS_BIT_POS |
+			1 << USB_DEVICE_ADDRESS_ADV_BIT_POS,
+			&dr_regs->deviceaddr);
+
 	/* Status phase */
 	if (ep0_prime_status(udc, EP_DIR_IN))
 		ep0stall(udc);
@@ -1762,13 +1773,6 @@ static void setup_received_irq(struct fsl_udc *udc,
 static void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,
 		struct fsl_req *req)
 {
-	if (udc->usb_state == USB_STATE_ADDRESS) {
-		/* Set the new address */
-		u32 new_address = (u32) udc->device_address;
-		fsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
-				&dr_regs->deviceaddr);
-	}
-
 	done(ep0, req, 0);
 }
 
@@ -2513,6 +2517,7 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 
 	dr_phy_low_power_mode(udc_controller, true);
 
+	dr_clk_gate(false);
 	printk(KERN_INFO "unregistered gadget driver '%s'\r\n",
 	       driver->driver.name);
 	return 0;
@@ -2905,6 +2910,7 @@ static void fsl_udc_release(struct device *dev)
 	dma_free_coherent(dev, udc_controller->ep_qh_size,
 			udc_controller->ep_qh, udc_controller->ep_qh_dma);
 	kfree(udc_controller);
+	udc_controller = NULL;
 }
 
 /******************************************************************
@@ -3068,6 +3074,7 @@ static int __devinit fsl_udc_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto err2a;
 	}
+	pdata->lowpower = false;
 
 	spin_lock_init(&pdata->lock);
 
@@ -3223,6 +3230,7 @@ err4:
 err3:
 	free_irq(udc_controller->irq, udc_controller);
 err2:
+	dr_phy_low_power_mode(udc_controller, true);
 	if (pdata->exit)
 		pdata->exit(pdata->pdev);
 err2a:
@@ -3239,19 +3247,27 @@ err1a:
 /* Driver removal function
  * Free resources and finish pending transactions
  */
-static int __exit fsl_udc_remove(struct platform_device *pdev)
+static int  fsl_udc_remove(struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-
+	u32 temp;
 	DECLARE_COMPLETION(done);
 
 	if (!udc_controller)
 		return -ENODEV;
 	udc_controller->done = &done;
 	/* open USB PHY clock */
-	if (udc_controller->stopped)
-		dr_clk_gate(true);
+	dr_clk_gate(true);
+
+	/* disable wake up and otgsc interrupt for safely remove udc driver*/
+	temp = fsl_readl(&dr_regs->otgsc);
+	temp &= ~(0x7f << 24);
+	fsl_writel(temp, &dr_regs->otgsc);
+	dr_wake_up_enable(udc_controller, false);
+
+	dr_discharge_line(pdata, true);
 
+	dr_clk_gate(false);
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
 
@@ -3283,20 +3299,16 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	release_mem_region(res->start, resource_size(res));
 }
 #endif
-
 	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
+
 	/*
-	 * do platform specific un-initialization:
-	 * release iomux pins, etc.
+	 * do platform specific un-initialization
 	 */
 	if (pdata->exit)
 		pdata->exit(pdata->pdev);
 
-	if (udc_controller->stopped)
-		dr_clk_gate(false);
-
 	return 0;
 }
 
@@ -3436,7 +3448,6 @@ static int fsl_udc_resume(struct platform_device *pdev)
 		u32 temp;
 		if (udc_controller->stopped)
 			dr_clk_gate(true);
-		usb_debounce_id_vbus();
 		if (fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID) {
 			temp = fsl_readl(&dr_regs->otgsc);
 			/* if b_session_irq_en is cleared by otg */
@@ -3483,7 +3494,6 @@ static int fsl_udc_resume(struct platform_device *pdev)
 			dr_clk_gate(true);
 		dr_wake_up_enable(udc_controller, false);
 		dr_phy_low_power_mode(udc_controller, false);
-		usb_debounce_id_vbus();
 		/* if in host mode, we need to do nothing */
 		if ((fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID) == 0) {
 			dr_phy_low_power_mode(udc_controller, true);
@@ -3523,7 +3533,7 @@ end:
 --------------------------------------------------------------------------*/
 
 static struct platform_driver udc_driver = {
-	.remove  = __exit_p(fsl_udc_remove),
+	.remove  = fsl_udc_remove,
 	/* these suspend and resume are not usb suspend and resume */
 	.suspend = fsl_udc_suspend,
 	.resume  = fsl_udc_resume,
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index 35a2790..bd2afbf 100755
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -202,6 +202,7 @@ struct usb_sys_interface {
 /* Device Address bit masks */
 #define  USB_DEVICE_ADDRESS_MASK              (0xFE000000)
 #define  USB_DEVICE_ADDRESS_BIT_POS           (25)
+#define  USB_DEVICE_ADDRESS_ADV_BIT_POS       (24)
 
 /* endpoint list address bit masks */
 #define USB_EP_LIST_ADDRESS_MASK              (0xfffff800)
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 9e99765..c9f9a65 100755
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -59,6 +59,13 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config FSL_USB_TEST_MODE
+	bool "FSL High-speed Electrical Test Mode Support"
+	depends on USB_EHCI_ARC
+	default n
+	---help---
+	    enable freescale test mode
+
 config USB_EHCI_ARC
 	bool "Support for Freescale controller"
 	depends on USB_EHCI_HCD && (ARCH_MXC || ARCH_STMP3XXX || ARCH_MXS)
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 624a362..0bcc665 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -35,3 +35,4 @@ obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
+obj-$(CONFIG_FSL_USB_TEST_MODE)	+= arc_hset.o
diff --git a/drivers/usb/host/arc_hset.c b/drivers/usb/host/arc_hset.c
new file mode 100644
index 0000000..2ec9055
--- /dev/null
+++ b/drivers/usb/host/arc_hset.c
@@ -0,0 +1,468 @@
+/*
+ * HS USB Host-mode HSET driver for ARC USB controller
+ * Copyright 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Zhang Yan <jasper.zhang@freescale.com>
+ * Peter Chen <peter.chen@freescale.com>  */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define EHCI_IAA_MSECS		10		/* arbitrary */
+#include <linux/usb/hcd.h>
+#include "../core/usb.h"
+#include "ehci-fsl.h"
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <mach/arc_otg.h>
+#include "ehci.h"
+
+#define rh_level 1
+#define SINGLE_STEP_SLEEP_COUNT  15000
+#define USB_HIGH_SPEED		0x01
+#define USB_FULL_SPEED		0x02
+#define USB_LOW_SPEED		0x03
+
+/* ARC port test mode */
+#define PORTSC_PTC_TEST_MODE_DISABLE	0x00
+#define PORTSC_PTC_TEST_J		0x01
+#define PORTSC_PTC_TEST_K		0x02
+#define PORTSC_PTC_SE0_NAK		0x03
+#define PORTSC_PTC_TEST_PACKET		0x04
+#define PORTSC_PTC_FORCE_ENABLE_HS	0x05
+#define PORTSC_PTC_FORCE_ENABLE_FS	0x06
+#define PORTSC_PTC_FORCE_ENABLE_LS	0x07
+
+/* Other test */
+#define HSET_TEST_SUSPEND_RESUME	0x08
+#define HSET_TEST_GET_DEV_DESC		0x09
+#define HSET_TEST_GET_DEV_DESC_DATA	0x0A
+
+
+#define TEST_DEVICE_VID	 0x1A0A
+static struct usb_device_id archset_table[] = {
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0101) },	/* Test_SE0_NAK */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0102) },	/* Test_J */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0103) },	/* Test_K */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0104) },	/* Test_Packet */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0105) },	/* Force enable */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0106) },	/* HS_HOST_PORT_SUSPEND_RESUME */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0107) },	/* SINGLE_STEP_GET_DEV_DESC */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0108) },	/* SINGLE_STEP_GET_DEV_DESC_DATA */
+	{ }	/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, archset_table);
+
+/* Private data */
+struct usb_archset {
+	struct usb_device    *udev;	/* the usb device for this device */
+	struct usb_interface *interface;	/* the interface for this device */
+	struct kref           kref;
+	struct ehci_hcd       *ehci;	/* the usb controller */
+	char                  ptcname[24];
+};
+
+ void set_single_step_desc_data_on(void);
+ void clear_single_step_desc_data_on(void);
+
+static void arc_kill_per_sched(struct ehci_hcd *ehci)
+{
+	u32 command = 0;
+	command = ehci_readl(ehci, &ehci->regs->command);
+	command &= ~(CMD_PSE);
+	ehci_writel(ehci, command, &ehci->regs->command);
+	printk(KERN_INFO "+++ %s: Periodic Schedule Stopped", __func__);
+}
+
+static void arc_hset_test(struct ehci_hcd *ehci, int mode)
+{
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc &= ~(0xf << 16);
+	portsc |= (mode << 16);
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+static inline void hub_set_testmode(struct usb_device *udev, u8
+			test_mode)
+{
+	struct usb_device *hub_dev;
+	int i;
+	int max_port;
+	int status;
+	u8 level = udev->level;
+
+	if (level == 0)
+		return;
+	else {
+		printk(KERN_INFO "run %s at tie %d hub\n", __func__, level);
+		/* get the port number of parent */
+		if (udev->parent != NULL) {
+			hub_dev = udev->parent;
+			max_port = hub_dev->maxchild;
+		} else {
+			printk(KERN_INFO "device don't have parent hub\n");
+			return;
+		}
+
+		for (i = 0; i < max_port; i++) {
+			status = usb_control_msg(hub_dev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RT_PORT,
+				USB_PORT_FEAT_SUSPEND, i+1,
+				NULL, 0, 1000);
+			if (status >= 0)
+				printk(KERN_INFO "send port_suspend to port %d\n", i+1);
+			else {
+				printk(KERN_INFO "send port_suspend error %d to port %d\n",
+					status, i+1);
+				continue;
+			}
+		}
+		msleep(1000);
+		status = usb_control_msg(hub_dev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE/*USB_REQ_CLEAR_FEATURE*/, USB_RT_PORT,
+				USB_PORT_FEAT_TEST, (__u16) ((test_mode << 8) | udev->portnum),
+				NULL, 0, 1000);
+		if (status >= 0)
+			printk(KERN_INFO "send cmd %d to port %d\n", test_mode, udev->portnum);
+		else
+			printk(KERN_INFO "send cmd %d error %d to port %d\n", test_mode, status, udev->portnum);
+	}
+}
+
+static inline void test_j(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	if (level == rh_level) {
+		printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_J);
+	} else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_J);
+}
+
+static inline void test_k(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_K);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_K);
+}
+
+static inline void test_se0_nak(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_SE0_NAK);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_SE0_NAK);
+}
+
+static inline void test_packet(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_PACKET);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_PACKET);
+}
+
+static inline void test_force_enable(struct usb_archset *hset, int
+			forcemode)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	int ptc_fmode = 0;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == 0) {
+		switch (forcemode) {
+		case USB_HIGH_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_HS;
+			break;
+		case USB_FULL_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_FS;
+			break;
+		case USB_LOW_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_LS;
+			break;
+		default:
+			printk(KERN_ERR "unknown speed mode %d\n", forcemode);
+			return;
+		}
+		arc_hset_test(hset->ehci, ptc_fmode);
+	} else
+		hub_set_testmode(udev, PORTSC_PTC_FORCE_ENABLE_HS);
+}
+
+static void suspend(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc |= PORT_SUSPEND;	/* Set suspend */
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+
+static void resume(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc |= PORT_RESUME;
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+static void test_suspend_resume(struct usb_archset *hset)
+{
+	printk(KERN_INFO "%s\n", __func__);
+
+	suspend(hset);
+	msleep(15000);	/* Wait for 15s */
+	resume(hset);
+}
+
+static void test_single_step_get_dev_desc(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	struct usb_bus *bus = hcd_to_bus(ehci_to_hcd(ehci));
+	struct usb_device *udev = hset->udev;
+	int    result;
+
+	if (!ehci || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+
+	if (!udev) {
+		printk(KERN_ERR "No device connected.\n");
+		return;
+	}
+
+	/* Stop Periodic schedule to prevent polling of hubs */
+	arc_kill_per_sched(hset->ehci);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);	/* SOF for 15s */
+
+	result = usb_get_device_descriptor(udev, sizeof(struct usb_device_descriptor));
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "usb_get_device_descriptor failed %d\n", result);
+	else
+		printk(KERN_INFO "usb_get_device_descriptor passed\n");
+}
+static void test_single_step_get_dev_desc_data(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	struct usb_device_descriptor *desc;
+	int    result;
+	unsigned int size = sizeof(struct usb_device_descriptor);
+	printk(KERN_INFO "%s size = %d\n", __func__, size);
+	desc = kmalloc(sizeof(*desc), GFP_NOIO);
+	if (!desc) {
+		printk(KERN_ERR "alloc desc failed\n");
+		return ;
+	}
+
+	set_single_step_desc_data_on();
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size, USB_CTRL_GET_TIMEOUT);
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the setup transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the setup transaction passed\n");
+
+
+	/* Stop Periodic schedule to prevent polling of hubs */
+	arc_kill_per_sched(hset->ehci);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size,	USB_CTRL_GET_TIMEOUT);
+	if (result <= 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the data transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the data transaction passed\n");
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size, USB_CTRL_GET_TIMEOUT);
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the status transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the status transaction passed\n");
+
+	clear_single_step_desc_data_on();
+
+	kfree(desc);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);	/* SOF for 15s */
+	printk(KERN_INFO "test_single_step_get_dev_desc_data finished\n");
+}
+
+
+void test_single_step_set_feature(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	struct usb_bus *bus = hcd_to_bus(ehci_to_hcd(ehci));
+	struct usb_device *udev;
+
+	if (!ehci || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_ERR "No device connected.\n");
+		return;
+	}
+	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, 0, 0, 0,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+static struct usb_archset *the_hset[4];
+static struct usb_archset *init_hset_dev(void *controller)
+{
+	struct ehci_hcd *ehci = (struct ehci_hcd *)controller;
+	struct usb_archset *hset = NULL;
+	int ctrid = 0;
+
+	ctrid = ehci_to_hcd(ehci)->self.busnum-1;
+	if (the_hset[ctrid]) {
+		kref_get(&the_hset[ctrid]->kref);
+		return the_hset[ctrid];
+	}
+
+	hset = kzalloc(sizeof(struct usb_archset), GFP_KERNEL);
+	if (hset == NULL) {
+		printk(KERN_ERR "Out of memory!\n");
+		return NULL;
+	}
+	hset->ehci = (struct ehci_hcd *)controller;
+	kref_init(&hset->kref);
+	the_hset[ctrid] = hset;
+
+	return hset;
+}
+
+
+static void hset_delete(struct kref *kref)
+{
+	struct usb_archset *hset = container_of(kref, struct usb_archset,
+								kref);
+
+	kfree(hset);
+}
+
+static int archset_probe(struct usb_interface *iface,
+		const struct usb_device_id *id)
+{
+	struct usb_archset *hset;
+	struct usb_device *udev;
+	struct usb_hcd *hcd;
+
+	udev = usb_get_dev(interface_to_usbdev(iface));
+	hcd = bus_to_hcd(udev->bus);
+	hset = init_hset_dev((void *)hcd_to_ehci(hcd));
+	if (hset == NULL)
+		return -ENOMEM;
+
+	hset->udev = udev;
+	usb_set_intfdata(iface, hset);
+	switch (id->idProduct) {
+	case 0x0101:
+		test_se0_nak(hset);
+		break;
+	case 0x0102:
+		test_j(hset);
+		break;
+	case 0x0103:
+		test_k(hset);
+		break;
+	case 0x0104:
+		test_packet(hset);
+		break;
+	case 0x0105:
+		printk(KERN_INFO "Force FS/FS/LS ?\n");
+		test_force_enable(hset, USB_HIGH_SPEED);
+		break;
+	case 0x0106:
+		test_suspend_resume(hset);
+		break;
+	case 0x0107:
+		printk(KERN_INFO "Begin SINGLE_STEP_GET_DEVICE_DESCRIPTOR\n");
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 0x0108:
+		printk(KERN_INFO "Begin SINGLE_STEP_GET_DEVICE_DESCRIPTOR_DATA\n");
+		test_single_step_get_dev_desc_data(hset);
+		break;
+	}
+
+	return 0;
+}
+
+static void archset_disconnect(struct usb_interface *iface)
+{
+	struct usb_archset *hset;
+
+	hset = usb_get_intfdata(iface);
+	usb_set_intfdata(iface, NULL);
+
+	usb_put_dev(hset->udev);
+	kref_put(&hset->kref, hset_delete);
+}
+
+
+static struct usb_driver archset_driver = {
+	.name = "arc hset",
+	.probe = archset_probe,
+	.disconnect = archset_disconnect,
+	.id_table = archset_table,
+};
+
+static int __init usb_hset_init(void)
+{
+	int ret = 0;
+	printk(KERN_ERR "usb register error with %d\n", ret);
+	/* register driver to usb subsystem */
+	ret = usb_register(&archset_driver);
+    if (ret)
+		printk(KERN_ERR "usb register error with %d\n", ret);
+	else
+		printk(KERN_INFO "usb hset init succeed\n");
+
+	return ret;
+}
+
+static void __exit usb_hset_exit(void)
+{
+	usb_deregister(&archset_driver);
+}
+
+module_init(usb_hset_init);
+module_exit(usb_hset_exit);
+MODULE_DESCRIPTION("Freescale USB Host Test Mode Driver");
+MODULE_AUTHOR("Jasper Zhang");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/usb/host/ehci-arc.c b/drivers/usb/host/ehci-arc.c
index cf9d9e1..dde47dd 100755
--- a/drivers/usb/host/ehci-arc.c
+++ b/drivers/usb/host/ehci-arc.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2005 MontaVista Software
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -249,6 +249,7 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		retval = -ENODEV;
 		goto err4;
 	}
+	pdata->lowpower = false;
 
 	spin_lock_init(&pdata->lock);
 
@@ -314,7 +315,10 @@ err2:
 	usb_put_hcd(hcd);
 err1:
 	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
-	if (pdata->exit)
+	fsl_usb_lowpower_mode(pdata, true);
+	if (pdata->usb_clock_for_pm)
+		pdata->usb_clock_for_pm(false);
+	if (pdata->exit && pdata->pdev)
 		pdata->exit(pdata->pdev);
 	return retval;
 }
@@ -332,26 +336,29 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	u32 tmp;
 
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
 		/* Need open clock for register access */
 		if (pdata->usb_clock_for_pm)
 			pdata->usb_clock_for_pm(true);
 
-		tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
-		if (tmp & PORT_PTS_PHCD) {
-			tmp &= ~PORT_PTS_PHCD;
-			ehci_writel(ehci, tmp, &ehci->regs->port_status[0]);
-			msleep(100);
+		/*disable the wakeup to avoid an abnormal wakeup interrupt*/
+		usb_host_set_wakeup(hcd->self.controller, false);
 
-			if (pdata->usb_clock_for_pm)
-				pdata->usb_clock_for_pm(false);
-		}
+		/* Put the PHY out of low power mode */
+		fsl_usb_lowpower_mode(pdata, false);
 	}
 
-	/* DDD shouldn't we turn off the power here? */
-	fsl_platform_set_vbus_power(pdata, 0);
+	/* disable the host wakeup */
+	usb_host_set_wakeup(hcd->self.controller, false);
+	/*free the ehci_fsl_pre_irq  */
+	free_irq(hcd->irq, (void *)pdev);
+
+	usb_remove_hcd(hcd);
+
+	ehci_port_power(ehci, 0);
+
+	iounmap(hcd->regs);
 
 	if (ehci->transceiver) {
 		(void)otg_set_host(ehci->transceiver, 0);
@@ -359,22 +366,23 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 	} else {
 		release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	}
-	/*disable the host wakeup and put phy to low power mode */
-	usb_host_set_wakeup(hcd->self.controller, false);
-	fsl_usb_lowpower_mode(pdata, true);
-	/*free the ehci_fsl_pre_irq  */
-	free_irq(hcd->irq, (void *)pdev);
-	usb_remove_hcd(hcd);
+
 	usb_put_hcd(hcd);
 
+	fsl_usb_lowpower_mode(pdata, true);
+
+	/* Close the VBUS */
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, pdata, 0);
+
+	if (pdata->usb_clock_for_pm)
+		pdata->usb_clock_for_pm(false);
+
 	/*
-	 * do platform specific un-initialization:
-	 * release iomux pins clocks, etc.
+	 * do platform specific un-initialization
 	 */
-	if (pdata->exit)
+	if (pdata->exit && pdata->pdev)
 		pdata->exit(pdata->pdev);
-
-	iounmap(hcd->regs);
 }
 
 static void fsl_setup_phy(struct ehci_hcd *ehci,
@@ -408,11 +416,23 @@ static void fsl_setup_phy(struct ehci_hcd *ehci,
 	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
 }
 
+static void ehci_fsl_stream_disable(struct ehci_hcd *ehci)
+{
+	u32 __iomem	*reg_ptr;
+	u32		tmp;
+
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
+	tmp = ehci_readl(ehci, reg_ptr);
+	tmp |= CI_USBMODE_SDIS;
+	ehci_writel(ehci, tmp, reg_ptr);
+}
+
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_fsl_reinit(struct ehci_hcd *ehci)
 {
 	fsl_platform_usb_setup(ehci);
 	ehci_port_power(ehci, 0);
+	ehci_fsl_stream_disable(ehci);
 
 	return 0;
 }
@@ -662,17 +682,32 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	/* Only handles OTG mode switch event, system suspend event will be done in bus suspend */
 	if (pdata->pmflags == 0) {
 		printk(KERN_DEBUG "%s, pm event \n", __func__);
+		disable_irq(hcd->irq);
 		if (!host_can_wakeup_system(pdev)) {
 			/* Need open clock for register access */
 			fsl_usb_clk_gate(hcd->self.controller->platform_data, true);
+			/*
+			 * Disable wakeup interrupt, since there is wakeup
+			 * when phcd from 1->0 if wakeup interrupt is enabled
+			 */
+			usb_host_set_wakeup(hcd->self.controller, false);
+
+			/*
+			 * Open PHY's clock, then the wakeup settings
+			 * can be wroten correctly
+			 */
+			fsl_usb_lowpower_mode(pdata, false);
 
 			usb_host_set_wakeup(hcd->self.controller, false);
 
+			fsl_usb_lowpower_mode(pdata, true);
+
 			fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
 		} else {
 			if (pdata->platform_phy_power_on)
 				pdata->platform_phy_power_on();
 		}
+		enable_irq(hcd->irq);
 
 		printk(KERN_DEBUG "host suspend ends\n");
 		return 0;
@@ -744,13 +779,18 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	return 0;
 }
 
+#define OTGSC_OFFSET 		0x64
+#define OTGSC_ID_VALUE		(1 << 8)
+#define OTGSC_ID_INT_STS	(1 << 16)
 static int ehci_fsl_drv_resume(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct usb_device *roothub = hcd->self.root_hub;
 	unsigned long flags;
-	u32 tmp;
+	u32 tmp, otgsc;
+	bool id_changed;
+	int id_value;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	struct fsl_usb2_wakeup_platform_data *wake_up_pdata = pdata->wakeup_pdata;
 	/* Only handles OTG mode switch event */
@@ -758,29 +798,36 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	if (pdata->pmflags == 0) {
 		printk(KERN_DEBUG "%s,pm event, wait for wakeup irq if needed\n", __func__);
 		wait_event_interruptible(wake_up_pdata->wq, !wake_up_pdata->usb_wakeup_is_pending);
+		disable_irq(hcd->irq);
 		if (!host_can_wakeup_system(pdev)) {
 			/* Need open clock for register access */
 			fsl_usb_clk_gate(hcd->self.controller->platform_data, true);
+			fsl_usb_lowpower_mode(pdata, false);
 
-			usb_host_set_wakeup(hcd->self.controller, true);
-
-#ifndef NO_FIX_DISCONNECT_ISSUE
-			/*Unplug&plug device during suspend without remote wakeup enabled
-			For Low and full speed device, we should power on and power off
-			the USB port to make sure USB internal state machine work well.
-			*/
 			tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
-			if ((tmp & PORT_CONNECT) && !(tmp & PORT_SUSPEND) &&
-				((tmp & (0x3<<26)) != (0x2<<26))) {
-					printk(KERN_DEBUG "%s will do power off and power on port.\n", pdata->name);
-					ehci_writel(ehci, tmp & ~(PORT_RWC_BITS | PORT_POWER),
-						&ehci->regs->port_status[0]);
-					ehci_writel(ehci, tmp | PORT_POWER,
-						&ehci->regs->port_status[0]);
+			if (pdata->operating_mode == FSL_USB2_DR_OTG) {
+				otgsc = ehci_readl(ehci, (u32 __iomem *)ehci->regs + OTGSC_OFFSET / 4);
+				id_changed = !!(otgsc & OTGSC_ID_INT_STS);
+				id_value = !!(otgsc & OTGSC_ID_VALUE);
+				if (((tmp & PORT_CONNECT) && !id_value) || id_changed) {
+					set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+				} else if (!(tmp & PORT_CONNECT)) {
+					usb_host_set_wakeup(hcd->self.controller, true);
+					fsl_usb_lowpower_mode(pdata, true);
+					fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
+				}
+			} else {
+				if (tmp & PORT_CONNECT) {
+					set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+				} else {
+					usb_host_set_wakeup(hcd->self.controller, true);
+					fsl_usb_lowpower_mode(pdata, true);
+					fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
+				}
+
 			}
-#endif
-			fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
 		}
+		enable_irq(hcd->irq);
 		return 0;
 	}
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
@@ -805,6 +852,7 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	ehci_writel(ehci, pdata->pm_configured_flag,
 		    &ehci->regs->configured_flag);
 
+	ehci_fsl_stream_disable(ehci);
 
 	tmp = ehci_readl(ehci, &ehci->regs->command);
 	tmp |= CMD_RUN;
diff --git a/drivers/usb/host/ehci-fsl.h b/drivers/usb/host/ehci-fsl.h
index 137c505..b0b0d17 100755
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2005-2011 Freescale Semiconductor, Inc.
+/* Copyright (C) 2005-2013 Freescale Semiconductor, Inc.
  * Copyright (c) 2005 MontaVista Software
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -36,6 +36,7 @@
 #define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
 #define USBMODE_CM_HOST		(3 << 0)	/* controller mode: host */
 #define USBMODE_ES		(1 << 2)	/* (Big) Endian Select */
+#define CI_USBMODE_SDIS		(1 << 4)	/* Chipidea Stream Disable bit */
 
 #define FSL_SOC_USB_USBGENCTRL	0x200
 #define USBGENCTRL_PPP		(1 << 3)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 58f4472..2bea9581 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -48,6 +48,21 @@
 #include <asm/system.h>
 #include <asm/unaligned.h>
 
+
+#ifdef CONFIG_FSL_USB_TEST_MODE
+static u32 single_step_desc_data_on;
+void set_single_step_desc_data_on(void)
+{
+	single_step_desc_data_on = 1;
+}
+EXPORT_SYMBOL_GPL(set_single_step_desc_data_on);
+
+void clear_single_step_desc_data_on(void)
+{
+	single_step_desc_data_on = 0;
+}
+EXPORT_SYMBOL_GPL(clear_single_step_desc_data_on);
+#endif
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -964,8 +979,22 @@ static int ehci_urb_enqueue (
 		/* FALLTHROUGH */
 	/* case PIPE_BULK: */
 	default:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+#ifdef CONFIG_FSL_USB_TEST_MODE
+		if (!single_step_desc_data_on) {
+			printk(KERN_DEBUG "in test mode, but single step NOT on\n");
+			if (!qh_urb_transaction(ehci, urb, &qtd_list,
+						mem_flags))
+				return -ENOMEM;
+		} else {
+			printk(KERN_DEBUG "in test mode, single step on\n");
+			if (!single_step_qh_urb_transaction(ehci, urb,
+				&qtd_list, mem_flags))
+				return -ENOMEM;
+		}
+#else
+		if (!qh_urb_transaction(ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
+#endif
 		return submit_async(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e4dd26a..361dd5d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -592,6 +592,187 @@ static void qtd_list_free (
 	}
 }
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+/*
+ * create a list of filled qtds for this URB; won't link into qh.
+ */
+static struct list_head *
+single_step_qh_urb_transaction(
+	struct ehci_hcd		*ehci,
+	struct urb		*urb,
+	struct list_head	*head,
+	gfp_t			flags
+) {
+	struct ehci_qtd		*qtd, *qtd_prev;
+	dma_addr_t		buf;
+	int			len, this_sg_len, maxpacket;
+	int			is_input;
+	u32			token;
+	int			i;
+	struct scatterlist	*sg;
+#define SINGLE_STEP_PHASE_SETUP  0
+#define SINGLE_STEP_PHASE_DATA   1
+#define SINGLE_STEP_PHASE_STATUS 2
+#define SINGLE_STEP_PHASE_NONE   0xFF
+	static u32  phase_state = SINGLE_STEP_PHASE_NONE;
+
+	/*
+	 * URBs map to sequences of QTDs:  one logical transaction
+	 */
+	qtd = ehci_qtd_alloc(ehci, flags);
+	if (unlikely(!qtd))
+		return NULL;
+	list_add_tail(&qtd->qtd_list, head);
+	qtd->urb = urb;
+
+	token = QTD_STS_ACTIVE;
+	token |= (EHCI_TUNE_CERR << 10);
+	/* for split transactions, SplitXState initialized to zero */
+	len = urb->transfer_buffer_length;
+	is_input = usb_pipein(urb->pipe);
+	if (!is_input) {
+		printk(KERN_INFO "single step can only send IN\n");
+		return NULL;
+	}
+
+	if (!usb_pipecontrol(urb->pipe)) {
+		printk(KERN_INFO "single step can only send control pipe\n");
+		return NULL;
+	}
+
+	if (phase_state == SINGLE_STEP_PHASE_NONE) {
+		/*
+		 * SETUP pid
+		 * we use transfer_buffer_length to identfiy whether it
+		 * is in setup phase or data phase
+		 */
+		qtd_fill(ehci, qtd, urb->setup_dma,
+				sizeof(struct usb_ctrlrequest),
+				token | (2 /* "setup" */ << 8), 8);
+
+		/* ... and always at least one more pid */
+		qtd->urb = urb;
+		phase_state = SINGLE_STEP_PHASE_SETUP;
+	}
+	/*
+	 * data transfer stage:  buffer setup
+	 */
+	else
+		if (phase_state == SINGLE_STEP_PHASE_SETUP &&
+		len != 0) {
+		i = urb->num_sgs;
+		if (len > 0 && i > 0) {
+			sg = urb->sg;
+			buf = sg_dma_address(sg);
+
+			/* urb->transfer_buffer_length may be smaller than the
+			* size of the scatterlist (or vice versa)
+			*/
+			this_sg_len = min_t(int, sg_dma_len(sg), len);
+		} else {
+			sg = NULL;
+			buf = urb->transfer_dma;
+			this_sg_len = len;
+		}
+
+		if (is_input)
+			token |= (1 /* "in" */ << 8);
+		/* else it's already initted to "out" pid (0 << 8) */
+		maxpacket = max_packet(usb_maxpacket(urb->dev,
+						urb->pipe, !is_input));
+		/* for the first data qtd, the toggle should be 1 */
+		token ^= QTD_TOGGLE;
+
+		/*
+		 * buffer gets wrapped in one or more qtds;
+		 * last one may be "short" (including zero len)
+		 * and may serve as a control status ack
+		 */
+		for (;;) {
+			int this_qtd_len;
+
+			this_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len,
+							token, maxpacket);
+			this_sg_len -= this_qtd_len;
+			len -= this_qtd_len;
+			buf += this_qtd_len;
+
+			/*
+			* short reads advance to a "magic" dummy instead of
+			* the next qtd ... that forces the queue to stop, for
+			* manual cleanup. (will usually be overridden later.)
+			*/
+			if (is_input)
+				qtd->hw_alt_next = ehci->async->hw->hw_alt_next;
+
+			/* qh makes control packets use qtd toggle; switch it*/
+			if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
+				token ^= QTD_TOGGLE;
+
+			if (likely(this_sg_len <= 0)) {
+				if (--i <= 0 || len <= 0)
+					break;
+				sg = sg_next(sg);
+				buf = sg_dma_address(sg);
+				this_sg_len = min_t(int, sg_dma_len(sg), len);
+			}
+
+			qtd_prev = qtd;
+			qtd = ehci_qtd_alloc(ehci, flags);
+			if (unlikely(!qtd))
+				goto cleanup;
+			qtd->urb = urb;
+			qtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);
+			list_add_tail(&qtd->qtd_list, head);
+		}
+
+		phase_state = SINGLE_STEP_PHASE_DATA;
+
+		/*
+		 * unless the caller requires manual cleanup after short reads,
+		 * have the alt_next mechanism keep the queue running after the
+		 * last data qtd (the only one, for control and other cases).
+		 */
+		if (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0
+					|| usb_pipecontrol(urb->pipe)))
+			qtd->hw_alt_next = EHCI_LIST_END(ehci);
+	}
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	else
+		if (phase_state == SINGLE_STEP_PHASE_DATA) {
+		int	one_more = 0;
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			/* for single step, it always be out here */
+			token &= ~(3 << 8);
+			token |= QTD_TOGGLE;	/* force DATA1 */
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length % maxpacket)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			/* never any data in such packets */
+			qtd_fill(ehci, qtd, 0, 0, token, 0);
+		}
+	}
+
+	/* by default, enable interrupt on urb completion */
+	if (likely(!(urb->transfer_flags & URB_NO_INTERRUPT)))
+		qtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);
+	return head;
+
+cleanup:
+	qtd_list_free(ehci, urb, head);
+	phase_state = SINGLE_STEP_PHASE_NONE;
+	return NULL;
+}
+#endif
+
 /*
  * create a list of filled qtds for this URB; won't link into qh.
  */
diff --git a/drivers/usb/otg/fsl_otg.c b/drivers/usb/otg/fsl_otg.c
index 4205ed9..abf11b8 100755
--- a/drivers/usb/otg/fsl_otg.c
+++ b/drivers/usb/otg/fsl_otg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Author: Li Yang <LeoLi@freescale.com>
  *         Jerry Huang <Chang-Ming.Huang@freescale.com>
@@ -551,13 +551,9 @@ int fsl_otg_start_host(struct otg_fsm *fsm, int on)
 			goto end;
 		else {
 			VDBG("host off......\n");
-			if (host_pdrv->suspend) {
+			if (host_pdrv->suspend)
 				retval = host_pdrv->suspend(host_pdev,
 							otg_suspend_state);
-				if (fsm->id)
-					/* default-b */
-					fsl_otg_drv_vbus(dev->platform_data, 0);
-			}
 			otg_dev->host_working = 0;
 		}
 	}
@@ -607,6 +603,9 @@ int fsl_otg_start_gadget(struct otg_fsm *fsm, int on)
 static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
 {
 	struct fsl_otg *otg_dev = container_of(otg_p, struct fsl_otg, otg);
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = otg_dev->otg.dev->platform_data;
 
 	if (!otg_p || otg_dev != fsl_otg_dev)
 		return -ENODEV;
@@ -628,11 +627,18 @@ static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
 
 		if (otg_dev->fsm.id) {
 			otg_dev->host_first_call = true;
+			/* The discharge will be false when the controller
+			 * is ready to use.
+			 */
+			if (pdata->dr_discharge_line)
+				pdata->dr_discharge_line(true);
 			schedule_otg_work(&otg_dev->otg_event, 100);
 		}
 		else {
 			/* if the device is already at the port */
 			otg_drv_vbus(&otg_dev->fsm, 1);
+			if (pdata->dr_discharge_line)
+				pdata->dr_discharge_line(false);
 			fsl_otg_wait_stable_vbus(true);
 			b_session_irq_enable(false);
 			fsl_otg_start_host(&otg_dev->fsm, 1);
@@ -660,8 +666,6 @@ static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
 
 	otg_dev->host_working = 0;
 
-	otg_statemachine(&otg_dev->fsm);
-
 	return 0;
 }
 
@@ -680,13 +684,19 @@ static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
 		return -ENODEV;
 
 	if (!gadget) {
-		if (!otg_dev->otg.default_a)
+		/*
+		 * At i.mx platform, we still not implement fully
+		 * OTG.
+		 */
+		/*
+		if (!otg_dev->otg.default_a) {
 			otg_p->gadget->ops->vbus_draw(otg_p->gadget, 0);
-		usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+			usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+		}
+		*/
 		otg_dev->otg.gadget = 0;
 		otg_dev->fsm.b_bus_req = 0;
 		pdata->port_enables = 0;
-		otg_statemachine(&otg_dev->fsm);
 		return 0;
 	}
 	pdata->port_enables = 1;
@@ -1398,6 +1408,7 @@ static int fsl_otg_remove(struct platform_device *pdev)
 
 	kfree(fsl_otg_dev);
 
+	fsl_otg_dev = NULL;
 	remove_proc_file();
 
 	unregister_chrdev(FSL_OTG_MAJOR, FSL_OTG_NAME);
diff --git a/drivers/usb/otg/otg_fsm.c b/drivers/usb/otg/otg_fsm.c
index 9e16afe..85b7148 100755
--- a/drivers/usb/otg/otg_fsm.c
+++ b/drivers/usb/otg/otg_fsm.c
@@ -1,6 +1,6 @@
 /* OTG Finite State Machine from OTG spec
  *
- * Copyright (C) 2006-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2006-2013 Freescale Semiconductor, Inc.
  *
  * Author: 	Li Yang <LeoLi@freescale.com>
  * 		Jerry Huang <Chang-Ming.Huang@freescale.com>
@@ -254,6 +254,8 @@ int otg_statemachine(struct otg_fsm *fsm)
 	enum usb_otg_state state;
 	unsigned long flags;
 
+	return 0;
+
 	spin_lock_irqsave(&fsm->lock, flags);
 
 	state = fsm->transceiver->state;
diff --git a/drivers/video/mxc/epdc_regs.h b/drivers/video/mxc/epdc_regs.h
index cc7b500..4f5137e 100644
--- a/drivers/video/mxc/epdc_regs.h
+++ b/drivers/video/mxc/epdc_regs.h
@@ -197,6 +197,7 @@ enum {
 	EPDC_FORMAT_BUF_PIXEL_SCALE_ROUND = 0x1000000,
 	EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK = 0xFF0000,
 	EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET = 16,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_MASK = 0x700,
 	EPDC_FORMAT_BUF_PIXEL_FORMAT_P2N = 0x200,
 	EPDC_FORMAT_BUF_PIXEL_FORMAT_P3N = 0x300,
 	EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N = 0x400,
diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
index 296a148..19de5c5 100644
--- a/drivers/video/mxc/ldb.c
+++ b/drivers/video/mxc/ldb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -105,6 +105,14 @@ static int g_ldb_mode;
 
 static struct fb_videomode ldb_modedb[] = {
 	{
+	 "LDB-WXGA", 60, 1280, 800, 14065,
+	 40, 40,
+	 10, 3,
+	 80, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},
+	{
 	 "LDB-XGA", 60, 1024, 768, 15385,
 	 220, 40,
 	 21, 7,
@@ -230,6 +238,8 @@ static int ldb_disp_setup(struct mxc_dispdrv_handle *disp, struct fb_info *fbi)
 	val = readl(ldb->control_reg);
 	val |= ldb->setting[setting_idx].ch_val;
 	writel(val, ldb->control_reg);
+	dev_dbg(&ldb->pdev->dev, "LDB setup, control reg:0x%x\n",
+			readl(ldb->control_reg));
 
 	/* vsync setup */
 	reg = readl(ldb->control_reg);
@@ -313,6 +323,9 @@ int ldb_fb_event(struct notifier_block *nb, unsigned long val, void *v)
 				data = readl(ldb->control_reg);
 				data &= ~ldb->setting[index].ch_mask;
 				writel(data, ldb->control_reg);
+				dev_dbg(&ldb->pdev->dev,
+					"LDB blank, control reg:0x%x\n",
+						readl(ldb->control_reg));
 			}
 		}
 		break;
@@ -403,6 +416,7 @@ static int ldb_disp_init(struct mxc_dispdrv_handle *disp,
 	uint32_t base_addr;
 	uint32_t reg, setting_idx;
 	uint32_t ch_mask = 0, ch_val = 0;
+	uint32_t ipu_id, disp_id;
 
 	/* if input format not valid, make RGB666 as default*/
 	if (!valid_mode(setting->if_fmt)) {
@@ -471,6 +485,28 @@ static int ldb_disp_init(struct mxc_dispdrv_handle *disp,
 					plat_data->disp_id, ret, ret);
 				plat_data->disp_id = ret;
 			}
+		} else if (((ldb->mode == LDB_SEP0) || (ldb->mode == LDB_SEP1))
+				&& (cpu_is_mx6q() || cpu_is_mx6dl())) {
+			if (plat_data->disp_id == plat_data->sec_disp_id) {
+				dev_err(&ldb->pdev->dev,
+					"For LVDS separate mode,"
+					"two DIs should be different!\n");
+				return -EINVAL;
+			}
+
+			if (((!plat_data->disp_id) && (ldb->mode == LDB_SEP1))
+				|| ((plat_data->disp_id) &&
+					(ldb->mode == LDB_SEP0))) {
+				dev_dbg(&ldb->pdev->dev,
+					"LVDS separate mode:"
+					"swap DI configuration!\n");
+				ipu_id = plat_data->ipu_id;
+				disp_id = plat_data->disp_id;
+				plat_data->ipu_id = plat_data->sec_ipu_id;
+				plat_data->disp_id = plat_data->sec_disp_id;
+				plat_data->sec_ipu_id = ipu_id;
+				plat_data->sec_disp_id = disp_id;
+			}
 		}
 
 		if (ldb->mode == LDB_SPL_DI0) {
@@ -671,19 +707,8 @@ static int ldb_disp_init(struct mxc_dispdrv_handle *disp,
 	ldb->setting[setting_idx].ch_mask = ch_mask;
 	ldb->setting[setting_idx].ch_val = ch_val;
 
-	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
-		if ((ldb->mode == LDB_SEP0) || (ldb->mode == LDB_SEP1)) {
-			reg = readl(ldb->control_reg);
-			reg &= ~(LDB_CH0_MODE_MASK | LDB_CH1_MODE_MASK);
-			reg |= LDB_CH0_MODE_EN_TO_DI0 | LDB_CH1_MODE_EN_TO_DI1;
-			writel(reg, ldb->control_reg);
-			ldb->setting[setting_idx].ch_mask = setting->disp_id ?
-					LDB_CH1_MODE_MASK : LDB_CH0_MODE_MASK;
-			ldb->setting[setting_idx].ch_val = setting->disp_id ?
-				LDB_CH1_MODE_EN_TO_DI1 : LDB_CH0_MODE_EN_TO_DI0;
-		}
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
 		ldb_ipu_ldb_route(setting->dev_id, setting->disp_id, ldb);
-	}
 
 	/*
 	 * ldb_di0_clk -> ipux_di0_clk
diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 6f36bd4..721ff88 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -78,12 +78,22 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
 	[8] = {
-		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
 	[9] = {
-		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #14: 1440x480p@59.94/60Hz 4:3 */
+	[14] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #15: 1440x480p@59.94/60Hz 16:9 */
+	[15] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #16: 1920x1080p@60Hz 16:9 */
@@ -114,6 +124,26 @@ const struct fb_videomode mxc_cea_mode[64] = {
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
+	/* #23: 720(1440)x288pH@50Hz 4:3 */
+	[23] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #24: 720(1440)x288pH@50Hz 16:9 */
+	[24] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #29: 720(1440)x576pH@50Hz 4:3 */
+	[29] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #30: 720(1440)x576pH@50Hz 16:9 */
+	[30] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
 	/* #31: 1920x1080p@50Hz */
 	[31] = {
 		NULL, 50, 1920, 1080, 6734, 148, 528, 36, 4, 44, 5,
@@ -126,10 +156,29 @@ const struct fb_videomode mxc_cea_mode[64] = {
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
-	/* #35: (2880)x480p4x@59.94/60Hz */
-	[35] = {
-		NULL, 60, 2880, 480, 9250, 240, 64, 30, 9, 248, 6, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	/* #33: 1920x1080p@25Hz */
+	[33] = {
+		NULL, 25, 1920, 1080, 13468, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #34: 1920x1080p@30Hz */
+	[34] = {
+		NULL, 30, 1920, 1080, 13468, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #41: 1280x720p@100Hz 16:9 */
+	[41] = {
+		NULL, 100, 1280, 720, 6734, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #47: 1280x720p@119.88/120Hz 16:9 */
+	[47] = {
+		NULL, 120, 1280, 720, 6734, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
 	},
 };
 
@@ -158,6 +207,9 @@ int mxc_edid_fb_mode_is_equal(bool use_aspect,
 		mode1->upper_margin == mode2->upper_margin &&
 		mode1->lower_margin == mode2->lower_margin &&
 		mode1->sync         == mode2->sync &&
+		/* refresh check, 59.94Hz and 60Hz have the same parameter
+		 * in struct of mxc_cea_mode */
+		abs(mode1->refresh - mode2->refresh) <= 1 &&
 		(mode1->vmode & mask) == (mode2->vmode & mask));
 }
 
diff --git a/drivers/video/mxc/mxc_elcdif_fb.c b/drivers/video/mxc/mxc_elcdif_fb.c
index 6624fd0..023d594 100644
--- a/drivers/video/mxc/mxc_elcdif_fb.c
+++ b/drivers/video/mxc/mxc_elcdif_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -940,14 +940,14 @@ static int mxc_elcdif_fb_set_par(struct fb_info *fbi)
 
 	setup_dotclk_panel((PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
 			   fbi->var.vsync_len,
-			   fbi->var.upper_margin +
-			   fbi->var.yres + fbi->var.lower_margin,
-			   fbi->var.upper_margin,
+			   fbi->var.upper_margin + fbi->var.yres +
+			   fbi->var.lower_margin + fbi->var.vsync_len,
+			   fbi->var.upper_margin + fbi->var.vsync_len,
 			   fbi->var.yres,
 			   fbi->var.hsync_len,
-			   fbi->var.left_margin +
-			   fbi->var.xres + fbi->var.right_margin,
-			   fbi->var.left_margin,
+			   fbi->var.left_margin + fbi->var.xres +
+			   fbi->var.right_margin + fbi->var.hsync_len,
+			   fbi->var.left_margin + fbi->var.hsync_len,
 			   fbi->var.xres,
 			   bpp_to_pixfmt(fbi),
 			   data->output_pix_fmt,
diff --git a/drivers/video/mxc/mxc_epdc_fb.c b/drivers/video/mxc/mxc_epdc_fb.c
index 2df4404..4103498 100644
--- a/drivers/video/mxc/mxc_epdc_fb.c
+++ b/drivers/video/mxc/mxc_epdc_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -733,11 +733,11 @@ static inline int epdc_get_next_lut(void)
 
 static int epdc_choose_next_lut(int rev, int *next_lut)
 {
-	u64 luts_status, unprocessed_luts;
-	bool next_lut_found = false;
+	u64 luts_status, unprocessed_luts, used_luts;
 	/* Available LUTs are reduced to 16 in 5-bit waveform mode */
-	u32 format_p5n = __raw_readl(EPDC_FORMAT) &
-		EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N;
+	bool format_p5n = ((__raw_readl(EPDC_FORMAT) &
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_MASK) ==
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N);
 
 	luts_status = __raw_readl(EPDC_STATUS_LUTS);
 	if ((rev < 20) || format_p5n)
@@ -754,48 +754,43 @@ static int epdc_choose_next_lut(int rev, int *next_lut)
 			unprocessed_luts &= 0xFFFF;
 	}
 
-	while (!next_lut_found) {
-		/*
-		 * Selecting a LUT to minimize incidence of TCE Underrun Error
-		 * --------------------------------------------------------
-		 * We want to find the lowest order LUT that is of greater
-		 * order than all other active LUTs.  If highest order LUT
-		 * is active, then we want to choose the lowest order
-		 * available LUT.
-		 *
-		 * NOTE: For EPDC version 2.0 and later, TCE Underrun error
-		 *       bug is fixed, so it doesn't matter which LUT is used.
-		 */
-		*next_lut = fls64(luts_status);
+	/*
+	 * Note on unprocessed_luts: There is a race condition
+	 * where a LUT completes, but has not been processed by
+	 * IRQ handler workqueue, and then a new update request
+	 * attempts to use that LUT.  We prevent that here by
+	 * ensuring that the LUT we choose doesn't have its IRQ
+	 * bit set (indicating it has completed but not yet been
+	 * processed).
+	 */
+	used_luts = luts_status | unprocessed_luts;
 
-		if ((rev < 20) || format_p5n) {
-			if (*next_lut > 15)
-				*next_lut = ffz(luts_status);
-		} else {
-			if (*next_lut > 63) {
-				*next_lut = ffz((u32)luts_status);
-				if (*next_lut == -1)
-					*next_lut =
-						ffz((u32)(luts_status >> 32)) + 32;
-			}
-		}
+	/*
+	 * Selecting a LUT to minimize incidence of TCE Underrun Error
+	 * --------------------------------------------------------
+	 * We want to find the lowest order LUT that is of greater
+	 * order than all other active LUTs.  If highest order LUT
+	 * is active, then we want to choose the lowest order
+	 * available LUT.
+	 *
+	 * NOTE: For EPDC version 2.0 and later, TCE Underrun error
+	 *       bug is fixed, so it doesn't matter which LUT is used.
+	 */
 
-		/*
-		 * Note on unprocessed_luts: There is a race condition
-		 * where a LUT completes, but has not been processed by
-		 * IRQ handler workqueue, and then a new update request
-		 * attempts to use that LUT.  We prevent that here by
-		 * ensuring that the LUT we choose doesn't have its IRQ
-		 * bit set (indicating it has completed but not yet been
-		 * processed).
-		 */
-		if ((1 << *next_lut) & unprocessed_luts)
-			luts_status |= (1 << *next_lut);
+	if ((rev < 20) || format_p5n) {
+		*next_lut = fls64(used_luts);
+		if (*next_lut > 15)
+			*next_lut = ffz(used_luts);
+	} else {
+		if ((u32)used_luts != ~0UL)
+			*next_lut = ffz((u32)used_luts);
+		else if ((u32)(used_luts >> 32) != ~0UL)
+			*next_lut = ffz((u32)(used_luts >> 32)) + 32;
 		else
-			next_lut_found = true;
+			*next_lut = INVALID_LUT;
 	}
 
-	if (luts_status & 0x8000)
+	if (used_luts & 0x8000)
 		return 1;
 	else
 		return 0;
@@ -1492,7 +1487,6 @@ static int mxc_epdc_fb_set_par(struct fb_info *info)
 	 */
 	if (!fb_data->hw_ready) {
 		struct fb_videomode mode;
-		bool found_match = false;
 		u32 xres_temp;
 
 		fb_var_to_videomode(&mode, screeninfo);
@@ -1506,19 +1500,31 @@ static int mxc_epdc_fb_set_par(struct fb_info *info)
 			mode.yres = xres_temp;
 		}
 
-		/* Match videomode against epdc modes */
-		for (i = 0; i < fb_data->pdata->num_modes; i++) {
-			if (!fb_mode_is_equal(epdc_modes[i].vmode, &mode))
-				continue;
-			fb_data->cur_mode = &epdc_modes[i];
-			found_match = true;
-			break;
-		}
+		/*
+		* If requested video mode does not match current video
+		* mode, search for a matching panel.
+		*/
+		if (fb_data->cur_mode &&
+			!fb_mode_is_equal(fb_data->cur_mode->vmode,
+			&mode)) {
+			bool found_match = false;
+
+			/* Match videomode against epdc modes */
+			for (i = 0; i < fb_data->pdata->num_modes; i++) {
+				if (!fb_mode_is_equal(epdc_modes[i].vmode,
+					&mode))
+					continue;
+				fb_data->cur_mode = &epdc_modes[i];
+				found_match = true;
+				break;
+			}
 
-		if (!found_match) {
-			dev_err(fb_data->dev,
-				"Failed to match requested video mode\n");
-			return EINVAL;
+			if (!found_match) {
+				dev_err(fb_data->dev,
+					"Failed to match requested "
+					"video mode\n");
+				return EINVAL;
+			}
 		}
 
 		/* Found a match - Grab timing params */
@@ -2247,7 +2253,7 @@ static int epdc_submit_merge(struct update_desc_list *upd_desc_list,
 	/* Merged update should take on the earliest order */
 	upd_desc_list->update_order =
 		(upd_desc_list->update_order > update_to_merge->update_order) ?
-		update_to_merge->update_order : upd_desc_list->update_order;
+		upd_desc_list->update_order : update_to_merge->update_order;
 
 	return MERGE_OK;
 }
@@ -5019,9 +5025,36 @@ static int mxc_epdc_fb_resume(struct platform_device *pdev)
 
 	return 0;
 }
+
+static void mxc_epdc_fb_shutdown(struct platform_device *pdev)
+{
+	struct mxc_epdc_fb_data *fb_data = platform_get_drvdata(pdev);
+
+	/* Disable power to the EPD panel */
+	if (regulator_is_enabled(fb_data->vcom_regulator))
+		regulator_disable(fb_data->vcom_regulator);
+	if (regulator_is_enabled(fb_data->display_regulator))
+		regulator_disable(fb_data->display_regulator);
+
+	/* Disable clocks to EPDC */
+	clk_enable(fb_data->epdc_clk_axi);
+	clk_enable(fb_data->epdc_clk_pix);
+	__raw_writel(EPDC_CTRL_CLKGATE, EPDC_CTRL_SET);
+	clk_disable(fb_data->epdc_clk_pix);
+	clk_disable(fb_data->epdc_clk_axi);
+
+	/* Disable pins used by EPDC (to prevent leakage current) */
+	if (fb_data->pdata->disable_pins)
+		fb_data->pdata->disable_pins();
+
+	/* turn off the V3p3 */
+	if (regulator_is_enabled(fb_data->v3p3_regulator))
+		regulator_disable(fb_data->v3p3_regulator);
+}
 #else
 #define mxc_epdc_fb_suspend	NULL
 #define mxc_epdc_fb_resume	NULL
+#define mxc_epdc_fb_shutdown	NULL
 #endif
 
 static struct platform_driver mxc_epdc_fb_driver = {
@@ -5029,6 +5062,7 @@ static struct platform_driver mxc_epdc_fb_driver = {
 	.remove = mxc_epdc_fb_remove,
 	.suspend = mxc_epdc_fb_suspend,
 	.resume = mxc_epdc_fb_resume,
+	.shutdown = mxc_epdc_fb_shutdown,
 	.driver = {
 		   .name = "imx_epdc_fb",
 		   .owner = THIS_MODULE,
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index 8038f3d..4c98d51 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -481,6 +481,14 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	ipu_disable_irq(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
 	ipu_disable_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, true);
 	ipu_uninit_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch);
+
+	/*
+	 * Disable IPU hsp clock if it is enabled for an
+	 * additional time in ipu common driver.
+	 */
+	if (mxc_fbi->first_set_par && mxc_fbi->late_init)
+		ipu_disable_hsp_clk(mxc_fbi->ipu);
+
 	mxcfb_set_fix(fbi);
 
 	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
@@ -1312,6 +1320,20 @@ static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 
 			break;
 		}
+	case MXCFB_CSC_UPDATE:
+		{
+			struct mxcfb_csc_matrix csc;
+
+			if (copy_from_user(&csc, (void *) arg, sizeof(csc)))
+				return -EFAULT;
+
+			if ((mxc_fbi->ipu_ch != MEM_FG_SYNC) &&
+				(mxc_fbi->ipu_ch != MEM_BG_SYNC) &&
+				(mxc_fbi->ipu_ch != MEM_BG_ASYNC0))
+				return -EFAULT;
+			ipu_set_csc_coefficients(mxc_fbi->ipu, mxc_fbi->ipu_ch,
+						csc.param);
+		}
 	default:
 		retval = -EINVAL;
 	}
@@ -2018,6 +2040,31 @@ static int mxcfb_register(struct fb_info *fbi)
 	fb_var_to_videomode(&m, &fbi->var);
 	fb_add_videomode(&m, &fbi->modelist);
 
+	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
+		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering EOF irq handler.\n");
+		ret = -EBUSY;
+		goto err0;
+	}
+	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
+	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
+		mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering NFACK irq handler.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
+
+	if (mxcfbi->ipu_alp_ch_irq != -1)
+		if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
+				mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
+					MXCFB_NAME, fbi) != 0) {
+			dev_err(fbi->device, "Error registering alpha irq "
+					"handler.\n");
+			ret = -EBUSY;
+			goto err2;
+		}
+
 	if (!mxcfbi->late_init) {
 		fbi->var.activate |= FB_ACTIVATE_FORCE;
 		console_lock();
@@ -2025,25 +2072,26 @@ static int mxcfb_register(struct fb_info *fbi)
 		ret = fb_set_var(fbi, &fbi->var);
 		fbi->flags &= ~FBINFO_MISC_USEREVENT;
 		console_unlock();
+		if (ret < 0) {
+			dev_err(fbi->device, "Error fb_set_var ret:%d\n", ret);
+			goto err3;
+		}
 
 		if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
 			console_lock();
-			fb_blank(fbi, FB_BLANK_UNBLANK);
+			ret = fb_blank(fbi, FB_BLANK_UNBLANK);
 			console_unlock();
+			if (ret < 0) {
+				dev_err(fbi->device,
+					"Error fb_blank ret:%d\n", ret);
+				goto err4;
+			}
 		}
 	} else {
 		/*
 		 * Setup the channel again though bootloader
 		 * has done this, then set_par() can stop the
-		 * channel and re-initialize it. Moreover,
-		 * ipu_init_channel() enables ipu hsp clock,
-		 * so we may keep the clock on until user
-		 * space triggers set_par(), i.e., any ipu
-		 * interface which enables/disables ipu hsp
-		 * clock with pair(called in IPUv3 fb driver
-		 * or mxc v4l2 driver<probed after fb driver>)
-		 * cannot eventually disables the clock to
-		 * damage the channel.
+		 * channel neatly and re-initialize it .
 		 */
 		if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
 			console_lock();
@@ -2053,44 +2101,13 @@ static int mxcfb_register(struct fb_info *fbi)
 		}
 	}
 
-	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
-		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
-		dev_err(fbi->device, "Error registering EOF irq handler.\n");
-		ret = -EBUSY;
-		goto err0;
-	}
-	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
-	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
-		mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
-		dev_err(fbi->device, "Error registering NFACK irq handler.\n");
-		ret = -EBUSY;
-		goto err1;
-	}
-	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
-
-	if (mxcfbi->ipu_alp_ch_irq != -1)
-		if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
-				mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
-					MXCFB_NAME, fbi) != 0) {
-			dev_err(fbi->device, "Error registering alpha irq "
-					"handler.\n");
-			ret = -EBUSY;
-			goto err2;
-		}
 
 	ret = register_framebuffer(fbi);
 	if (ret < 0)
-		goto err3;
+		goto err5;
 
 	return ret;
-err3:
-	if (mxcfbi->ipu_alp_ch_irq != -1)
-		ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq, fbi);
-err2:
-	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq, fbi);
-err1:
-	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq, fbi);
-err0:
+err5:
 	if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
 		console_lock();
 		if (!mxcfbi->late_init)
@@ -2102,6 +2119,15 @@ err0:
 		}
 		console_unlock();
 	}
+err4:
+err3:
+	if (mxcfbi->ipu_alp_ch_irq != -1)
+		ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq, fbi);
+err2:
+	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq, fbi);
+err1:
+	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq, fbi);
+err0:
 	return ret;
 }
 
diff --git a/drivers/video/mxc/mxcfb_sii902x_elcdif.c b/drivers/video/mxc/mxcfb_sii902x_elcdif.c
index ceab3e6..ecba5b8 100644
--- a/drivers/video/mxc/mxcfb_sii902x_elcdif.c
+++ b/drivers/video/mxc/mxcfb_sii902x_elcdif.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -238,11 +238,6 @@ static void det_worker(struct work_struct *work)
 			dev_dbg(&sii902x.pdev->dev, "EVENT=plugin\n");
 			sprintf(event_string, "EVENT=plugin");
 
-			/* make sure fb is powerdown */
-			console_lock();
-			fb_blank(sii902x.fbi, FB_BLANK_POWERDOWN);
-			console_unlock();
-
 			if (sii902x_read_edid(sii902x.fbi) < 0)
 				dev_err(&sii902x.client->dev,
 					"Sii902x: read edid fail\n");
@@ -286,18 +281,15 @@ static void det_worker(struct work_struct *work)
 					sii902x.fbi->flags &= ~FBINFO_MISC_USEREVENT;
 					console_unlock();
 				}
-
-				console_lock();
-				fb_blank(sii902x.fbi, FB_BLANK_UNBLANK);
-				console_unlock();
+				/* Power on sii902x */
+				sii902x_poweron();
 			}
 		} else {
 			sii902x.cable_plugin = 0;
 			dev_dbg(&sii902x.pdev->dev, "EVENT=plugout\n");
 			sprintf(event_string, "EVENT=plugout");
-			console_lock();
-			fb_blank(sii902x.fbi, FB_BLANK_POWERDOWN);
-			console_unlock();
+			/* Power off sii902x */
+			sii902x_poweroff();
 		}
 		kobject_uevent_env(&sii902x.pdev->dev.kobj, KOBJ_CHANGE, envp);
 	}
@@ -461,18 +453,6 @@ static int __devexit sii902x_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int sii902x_suspend(struct i2c_client *client, pm_message_t message)
-{
-	/*TODO*/
-	return 0;
-}
-
-static int sii902x_resume(struct i2c_client *client)
-{
-	/*TODO*/
-	return 0;
-}
-
 static void sii902x_poweron(void)
 {
 	struct fsl_mxc_lcd_platform_data *plat = sii902x.client->dev.platform_data;
@@ -522,8 +502,6 @@ static struct i2c_driver sii902x_i2c_driver = {
 		   },
 	.probe = sii902x_probe,
 	.remove = sii902x_remove,
-	.suspend = sii902x_suspend,
-	.resume = sii902x_resume,
 	.id_table = sii902x_id,
 };
 
diff --git a/drivers/video/mxc_hdmi.c b/drivers/video/mxc_hdmi.c
index a45c347..c5069aa 100644
--- a/drivers/video/mxc_hdmi.c
+++ b/drivers/video/mxc_hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -53,6 +53,7 @@
 #include <linux/console.h>
 #include <linux/types.h>
 
+#include "edid.h"
 #include <mach/mxc_edid.h>
 #include "mxc/mxc_dispdrv.h"
 
@@ -94,7 +95,7 @@
 static const struct fb_videomode vga_mode = {
 	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
 	NULL, 60, 640, 480, 39721, 48, 16, 33, 10, 96, 2, 0,
-	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, FB_MODE_IS_VESA,
 };
 
 static const struct fb_videomode xga_mode = {
@@ -148,9 +149,16 @@ struct hdmi_data_info {
 	unsigned int colorimetry;
 	unsigned int pix_repet_factor;
 	unsigned int hdcp_enable;
+	unsigned int rgb_out_enable;
 	struct hdmi_vmode video_mode;
 };
 
+struct hdmi_phy_reg_config {
+	/* HDMI PHY register config for pass HCT */
+	u16 reg_vlev;
+	u16 reg_cksymtx;
+};
+
 struct mxc_hdmi {
 	struct platform_device *pdev;
 	struct platform_device *core_pdev;
@@ -159,6 +167,7 @@ struct mxc_hdmi {
 	struct clk *hdmi_isfr_clk;
 	struct clk *hdmi_iahb_clk;
 	struct delayed_work hotplug_work;
+	struct delayed_work hdcp_hdp_work;
 	struct notifier_block nb;
 
 	struct hdmi_data_info hdmi_data;
@@ -178,14 +187,24 @@ struct mxc_hdmi {
 	struct fb_videomode previous_mode;
 	struct fb_videomode previous_non_vga_mode;
 	bool requesting_vga_for_initialization;
+
+	struct hdmi_phy_reg_config phy_config;
 };
 
+static int hdmi_major;
+static struct class *hdmi_class;
 struct i2c_client *hdmi_i2c;
+struct mxc_hdmi *g_hdmi;
 
 static bool hdmi_inited;
 
 extern const struct fb_videomode mxc_cea_mode[64];
 extern void mxc_hdmi_cec_handle(u16 cec_stat);
+
+static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event);
+static void mxc_hdmi_enable_pins(struct mxc_hdmi *hdmi);
+static void mxc_hdmi_disable_pins(struct mxc_hdmi *hdmi);
+
 #ifdef DEBUG
 static void dump_fb_videomode(struct fb_videomode *m)
 {
@@ -245,6 +264,88 @@ static ssize_t mxc_hdmi_show_edid(struct device *dev,
 
 static DEVICE_ATTR(edid, S_IRUGO, mxc_hdmi_show_edid, NULL);
 
+static ssize_t mxc_hdmi_show_rgb_out_enable(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi->hdmi_data.rgb_out_enable == true)
+		strcpy(buf, "RGB out\n");
+	else
+		strcpy(buf, "YCbCr out\n");
+
+	return strlen(buf);
+}
+
+static ssize_t mxc_hdmi_store_rgb_out_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	hdmi->hdmi_data.rgb_out_enable = value;
+
+	/* Reconfig HDMI for output color space change */
+	mxc_hdmi_setup(hdmi, 0);
+
+	return count;
+}
+
+static DEVICE_ATTR(rgb_out_enable, S_IRUGO | S_IWUSR,
+				mxc_hdmi_show_rgb_out_enable,
+				mxc_hdmi_store_rgb_out_enable);
+
+static ssize_t mxc_hdmi_show_hdcp_enable(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi->hdmi_data.hdcp_enable == false)
+		strcpy(buf, "hdcp disable\n");
+	else
+		strcpy(buf, "hdcp enable\n");
+
+	return strlen(buf);
+}
+
+static ssize_t mxc_hdmi_store_hdcp_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	char event_string[32];
+	char *envp[] = { event_string, NULL };
+	unsigned long value;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	hdmi->hdmi_data.hdcp_enable = value;
+
+	/* Reconfig HDMI for HDCP */
+	mxc_hdmi_setup(hdmi, 0);
+
+	if (hdmi->hdmi_data.hdcp_enable == false) {
+		sprintf(event_string, "EVENT=hdcpdisable");
+		kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+	} else {
+		sprintf(event_string, "EVENT=hdcpenable");
+		kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+	}
+
+	return count;
+
+}
+
+static DEVICE_ATTR(hdcp_enable, S_IRUGO | S_IWUSR,
+			mxc_hdmi_show_hdcp_enable, mxc_hdmi_store_hdcp_enable);
+
 /*!
  * this submodule is responsible for the video data synchronization.
  * for example, for RGB 4:4:4 input, the data map is defined as
@@ -778,6 +879,45 @@ static int hdmi_phy_i2c_write_verify(struct mxc_hdmi *hdmi, unsigned short data,
 }
 #endif
 
+static bool  hdmi_edid_wait_i2c_done(struct mxc_hdmi *hdmi, int msec)
+{
+    unsigned char val = 0;
+    val = hdmi_readb(HDMI_IH_I2CM_STAT0) & 0x2;
+    while (val == 0) {
+		udelay(1000);
+		if (msec-- == 0) {
+			dev_dbg(&hdmi->pdev->dev,
+					"HDMI EDID i2c operation time out!!\n");
+			return false;
+		}
+		val = hdmi_readb(HDMI_IH_I2CM_STAT0) & 0x2;
+	}
+	return true;
+}
+
+static u8 hdmi_edid_i2c_read(struct mxc_hdmi *hdmi,
+					u8 addr, u8 blockno)
+{
+	u8 spointer = blockno / 2;
+	u8 edidaddress = ((blockno % 2) * 0x80) + addr;
+	u8 data;
+
+	hdmi_writeb(0xFF, HDMI_IH_I2CM_STAT0);
+	hdmi_writeb(edidaddress, HDMI_I2CM_ADDRESS);
+	hdmi_writeb(spointer, HDMI_I2CM_SEGADDR);
+	if (spointer == 0)
+		hdmi_writeb(HDMI_I2CM_OPERATION_READ,
+			HDMI_I2CM_OPERATION);
+	else
+		hdmi_writeb(HDMI_I2CM_OPERATION_READ_EXT,
+			HDMI_I2CM_OPERATION);
+
+	hdmi_edid_wait_i2c_done(hdmi, 1000);
+	data = hdmi_readb(HDMI_I2CM_DATAI);
+	hdmi_writeb(0xFF, HDMI_IH_I2CM_STAT0);
+	return data;
+}
+
 /* "Power-down enable (active low)"
  * That mean that power up == 1! */
 static void mxc_hdmi_phy_enable_power(u8 enable)
@@ -1046,6 +1186,14 @@ static int hdmi_phy_configure(struct mxc_hdmi *hdmi, unsigned char pRep,
 	hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
 	/* TX/CK LVL 10 */
 	hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
+
+	/* Board specific setting for PHY register 0x09, 0x0e to pass HCT */
+	if (hdmi->phy_config.reg_cksymtx != 0)
+		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_cksymtx, 0x09);
+
+	if (hdmi->phy_config.reg_vlev != 0)
+		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_vlev, 0x0E);
+
 	/* REMOVE CLK TERM */
 	hdmi_phy_i2c_write(hdmi, 0x8000, 0x05);  /* CKCALCTRL */
 
@@ -1114,28 +1262,13 @@ static void mxc_hdmi_phy_init(struct mxc_hdmi *hdmi)
 
 static void hdmi_tx_hdcp_config(struct mxc_hdmi *hdmi)
 {
-	u8 de, val;
-
-	if (hdmi->hdmi_data.video_mode.mDataEnablePolarity)
-		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;
-	else
-		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW;
-
-	/* disable rx detect */
-	val = hdmi_readb(HDMI_A_HDCPCFG0);
-	val &= HDMI_A_HDCPCFG0_RXDETECT_MASK;
-	val |= HDMI_A_HDCPCFG0_RXDETECT_DISABLE;
-	hdmi_writeb(val, HDMI_A_HDCPCFG0);
-
-	val = hdmi_readb(HDMI_A_VIDPOLCFG);
-	val &= HDMI_A_VIDPOLCFG_DATAENPOL_MASK;
-	val |= de;
-	hdmi_writeb(val, HDMI_A_VIDPOLCFG);
-
-	val = hdmi_readb(HDMI_A_HDCPCFG1);
-	val &= HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK;
-	val |= HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE;
-	hdmi_writeb(val, HDMI_A_HDCPCFG1);
+	if (hdmi->hdmi_data.hdcp_enable) {
+		/* Enable HDMI DDC pin */
+		mxc_hdmi_enable_pins(hdmi);
+	} else {
+		/* Disable HDMI DDC pin */
+		mxc_hdmi_disable_pins(hdmi);
+	}
 }
 
 static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
@@ -1362,19 +1495,131 @@ static void hdmi_av_composer(struct mxc_hdmi *hdmi)
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 }
 
+static int mxc_edid_read_internal(struct mxc_hdmi *hdmi, unsigned char *edid,
+			struct mxc_edid_cfg *cfg, struct fb_info *fbi)
+{
+	int extblknum;
+	int i, j, ret;
+	unsigned char *ediddata = edid;
+	unsigned char tmpedid[EDID_LENGTH];
+
+	dev_info(&hdmi->pdev->dev, "%s\n", __func__);
+
+	if (!edid || !cfg || !fbi)
+		return -EINVAL;
+
+	/* init HDMI I2CM for read edid*/
+	hdmi_writeb(0x0, HDMI_I2CM_DIV);
+	hdmi_writeb(0x00, HDMI_I2CM_SS_SCL_HCNT_1_ADDR);
+	hdmi_writeb(0x79, HDMI_I2CM_SS_SCL_HCNT_0_ADDR);
+	hdmi_writeb(0x00, HDMI_I2CM_SS_SCL_LCNT_1_ADDR);
+	hdmi_writeb(0x91, HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
+
+	hdmi_writeb(0x00, HDMI_I2CM_FS_SCL_HCNT_1_ADDR);
+	hdmi_writeb(0x0F, HDMI_I2CM_FS_SCL_HCNT_0_ADDR);
+	hdmi_writeb(0x00, HDMI_I2CM_FS_SCL_LCNT_1_ADDR);
+	hdmi_writeb(0x21, HDMI_I2CM_FS_SCL_LCNT_0_ADDR);
+
+	hdmi_writeb(0x50, HDMI_I2CM_SLAVE);
+	hdmi_writeb(0x30, HDMI_I2CM_SEGADDR);
+
+	/* Umask edid interrupt */
+	hdmi_writeb(HDMI_I2CM_INT_DONE_POL,
+		    HDMI_I2CM_INT);
+
+	hdmi_writeb(HDMI_I2CM_CTLINT_NAC_POL |
+		    HDMI_I2CM_CTLINT_ARBITRATION_POL,
+		    HDMI_I2CM_CTLINT);
+
+	/* reset edid data zero */
+	memset(edid, 0, EDID_LENGTH*4);
+	memset(cfg, 0, sizeof(struct mxc_edid_cfg));
+
+	/* Check first three byte of EDID head */
+	if (!(hdmi_edid_i2c_read(hdmi, 0, 0) == 0x00) ||
+		!(hdmi_edid_i2c_read(hdmi, 1, 0) == 0xFF) ||
+		!(hdmi_edid_i2c_read(hdmi, 2, 0) == 0xFF)) {
+		dev_info(&hdmi->pdev->dev, "EDID head check failed!");
+		return -ENOENT;
+	}
+
+	for (i = 0; i < 128; i++) {
+		*ediddata = hdmi_edid_i2c_read(hdmi, i, 0);
+		ediddata++;
+	}
+
+	extblknum = edid[0x7E];
+	if (extblknum < 0)
+		return extblknum;
+
+	if (extblknum) {
+		ediddata = edid + EDID_LENGTH;
+		for (i = 0; i < 128; i++) {
+			*ediddata = hdmi_edid_i2c_read(hdmi, i, 1);
+			ediddata++;
+		}
+	}
+
+	/* edid first block parsing */
+	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
+	fb_edid_to_monspecs(edid, &fbi->monspecs);
+
+	ret = mxc_edid_parse_ext_blk(edid + EDID_LENGTH,
+			cfg, &fbi->monspecs);
+	if (ret < 0)
+		return -ENOENT;
+
+	/* need read segment block? */
+	if (extblknum > 1) {
+		for (j = 1; j <= extblknum; j++) {
+			for (i = 0; i < 128; i++)
+				*(tmpedid + 1) = hdmi_edid_i2c_read(hdmi, i, j);
+
+			/* edid ext block parsing */
+			ret = mxc_edid_parse_ext_blk(tmpedid + EDID_LENGTH,
+					cfg, &fbi->monspecs);
+			if (ret < 0)
+				return -ENOENT;
+		}
+	}
+
+	return 0;
+}
+
 static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 {
 	int ret;
 	u8 edid_old[HDMI_EDID_LEN];
+	u8 clkdis;
 
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
 	/* save old edid */
 	memcpy(edid_old, hdmi->edid, HDMI_EDID_LEN);
 
-	ret = mxc_edid_read(hdmi_i2c->adapter, hdmi_i2c->addr, hdmi->edid,
-			    &hdmi->edid_cfg, hdmi->fbi);
+	if (!hdmi->hdmi_data.hdcp_enable)
+		ret = mxc_edid_read(hdmi_i2c->adapter, hdmi_i2c->addr,
+				hdmi->edid, &hdmi->edid_cfg, hdmi->fbi);
+	else {
+
+		/* Disable HDCP clk */
+		if (hdmi->hdmi_data.hdcp_enable) {
+			clkdis = hdmi_readb(HDMI_MC_CLKDIS);
+			clkdis |= HDMI_MC_CLKDIS_HDCPCLK_DISABLE;
+			hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+		}
+
+		ret = mxc_edid_read_internal(hdmi, hdmi->edid,
+				&hdmi->edid_cfg, hdmi->fbi);
+
+		/* Enable HDCP clk */
+		if (hdmi->hdmi_data.hdcp_enable) {
+			clkdis = hdmi_readb(HDMI_MC_CLKDIS);
+			clkdis &= ~HDMI_MC_CLKDIS_HDCPCLK_DISABLE;
+			hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+		}
 
+	}
 	if (ret < 0)
 		return HDMI_EDID_FAIL;
 
@@ -1394,6 +1639,28 @@ static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 	return HDMI_EDID_SUCCESS;
 }
 
+static void mxc_hdmi_enable_pins(struct mxc_hdmi *hdmi)
+{
+	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Enable pins to HDMI */
+	if (plat->enable_pins)
+		plat->enable_pins();
+}
+
+static void mxc_hdmi_disable_pins(struct mxc_hdmi *hdmi)
+{
+	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Disable pins to HDMI */
+	if (plat->disable_pins)
+		plat->disable_pins();
+}
+
 static void mxc_hdmi_phy_disable(struct mxc_hdmi *hdmi)
 {
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
@@ -1557,6 +1824,12 @@ static void mxc_hdmi_edid_rebuild_modelist(struct mxc_hdmi *hdmi)
 	console_unlock();
 }
 
+static void  mxc_hdmi_default_edid_cfg(struct mxc_hdmi *hdmi)
+{
+	/* Default setting HDMI working in HDMI mode */
+	hdmi->edid_cfg.hdmi_cap = true;
+}
+
 static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 {
 	u32 i;
@@ -1572,6 +1845,11 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 
 	fb_destroy_modelist(&hdmi->fbi->modelist);
 
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&vga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
+
 	/*Add all no interlaced CEA mode to default modelist */
 	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
 		mode = &mxc_cea_mode[i];
@@ -1579,10 +1857,6 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 			fb_add_videomode(mode, &hdmi->fbi->modelist);
 	}
 
-	/*Add XGA and SXGA to default modelist */
-	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
-	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
-
 	console_unlock();
 }
 
@@ -1629,17 +1903,17 @@ static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi)
 		return;
 	}
 
-	/* If video mode same as previous, init HDMI PHY and return */
+	/* If video mode same as previous, init HDMI again */
 	if (fb_mode_is_equal(&hdmi->previous_non_vga_mode, mode)) {
 		dev_dbg(&hdmi->pdev->dev,
 				"%s: Video mode same as previous\n", __func__);
 		/* update fbi mode in case modelist is updated */
 		hdmi->fbi->mode = (struct fb_videomode *)mode;
-		mxc_hdmi_phy_init(hdmi);
+		/* update hdmi setting in case EDID data updated  */
+		mxc_hdmi_setup(hdmi, 0);
 	} else {
 		dev_dbg(&hdmi->pdev->dev, "%s: New video mode\n", __func__);
 		mxc_hdmi_set_mode_to_vga_dvi(hdmi);
-
 		fb_videomode_to_var(&hdmi->fbi->var, mode);
 		dump_fb_videomode((struct fb_videomode *)mode);
 		mxc_hdmi_notify_fb(hdmi);
@@ -1675,8 +1949,10 @@ static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
 	case HDMI_EDID_SAME:
 		break;
 
-	case HDMI_EDID_NO_MODES:
 	case HDMI_EDID_FAIL:
+		mxc_hdmi_default_edid_cfg(hdmi);
+		/* No break here  */
+	case HDMI_EDID_NO_MODES:
 	default:
 		mxc_hdmi_default_modelist(hdmi);
 		break;
@@ -1705,10 +1981,13 @@ static void mxc_hdmi_cable_disconnected(struct mxc_hdmi *hdmi)
 {
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
-	hdmi_disable_overflow_interrupts();
+	/* Disable All HDMI clock */
+	hdmi_writeb(0xff, HDMI_MC_CLKDIS);
 
 	mxc_hdmi_phy_disable(hdmi);
 
+	hdmi_disable_overflow_interrupts();
+
 	hdmi->cable_plugin = false;
 }
 
@@ -1720,7 +1999,7 @@ static void hotplug_worker(struct work_struct *work)
 	u32 phy_int_stat, phy_int_pol, phy_int_mask;
 	u8 val;
 	unsigned long flags;
-	char event_string[16];
+	char event_string[32];
 	char *envp[] = { event_string, NULL };
 
 	phy_int_stat = hdmi->latest_intr_stat;
@@ -1789,6 +2068,21 @@ static void hotplug_worker(struct work_struct *work)
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 }
 
+static void hdcp_hdp_worker(struct work_struct *work)
+{
+	struct delayed_work *delay_work = to_delayed_work(work);
+	struct mxc_hdmi *hdmi =
+		container_of(delay_work, struct mxc_hdmi, hdcp_hdp_work);
+	char event_string[32];
+	char *envp[] = { event_string, NULL };
+
+	/* HDCP interrupt */
+	sprintf(event_string, "EVENT=hdcpint");
+	kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+
+	/* Unmute interrupts in HDCP application*/
+}
+
 static irqreturn_t mxc_hdmi_hotplug(int irq, void *data)
 {
 	struct mxc_hdmi *hdmi = data;
@@ -1837,6 +2131,17 @@ static irqreturn_t mxc_hdmi_hotplug(int irq, void *data)
 		schedule_delayed_work(&(hdmi->hotplug_work), msecs_to_jiffies(20));
 	}
 
+	/* Check HDCP  interrupt state */
+	if (hdmi->hdmi_data.hdcp_enable) {
+		val = hdmi_readb(HDMI_A_APIINTSTAT);
+		if (val != 0) {
+			/* Mute interrupts until interrupt handled */
+			val = 0xFF;
+			hdmi_writeb(val, HDMI_A_APIINTMSK);
+			schedule_delayed_work(&(hdmi->hdcp_hdp_work), msecs_to_jiffies(50));
+		}
+	}
+
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 	return IRQ_HANDLED;
 }
@@ -1851,15 +2156,6 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	fb_var_to_videomode(&m, &hdmi->fbi->var);
 	dump_fb_videomode(&m);
 
-	/* Exit the setup if we get mode change and are already set to
-	 * this video mode */
-	if ((event == FB_EVENT_MODE_CHANGE) &&
-		fb_mode_is_equal(&hdmi->previous_mode, &m)) {
-		dev_dbg(&hdmi->pdev->dev,
-			"%s video mode did not change.\n", __func__);
-		mxc_hdmi_phy_init(hdmi);
-		return;
-	}
 	dev_dbg(&hdmi->pdev->dev, "%s - video mode changed\n", __func__);
 
 	/* Save mode as 'previous_mode' so that we can know if mode changed. */
@@ -1881,17 +2177,12 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 
 	hdmi_disable_overflow_interrupts();
 
-	if (hdmi->vic == 0) {
-		dev_dbg(&hdmi->pdev->dev, "Non-CEA mode used in HDMI\n");
+	dev_dbg(&hdmi->pdev->dev, "CEA mode used vic=%d\n", hdmi->vic);
+	if (hdmi->edid_cfg.hdmi_cap)
+		hdmi->hdmi_data.video_mode.mDVI = false;
+	else {
+		dev_dbg(&hdmi->pdev->dev, "CEA mode vic=%d work in DVI\n", hdmi->vic);
 		hdmi->hdmi_data.video_mode.mDVI = true;
-	} else {
-		dev_dbg(&hdmi->pdev->dev, "CEA mode used vic=%d\n", hdmi->vic);
-		if (hdmi->edid_cfg.hdmi_cap)
-			hdmi->hdmi_data.video_mode.mDVI = false;
-		else {
-			dev_dbg(&hdmi->pdev->dev, "CEA mode vic=%d work in DVI\n", hdmi->vic);
-			hdmi->hdmi_data.video_mode.mDVI = true;
-		}
 	}
 
 	if ((hdmi->vic == 6) || (hdmi->vic == 7) ||
@@ -1920,8 +2211,10 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	hdmi->hdmi_data.enc_in_format = RGB;
 
 	hdmi->hdmi_data.enc_out_format = RGB;
-	/*DVI mode not support non-RGB */
-	if (!hdmi->hdmi_data.video_mode.mDVI) {
+
+	/* YCbCr only enabled in HDMI mode */
+	if (!hdmi->hdmi_data.video_mode.mDVI &&
+		!hdmi->hdmi_data.rgb_out_enable) {
 		if (hdmi->edid_cfg.cea_ycbcr444)
 			hdmi->hdmi_data.enc_out_format = YCBCR444;
 		else if (hdmi->edid_cfg.cea_ycbcr422)
@@ -1931,7 +2224,6 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	/* IPU not support depth color output */
 	hdmi->hdmi_data.enc_color_depth = 8;
 	hdmi->hdmi_data.pix_repet_factor = 0;
-	hdmi->hdmi_data.hdcp_enable = 0;
 	hdmi->hdmi_data.video_mode.mDataEnablePolarity = true;
 
 	/* HDMI Initialization Step B.1 */
@@ -2092,6 +2384,7 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	int ret = 0;
 	u32 i;
 	const struct fb_videomode *mode;
+	struct fb_videomode m;
 	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
 	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
 	int irq = platform_get_irq(hdmi->pdev, 0);
@@ -2135,6 +2428,10 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	if (plat->init)
 		plat->init(mxc_hdmi_ipu_id, mxc_hdmi_disp_id);
 
+	/* Specific phy config */
+	hdmi->phy_config.reg_cksymtx = plat->phy_reg_cksymtx;
+	hdmi->phy_config.reg_vlev = plat->phy_reg_vlev;
+
 	hdmi->hdmi_isfr_clk = clk_get(&hdmi->pdev->dev, "hdmi_isfr_clk");
 	if (IS_ERR(hdmi->hdmi_isfr_clk)) {
 		ret = PTR_ERR(hdmi->hdmi_isfr_clk);
@@ -2205,7 +2502,23 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	console_unlock();
 
+	/* Find a nearest mode in default modelist */
+	fb_var_to_videomode(&m, &hdmi->fbi->var);
+	dump_fb_videomode(&m);
+
+	mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
+	if (!mode) {
+		pr_err("%s: could not find mode in modelist\n", __func__);
+		return -1;
+	}
+
+	fb_videomode_to_var(&hdmi->fbi->var, mode);
+
+	/* Default setting HDMI working in HDMI mode*/
+	hdmi->edid_cfg.hdmi_cap = true;
+
 	INIT_DELAYED_WORK(&hdmi->hotplug_work, hotplug_worker);
+	INIT_DELAYED_WORK(&hdmi->hdcp_hdp_work, hdcp_hdp_worker);
 
 	/* Configure registers related to HDMI interrupt
 	 * generation before registering IRQ. */
@@ -2221,6 +2534,9 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	memset(&hdmi->hdmi_data, 0, sizeof(struct hdmi_data_info));
 
+	/* Default HDMI working in RGB mode */
+	hdmi->hdmi_data.rgb_out_enable = true;
+
 	ret = request_irq(irq, mxc_hdmi_hotplug, IRQF_SHARED,
 			  dev_name(&hdmi->pdev->dev), hdmi);
 	if (ret < 0) {
@@ -2242,6 +2558,16 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 		dev_warn(&hdmi->pdev->dev,
 			"cound not create sys node for edid\n");
 
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_rgb_out_enable);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for rgb out enable\n");
+
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_hdcp_enable);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for hdcp enable\n");
+
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 
 	hdmi_inited = true;
@@ -2299,9 +2625,50 @@ static struct mxc_dispdrv_driver mxc_hdmi_drv = {
 	.disable = mxc_hdmi_power_off,
 };
 
+
+static int mxc_hdmi_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long mxc_hdmi_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int __user *argp = (void __user *)arg;
+	int ret = 0;
+
+	switch (cmd) {
+	case HDMI_IOC_GET_RESOURCE:
+		ret = copy_to_user(argp, &g_hdmi->hdmi_data,
+				sizeof(g_hdmi->hdmi_data)) ? -EFAULT : 0;
+		break;
+	case HDMI_IOC_GET_CPU_TYPE:
+		*argp = mxc_cpu_type;
+		break;
+	default:
+		pr_debug("Unsupport cmd %d\n", cmd);
+		break;
+     }
+     return ret;
+}
+
+static int mxc_hdmi_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations mxc_hdmi_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_hdmi_open,
+	.release = mxc_hdmi_release,
+	.unlocked_ioctl = mxc_hdmi_ioctl,
+};
+
+
 static int __devinit mxc_hdmi_probe(struct platform_device *pdev)
 {
 	struct mxc_hdmi *hdmi;
+	struct device *temp_class;
 	int ret = 0;
 
 	/* Check that I2C driver is loaded and available */
@@ -2314,6 +2681,28 @@ static int __devinit mxc_hdmi_probe(struct platform_device *pdev)
 		ret = -ENOMEM;
 		goto ealloc;
 	}
+	g_hdmi = hdmi;
+
+	hdmi_major = register_chrdev(hdmi_major, "mxc_hdmi", &mxc_hdmi_fops);
+	if (hdmi_major < 0) {
+		printk(KERN_ERR "HDMI: unable to get a major for HDMI\n");
+		ret = -EBUSY;
+		goto ealloc;
+	}
+
+	hdmi_class = class_create(THIS_MODULE, "mxc_hdmi");
+	if (IS_ERR(hdmi_class)) {
+		ret = PTR_ERR(hdmi_class);
+		goto err_out_chrdev;
+	}
+
+	temp_class = device_create(hdmi_class, NULL, MKDEV(hdmi_major, 0),
+				   NULL, "mxc_hdmi");
+	if (IS_ERR(temp_class)) {
+		ret = PTR_ERR(temp_class);
+		goto err_out_class;
+	}
+
 
 	hdmi->pdev = pdev;
 
@@ -2343,6 +2732,11 @@ edispdrv:
 	platform_device_put(hdmi->core_pdev);
 ecore:
 	kfree(hdmi);
+err_out_class:
+	device_destroy(hdmi_class, MKDEV(hdmi_major, 0));
+	class_destroy(hdmi_class);
+err_out_chrdev:
+	unregister_chrdev(hdmi_major, "mxc_hdmi");
 ealloc:
 	return ret;
 }
@@ -2359,6 +2753,7 @@ static int mxc_hdmi_remove(struct platform_device *pdev)
 	/* No new work will be scheduled, wait for running ISR */
 	free_irq(irq, hdmi);
 	kfree(hdmi);
+	g_hdmi = NULL;
 
 	return 0;
 }
@@ -2380,6 +2775,13 @@ module_init(mxc_hdmi_init);
 
 static void __exit mxc_hdmi_exit(void)
 {
+	if (hdmi_major > 0) {
+		device_destroy(hdmi_class, MKDEV(hdmi_major, 0));
+		class_destroy(hdmi_class);
+		unregister_chrdev(hdmi_major, "mxc_hdmi");
+		hdmi_major = 0;
+	}
+
 	platform_driver_unregister(&mxc_hdmi_driver);
 }
 module_exit(mxc_hdmi_exit);
diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index cc0bb49..129dbee 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -93,7 +93,7 @@ void can_bus_off(struct net_device *dev);
 
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 		      unsigned int idx);
-void can_get_echo_skb(struct net_device *dev, unsigned int idx);
+unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
 struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index d6733e2..acc1435 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -151,6 +151,12 @@ clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 				      freq, minsec);
 }
 
+#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)
+extern int tick_check_broadcast_pending(void);
+#else
+static inline int tick_check_broadcast_pending(void) { return 0; }
+#endif
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else
diff --git a/include/linux/dmapool.h b/include/linux/dmapool.h
index 4509501..c3c41ef 100644
--- a/include/linux/dmapool.h
+++ b/include/linux/dmapool.h
@@ -22,10 +22,8 @@ void dma_pool_destroy(struct dma_pool *pool);
 void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
 		     dma_addr_t *handle);
 
-#ifdef CONFIG_FSL_UTP
 void *dma_pool_alloc_nonbufferable(struct dma_pool *pool, gfp_t mem_flags,
 		     dma_addr_t *handle);
-#endif
 
 void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t addr);
 
diff --git a/include/linux/fec.h b/include/linux/fec.h
index 8f69cb5..7d4e73d 100644
--- a/include/linux/fec.h
+++ b/include/linux/fec.h
@@ -3,7 +3,7 @@
  * Copyright (c) 2009 Orex Computed Radiography
  *   Baruch Siach <baruch@tkos.co.il>
  *
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  *
  * Header file for the FEC platform data
  *
@@ -21,6 +21,7 @@ struct fec_platform_data {
 	int (*power_hibernate) (struct phy_device *);
 	phy_interface_t phy;
 	unsigned char mac[ETH_ALEN];
+	int gpio_irq;
 };
 
 #endif
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index ab22c4a..ac56f18 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -6,7 +6,7 @@
  *
  * Maintainer: Kumar Gala <galak@kernel.crashing.org>
  *
- * Copyright 2004-2012 Freescale Semiconductor, Inc.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -284,6 +284,9 @@ struct fsl_mxc_hdmi_platform_data {
 	void (*put_pins) (void);
 	void (*enable_pins) (void);
 	void (*disable_pins) (void);
+	/* HDMI PHY register config for pass HCT */
+	u16 phy_reg_vlev;
+	u16 phy_reg_cksymtx;
 };
 
 struct fsl_mxc_hdmi_core_platform_data {
@@ -320,6 +323,8 @@ struct fsl_mxc_tvin_platform_data {
 	void (*reset)(void);
 	void (*io_init)(void);
 	bool cvbs;
+	/* adv7280 mipi-csi i2c slave addr */
+	u8 csi_tx_addr;
 };
 
 struct mpc8xx_pcmcia_ops {
diff --git a/include/linux/i2c/novatek_ts.h b/include/linux/i2c/novatek_ts.h
new file mode 100644
index 0000000..0f8695f
--- /dev/null
+++ b/include/linux/i2c/novatek_ts.h
@@ -0,0 +1,16 @@
+/* Copyright (C) 2012 Freescale Semiconductor, Inc. */
+
+#ifndef NOVATEK_TS_H
+#define NOVATEK_TS_H
+
+
+
+/**
+ * struct novatek_platform_data - platform data for novatek touch screen chip.
+ * @reset_gpio: gpio for chip reset pin
+ */
+struct novatek_platform_data {
+	int reset_gpio;
+};
+
+#endif
diff --git a/include/linux/ipu.h b/include/linux/ipu.h
index f8178f1..358d315 100644
--- a/include/linux/ipu.h
+++ b/include/linux/ipu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -94,6 +94,7 @@ typedef enum {
 /*! @{ */
 #define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
 #define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_16 fourcc('I', 'P', 'U', '2')	/*!< IPU Generic Data */
 #define IPU_PIX_FMT_LVDS666 fourcc('L', 'V', 'D', '6')	/*!< IPU Generic Data */
 #define IPU_PIX_FMT_LVDS888 fourcc('L', 'V', 'D', '8')	/*!< IPU Generic Data */
 /*! @} */
@@ -168,6 +169,14 @@ struct ipu_deinterlace {
 	u8	motion; /*see ipu_motion_sel*/
 #define IPU_DEINTERLACE_FIELD_TOP	0
 #define IPU_DEINTERLACE_FIELD_BOTTOM	1
+#define IPU_DEINTERLACE_FIELD_MASK	\
+		(IPU_DEINTERLACE_FIELD_TOP | IPU_DEINTERLACE_FIELD_BOTTOM)
+	/* deinterlace frame rate double flags */
+#define IPU_DEINTERLACE_RATE_EN		0x80
+#define IPU_DEINTERLACE_RATE_FRAME1	0x40
+#define IPU_DEINTERLACE_RATE_MASK	\
+		(IPU_DEINTERLACE_RATE_EN | IPU_DEINTERLACE_RATE_FRAME1)
+#define IPU_DEINTERLACE_MAX_FRAME	2
 	u8	field_fmt;
 };
 
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index a9e6ba4..418fd87 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -432,7 +432,7 @@ static inline void inline_map_copy_from(struct map_info *map, void *to, unsigned
 	if (map->cached)
 		memcpy(to, (char *)map->cached + from, len);
 	else
-		memcpy_fromio(to, map->virt + from, len);
+		memcpy(to, map->virt + from, len);
 }
 
 static inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
diff --git a/include/linux/mxc_asrc.h b/include/linux/mxc_asrc.h
index 081fafa..8de07b9 100644
--- a/include/linux/mxc_asrc.h
+++ b/include/linux/mxc_asrc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -27,33 +27,34 @@
 #define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
 #define ASRC_CONFIG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
 #define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
-#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
-#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
-#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
-#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
-#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
-#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
-#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
-#define ASRC_STATUS	_IOW(ASRC_IOC_MAGIC, 10, struct asrc_status_flags)
-#define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 11, enum asrc_pair_index)
-
+#define ASRC_CONVERT	_IOW(ASRC_IOC_MAGIC, 3, struct asrc_convert_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 4, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 5, enum asrc_pair_index)
+#define ASRC_STATUS	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_status_flags)
+#define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 7, enum asrc_pair_index)
 
 enum asrc_pair_index {
+	ASRC_UNVALID_PAIR = -1,
 	ASRC_PAIR_A,
 	ASRC_PAIR_B,
 	ASRC_PAIR_C
 };
 
+#define ASRC_PAIR_MAX_NUM	(ASRC_PAIR_C + 1)
+
 enum asrc_inclk {
 	INCLK_NONE = 0x03,
 	INCLK_ESAI_RX = 0x00,
 	INCLK_SSI1_RX = 0x01,
 	INCLK_SSI2_RX = 0x02,
+	INCLK_SSI3_RX = 0x07,
 	INCLK_SPDIF_RX = 0x04,
 	INCLK_MLB_CLK = 0x05,
+	INCLK_PAD = 0x06,
 	INCLK_ESAI_TX = 0x08,
 	INCLK_SSI1_TX = 0x09,
 	INCLK_SSI2_TX = 0x0a,
+	INCLK_SSI3_TX = 0x0b,
 	INCLK_SPDIF_TX = 0x0c,
 	INCLK_ASRCK1_CLK = 0x0f,
 };
@@ -63,11 +64,14 @@ enum asrc_outclk {
 	OUTCLK_ESAI_TX = 0x00,
 	OUTCLK_SSI1_TX = 0x01,
 	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SSI3_TX = 0x07,
 	OUTCLK_SPDIF_TX = 0x04,
 	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_PAD = 0x06,
 	OUTCLK_ESAI_RX = 0x08,
 	OUTCLK_SSI1_RX = 0x09,
 	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SSI3_RX = 0x0b,
 	OUTCLK_SPDIF_RX = 0x0c,
 	OUTCLK_ASRCK1_CLK = 0x0f,
 };
@@ -112,12 +116,21 @@ struct asrc_querybuf {
 	unsigned long output_offset;
 };
 
+struct asrc_convert_buffer {
+	void *input_buffer_vaddr;
+	void *output_buffer_vaddr;
+	unsigned int input_buffer_length;
+	unsigned int output_buffer_length;
+};
+
 struct asrc_buffer {
 	unsigned int index;
 	unsigned int length;
+	unsigned int output_last_length;
 	int buf_valid;
 };
 
+
 struct asrc_status_flags {
 	enum asrc_pair_index index;
 	unsigned int overload_error;
@@ -134,10 +147,15 @@ enum asrc_error_status {
 };
 
 #ifdef __KERNEL__
+#include <linux/scatterlist.h>
 
 #define ASRC_DMA_BUFFER_NUM		2
 #define ASRC_INPUTFIFO_THRESHOLD	32
 #define ASRC_OUTPUTFIFO_THRESHOLD	32
+#define ASRC_DMA_BUFFER_SIZE	(1024 * 48 * 4)
+#define ASRC_MAX_BUFFER_SIZE	(1024 * 48)
+#define ASRC_OUTPUT_LAST_SAMPLE	8
+
 
 #define ASRC_ASRCTR_REG 	0x00
 #define ASRC_ASRIER_REG 	0x04
@@ -182,10 +200,19 @@ enum asrc_error_status {
 #define ASRC_ASRMCR1C_REG   0xC8
 
 
+#define ASRC_ASRFSTX_INPUT_FIFO_WIDTH	7
+#define ASRC_ASRFSTX_INPUT_FIFO_OFFSET	0
+#define ASRC_ASRFSTX_INPUT_FIFO_MASK	0x7F
+
+#define ASRC_ASRFSTX_OUTPUT_FIFO_WIDTH	7
+#define ASRC_ASRFSTX_OUTPUT_FIFO_OFFSET	12
+#define ASRC_ASRFSTX_OUTPUT_FIFO_MASK (0x7F << ASRC_ASRFSTX_OUTPUT_FIFO_OFFSET)
+
+
 struct dma_block {
 	unsigned int index;
 	unsigned int length;
-	unsigned char *dma_vaddr;
+	void *dma_vaddr;
 	dma_addr_t dma_paddr;
 	struct list_head queue;
 };
@@ -197,16 +224,10 @@ struct asrc_p2p_params {
 
 struct asrc_pair_params {
 	enum asrc_pair_index index;
-	struct list_head input_queue;
-	struct list_head input_done_queue;
-	struct list_head output_queue;
-	struct list_head output_done_queue;
 	wait_queue_head_t input_wait_queue;
 	wait_queue_head_t output_wait_queue;
 	unsigned int input_counter;
 	unsigned int output_counter;
-	unsigned int input_queue_empty;
-	unsigned int output_queue_empty;
 	struct dma_chan *input_dma_channel;
 	struct dma_chan *output_dma_channel;
 	unsigned int input_buffer_size;
@@ -219,8 +240,19 @@ struct asrc_pair_params {
 	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
 	struct dma_block output_dma_total;
 	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_last_period;
 	struct dma_async_tx_descriptor *desc_in;
 	struct dma_async_tx_descriptor *desc_out;
+	struct work_struct task_output_work;
+	unsigned int		input_sg_nodes;
+	unsigned int		output_sg_nodes;
+	struct scatterlist	input_sg[4], output_sg[4];
+	enum asrc_word_width input_word_width;
+	enum asrc_word_width output_word_width;
+	u32 input_sample_rate;
+	u32 output_sample_rate;
+	u32 input_wm;
+	u32 output_wm;
 };
 
 struct asrc_data {
@@ -236,6 +268,19 @@ struct asrc_data {
 	struct device *dev;
 };
 
+struct asrc_p2p_ops {
+	void (*asrc_p2p_start_conv)(enum asrc_pair_index);
+	void (*asrc_p2p_stop_conv)(enum asrc_pair_index);
+	int (*asrc_p2p_get_dma_request)(enum asrc_pair_index, bool);
+	u32 (*asrc_p2p_per_addr)(enum asrc_pair_index, bool);
+	int (*asrc_p2p_req_pair)(int, enum asrc_pair_index *index);
+	int (*asrc_p2p_config_pair)(struct asrc_config *config);
+	void (*asrc_p2p_release_pair)(enum asrc_pair_index);
+	void (*asrc_p2p_finish_conv)(enum asrc_pair_index);
+};
+
+extern void asrc_p2p_hook(struct asrc_p2p_ops *asrc_p2p_ct);
+
 extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
 extern void asrc_release_pair(enum asrc_pair_index index);
 extern int asrc_config_pair(struct asrc_config *config);
@@ -245,6 +290,8 @@ extern void asrc_stop_conv(enum asrc_pair_index index);
 extern u32 asrc_get_per_addr(enum asrc_pair_index index, bool i);
 extern int asrc_get_dma_request(enum asrc_pair_index index, bool i);
 extern void asrc_finish_conv(enum asrc_pair_index index);
+extern int asrc_set_watermark(enum asrc_pair_index index,
+					u32 in_wm, u32 out_wm);
 
 #endif				/* __kERNEL__ */
 
diff --git a/include/linux/mxc_mlb.h b/include/linux/mxc_mlb.h
index 7ac953c..3a63647 100644
--- a/include/linux/mxc_mlb.h
+++ b/include/linux/mxc_mlb.h
@@ -1,7 +1,7 @@
 /*
  * mxc_mlb.h
  *
- * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,6 +21,7 @@
 #define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
 #define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
 #define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+
 /*!
  * set channel address for each logical channel
  * the MSB 16bits is for tx channel, the left LSB is for rx channel
@@ -30,6 +31,10 @@
 #define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
 #define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
 
+#define MLB_SET_ISOC_BLKSIZE_188 _IO('S', 0x17)
+#define MLB_SET_ISOC_BLKSIZE_196 _IO('S', 0x18)
+#define MLB_SET_SYNC_QUAD	_IOW('S', 0x19, unsigned int)
+
 /*!
  * MLB event define
  */
diff --git a/include/linux/mxcfb.h b/include/linux/mxcfb.h
index be391e0..d96d1b7 100644
--- a/include/linux/mxcfb.h
+++ b/include/linux/mxcfb.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -110,7 +110,7 @@ struct mxcfb_update_data {
 	__u32 update_mode;
 	__u32 update_marker;
 	int temp;
-	uint flags;
+	unsigned int flags;
 	struct mxcfb_alt_buffer_data alt_buffer_data;
 };
 
@@ -132,6 +132,14 @@ struct mxcfb_waveform_modes {
 	int mode_gc32;
 };
 
+/*
+ * Structure used to define a 5*3 matrix of parameters for
+ * setting IPU DP CSC module related to this framebuffer.
+ */
+struct mxcfb_csc_matrix {
+	int param[5][3];
+};
+
 #define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
 #define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
 #define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
@@ -144,6 +152,7 @@ struct mxcfb_waveform_modes {
 #define MXCFB_GET_DIFMT	       _IOR('F', 0x2A, u_int32_t)
 #define MXCFB_GET_FB_BLANK     _IOR('F', 0x2B, u_int32_t)
 #define MXCFB_SET_DIFMT		_IOW('F', 0x2C, u_int32_t)
+#define MXCFB_CSC_UPDATE	_IOW('F', 0x2D, struct mxcfb_csc_matrix)
 
 /* IOCTLs for E-ink panel updates */
 #define MXCFB_SET_WAVEFORM_MODES	_IOW('F', 0x2B, struct mxcfb_waveform_modes)
diff --git a/kernel/power/main.c b/kernel/power/main.c
index b7d0e30..0fae580 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -16,6 +16,7 @@
 #include "power.h"
 
 DEFINE_MUTEX(pm_mutex);
+EXPORT_SYMBOL(pm_mutex);
 
 #ifdef CONFIG_PM_SLEEP
 
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index 7a90d02..56f7043 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -360,6 +360,8 @@ int tick_resume_broadcast(void)
 
 /* FIXME: use cpumask_var_t. */
 static DECLARE_BITMAP(tick_broadcast_oneshot_mask, NR_CPUS);
+static DECLARE_BITMAP(tick_broadcast_pending, NR_CPUS);
+static DECLARE_BITMAP(tick_force_broadcast_mask, NR_CPUS);
 
 /*
  * Exposed for debugging: see timer_list.c
@@ -376,6 +378,15 @@ static int tick_broadcast_set_event(ktime_t expires, int force)
 	return tick_dev_program_event(bc, expires, force);
 }
 
+/*
+ * Called before going idle with interrupts disabled. Checks whether a
+ * broadcast event from the other core is about to happen.
+ */
+int tick_check_broadcast_pending(void)
+{
+	return test_bit(smp_processor_id(), tick_force_broadcast_mask);
+}
+
 int tick_resume_broadcast_oneshot(struct clock_event_device *bc)
 {
 	clockevents_set_mode(bc, CLOCK_EVT_MODE_ONESHOT);
@@ -413,12 +424,24 @@ again:
 	/* Find all expired events */
 	for_each_cpu(cpu, tick_get_broadcast_oneshot_mask()) {
 		td = &per_cpu(tick_cpu_device, cpu);
-		if (td->evtdev->next_event.tv64 <= now.tv64)
+		if (td->evtdev->next_event.tv64 <= now.tv64) {
 			cpumask_set_cpu(cpu, to_cpumask(tmpmask));
-		else if (td->evtdev->next_event.tv64 < next_event.tv64)
+			/*
+			 * Mark the remote cpu in the pending mask, so
+			 * it can avoid reprogramming the cpu local
+			 * timer in tick_broadcast_oneshot_control().
+			 */
+			set_bit(cpu, tick_broadcast_pending);
+		} else if (td->evtdev->next_event.tv64 < next_event.tv64)
 			next_event.tv64 = td->evtdev->next_event.tv64;
 	}
 
+	/* Take care of enforced broadcast requests */
+	for_each_cpu(cpu, to_cpumask(tick_force_broadcast_mask)) {
+		set_bit(cpu, tmpmask);
+		clear_bit(cpu, tick_force_broadcast_mask);
+	}
+
 	/*
 	 * Wakeup the cpus which have an expired event.
 	 */
@@ -454,6 +477,7 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 	struct clock_event_device *bc, *dev;
 	struct tick_device *td;
 	unsigned long flags;
+	ktime_t now;
 	int cpu;
 
 	/*
@@ -478,6 +502,8 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 
 	raw_spin_lock_irqsave(&tick_broadcast_lock, flags);
 	if (reason == CLOCK_EVT_NOTIFY_BROADCAST_ENTER) {
+		WARN_ON_ONCE(test_bit(cpu, tick_broadcast_pending));
+		WARN_ON_ONCE(test_bit(cpu, tick_force_broadcast_mask));
 		if (!cpumask_test_cpu(cpu, tick_get_broadcast_oneshot_mask())) {
 			cpumask_set_cpu(cpu, tick_get_broadcast_oneshot_mask());
 			clockevents_set_mode(dev, CLOCK_EVT_MODE_SHUTDOWN);
@@ -489,10 +515,61 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 			cpumask_clear_cpu(cpu,
 					  tick_get_broadcast_oneshot_mask());
 			clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
-			if (dev->next_event.tv64 != KTIME_MAX)
-				tick_program_event(dev->next_event, 1);
+			if (dev->next_event.tv64 == KTIME_MAX)
+				goto out;
+			/*
+			 * The cpu handling the broadcast timer marked
+			 * this cpu in the broadcast pending mask and
+			 * fired the broadcast IPI. So we are going to
+			 * handle the expired event anyway via the
+			 * broadcast IPI handler. No need to reprogram
+			 * the timer with an already expired event.
+			 */
+			if (test_and_clear_bit(cpu, tick_broadcast_pending))
+				goto out;
+			/*
+			 * If the pending bit is not set, then we are
+			 * either the CPU handling the broadcast
+			 * interrupt or we got woken by something else.
+			 *
+			 * We are not longer in the broadcast mask, so
+			 * if the cpu local expiry time is already
+			 * reached, we would reprogram the cpu local
+			 * timer with an already expired event.
+			 *
+			 * This can lead to a ping-pong when we return
+			 * to idle and therefor rearm the broadcast
+			 * timer before the cpu local timer was able
+			 * to fire. This happens because the forced
+			 * reprogramming makes sure that the event
+			 * will happen in the future and depending on
+			 * the min_delta setting this might be far
+			 * enough out that the ping-pong starts.
+			 *
+			 * If the cpu local next_event has expired
+			 * then we know that the broadcast timer
+			 * next_event has expired as well and
+			 * broadcast is about to be handled. So we
+			 * avoid reprogramming and enforce that the
+			 * broadcast handler, which did not run yet,
+			 * will invoke the cpu local handler.
+			 *
+			 * We cannot call the handler directly from
+			 * here, because we might be in a NOHZ phase
+			 * and we did not go through the irq_enter()
+			 * nohz fixups.
+			 */
+			now = ktime_get();
+			if (dev->next_event.tv64 <= now.tv64)
+				set_bit(cpu, tick_force_broadcast_mask);
+			/*
+			 * We got woken by something else. Reprogram
+			 * the cpu local timer device.
+			 */
+			tick_program_event(dev->next_event, 1);
 		}
 	}
+out:
 	raw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);
 }
 
diff --git a/mm/compaction.c b/mm/compaction.c
index c4bc5ac..bf6bc32 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -715,14 +715,12 @@ static int compact_node(int nid)
 }
 
 /* Compact all nodes in the system */
-static int compact_nodes(void)
+static void compact_nodes(void)
 {
 	int nid;
 
 	for_each_online_node(nid)
 		compact_node(nid);
-
-	return COMPACT_COMPLETE;
 }
 
 /* The written value is actually unused, all memory is compacted */
@@ -733,7 +731,7 @@ int sysctl_compaction_handler(struct ctl_table *table, int write,
 			void __user *buffer, size_t *length, loff_t *ppos)
 {
 	if (write)
-		return compact_nodes();
+		compact_nodes();
 
 	return 0;
 }
diff --git a/mm/dmapool.c b/mm/dmapool.c
index 98798f41..0d19926 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -212,7 +212,6 @@ static void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)
 	} while (offset < pool->allocation);
 }
 
-#ifdef CONFIG_FSL_UTP
 static struct dma_page *pool_alloc_page_nonbufferable(struct dma_pool *pool, gfp_t mem_flags)
 {
 	struct dma_page *page;
@@ -236,7 +235,6 @@ static struct dma_page *pool_alloc_page_nonbufferable(struct dma_pool *pool, gfp
 	}
 	return page;
 }
-#endif
 
 static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)
 {
@@ -379,7 +377,6 @@ void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
 }
 EXPORT_SYMBOL(dma_pool_alloc);
 
-#ifdef CONFIG_FSL_UTP
 /**
  * dma_pool_alloc_nonbufferable - get a block of consistent memory
  * @pool: dma pool that will produce the block
@@ -439,7 +436,6 @@ void *dma_pool_alloc_nonbufferable(struct dma_pool *pool, gfp_t mem_flags,
 	return retval;
 }
 EXPORT_SYMBOL(dma_pool_alloc_nonbufferable);
-#endif
 
 static struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)
 {
diff --git a/sound/soc/codecs/cs42888.c b/sound/soc/codecs/cs42888.c
index 698ff4b..03f160b 100644
--- a/sound/soc/codecs/cs42888.c
+++ b/sound/soc/codecs/cs42888.c
@@ -1,6 +1,6 @@
 /*
  * cs42888.c  -- CS42888 ALSA SoC Audio Driver
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 /*
  * The code contained herein is licensed under the GNU General Public
@@ -129,6 +129,11 @@ static const char *cs42888_supply_names[CS42888_NUM_SUPPLIES] = {
 #define CS42888_TRANS_ADC_SNGVOL_MASK	(1 << CS42888_TRANS_ADC_SNGVOL_OFFSET)
 #define CS42888_TRANS_ADC_SZC_MASK	(3 << CS42888_TRANS_ADC_SZC_OFFSET)
 
+#define CS42888_TRANS_DAC_SZC_IC     (0 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_ZC     (1 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_SR     (2 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_SRZC   (3 << CS42888_TRANS_DAC_SZC_OFFSET)
+
 #define CS42888_MUTE_AOUT8	(0x1 << 7)
 #define CS42888_MUTE_AOUT7	(0x1 << 6)
 #define CS42888_MUTE_AOUT6	(0x1 << 5)
@@ -717,7 +722,6 @@ static int cs42888_hw_params(struct snd_pcm_substream *substream,
 		pr_err("i2c write failed\n");
 		return ret;
 	}
-	 msleep(400);
 
 	ret = cs42888_fill_cache(codec);
 	if (ret < 0) {
@@ -884,6 +888,8 @@ static int cs42888_probe(struct snd_soc_codec *codec)
 	/* Disable auto-mute */
 	val = snd_soc_read(codec, CS42888_TRANS);
 	val &= ~CS42888_TRANS_AMUTE_MASK;
+	val &= ~CS42888_TRANS_DAC_SZC_MASK;
+	val |=  CS42888_TRANS_DAC_SZC_SR;
 	ret = snd_soc_write(codec, CS42888_TRANS, val);
 	if (ret < 0) {
 		pr_err("i2c write failed\n");
diff --git a/sound/soc/codecs/mxc_spdif.c b/sound/soc/codecs/mxc_spdif.c
index 33b2337..b358f71 100644
--- a/sound/soc/codecs/mxc_spdif.c
+++ b/sound/soc/codecs/mxc_spdif.c
@@ -1,7 +1,7 @@
 /*
  * MXC SPDIF ALSA Soc Codec Driver
  *
- * Copyright (C) 2007-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -881,10 +881,17 @@ static int mxc_spdif_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int cstatus;
 
-	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW))
+	clk_enable(plat_data->spdif_clk);
+
+	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW)) {
+		clk_disable(plat_data->spdif_clk);
 		return -EAGAIN;
+	}
 
 	cstatus = __raw_readl(spdif_base_addr + SPDIF_REG_SRCSLH);
 	ucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;
@@ -898,6 +905,8 @@ static int mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 	/* clear intr */
 	__raw_writel(INT_CNEW, spdif_base_addr + SPDIF_REG_SIC);
 
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -980,12 +989,19 @@ static int mxc_spdif_vbit_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_vbit_get(struct snd_kcontrol *kcontrol,
 			      struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int int_val;
 
+	clk_enable(plat_data->spdif_clk);
+
 	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SIS);
 	ucontrol->value.integer.value[0] = (int_val & INT_VAL_NOGOOD) != 0;
 	__raw_writel(INT_VAL_NOGOOD, spdif_base_addr + SPDIF_REG_SIC);
 
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1016,9 +1032,11 @@ static int mxc_spdif_rxrate_get(struct snd_kcontrol *kcontrol,
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 
 	if (atomic_read(&spdif_priv->dpll_locked)) {
+		clk_enable(plat_data->spdif_clk);
 		ucontrol->value.integer.value[0] =
 		    spdif_get_rxclk_rate(plat_data->spdif_clk,
 					 SPDIF_DEFAULT_GAINSEL);
+		clk_disable(plat_data->spdif_clk);
 	} else {
 		ucontrol->value.integer.value[0] = 0;
 	}
@@ -1046,9 +1064,18 @@ static int mxc_spdif_usync_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int int_val;
+
+	clk_enable(plat_data->spdif_clk);
+
 	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SRCD);
 	ucontrol->value.integer.value[0] = (int_val & SRCD_CD_USER) != 0;
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1060,10 +1087,18 @@ static int mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_usync_put(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int int_val;
 
+	clk_enable(plat_data->spdif_clk);
+
 	int_val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;
 	__raw_writel(int_val, spdif_base_addr + SPDIF_REG_SRCD);
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c
index 784b595..b54ddb7 100644
--- a/sound/soc/codecs/wm8962.c
+++ b/sound/soc/codecs/wm8962.c
@@ -5,7 +5,7 @@
  *
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  *
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -2218,6 +2218,8 @@ SOC_ENUM("Capture LHPF Mode", cap_lhpf_mode),
 SOC_DOUBLE_R_TLV("Sidetone Volume", WM8962_DAC_DSP_MIXING_1,
 		 WM8962_DAC_DSP_MIXING_2, 4, 12, 0, st_tlv),
 
+SOC_DOUBLE_R_TLV("Digital Playback Volume", WM8962_LEFT_DAC_VOLUME,
+		 WM8962_RIGHT_DAC_VOLUME, 1, 127, 0, digital_tlv),
 SOC_SINGLE("DAC High Performance Switch", WM8962_ADC_DAC_CONTROL_2, 0, 1, 0),
 
 SOC_SINGLE("ADC High Performance Switch", WM8962_ADDITIONAL_CONTROL_1,
@@ -2377,9 +2379,9 @@ static int sysclk_event(struct snd_soc_dapm_widget *w,
 		break;
 
 	case SND_SOC_DAPM_POST_PMD:
-		if (fll)
-			snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
-					    WM8962_FLL_ENA, 0);
+		/* After Power-down, close FLL if FLL-enabled */
+		snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
+				WM8962_FLL_ENA, 0);
 		break;
 
 	default:
@@ -3459,6 +3461,9 @@ static int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,
 	if (fll_div.theta || fll_div.lambda)
 		fll1 |= WM8962_FLL_FRAC;
 
+	/* Stop the FLL while we reconfigure */
+	snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1, WM8962_FLL_ENA, 0);
+
 	snd_soc_update_bits(codec, WM8962_FLL_CONTROL_2,
 			    WM8962_FLL_OUTDIV_MASK |
 			    WM8962_FLL_REFCLK_DIV_MASK,
@@ -4099,10 +4104,6 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 			    WM8962_SPKOUTL_VOL_MASK, 0x72);
 	snd_soc_update_bits(codec, WM8962_SPKOUTR_VOLUME,
 			    WM8962_SPKOUTR_VOL_MASK, 0x72);
-	snd_soc_update_bits(codec, WM8962_LEFT_DAC_VOLUME,
-			    WM8962_DACL_VOL_MASK, 0xd8);
-	snd_soc_update_bits(codec, WM8962_RIGHT_DAC_VOLUME,
-			    WM8962_DACR_VOL_MASK, 0xd8);
 
 	snd_soc_update_bits(codec, WM8962_LEFT_INPUT_VOLUME,
 			    WM8962_INL_VOL_MASK, 0x3f);
@@ -4110,7 +4111,7 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 			    WM8962_INR_VOL_MASK, 0x3f);
 	snd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,
 			    WM8962_ADCL_VOL_MASK, 0xd8);
-	snd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,
+	snd_soc_update_bits(codec, WM8962_RIGHT_ADC_VOLUME,
 			    WM8962_ADCR_VOL_MASK, 0xd8);
 	snd_soc_update_bits(codec, WM8962_RIGHT_INPUT_MIXER_VOLUME,
 			    WM8962_IN3R_MIXINR_VOL_MASK, 0x7);
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index 72d8550..e30ebbe 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -124,4 +124,10 @@ config SND_SOC_IMX_HDMI
 	help
 	  Say Y if you want to add support for SoC audio through IMX HDMI.
 
+config SND_MXC_SOC_IRAM
+	bool "Locate SSI Audio DMA playback buffers in IRAM"
+	depends on MACH_MX6SL_EVK && MACH_MX6SL_ARM2
+	help
+	  Say Y if you don't want Audio playback buffers in external ram
+
 endif	# SND_IMX_SOC
diff --git a/sound/soc/imx/imx-cs42888.c b/sound/soc/imx/imx-cs42888.c
index acec900..62d221f 100644
--- a/sound/soc/imx/imx-cs42888.c
+++ b/sound/soc/imx/imx-cs42888.c
@@ -82,7 +82,8 @@ static int config_asrc(struct snd_pcm_substream *substream,
 	if ((channel != 2) && (channel != 4) && (channel != 6))
 		return -EINVAL;
 
-	ret = asrc_req_pair(channel, &iprtd->asrc_index);
+	ret = iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_req_pair(channel, &iprtd->asrc_index);
 	if (ret < 0) {
 		pr_err("Fail to request asrc pair\n");
 		return -EINVAL;
@@ -97,7 +98,7 @@ static int config_asrc(struct snd_pcm_substream *substream,
 	config.inclk = INCLK_NONE;
 	config.outclk = OUTCLK_ESAI_TX;
 
-	ret = asrc_config_pair(&config);
+	ret = iprtd->asrc_pcm_p2p_ops_ko->asrc_p2p_config_pair(&config);
 	if (ret < 0) {
 		pr_err("Fail to config asrc\n");
 		return ret;
@@ -142,8 +143,11 @@ static int imx_3stack_surround_hw_free(struct snd_pcm_substream *substream)
 
 	if (iprtd->asrc_enable) {
 		if (iprtd->asrc_index != -1) {
-			asrc_release_pair(iprtd->asrc_index);
-			asrc_finish_conv(iprtd->asrc_index);
+			iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_release_pair(
+						iprtd->asrc_index);
+			iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_finish_conv(iprtd->asrc_index);
 		}
 		iprtd->asrc_index = -1;
 	}
diff --git a/sound/soc/imx/imx-esai.h b/sound/soc/imx/imx-esai.h
index d27cbd0..53c899e 100644
--- a/sound/soc/imx/imx-esai.h
+++ b/sound/soc/imx/imx-esai.h
@@ -298,8 +298,6 @@
 #define ESAI_RX_DIV_PM	4
 #define ESAI_RX_DIV_FP	5
 
-#define IMX_ESAI_DMABUF_SIZE     (64 * 1024)
-
 #define DRV_NAME "imx-esai"
 
 #include <linux/dmaengine.h>
diff --git a/sound/soc/imx/imx-hdmi-dai.c b/sound/soc/imx/imx-hdmi-dai.c
index 0a1686b..06805f3 100644
--- a/sound/soc/imx/imx-hdmi-dai.c
+++ b/sound/soc/imx/imx-hdmi-dai.c
@@ -1,7 +1,7 @@
 /*
  * ALSA SoC HDMI Audio Layer for MXS
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * Based on stmp3xxx_spdif_dai.c
  * Vladimir Barinov <vbarinov@embeddedalley.com>
@@ -42,8 +42,10 @@ static int imx_hdmi_dai_probe(struct platform_device *pdev)
 	struct imx_hdmi *hdmi_data;
 	int ret = 0;
 
-	if (!hdmi_get_registered())
-		return -ENOMEM;
+	if (!hdmi_get_registered()) {
+		dev_err(&pdev->dev, "Failed: Load HDMI-video first.\n");
+		return -ENODEV;
+	}
 
 	hdmi_data = kzalloc(sizeof(*hdmi_data), GFP_KERNEL);
 	if (!hdmi_data)
diff --git a/sound/soc/imx/imx-hdmi-dma.c b/sound/soc/imx/imx-hdmi-dma.c
index dc71d52..84b3503 100644
--- a/sound/soc/imx/imx-hdmi-dma.c
+++ b/sound/soc/imx/imx-hdmi-dma.c
@@ -583,7 +583,7 @@ static void hdmi_sdma_isr(void *data)
 	struct imx_hdmi_dma_runtime_data *rtd = data;
 	struct snd_pcm_substream *substream = rtd->tx_substream;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned long offset,  count, space_to_end, appl_bytes;
+	unsigned long offset, count, appl_bytes;
 	unsigned long flags;
 
 	spin_lock_irqsave(&rtd->irq_lock, flags);
@@ -597,38 +597,11 @@ static void hdmi_sdma_isr(void *data)
 		 * to hw_buffer and add the frame info. */
 		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
 			appl_bytes = frames_to_bytes(runtime,
-						runtime->control->appl_ptr);
-
-			if (rtd->appl_bytes > appl_bytes) {
-				if (appl_bytes > rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-				else
-					rtd->appl_bytes = 0;
-			} else {
-				if ((appl_bytes - rtd->appl_bytes) >
-						rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-
-			}
-
-			offset = rtd->appl_bytes % rtd->buffer_bytes;
-			space_to_end = rtd->buffer_bytes - offset;
-			count = appl_bytes - rtd->appl_bytes;
-			if (count > rtd->buffer_bytes)
-				count = rtd->buffer_bytes;
-
-			rtd->appl_bytes = appl_bytes;
-
-			if (count <= space_to_end) {
-				hdmi_dma_mmap_copy(substream, offset, count);
-			} else {
-				hdmi_dma_mmap_copy(substream,
-						offset, space_to_end);
-				hdmi_dma_mmap_copy(substream,
-						0, count - space_to_end);
-			}
+						runtime->status->hw_ptr);
+			appl_bytes += 2 * rtd->period_bytes;
+			offset = appl_bytes % rtd->buffer_bytes;
+			count = rtd->period_bytes;
+			hdmi_dma_mmap_copy(substream, offset, count);
 		}
 		snd_pcm_period_elapsed(substream);
 
@@ -645,7 +618,7 @@ static irqreturn_t hdmi_dma_isr(int irq, void *dev_id)
 	struct imx_hdmi_dma_runtime_data *rtd = dev_id;
 	struct snd_pcm_substream *substream = rtd->tx_substream;
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned long offset,  count, space_to_end, appl_bytes;
+	unsigned long offset, count, appl_bytes;
 	unsigned long flags;
 	unsigned int status;
 
@@ -663,34 +636,11 @@ static irqreturn_t hdmi_dma_isr(int irq, void *dev_id)
 		 * to hw_buffer and add the frame info. */
 		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
 			appl_bytes = frames_to_bytes(runtime,
-						runtime->control->appl_ptr);
-			if (rtd->appl_bytes > appl_bytes) {
-				if (appl_bytes > rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-				else
-					rtd->appl_bytes = 0;
-			} else {
-				if ((appl_bytes - rtd->appl_bytes) >
-							rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-
-			}
-
-			offset = rtd->appl_bytes % rtd->buffer_bytes;
-			space_to_end = rtd->buffer_bytes - offset;
-			count = appl_bytes - rtd->appl_bytes;
-			if (count > rtd->buffer_bytes)
-				count = rtd->buffer_bytes;
-			rtd->appl_bytes = appl_bytes;
-
-			if (count <= space_to_end) {
-				hdmi_dma_mmap_copy(substream, offset, count);
-			} else {
-				hdmi_dma_mmap_copy(substream, offset, space_to_end);
-				hdmi_dma_mmap_copy(substream, 0, count - space_to_end);
-			}
+						runtime->status->hw_ptr);
+			appl_bytes += 2 * rtd->period_bytes;
+			offset = appl_bytes % rtd->buffer_bytes;
+			count = rtd->period_bytes;
+			hdmi_dma_mmap_copy(substream, offset, count);
 		}
 		snd_pcm_period_elapsed(substream);
 
@@ -1122,36 +1072,10 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		rtd->frame_idx = 0;
 		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
 			appl_bytes = frames_to_bytes(runtime,
-						runtime->control->appl_ptr);
-			/* If resume, the rtd->appl_bytes may stil
-			 * keep the old value but the control->
-			 * appl_ptr is clear. Reset it if this
-			 * misalignment happens*/
-			if (rtd->appl_bytes > appl_bytes) {
-				if (appl_bytes > rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-				else
-					rtd->appl_bytes = 0;
-			} else {
-				if ((appl_bytes - rtd->appl_bytes) >
-						rtd->buffer_bytes)
-					rtd->appl_bytes =
-						appl_bytes - rtd->buffer_bytes;
-
-			}
-
-			offset = rtd->appl_bytes % rtd->buffer_bytes;
+						runtime->status->hw_ptr);
+			offset = appl_bytes % rtd->buffer_bytes;
+			count = rtd->buffer_bytes;
 			space_to_end = rtd->buffer_bytes - offset;
-			count = appl_bytes - rtd->appl_bytes;
-
-			if (count > rtd->buffer_bytes) {
-				pr_err("Error Count,ring buffer size[%ld], count[%ld]!\n",
-						rtd->buffer_bytes, count);
-				return -EINVAL;
-			}
-
-			rtd->appl_bytes = appl_bytes;
 
 			if (count <= space_to_end) {
 				hdmi_dma_mmap_copy(substream, offset, count);
@@ -1161,7 +1085,6 @@ static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 				hdmi_dma_mmap_copy(substream,
 						0, count - space_to_end);
 			}
-
 		}
 		dumpregs();
 
diff --git a/sound/soc/imx/imx-hdmi.c b/sound/soc/imx/imx-hdmi.c
index a30d478..f214cff 100644
--- a/sound/soc/imx/imx-hdmi.c
+++ b/sound/soc/imx/imx-hdmi.c
@@ -1,7 +1,7 @@
 /*
  * ASoC HDMI Transmitter driver for IMX development boards
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * based on stmp3780_devb_spdif.c
  *
@@ -57,8 +57,10 @@ static int __init imx_hdmi_init(void)
 {
 	int ret = 0;
 
-	if (!hdmi_get_registered())
-		return -ENOMEM;
+	if (!hdmi_get_registered()) {
+		pr_err("Initialize HDMI-audio failed. Load HDMI-video first!\n");
+		return -ENODEV;
+	}
 
 	imx_hdmi_snd_device = platform_device_alloc("soc-audio", 4);
 	if (!imx_hdmi_snd_device) {
diff --git a/sound/soc/imx/imx-pcm-dma-mx2.c b/sound/soc/imx/imx-pcm-dma-mx2.c
index ad8d5a3..047a5db 100644
--- a/sound/soc/imx/imx-pcm-dma-mx2.c
+++ b/sound/soc/imx/imx-pcm-dma-mx2.c
@@ -35,6 +35,14 @@
 #include "imx-ssi.h"
 #include "imx-pcm.h"
 
+struct asrc_p2p_ops *asrc_pcm_p2p_ops;
+
+void asrc_p2p_hook(struct asrc_p2p_ops *asrc_p2p_ct)
+{
+	asrc_pcm_p2p_ops = asrc_p2p_ct;
+	return ;
+}
+EXPORT_SYMBOL(asrc_p2p_hook);
 
 static void audio_dma_irq(void *data)
 {
@@ -109,14 +117,16 @@ static int imx_ssi_asrc_dma_alloc(struct snd_pcm_substream *substream,
 	iprtd->asrc_dma_data.peripheral_type = IMX_DMATYPE_ASRC;
 	iprtd->asrc_dma_data.priority = DMA_PRIO_HIGH;
 	iprtd->asrc_dma_data.dma_request =
-			asrc_get_dma_request(iprtd->asrc_index, 1);
+			iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_get_dma_request(iprtd->asrc_index, 1);
 	iprtd->asrc_dma_chan = dma_request_channel(mask, asrc_filter, iprtd);
 
 	if (!iprtd->asrc_dma_chan)
 		goto error;
 
 	slave_config.direction = DMA_TO_DEVICE;
-	slave_config.dst_addr = asrc_get_per_addr(iprtd->asrc_index, 1);
+	slave_config.dst_addr = iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_per_addr(iprtd->asrc_index, 1);
 	slave_config.dst_addr_width = buswidth;
 	slave_config.dst_maxburst = dma_params->burstsize * buswidth;
 
@@ -127,7 +137,8 @@ static int imx_ssi_asrc_dma_alloc(struct snd_pcm_substream *substream,
 	iprtd->asrc_p2p_dma_data.peripheral_type = IMX_DMATYPE_ASRC;
 	iprtd->asrc_p2p_dma_data.priority = DMA_PRIO_HIGH;
 	iprtd->asrc_p2p_dma_data.dma_request =
-			asrc_get_dma_request(iprtd->asrc_index, 0);
+			iprtd->asrc_pcm_p2p_ops_ko->
+				asrc_p2p_get_dma_request(iprtd->asrc_index, 0);
 	iprtd->asrc_p2p_dma_data.dma_request_p2p = dma_params->dma;
 	iprtd->asrc_p2p_dma_chan =
 		dma_request_channel(mask, asrc_p2p_filter, iprtd);
@@ -146,7 +157,8 @@ static int imx_ssi_asrc_dma_alloc(struct snd_pcm_substream *substream,
 	}
 
 	slave_config.direction = DMA_DEV_TO_DEV;
-	slave_config.src_addr = asrc_get_per_addr(iprtd->asrc_index, 0);
+	slave_config.src_addr = iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_per_addr(iprtd->asrc_index, 0);
 	slave_config.src_addr_width = buswidth;
 	slave_config.src_maxburst = dma_params->burstsize * buswidth;
 	slave_config.dst_addr = dma_params->dma_addr;
@@ -358,7 +370,8 @@ static int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		if (iprtd->asrc_enable) {
 			dmaengine_submit(iprtd->asrc_p2p_desc);
 			dmaengine_submit(iprtd->asrc_desc);
-			asrc_start_conv(iprtd->asrc_index);
+			iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_start_conv(iprtd->asrc_index);
 			mdelay(1);
 		} else {
 			dmaengine_submit(iprtd->desc);
@@ -371,7 +384,8 @@ static int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		if (iprtd->asrc_enable) {
 			dmaengine_terminate_all(iprtd->asrc_dma_chan);
 			dmaengine_terminate_all(iprtd->asrc_p2p_dma_chan);
-			asrc_stop_conv(iprtd->asrc_index);
+			iprtd->asrc_pcm_p2p_ops_ko->
+					asrc_p2p_stop_conv(iprtd->asrc_index);
 		} else {
 			dmaengine_terminate_all(iprtd->dma_chan);
 		}
@@ -405,7 +419,7 @@ static struct snd_pcm_hardware snd_imx_hardware = {
 	.rate_min = 8000,
 	.channels_min = 2,
 	.channels_max = 2,
-	.buffer_bytes_max = IMX_SSI_DMABUF_SIZE,
+	.buffer_bytes_max = IMX_DEFAULT_DMABUF_SIZE,
 	.period_bytes_min = 128,
 	.period_bytes_max = 65535, /* Limited by SDMA engine */
 	.periods_min = 2,
@@ -428,6 +442,11 @@ static int snd_imx_open(struct snd_pcm_substream *substream)
 		iprtd->p2p =
 			(struct asrc_p2p_params *)snd_soc_pcm_get_drvdata(rtd);
 		iprtd->asrc_index = -1;
+		if (!asrc_pcm_p2p_ops) {
+			pr_err("ASRC is not loaded!\n");
+			return -EINVAL;
+		}
+		iprtd->asrc_pcm_p2p_ops_ko = asrc_pcm_p2p_ops;
 	}
 
 	runtime->private_data = iprtd;
@@ -439,6 +458,15 @@ static int snd_imx_open(struct snd_pcm_substream *substream)
 		return ret;
 	}
 
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+		snd_imx_hardware.buffer_bytes_max = IMX_SSI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-esai", strlen("imx-esai")))
+		snd_imx_hardware.buffer_bytes_max = IMX_ESAI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-spdif", strlen("imx-spdif")))
+		snd_imx_hardware.buffer_bytes_max = IMX_SPDIF_DMABUF_SIZE;
+	else
+		snd_imx_hardware.buffer_bytes_max = IMX_DEFAULT_DMABUF_SIZE;
+
 	snd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);
 
 	return 0;
@@ -476,8 +504,11 @@ static int __devinit imx_soc_platform_probe(struct platform_device *pdev)
 {
 	struct imx_ssi *ssi = platform_get_drvdata(pdev);
 
-	ssi->dma_params_tx.burstsize = 6;
-	ssi->dma_params_rx.burstsize = 4;
+	if (ssi->dma_params_tx.burstsize == 0
+			&& ssi->dma_params_rx.burstsize == 0) {
+		ssi->dma_params_tx.burstsize = 6;
+		ssi->dma_params_rx.burstsize = 4;
+	}
 
 	return snd_soc_register_platform(&pdev->dev, &imx_soc_platform_mx2);
 }
diff --git a/sound/soc/imx/imx-pcm.h b/sound/soc/imx/imx-pcm.h
index c612621..1b126be 100644
--- a/sound/soc/imx/imx-pcm.h
+++ b/sound/soc/imx/imx-pcm.h
@@ -43,6 +43,11 @@
 
 #include <mach/dma.h>
 
+#define IMX_DEFAULT_DMABUF_SIZE		(64 * 1024)
+#define IMX_SSI_DMABUF_SIZE			(64 * 1024)
+#define IMX_ESAI_DMABUF_SIZE		(256 * 1024)
+#define IMX_SPDIF_DMABUF_SIZE		(64 * 1024)
+
 struct imx_pcm_runtime_data {
 	int period_bytes;
 	int periods;
@@ -55,6 +60,7 @@ struct imx_pcm_runtime_data {
 	struct dma_chan *dma_chan;
 	struct imx_dma_data dma_data;
 	int asrc_enable;
+	struct asrc_p2p_ops *asrc_pcm_p2p_ops_ko;
 
 #if defined(CONFIG_MXC_ASRC) || defined(CONFIG_IMX_HAVE_PLATFORM_IMX_ASRC)
 	enum asrc_pair_index asrc_index;
diff --git a/sound/soc/imx/imx-si4763.c b/sound/soc/imx/imx-si4763.c
index 1dd50e7..7b2458e 100644
--- a/sound/soc/imx/imx-si4763.c
+++ b/sound/soc/imx/imx-si4763.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -131,7 +131,7 @@ static struct snd_soc_card snd_soc_card_imx_3stack = {
 	.num_links = 1,
 };
 
-static int __init imx_3stack_si4763_probe(struct platform_device *pdev)
+static int __devinit imx_3stack_si4763_probe(struct platform_device *pdev)
 {
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
 
diff --git a/sound/soc/imx/imx-ssi.c b/sound/soc/imx/imx-ssi.c
index e9b102d..d398307 100644
--- a/sound/soc/imx/imx-ssi.c
+++ b/sound/soc/imx/imx-ssi.c
@@ -1,7 +1,7 @@
 /*
  * imx-ssi.c  --  ALSA Soc Audio Layer
  *
- * Copyright 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
  *
@@ -53,14 +53,19 @@
 #include <sound/soc.h>
 
 #include <mach/ssi.h>
+#include <mach/iram.h>
 #include <mach/hardware.h>
 
 #include "imx-ssi.h"
+#include "imx-pcm.h"
 
 #define SSI_SACNT_DEFAULT (SSI_SACNT_AC97EN | SSI_SACNT_FV)
 #define IMX_SSI_FORMATS \
 	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
 	SNDRV_PCM_FMTBIT_S24_LE)
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+static int UseIRAM;
+#endif
 
 /*
  * SSI Network Mode or TDM slots configuration.
@@ -418,15 +423,61 @@ static struct snd_soc_dai_ops imx_ssi_pcm_dai_ops = {
 	.shutdown	= imx_ssi_shutdown,
 };
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+
+static struct vm_operations_struct snd_mxc_audio_playback_vm_ops = {
+	.open = snd_pcm_mmap_data_open,
+	.close = snd_pcm_mmap_data_close,
+};
+
+/*
+	enable user space access to iram buffer
+*/
+static int imx_iram_audio_playback_mmap(struct snd_pcm_substream *substream,
+					struct vm_area_struct *area)
+{
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	unsigned long off;
+	unsigned long phys;
+	unsigned long size;
+	int ret = 0;
+
+	area->vm_ops = &snd_mxc_audio_playback_vm_ops;
+	area->vm_private_data = substream;
+
+	off = area->vm_pgoff << PAGE_SHIFT;
+	phys = buf->addr + off;
+	size = area->vm_end - area->vm_start;
+
+	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+	area->vm_flags |= VM_IO;
+	ret =
+	    remap_pfn_range(area, area->vm_start, phys >> PAGE_SHIFT,
+			    size, area->vm_page_prot);
+
+	return ret;
+}
+#endif
+
 int snd_imx_pcm_mmap(struct snd_pcm_substream *substream,
 		struct vm_area_struct *vma)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if ((!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+			&& (UseIRAM & (1<<substream->stream)))
+		ret = imx_iram_audio_playback_mmap(substream, vma);
+	else
+		ret = dma_mmap_coherent(NULL, vma, runtime->dma_area,
+			runtime->dma_addr, runtime->dma_bytes);
+#else
 	ret = dma_mmap_coherent(NULL, vma, runtime->dma_area,
 			runtime->dma_addr, runtime->dma_bytes);
-
+#endif
 	pr_debug("%s: ret: %d %p 0x%08x 0x%08x\n", __func__, ret,
 			runtime->dma_area,
 			runtime->dma_addr,
@@ -438,17 +489,53 @@ EXPORT_SYMBOL_GPL(snd_imx_pcm_mmap);
 static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
-	size_t size = IMX_SSI_DMABUF_SIZE;
+	size_t size;
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	unsigned long buf_paddr;
+#endif
+
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+		size = IMX_SSI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-esai", strlen("imx-esai")))
+		size = IMX_ESAI_DMABUF_SIZE;
+	else if (!strncmp(rtd->cpu_dai->name, "imx-spdif", strlen("imx-spdif")))
+		size = IMX_SPDIF_DMABUF_SIZE;
+	else
+		size = IMX_DEFAULT_DMABUF_SIZE;
 
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
+	buf->bytes = size;
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi"))) {
+		buf->area = iram_alloc(size, &buf_paddr);
+		if (!buf->area) {
+			buf->area =
+			    dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+			if (!buf->area)
+				return -ENOMEM;
+		} else {
+			buf->addr = buf_paddr;
+			UseIRAM |= 1<<substream->stream;
+		}
+	} else {
+		buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+		if (!buf->area)
+			return -ENOMEM;
+
+	}
+#else
 	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
 					   &buf->addr, GFP_KERNEL);
 	if (!buf->area)
 		return -ENOMEM;
-	buf->bytes = size;
+#endif
 
 	return 0;
 }
@@ -489,6 +576,9 @@ void imx_pcm_free(struct snd_pcm *pcm)
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	int stream;
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+#endif
 
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
@@ -499,8 +589,19 @@ void imx_pcm_free(struct snd_pcm *pcm)
 		if (!buf->area)
 			continue;
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+		if ((!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+			&& (UseIRAM & (1<<substream->stream))) {
+			iram_free(buf->addr, IMX_SSI_DMABUF_SIZE);
+			UseIRAM &= ~(1<<substream->stream);
+		} else {
+			dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		}
+#else
 		dma_free_writecombine(pcm->card->dev, buf->bytes,
 				      buf->area, buf->addr);
+#endif
 		buf->area = NULL;
 	}
 }
@@ -743,7 +844,7 @@ static int imx_ssi_probe(struct platform_device *pdev)
 	ssi->dma_params_rx.dma_addr = res->start + SSI_SRX0;
 	ssi->dma_params_tx.dma_addr = res->start + SSI_STX0;
 
-	ssi->dma_params_tx.burstsize = 4;
+	ssi->dma_params_tx.burstsize = 6;
 	ssi->dma_params_rx.burstsize = 4;
 
 	ssi->dma_params_tx.peripheral_type = IMX_DMATYPE_SSI_SP;
diff --git a/sound/soc/imx/imx-ssi.h b/sound/soc/imx/imx-ssi.h
index c57f9fe..af8e5a2 100644
--- a/sound/soc/imx/imx-ssi.h
+++ b/sound/soc/imx/imx-ssi.h
@@ -222,7 +222,4 @@ int snd_imx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct
 int imx_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
 	struct snd_pcm *pcm);
 void imx_pcm_free(struct snd_pcm *pcm);
-
-#define IMX_SSI_DMABUF_SIZE	(256 * 1024)
-
 #endif /* _IMX_SSI_H */
diff --git a/sound/soc/imx/imx-wm8962.c b/sound/soc/imx/imx-wm8962.c
index a224518..d6ab88d 100644
--- a/sound/soc/imx/imx-wm8962.c
+++ b/sound/soc/imx/imx-wm8962.c
@@ -1,7 +1,7 @@
 /*
  * imx-wm8962.c
  *
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -27,6 +27,7 @@
 #include <linux/fsl_devices.h>
 #include <linux/slab.h>
 #include <linux/clk.h>
+#include <linux/kthread.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -52,12 +53,42 @@ struct imx_priv {
 	int amic_irq;
 	int amic_status;
 	struct platform_device *pdev;
+	struct snd_pcm_substream *first_stream;
+	struct snd_pcm_substream *second_stream;
 };
 unsigned int sample_format = SNDRV_PCM_FMTBIT_S16_LE;
 static struct imx_priv card_priv;
 static struct snd_soc_card snd_soc_card_imx;
 static struct snd_soc_codec *gcodec;
 
+static struct snd_soc_jack imx_hp_jack;
+static struct snd_soc_jack_pin imx_hp_jack_pins[] = {
+	{
+		.pin = "Ext Spk",
+		.mask = SND_JACK_HEADPHONE,
+	},
+};
+static struct snd_soc_jack_gpio imx_hp_jack_gpio = {
+	.name = "headphone detect",
+	.report = SND_JACK_HEADPHONE,
+	.debounce_time = 150,
+	.invert = 0,
+};
+
+static struct snd_soc_jack imx_mic_jack;
+static struct snd_soc_jack_pin imx_mic_jack_pins[] = {
+	{
+		.pin = "DMIC",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+static struct snd_soc_jack_gpio imx_mic_jack_gpio = {
+	.name = "micphone detect",
+	.report = SND_JACK_MICROPHONE,
+	.debounce_time = 150,
+	.invert = 0,
+};
+
 static int imx_hifi_startup(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
@@ -84,6 +115,56 @@ static void imx_hifi_shutdown(struct snd_pcm_substream *substream)
 	return;
 }
 
+static int check_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct imx_priv *priv = &card_priv;
+	unsigned int channels = params_channels(params);
+	unsigned int sample_rate = params_rate(params);
+	snd_pcm_format_t sample_format = params_format(params);
+
+	substream->runtime->sample_bits =
+		snd_pcm_format_physical_width(sample_format);
+	substream->runtime->rate = sample_rate;
+	substream->runtime->format = sample_format;
+	substream->runtime->channels = channels;
+
+	if (!priv->first_stream) {
+		priv->first_stream = substream;
+	} else {
+		priv->second_stream = substream;
+
+		/* Check two sample rates of two streams */
+		if (priv->first_stream->runtime->rate !=
+				priv->second_stream->runtime->rate) {
+			pr_err("\n!KEEP THE SAME SAMPLE RATE: %d!\n",
+					priv->first_stream->runtime->rate);
+			return -EINVAL;
+		}
+
+		/* Check two sample bits of two streams */
+		if (priv->first_stream->runtime->sample_bits !=
+				priv->second_stream->runtime->sample_bits) {
+			snd_pcm_format_t first_format =
+				priv->first_stream->runtime->format;
+
+			pr_err("\n!KEEP THE SAME FORMAT: %s!\n",
+					snd_pcm_format_name(first_format));
+			return -EINVAL;
+		}
+
+		/* Check two channel numbers of two streams */
+		if (priv->first_stream->runtime->channels !=
+				priv->second_stream->runtime->channels) {
+			pr_err("\n!KEEP THE SAME CHANNEL NUMBER: %d!\n",
+					priv->first_stream->runtime->channels);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 				     struct snd_pcm_hw_params *params)
 {
@@ -97,6 +178,18 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 	u32 dai_format;
 	unsigned int pll_out;
 
+	/*
+	 * WM8962 doesn't support two substreams in different parameters
+	 * (i.e. different sample rates, audio formats, channel numbers)
+	 * So we here check the three parameters above of two substreams
+	 * if they are running in the same time.
+	 */
+	ret = check_hw_params(substream, params);
+	if (ret < 0) {
+		pr_err("Failed to match hw params: %d\n", ret);
+		return ret;
+	}
+
 	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
 		SND_SOC_DAIFMT_CBM_CFM;
 
@@ -127,8 +220,8 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 	else
 		pll_out = sample_rate * 256;
 
-	ret = snd_soc_dai_set_pll(codec_dai, WM8962_FLL_OSC,
-				  WM8962_FLL_OSC, priv->sysclk,
+	ret = snd_soc_dai_set_pll(codec_dai, WM8962_FLL_MCLK,
+				  WM8962_FLL_MCLK, priv->sysclk,
 				  pll_out);
 	if (ret < 0)
 		pr_err("Failed to start FLL: %d\n", ret);
@@ -145,105 +238,120 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static const struct snd_kcontrol_new controls[] = {
-	SOC_DAPM_PIN_SWITCH("Ext Spk"),
-};
-
-/* imx card dapm widgets */
-static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
-	SND_SOC_DAPM_HP("Headphone Jack", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
-	SND_SOC_DAPM_MIC("AMIC", NULL),
-	SND_SOC_DAPM_MIC("DMIC", NULL),
-};
-
-/* imx machine connections to the codec pins */
-static const struct snd_soc_dapm_route audio_map[] = {
-	{ "Headphone Jack", NULL, "HPOUTL" },
-	{ "Headphone Jack", NULL, "HPOUTR" },
-
-	{ "Ext Spk", NULL, "SPKOUTL" },
-	{ "Ext Spk", NULL, "SPKOUTR" },
 
-	{ "MICBIAS", NULL, "AMIC" },
-	{ "IN3R", NULL, "MICBIAS" },
+static int imx_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	int ret;
 
-	{ "DMIC", NULL, "MICBIAS" },
-	{ "DMICDAT", NULL, "DMIC" },
+	if (priv->first_stream == substream)
+		priv->first_stream = priv->second_stream;
+	priv->second_stream = NULL;
+
+	if (!priv->first_stream) {
+		/*
+		 * wm8962 doesn't allow us to continuously setting FLL,
+		 * So we set MCLK as sysclk once, which'd remove the limitation.
+		 */
+		ret = snd_soc_dai_set_sysclk(codec_dai, WM8962_SYSCLK_MCLK,
+				0, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to set SYSCLK: %d\n", ret);
+			return ret;
+		}
 
-};
+		/*
+		 * Continuously setting FLL would cause playback distortion.
+		 * We can fix it just by mute codec after playback.
+		 */
+		ret = snd_soc_dai_digital_mute(codec_dai, 1);
+		if (ret < 0) {
+			pr_err("Failed to set MUTE: %d\n", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
 
-static void headphone_detect_handler(struct work_struct *wor)
+static void imx_resume_event(struct work_struct *wor)
 {
 	struct imx_priv *priv = &card_priv;
 	struct platform_device *pdev = priv->pdev;
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
-	char *envp[3];
-	char *buf;
+	struct snd_soc_jack *jack;
+	int enable;
+	int report;
 
-	/*sysfs_notify(&pdev->dev.kobj, NULL, "headphone");*/
-	priv->hp_status = gpio_get_value(plat->hp_gpio);
+	if (plat->hp_gpio != -1) {
+		jack = imx_hp_jack_gpio.jack;
 
-	/* if headphone is inserted, disable speaker */
-	if (priv->hp_status != plat->hp_active_low)
-		snd_soc_dapm_nc_pin(&gcodec->dapm, "Ext Spk");
-	else
-		snd_soc_dapm_enable_pin(&gcodec->dapm, "Ext Spk");
+		enable = gpio_get_value_cansleep(imx_hp_jack_gpio.gpio);
+		if (imx_hp_jack_gpio.invert)
+			enable = !enable;
 
-	snd_soc_dapm_sync(&gcodec->dapm);
+		if (enable)
+			report = imx_hp_jack_gpio.report;
+		else
+			report = 0;
 
-	/* setup a message for userspace headphone in */
-	buf = kmalloc(32, GFP_ATOMIC);
-	if (!buf) {
-		pr_err("%s kmalloc failed\n", __func__);
-		return;
+		snd_soc_jack_report(jack, report, imx_hp_jack_gpio.report);
 	}
 
-	if (priv->hp_status != plat->hp_active_low)
-		snprintf(buf, 32, "STATE=%d", 2);
-	else
-		snprintf(buf, 32, "STATE=%d", 0);
-
-	envp[0] = "NAME=headphone";
-	envp[1] = buf;
-	envp[2] = NULL;
-	kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
-	kfree(buf);
+	if (plat->mic_gpio != -1) {
+		jack = imx_mic_jack_gpio.jack;
 
-	enable_irq(priv->hp_irq);
+		enable = gpio_get_value_cansleep(imx_mic_jack_gpio.gpio);
+		if (imx_mic_jack_gpio.invert)
+			enable = !enable;
 
-	return;
-}
+		if (enable)
+			report = imx_mic_jack_gpio.report;
+		else
+			report = 0;
 
-static DECLARE_DELAYED_WORK(hp_event, headphone_detect_handler);
+		snd_soc_jack_report(jack, report, imx_mic_jack_gpio.report);
+	}
 
-static irqreturn_t imx_headphone_detect_handler(int irq, void *data)
-{
-	disable_irq_nosync(irq);
-	schedule_delayed_work(&hp_event, msecs_to_jiffies(200));
-	return IRQ_HANDLED;
+	return;
 }
 
-static ssize_t show_headphone(struct device_driver *dev, char *buf)
+static int imx_event_hp(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
 {
 	struct imx_priv *priv = &card_priv;
 	struct platform_device *pdev = priv->pdev;
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	char *envp[3];
+	char *buf;
 
-	/* determine whether hp is plugged in */
-	priv->hp_status = gpio_get_value(plat->hp_gpio);
+	if (plat->hp_gpio != -1) {
+		priv->hp_status = gpio_get_value(plat->hp_gpio);
 
-	if (priv->hp_status != plat->hp_active_low)
-		strcpy(buf, "headphone\n");
-	else
-		strcpy(buf, "speaker\n");
+		buf = kmalloc(32, GFP_ATOMIC);
+		if (!buf) {
+			pr_err("%s kmalloc failed\n", __func__);
+			return -ENOMEM;
+		}
 
-	return strlen(buf);
-}
+		if (priv->hp_status != plat->hp_active_low)
+			snprintf(buf, 32, "STATE=%d", 2);
+		else
+			snprintf(buf, 32, "STATE=%d", 0);
 
-static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+		envp[0] = "NAME=headphone";
+		envp[1] = buf;
+		envp[2] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+		kfree(buf);
+	}
+
+	return 0;
+}
 
-static void amic_detect_handler(struct work_struct *work)
+static int imx_event_mic(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
 {
 	struct imx_priv *priv = &card_priv;
 	struct platform_device *pdev = priv->pdev;
@@ -251,47 +359,78 @@ static void amic_detect_handler(struct work_struct *work)
 	char *envp[3];
 	char *buf;
 
-	/* sysfs_notify(&pdev->dev.kobj, NULL, "amic"); */
-	priv->amic_status = gpio_get_value(plat->mic_gpio);
+	if (plat->mic_gpio != -1) {
+		priv->amic_status = gpio_get_value(plat->mic_gpio);
 
-	/* if amic is inserted, disable dmic */
-	if (priv->amic_status != plat->mic_active_low)
-		snd_soc_dapm_nc_pin(&gcodec->dapm, "DMIC");
-	else
-		snd_soc_dapm_enable_pin(&gcodec->dapm, "DMIC");
+		buf = kmalloc(32, GFP_ATOMIC);
+		if (!buf) {
+			pr_err("%s kmalloc failed\n", __func__);
+			return -ENOMEM;
+		}
 
-	snd_soc_dapm_sync(&gcodec->dapm);
+		if (priv->amic_status == 0)
+			snprintf(buf, 32, "STATE=%d", 2);
+		else
+			snprintf(buf, 32, "STATE=%d", 0);
 
-	/* setup a message for userspace headphone in */
-	buf = kmalloc(32, GFP_ATOMIC);
-	if (!buf) {
-		pr_err("%s kmalloc failed\n", __func__);
-		return;
+		envp[0] = "NAME=amic";
+		envp[1] = buf;
+		envp[2] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+		kfree(buf);
 	}
 
-	if (priv->amic_status == 0)
-		snprintf(buf, 32, "STATE=%d", 2);
-	else
-		snprintf(buf, 32, "STATE=%d", 0);
+	return 0;
+}
 
-	envp[0] = "NAME=amic";
-	envp[1] = buf;
-	envp[2] = NULL;
-	kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
-	kfree(buf);
 
-	enable_irq(priv->amic_irq);
-}
+static const struct snd_kcontrol_new controls[] = {
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+/* imx card dapm widgets */
+static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", imx_event_hp),
+	SND_SOC_DAPM_MIC("AMIC", NULL),
+	SND_SOC_DAPM_MIC("DMIC", imx_event_mic),
+};
+
+/* imx machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "Headphone Jack", NULL, "HPOUTL" },
+	{ "Headphone Jack", NULL, "HPOUTR" },
+
+	{ "Ext Spk", NULL, "SPKOUTL" },
+	{ "Ext Spk", NULL, "SPKOUTR" },
+
+	{ "MICBIAS", NULL, "AMIC" },
+	{ "IN3R", NULL, "MICBIAS" },
 
-static DECLARE_DELAYED_WORK(amic_event, amic_detect_handler);
+	{ "DMIC", NULL, "MICBIAS" },
+	{ "DMICDAT", NULL, "DMIC" },
+
+};
 
-static irqreturn_t imx_amic_detect_handler(int irq, void *data)
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
 {
-	disable_irq_nosync(irq);
-	schedule_delayed_work(&amic_event, msecs_to_jiffies(200));
-	return IRQ_HANDLED;
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	/* determine whether hp is plugged in */
+	priv->hp_status = gpio_get_value(plat->hp_gpio);
+
+	if (priv->hp_status != plat->hp_active_low)
+		strcpy(buf, "headphone\n");
+	else
+		strcpy(buf, "speaker\n");
+
+	return strlen(buf);
 }
 
+static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
 static ssize_t show_amic(struct device_driver *dev, char *buf)
 {
 	struct imx_priv *priv = &card_priv;
@@ -311,6 +450,23 @@ static ssize_t show_amic(struct device_driver *dev, char *buf)
 
 static DRIVER_ATTR(amic, S_IRUGO | S_IWUSR, show_amic, NULL);
 
+static DECLARE_DELAYED_WORK(resume_hp_event, imx_resume_event);
+
+int imx_hifi_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (SNDRV_PCM_TRIGGER_RESUME == cmd) {
+		if ((plat->hp_gpio != -1) || (plat->mic_gpio != -1))
+			schedule_delayed_work(&resume_hp_event,
+				msecs_to_jiffies(200));
+	}
+
+	return 0;
+}
+
 static int imx_wm8962_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_codec *codec = rtd->codec;
@@ -331,63 +487,45 @@ static int imx_wm8962_init(struct snd_soc_pcm_runtime *rtd)
 	snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
 	snd_soc_dapm_enable_pin(&codec->dapm, "AMIC");
 
-	snd_soc_dapm_sync(&codec->dapm);
-
 	if (plat->hp_gpio != -1) {
-		priv->hp_irq = gpio_to_irq(plat->hp_gpio);
-
-		ret = request_irq(priv->hp_irq,
-					imx_headphone_detect_handler,
-					IRQ_TYPE_EDGE_BOTH, pdev->name, priv);
-
-		if (ret < 0) {
-			ret = -EINVAL;
-			return ret;
-		}
+		imx_hp_jack_gpio.gpio = plat->hp_gpio;
+		snd_soc_jack_new(codec, "Ext Spk", SND_JACK_LINEOUT,
+				&imx_hp_jack);
+		snd_soc_jack_add_pins(&imx_hp_jack,
+					ARRAY_SIZE(imx_hp_jack_pins),
+					imx_hp_jack_pins);
+		snd_soc_jack_add_gpios(&imx_hp_jack,
+					1, &imx_hp_jack_gpio);
 
 		ret = driver_create_file(pdev->dev.driver,
-						&driver_attr_headphone);
+							&driver_attr_headphone);
 		if (ret < 0) {
 			ret = -EINVAL;
 			return ret;
 		}
-
-		priv->hp_status = gpio_get_value(plat->hp_gpio);
-
-		/* if headphone is inserted, disable speaker */
-		if (priv->hp_status != plat->hp_active_low)
-			snd_soc_dapm_nc_pin(&codec->dapm, "Ext Spk");
-		else
-			snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
 	}
 
 	if (plat->mic_gpio != -1) {
-		priv->amic_irq = gpio_to_irq(plat->mic_gpio);
-
-		ret = request_irq(priv->amic_irq,
-					imx_amic_detect_handler,
-					IRQ_TYPE_EDGE_BOTH, pdev->name, priv);
+		imx_mic_jack_gpio.gpio = plat->mic_gpio;
+		snd_soc_jack_new(codec, "DMIC", SND_JACK_MICROPHONE,
+				&imx_mic_jack);
+		snd_soc_jack_add_pins(&imx_mic_jack,
+					ARRAY_SIZE(imx_mic_jack_pins),
+					imx_mic_jack_pins);
+		snd_soc_jack_add_gpios(&imx_mic_jack,
+					1, &imx_mic_jack_gpio);
 
+		ret = driver_create_file(pdev->dev.driver,
+							&driver_attr_amic);
 		if (ret < 0) {
 			ret = -EINVAL;
 			return ret;
 		}
-
-		ret = driver_create_file(pdev->dev.driver, &driver_attr_amic);
-		if (ret < 0) {
-			ret = -EINVAL;
-			return ret;
-		}
-
-		priv->amic_status = gpio_get_value(plat->mic_gpio);
-
-		/* if amic is inserted, disable DMIC */
-		if (priv->amic_status != plat->mic_active_low)
-			snd_soc_dapm_nc_pin(&codec->dapm, "DMIC");
-		else
-			snd_soc_dapm_enable_pin(&codec->dapm, "DMIC");
-	} else if (!snd_soc_dapm_get_pin_status(&codec->dapm, "DMICDAT"))
+	} else {
 		snd_soc_dapm_nc_pin(&codec->dapm, "DMIC");
+	}
+
+	snd_soc_dapm_sync(&codec->dapm);
 
 	return 0;
 }
@@ -396,6 +534,8 @@ static struct snd_soc_ops imx_hifi_ops = {
 	.startup = imx_hifi_startup,
 	.shutdown = imx_hifi_shutdown,
 	.hw_params = imx_hifi_hw_params,
+	.hw_free = imx_hifi_hw_free,
+	.trigger = imx_hifi_trigger,
 };
 
 static struct snd_soc_dai_link imx_dai[] = {
@@ -459,6 +599,9 @@ static int __devinit imx_wm8962_probe(struct platform_device *pdev)
 
 	priv->sysclk = plat->sysclk;
 
+	priv->first_stream = NULL;
+	priv->second_stream = NULL;
+
 	return ret;
 }
 
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index ad12a4c..b3ab124 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -5,6 +5,7 @@
  * Copyright 2005 Openedhand Ltd.
  * Copyright (C) 2010 Slimlogic Ltd.
  * Copyright (C) 2010 Texas Instruments Inc.
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
  *
  * Author: Liam Girdwood <lrg@slimlogic.co.uk>
  *         with code, comments and ideas from :-
@@ -747,6 +748,9 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	codec_dai->active--;
 	codec->active--;
 
+	if (!cpu_dai->active && !codec_dai->active)
+		rtd->rate = 0;
+
 	/* Muting the DAC suppresses artifacts caused during digital
 	 * shutdown, for example from stopping clocks.
 	 */
@@ -986,6 +990,12 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		if (ret < 0)
 			return ret;
 	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->trigger) {
+		ret = rtd->dai_link->ops->trigger(substream, cmd);
+		if (ret < 0)
+			return ret;
+	}
 	return 0;
 }
 
-- 
2.0.0

