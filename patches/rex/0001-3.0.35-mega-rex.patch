From 5de01df8cc538b7d44c25850ea03411d73e50164 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Tue, 24 Jun 2014 19:21:03 -0500
Subject: [PATCH] 3.0.35 mega rex

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/Kconfig                                   |   10 +
 arch/arm/configs/imx6_defconfig                    |    6 +-
 arch/arm/configs/imx6_updater_defconfig            |    5 +-
 arch/arm/configs/imx6s_defconfig                   |    5 +
 arch/arm/configs/imx6s_updater_defconfig           |    1 +
 arch/arm/include/asm/dma-mapping.h                 |   13 +
 arch/arm/kernel/process.c                          |    2 +-
 arch/arm/mach-mx6/Kconfig                          |   57 +
 arch/arm/mach-mx6/Makefile                         |    3 +
 arch/arm/mach-mx6/board-mx6dl_arm2.h               |   10 +-
 arch/arm/mach-mx6/board-mx6dl_hdmidongle.h         |  342 +++
 arch/arm/mach-mx6/board-mx6dl_sabresd.h            |    5 +-
 arch/arm/mach-mx6/board-mx6q_arm2.c                |   86 +-
 arch/arm/mach-mx6/board-mx6q_arm2.h                |    9 +-
 arch/arm/mach-mx6/board-mx6q_hdmidongle.c          |  800 +++++++
 arch/arm/mach-mx6/board-mx6q_hdmidongle.h          |  343 +++
 arch/arm/mach-mx6/board-mx6q_sabreauto.c           |  190 +-
 arch/arm/mach-mx6/board-mx6q_sabreauto.h           |    9 +-
 arch/arm/mach-mx6/board-mx6q_sabrelite.c           |   91 +-
 arch/arm/mach-mx6/board-mx6q_sabresd.c             |  149 +-
 arch/arm/mach-mx6/board-mx6q_sabresd.h             |    7 +-
 arch/arm/mach-mx6/board-mx6sl_arm2.c               |   18 +-
 arch/arm/mach-mx6/board-mx6sl_common.h             |    6 +-
 arch/arm/mach-mx6/board-mx6sl_evk.c                |  101 +-
 arch/arm/mach-mx6/board-mx6solo_sabreauto.h        |    9 +-
 arch/arm/mach-mx6/bus_freq.c                       |   15 +-
 arch/arm/mach-mx6/clock.c                          |  195 +-
 arch/arm/mach-mx6/clock_mx6sl.c                    |  187 +-
 arch/arm/mach-mx6/cpu.c                            |   17 +-
 arch/arm/mach-mx6/cpu_op-mx6.c                     |   21 +-
 arch/arm/mach-mx6/cpu_regulator-mx6.c              |    3 +-
 arch/arm/mach-mx6/crm_regs.h                       |   29 +-
 arch/arm/mach-mx6/irq.c                            |    8 +-
 arch/arm/mach-mx6/localtimer.c                     |    4 +-
 arch/arm/mach-mx6/mm.c                             |   18 +-
 arch/arm/mach-mx6/msi.c                            |  151 ++
 arch/arm/mach-mx6/msi.h                            |   26 +
 arch/arm/mach-mx6/mx6_bt_rfkill.c                  |  167 ++
 arch/arm/mach-mx6/mx6_ddr_freq.S                   |   98 +-
 arch/arm/mach-mx6/mx6sl_ddr.S                      |   70 +-
 arch/arm/mach-mx6/mx6sl_wfi.S                      |   89 +-
 arch/arm/mach-mx6/pcie.c                           |  612 ++++-
 arch/arm/mach-mx6/pm.c                             |   37 +-
 arch/arm/mach-mx6/regs-anadig.h                    |    5 +-
 arch/arm/mach-mx6/system.c                         |   95 +-
 arch/arm/mach-mx6/usb_dr.c                         |  158 +-
 arch/arm/mach-mx6/usb_h1.c                         |   65 +-
 arch/arm/mach-mx6/usb_h2.c                         |    7 +-
 arch/arm/mach-mx6/usb_h3.c                         |    7 +-
 arch/arm/mm/cache-v7.S                             |    3 +
 arch/arm/mm/dma-mapping.c                          |   17 +
 arch/arm/plat-mxc/Makefile                         |    2 +-
 arch/arm/plat-mxc/ahci_sata.c                      |    8 +-
 arch/arm/plat-mxc/devices/platform-ahci-imx.c      |    5 +-
 arch/arm/plat-mxc/devices/platform-fec.c           |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c   |    5 +-
 .../plat-mxc/devices/platform-imx-hdmi-soc-dai.c   |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c  |    9 +-
 arch/arm/plat-mxc/devices/platform-imx-i2c.c       |    3 +
 arch/arm/plat-mxc/devices/platform-imx-pcie.c      |    5 +-
 arch/arm/plat-mxc/devices/platform-imx-pxp.c       |   15 +-
 arch/arm/plat-mxc/devices/platform-imx-uart.c      |    1 +
 arch/arm/plat-mxc/devices/platform-imx_vpu.c       |   16 +-
 arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c |    5 +-
 arch/arm/plat-mxc/devices/platform-mxc_hdmi.c      |    6 +-
 arch/arm/plat-mxc/devices/platform-mxc_mlb.c       |    8 +-
 arch/arm/plat-mxc/devices/platform-viv_gpu.c       |   35 +-
 arch/arm/plat-mxc/fuse.c                           |  165 ++
 arch/arm/plat-mxc/gpio.c                           |    9 +-
 arch/arm/plat-mxc/include/mach/arc_otg.h           |    3 +-
 arch/arm/plat-mxc/include/mach/epdc.h              |    2 +-
 arch/arm/plat-mxc/include/mach/iomux-mx6dl.h       |  103 +-
 arch/arm/plat-mxc/include/mach/iomux-mx6q.h        |  105 +-
 arch/arm/plat-mxc/include/mach/ipu-v3.h            |   13 +-
 arch/arm/plat-mxc/include/mach/irqs.h              |   11 +-
 arch/arm/plat-mxc/include/mach/mx6.h               |    5 +-
 arch/arm/plat-mxc/include/mach/mxc.h               |   24 +-
 arch/arm/plat-mxc/include/mach/mxc_hdmi.h          |    9 +-
 arch/arm/plat-mxc/include/mach/mxc_vpu.h           |    5 +-
 arch/arm/plat-mxc/include/mach/pcie.h              |    3 +-
 arch/arm/plat-mxc/pwm.c                            |    8 +-
 arch/arm/plat-mxc/usb_common.c                     |    6 +-
 arch/arm/plat-mxc/usb_wakeup.c                     |   20 +-
 arch/arm/tools/mach-types                          |    1 +
 arch/arm/vfp/vfpmodule.c                           |   10 +-
 arch/sh/boot/compressed/vmlinux.scr                |   10 -
 arch/sh/boot/romimage/vmlinux.scr                  |    8 -
 crypto/tcrypt.c                                    |   14 +-
 drivers/crypto/caam/caamalg.c                      |   18 +-
 drivers/crypto/caam/caamhash.c                     |    4 +-
 drivers/crypto/caam/sg_sw_sec4.h                   |   10 +-
 drivers/dma/imx-sdma.c                             |   73 +-
 drivers/dma/pxp/pxp_dma_v2.c                       |    2 +-
 drivers/gpu/drm/Makefile                           |    2 +-
 drivers/gpu/drm/vivante/Makefile                   |    2 +-
 drivers/gpu/drm/vivante/vivante_drv.c              |    2 +-
 drivers/gpu/drm/vivante/vivante_drv.h              |    2 +-
 drivers/i2c/busses/i2c-imx.c                       |   96 +-
 drivers/input/touchscreen/novatek_ts.c             |   13 +-
 drivers/media/video/mxc/capture/Kconfig            |    6 -
 drivers/media/video/mxc/capture/adv7180.c          |   60 +-
 drivers/media/video/mxc/capture/csi_v4l2_capture.c |  465 +++-
 drivers/media/video/mxc/capture/fsl_csi.c          |   34 +-
 drivers/media/video/mxc/capture/fsl_csi.h          |    2 +
 drivers/media/video/mxc/capture/ipu_csi_enc.c      |    3 +-
 .../media/video/mxc/capture/ipu_fg_overlay_sdc.c   |   43 +-
 drivers/media/video/mxc/capture/mxc_v4l2_capture.c |   38 +-
 drivers/media/video/mxc/capture/mxc_v4l2_capture.h |    9 +-
 drivers/media/video/mxc/capture/ov5640.c           | 1639 ++++++++-----
 drivers/media/video/mxc/capture/ov5640_mipi.c      |    8 +-
 drivers/media/video/mxc/capture/ov5642.c           |    8 +-
 drivers/media/video/mxc/output/mxc_vout.c          |  424 ++--
 drivers/media/video/videobuf-dma-contig.c          |    3 +-
 drivers/mfd/wm831x-i2c.c                           |   16 +-
 drivers/mmc/core/mmc.c                             |   73 +-
 drivers/mtd/chips/cfi_cmdset_0002.c                |  386 ++-
 drivers/mtd/nand/gpmi-nand/gpmi-lib.c              |    4 +-
 drivers/mxc/asrc/mxc_asrc.c                        |  335 ++-
 drivers/mxc/gpu-viv/Kbuild                         |    5 +-
 .../hal/kernel/gc_hal_kernel_hardware_command_vg.c |    4 +-
 .../hal/kernel/gc_hal_kernel_hardware_command_vg.h |    5 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.c   |   76 +-
 .../GC350/hal/kernel/gc_hal_kernel_hardware_vg.h   |    7 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.c   |   19 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_context.h   |    4 +-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c  |  979 +++++++-
 .../arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h  |   10 +-
 drivers/mxc/gpu-viv/config                         |    3 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c     | 1209 +++++++---
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h     |  122 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c |  390 ++-
 .../gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c  |   32 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c  |  161 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c   |    4 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c   |  168 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c    |    4 +-
 .../hal/kernel/gc_hal_kernel_interrupt_vg.c        |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c |  365 ++-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c  |    4 +-
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c   |  347 +++
 .../mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c  |  139 +-
 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h  |    5 +-
 .../hal/kernel/gc_hal_kernel_video_memory.c        |   10 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h        |  166 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h   |  125 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h   |  575 ++++-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h |  290 ++-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h  |    9 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h   |    3 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h    |   30 +-
 .../hal/kernel/inc/gc_hal_eglplatform_type.h       |    3 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h |  160 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h  |   11 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h   |   25 +-
 .../gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h  |   49 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h    |   16 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h    |  147 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h   |   17 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h |    4 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h |    4 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h |    3 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h  |   46 +-
 .../mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h    |    6 +-
 drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h     |   13 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debug.h      |    4 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.c    |    2 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debugfs.h    |    4 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  122 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |   15 +-
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     |  203 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.c      |   20 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_math.c       |    4 +-
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c |  891 +++----
 .../gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h |   15 +-
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c                |    6 +-
 drivers/mxc/ipu/ipu_calc_stripes_sizes.c           |   42 +-
 drivers/mxc/ipu3/ipu_calc_stripes_sizes.c          |   42 +-
 drivers/mxc/ipu3/ipu_capture.c                     |   32 +-
 drivers/mxc/ipu3/ipu_common.c                      |  187 +-
 drivers/mxc/ipu3/ipu_device.c                      |  285 ++-
 drivers/mxc/ipu3/ipu_disp.c                        |    8 +-
 drivers/mxc/ipu3/ipu_ic.c                          |    9 +-
 drivers/mxc/ipu3/ipu_param_mem.h                   |   10 +-
 drivers/mxc/mlb/mxc_mlb150.c                       | 2510 +++++++++++---------
 drivers/mxc/thermal/cooling.c                      |   11 +-
 drivers/mxc/thermal/thermal.c                      |   83 +-
 drivers/mxc/vpu/mxc_vpu.c                          |  111 +-
 drivers/net/can/dev.c                              |   10 +-
 drivers/net/can/flexcan.c                          |   23 +-
 drivers/net/fec.c                                  |  116 +-
 drivers/power/sabresd_battery.c                    |   10 +-
 drivers/regulator/pfuze100-regulator.c             |    4 +-
 drivers/usb/core/driver.c                          |    2 +
 drivers/usb/core/hub.c                             |   59 +
 drivers/usb/core/quirks.c                          |    3 -
 drivers/usb/gadget/arcotg_udc.c                    |   22 +-
 drivers/usb/host/Kconfig                           |    7 +
 drivers/usb/host/Makefile                          |    1 +
 drivers/usb/host/arc_hset.c                        |  468 ++++
 drivers/usb/host/ehci-arc.c                        |  126 +-
 drivers/usb/host/ehci-fsl.h                        |    3 +-
 drivers/usb/host/ehci-hcd.c                        |   31 +-
 drivers/usb/host/ehci-q.c                          |  181 ++
 drivers/usb/otg/fsl_otg.c                          |   27 +-
 drivers/usb/otg/otg_fsm.c                          |    4 +-
 drivers/video/mxc/ldb.c                            |   43 +-
 drivers/video/mxc/mxc_edid.c                       |   68 +-
 drivers/video/mxc/mxc_elcdif_fb.c                  |   14 +-
 drivers/video/mxc/mxc_epdc_fb.c                    |   32 +-
 drivers/video/mxc/mxc_ipuv3_fb.c                   |  114 +-
 drivers/video/mxc/mxcfb_sii902x_elcdif.c           |   32 +-
 drivers/video/mxc_hdmi.c                           |  504 +++-
 include/linux/can/dev.h                            |    2 +-
 include/linux/clockchips.h                         |    6 +
 include/linux/dmapool.h                            |    2 -
 include/linux/fec.h                                |    3 +-
 include/linux/fsl_devices.h                        |    5 +-
 include/linux/ipu.h                                |   11 +-
 include/linux/mtd/map.h                            |    2 +-
 include/linux/mxc_asrc.h                           |   11 +-
 include/linux/mxc_mlb.h                            |    7 +-
 include/linux/mxcfb.h                              |   13 +-
 kernel/power/main.c                                |    1 +
 kernel/time/tick-broadcast.c                       |   85 +-
 mm/compaction.c                                    |    6 +-
 mm/dmapool.c                                       |    4 -
 sound/soc/codecs/cs42888.c                         |   10 +-
 sound/soc/codecs/mxc_spdif.c                       |   39 +-
 sound/soc/codecs/wm8962.c                          |   19 +-
 sound/soc/imx/Kconfig                              |    6 +
 sound/soc/imx/imx-hdmi-dai.c                       |    8 +-
 sound/soc/imx/imx-hdmi.c                           |    8 +-
 sound/soc/imx/imx-si4763.c                         |    4 +-
 sound/soc/imx/imx-ssi.c                            |   96 +-
 sound/soc/imx/imx-wm8962.c                         |  439 ++--
 sound/soc/soc-core.c                               |    3 +
 tools/perf/builtin-sched.c                         |    1 -
 239 files changed, 16299 insertions(+), 5632 deletions(-)
 create mode 100644 arch/arm/mach-mx6/board-mx6dl_hdmidongle.h
 create mode 100644 arch/arm/mach-mx6/board-mx6q_hdmidongle.c
 create mode 100644 arch/arm/mach-mx6/board-mx6q_hdmidongle.h
 create mode 100644 arch/arm/mach-mx6/msi.c
 create mode 100644 arch/arm/mach-mx6/msi.h
 create mode 100644 arch/arm/mach-mx6/mx6_bt_rfkill.c
 create mode 100644 arch/arm/plat-mxc/fuse.c
 delete mode 100644 arch/sh/boot/compressed/vmlinux.scr
 delete mode 100644 arch/sh/boot/romimage/vmlinux.scr
 mode change 100644 => 100755 drivers/mfd/wm831x-i2c.c
 create mode 100644 drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
 create mode 100644 drivers/usb/host/arc_hset.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 164e772..25f41ef 100755
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1248,6 +1248,16 @@ config ARM_ERRATA_754327
 	  This workaround defines cpu_relax() as smp_mb(), preventing correctly
 	  written polling loops from denying visibility of updates to memory.
 
+config ARM_ERRATA_775420
+       bool "ARM errata: A data cache maintenance operation which aborts, might lead to deadlock"
+       depends on CPU_V7
+       help
+	 This option enables the workaround for the 775420 Cortex-A9 (r2p2,
+	 r2p6,r2p8,r2p10,r3p0) erratum. In case a date cache maintenance
+	 operation aborts with MMU exception, it might cause the processor
+	 to deadlock. This workaround puts DSB before executing ISB if
+	 an abort may occur on cache maintenance.
+
 endmenu
 
 source "arch/arm/common/Kconfig"
diff --git a/arch/arm/configs/imx6_defconfig b/arch/arm/configs/imx6_defconfig
index 6f30e36..b02b875 100644
--- a/arch/arm/configs/imx6_defconfig
+++ b/arch/arm/configs/imx6_defconfig
@@ -310,6 +310,7 @@ CONFIG_MACH_MX6Q_ARM2=y
 CONFIG_MACH_MX6Q_SABRELITE=y
 CONFIG_MACH_MX6Q_SABRESD=y
 CONFIG_MACH_MX6Q_SABREAUTO=y
+CONFIG_MACH_MX6Q_HDMIDONGLE=y
 
 #
 # MX6 Options:
@@ -380,6 +381,7 @@ CONFIG_ARM_ERRATA_751472=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
 # CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
@@ -390,7 +392,7 @@ CONFIG_ARM_AMBA=y
 # CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 CONFIG_ARM_ERRATA_764369=y
-# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_PL310_ERRATA_769419=y
 
 #
 # Kernel Features
@@ -1961,7 +1963,7 @@ CONFIG_USB_EHCI_ARC_OTG=y
 # CONFIG_USB_EHCI_ARC_HSIC is not set
 # CONFIG_USB_STATIC_IRAM is not set
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
-# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
 # CONFIG_USB_EHCI_MXC is not set
 # CONFIG_USB_OXU210HP_HCD is not set
 # CONFIG_USB_ISP116X_HCD is not set
diff --git a/arch/arm/configs/imx6_updater_defconfig b/arch/arm/configs/imx6_updater_defconfig
index 8c58f19..2eea527 100644
--- a/arch/arm/configs/imx6_updater_defconfig
+++ b/arch/arm/configs/imx6_updater_defconfig
@@ -320,6 +320,7 @@ CONFIG_MACH_MX6SL_ARM2=y
 CONFIG_MACH_MX6Q_SABRELITE=y
 CONFIG_MACH_MX6Q_SABRESD=y
 CONFIG_MACH_MX6Q_SABREAUTO=y
+CONFIG_MACH_MX6Q_HDMIDONGLE=y
 
 #
 # MX6 Options:
@@ -390,6 +391,7 @@ CONFIG_ARM_ERRATA_751472=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
 # CONFIG_ARM_ERRATA_754327 is not set
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
@@ -400,7 +402,7 @@ CONFIG_ARM_AMBA=y
 # CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 # CONFIG_ARM_ERRATA_764369 is not set
-# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_PL310_ERRATA_769419=y
 
 #
 # Kernel Features
@@ -728,6 +730,7 @@ CONFIG_MTD_CFI_UTIL=y
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_IMX6X_WEIMNOR=y
 # CONFIG_MTD_PHYSMAP_COMPAT is not set
 # CONFIG_MTD_ARM_INTEGRATOR is not set
 # CONFIG_MTD_PLATRAM is not set
diff --git a/arch/arm/configs/imx6s_defconfig b/arch/arm/configs/imx6s_defconfig
index 0c980c9..14e9ba5 100644
--- a/arch/arm/configs/imx6s_defconfig
+++ b/arch/arm/configs/imx6s_defconfig
@@ -1,3 +1,4 @@
+
 #
 # Automatically generated make config: don't edit
 # Linux/arm 3.0.35 Kernel Configuration
@@ -316,6 +317,7 @@ CONFIG_MACH_MX6SL_EVK=y
 # CONFIG_MACH_MX6Q_SABRELITE is not set
 CONFIG_MACH_MX6Q_SABRESD=y
 # CONFIG_MACH_MX6Q_SABREAUTO is not set
+CONFIG_SDMA_IRAM=y
 
 #
 # MX6 Options:
@@ -336,6 +338,7 @@ CONFIG_ARCH_MXC_AUDMUX_V2=y
 CONFIG_IRAM_ALLOC=y
 CONFIG_CLK_DEBUG=y
 CONFIG_DMA_ZONE_SIZE=184
+CONFIG_MACH_IMX_BLUETOOTH_RFKILL=y
 
 #
 # System MMU
@@ -381,6 +384,7 @@ CONFIG_CPU_HAS_PMU=y
 CONFIG_ARM_ERRATA_743622=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
@@ -1817,6 +1821,7 @@ CONFIG_SND_SOC=y
 CONFIG_SND_SOC_AC97_BUS=y
 CONFIG_SND_IMX_SOC=y
 CONFIG_SND_MXC_SOC_MX2=y
+CONFIG_SND_MXC_SOC_IRAM=y
 CONFIG_SND_MXC_SOC_SPDIF_DAI=y
 CONFIG_SND_SOC_IMX_SGTL5000=y
 CONFIG_SND_SOC_IMX_WM8958=y
diff --git a/arch/arm/configs/imx6s_updater_defconfig b/arch/arm/configs/imx6s_updater_defconfig
index b80f401..3fffe50 100644
--- a/arch/arm/configs/imx6s_updater_defconfig
+++ b/arch/arm/configs/imx6s_updater_defconfig
@@ -385,6 +385,7 @@ CONFIG_CPU_HAS_PMU=y
 CONFIG_ARM_ERRATA_743622=y
 # CONFIG_ARM_ERRATA_753970 is not set
 CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_775420=y
 CONFIG_ARM_GIC=y
 
 #
diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h
index 635c940..5eaa7a2 100644
--- a/arch/arm/include/asm/dma-mapping.h
+++ b/arch/arm/include/asm/dma-mapping.h
@@ -173,6 +173,19 @@ static inline void dma_free_noncoherent(struct device *dev, size_t size,
 }
 
 /**
+ * dma_alloc_noncached - allocate consistent memory for DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @size: required memory size
+ * @handle: bus-specific DMA address
+ *
+ * Allocate some uncached, unbuffered memory for a device for
+ * performing DMA.  This function allocates pages, and will
+ * return the CPU-viewed address, and sets @handle to be the
+ * device-viewed address.
+ */
+extern void *dma_alloc_noncached(struct device *, size_t, dma_addr_t *, gfp_t);
+
+/**
  * dma_alloc_coherent - allocate consistent memory for DMA
  * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
  * @size: required memory size
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 63c9205..f818b4e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -195,7 +195,7 @@ void cpu_idle(void)
 #ifdef CONFIG_PL310_ERRATA_769419
 			wmb();
 #endif
-			if (hlt_counter) {
+			if (hlt_counter || tick_check_broadcast_pending()) {
 				local_irq_enable();
 				cpu_relax();
 			} else {
diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 2ffd90d..64ce4d4 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -5,6 +5,7 @@ config ARCH_MX6Q
 	select USB_ARCH_HAS_EHCI
 	select ARCH_MXC_IOMUX_V3
 	select ARCH_MXC_AUDMUX_V2
+	select ARCH_SUPPORTS_MSI
 	select ARM_GIC
 	select ARCH_HAS_CPUFREQ
 	select OC_ETM
@@ -251,12 +252,50 @@ config MACH_MX6Q_SABREAUTO
 	  Include support for i.MX 6Quad SABRE Auto platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX6Q_HDMIDONGLE
+	bool "Support i.MX 6Quad HDMIDONGLE platform"
+	select ARCH_MX6Q
+	select SOC_IMX6Q
+	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_DMA
+	select IMX_HAVE_PLATFORM_GPMI_NFC
+	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_VIV_GPU
+	select IMX_HAVE_PLATFORM_IMX_VPU
+	select IMX_HAVE_PLATFORM_IMX_DVFS
+	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
+	select IMX_HAVE_PLATFORM_FSL_USB2_UDC
+	select IMX_HAVE_PLATFORM_MXC_EHCI
+	select IMX_HAVE_PLATFORM_FSL_OTG
+	select IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
+	select IMX_HAVE_PLATFORM_AHCI
+	select IMX_HAVE_PLATFORM_IMX_OCOTP
+	select IMX_HAVE_PLATFORM_IMX_VIIM
+	select IMX_HAVE_PLATFORM_IMX2_WDT
+	select IMX_HAVE_PLATFORM_IMX_SNVS_RTC
+	select IMX_HAVE_PLATFORM_IMX_PM
+	select IMX_HAVE_PLATFORM_MXC_HDMI
+	select IMX_HAVE_PLATFORM_IMX_PCIE
+	help
+	  Include support for i.MX 6Quad HDMI Dongle platform. This includes specific
+	  configurations for the board and its peripherals.
+
 comment "MX6 Options:"
 
 config IMX_PCIE
 	bool "PCI Express support"
 	select PCI
 
+config IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+	bool "PCI Express EP mode in the IMX6 RC/EP interconnection system"
+	depends on IMX_PCIE
+
+config IMX_PCIE_RC_MODE_IN_EP_RC_SYS
+	bool "PCI Express RC mode in the IMX6 RC/EP interconnection system"
+	depends on IMX_PCIE
+
 config USB_EHCI_ARC_H1
 	tristate "USB Host 1 support"
 	depends on USB_EHCI_ARC
@@ -264,6 +303,11 @@ config USB_EHCI_ARC_H1
 config USB_FSL_ARC_OTG
 	tristate "FSL USB OTG support"
 
+config USB_ID_WAKEUP_ENABLE
+	bool "Enable USB ID Pin As System Wakeup Source"
+	depends on SOC_IMX6SL
+	default n
+
 config MX6_INTER_LDO_BYPASS
 	bool "Internal LDO in MX6Q/DL bypass"
 	depends on  REGULATOR_PFUZE100 && CPU_FREQ_IMX && ARCH_MX6
@@ -282,4 +326,17 @@ config MX6_CLK_FOR_BOOTUI_TRANS
 	 avoid setting IPU related clocks' parents when initializing clock tree
 	 so that bootloader splashimage can transition to kernel smoothly.
 
+config MACH_IMX_BLUETOOTH_RFKILL
+       tristate "i.MX Bluetooth rfkill interface support"
+       depends on RFKILL
+       ---help---
+	Say Y to get the standard rfkill interface of Bluetooth
+
+config SDMA_IRAM
+	bool "Use Internal RAM for SDMA data structures"
+	depends on IMX_SDMA && SOC_IMX6SL
+	help
+	  SDMA buffer or control structures are stored in the IRAM/OCRAM
+
+
 endif
diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 5cac9bc..8c1d754 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -14,8 +14,11 @@ obj-$(CONFIG_MACH_MX6SL_EVK) += board-mx6sl_evk.o mx6sl_evk_pmic_pfuze100.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += board-mx6q_sabrelite.o
 obj-$(CONFIG_MACH_MX6Q_SABRESD) += board-mx6q_sabresd.o mx6q_sabresd_pmic_pfuze100.o
 obj-$(CONFIG_MACH_MX6Q_SABREAUTO) += board-mx6q_sabreauto.o mx6q_sabreauto_pmic_pfuze100.o
+obj-$(CONFIG_MACH_MX6Q_HDMIDONGLE) += board-mx6q_hdmidongle.o
 obj-$(CONFIG_SMP) += plat_hotplug.o platsmp.o headsmp.o
 obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
 obj-$(CONFIG_IMX_PCIE) += pcie.o
 obj-$(CONFIG_USB_FSL_ARC_OTG) += usb_dr.o
 obj-$(CONFIG_USB_EHCI_ARC_H1) += usb_h1.o
+obj-$(CONFIG_MACH_IMX_BLUETOOTH_RFKILL) += mx6_bt_rfkill.o
+obj-$(CONFIG_PCI_MSI) += msi.o
diff --git a/arch/arm/mach-mx6/board-mx6dl_arm2.h b/arch/arm/mach-mx6/board-mx6dl_arm2.h
index 429febb..f4560e4 100644
--- a/arch/arm/mach-mx6/board-mx6dl_arm2.h
+++ b/arch/arm/mach-mx6/board-mx6dl_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -182,13 +182,7 @@ static iomux_v3_cfg_t mx6dl_arm2_pads[] = {
 
 	/* USBOTG ID pin */
 	MX6DL_PAD_GPIO_1__USBOTG_ID,
-
-	/* MLB150 */
-	MX6DL_PAD_GPIO_3__MLB_MLBCLK,
-	MX6DL_PAD_GPIO_6__MLB_MLBSIG,
-	MX6DL_PAD_GPIO_2__MLB_MLBDAT,
-
-};
+ };
 
 static iomux_v3_cfg_t mx6dl_arm2_epdc_pads[] = {
 	MX6DL_PAD_EIM_A17__GPIO_2_21,
diff --git a/arch/arm/mach-mx6/board-mx6dl_hdmidongle.h b/arch/arm/mach-mx6/board-mx6dl_hdmidongle.h
new file mode 100644
index 0000000..b46b6e1
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6dl_hdmidongle.h
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _BOARD_MX6DL_HDMIDONGLE_H
+#define _BOARD_MX6DL_HDMIDONGLE_H
+#include <mach/iomux-mx6dl.h>
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_rev_a_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6DL_PAD_EIM_OE__ECSPI2_MISO,
+	MX6DL_PAD_EIM_RW__ECSPI2_SS0,
+	MX6DL_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6DL_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6DL_PAD_EIM_A16__GPIO_2_22,
+	/*BT_WAKEUP_HOST(Combo module BT wake-up output) */
+	MX6DL_PAD_EIM_A25__GPIO_5_2,
+	/* HOST_WAKEUP_BT(CPU wakeup BT signal)*/
+	MX6DL_PAD_EIM_D16__GPIO_3_16,
+
+	/* I2C3  */
+	MX6DL_PAD_EIM_D17__I2C3_SCL,
+	MX6DL_PAD_EIM_D18__I2C3_SDA,
+
+	/* USB OC pin */
+	MX6DL_PAD_EIM_D21__USBOH3_USBOTG_OC,
+	/* WLAN_WAKEUP_HOST(Combo module WLAN host wake-up output) */
+	MX6DL_PAD_EIM_D22__GPIO_3_22,
+
+	/* BT_UART2  */
+	MX6DL_PAD_EIM_D26__UART2_TXD,
+	MX6DL_PAD_EIM_D27__UART2_RXD,
+	MX6DL_PAD_EIM_D28__UART2_CTS,
+	MX6DL_PAD_EIM_D29__UART2_RTS,
+
+	/*BT_nRST(Combo module BT reset signal)*/
+	MX6DL_PAD_EIM_DA7__GPIO_3_7,
+
+	/*BT_REG_ON(Combo module BT Internal regulators power enable/disable)*/
+	MX6DL_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WL_REG_ON(Combo module WLAN Internal regulators power enable/disable)*/
+	MX6DL_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6DL_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6DL_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6DL_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6DL_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A24__GPIO_5_4,	/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6DL_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+	/* I2C1  */
+	MX6DL_PAD_CSI0_DAT8__I2C1_SDA,
+	MX6DL_PAD_CSI0_DAT9__I2C1_SCL,
+
+	/* UART1 for debug */
+	MX6DL_PAD_CSI0_DAT10__UART1_TXD,
+	MX6DL_PAD_CSI0_DAT11__UART1_RXD,
+
+	/* SD1 (Combo module WLAN SDIO )*/
+	MX6DL_PAD_SD1_CLK__USDHC1_CLK,
+	MX6DL_PAD_SD1_CMD__USDHC1_CMD,
+	MX6DL_PAD_SD1_DAT0__USDHC1_DAT0,
+	MX6DL_PAD_SD1_DAT1__USDHC1_DAT1,
+	MX6DL_PAD_SD1_DAT2__USDHC1_DAT2,
+	MX6DL_PAD_SD1_DAT3__USDHC1_DAT3,
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6DL_PAD_SD2_CLK__USDHC2_CLK,
+	MX6DL_PAD_SD2_CMD__USDHC2_CMD,
+	MX6DL_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6DL_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6DL_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6DL_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6DL_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6DL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6DL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6DL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6DL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6DL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6DL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6DL_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6DL_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6DL_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6DL_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6DL_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6DL_PAD_KEY_COL0__UART4_TXD,
+	MX6DL_PAD_KEY_ROW0__UART4_RXD,
+
+	/*HDMI CEC communication PIN*/
+	MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/* I2C2 */
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/*DCDC5V_PWREN(5V DCDC BOOST control signal)*/
+	MX6DL_PAD_KEY_COL4__GPIO_4_14,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6DL_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6DL_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C3 */
+	MX6DL_PAD_GPIO_5__I2C3_SCL,
+	MX6DL_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6DL_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6DL_PAD_NANDF_CS0__GPIO_6_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6DL_PAD_NANDF_CS1__GPIO_6_14,
+
+	/*PWRKEY_DET(Power key press detection)*/
+	MX6DL_PAD_NANDF_CS3__GPIO_6_16,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6DL_PAD_NANDF_D6__GPIO_2_6,
+
+	/*IR_RC*/
+	MX6DL_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_rev_b_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6DL_PAD_EIM_OE__ECSPI2_MISO,
+	MX6DL_PAD_EIM_RW__ECSPI2_SS0,
+	MX6DL_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6DL_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6DL_PAD_EIM_A16__GPIO_2_22,
+	/*WLAN_CLKREQn*/
+	MX6DL_PAD_EIM_A25__GPIO_5_2,
+
+	/* WLAN_ACT */
+	MX6DL_PAD_EIM_D17__GPIO_3_17,
+
+	/*BT_PERI*/
+	MX6DL_PAD_EIM_D18__GPIO_3_18,
+
+	/* USB OC pin */
+	MX6DL_PAD_EIM_D21__USBOH3_USBOTG_OC,
+
+	/* WLAN_WAKEn (PM event, OD, used to reactivate the PCIe main PWR and REF CLK) */
+	MX6DL_PAD_EIM_D22__GPIO_3_22,
+
+
+	/*WLAN_PERSTn (PCIe rst signal, avtive LOW)*/
+	MX6DL_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WLAN_PDn (Externally shutdown RTL8192)*/
+	MX6DL_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6DL_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6DL_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6DL_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6DL_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6DL_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6DL_PAD_EIM_A24__GPIO_5_4,		/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6DL_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6DL_PAD_SD2_CLK__USDHC2_CLK,
+	MX6DL_PAD_SD2_CMD__USDHC2_CMD,
+	MX6DL_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6DL_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6DL_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6DL_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6DL_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6DL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6DL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6DL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6DL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6DL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6DL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6DL_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6DL_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6DL_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6DL_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6DL_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6DL_PAD_KEY_COL0__UART4_TXD,
+	MX6DL_PAD_KEY_ROW0__UART4_RXD,
+
+	/*SD2_VSELECT (SD2 SDXC power exchange control signal)*/
+	MX6DL_PAD_KEY_ROW1__GPIO_4_9,
+
+	/*HDMI CEC communication PIN*/
+	MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/*PWRKEY_DET (Pwr button detection interrupt)*/
+	MX6DL_PAD_ENET_RXD0__GPIO_1_27,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6DL_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6DL_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C2 */
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/* I2C3 */
+	MX6DL_PAD_GPIO_5__I2C3_SCL,
+	MX6DL_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6DL_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6DL_PAD_SD4_DAT3__GPIO_2_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6DL_PAD_SD4_DAT1__GPIO_2_9,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6DL_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+/* The GPMI is conflicted with SD3, so init this in the driver. */
+static iomux_v3_cfg_t mx6dl_gpmi_nand[] __initdata = {
+	MX6DL_PAD_NANDF_CLE__RAWNAND_CLE,
+	MX6DL_PAD_NANDF_ALE__RAWNAND_ALE,
+	MX6DL_PAD_NANDF_CS0__RAWNAND_CE0N,
+	MX6DL_PAD_NANDF_CS1__RAWNAND_CE1N,
+	MX6DL_PAD_NANDF_CS2__RAWNAND_CE2N,
+	MX6DL_PAD_NANDF_CS3__RAWNAND_CE3N,
+	MX6DL_PAD_NANDF_RB0__RAWNAND_READY0,
+	MX6DL_PAD_SD4_DAT0__RAWNAND_DQS,
+	MX6DL_PAD_NANDF_D0__RAWNAND_D0,
+	MX6DL_PAD_NANDF_D1__RAWNAND_D1,
+	MX6DL_PAD_NANDF_D2__RAWNAND_D2,
+	MX6DL_PAD_NANDF_D3__RAWNAND_D3,
+	MX6DL_PAD_NANDF_D4__RAWNAND_D4,
+	MX6DL_PAD_NANDF_D5__RAWNAND_D5,
+	MX6DL_PAD_NANDF_D6__RAWNAND_D6,
+	MX6DL_PAD_NANDF_D7__RAWNAND_D7,
+	MX6DL_PAD_SD4_CMD__RAWNAND_RDN,
+	MX6DL_PAD_SD4_CLK__RAWNAND_WRN,
+	MX6DL_PAD_NANDF_WP_B__RAWNAND_RESETN,
+};
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_hdmi_ddc_pads[] = {
+	MX6DL_PAD_KEY_COL3__HDMI_TX_DDC_SCL, /* HDMI DDC SCL */
+	MX6DL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA, /* HDMI DDC SDA */
+};
+
+static iomux_v3_cfg_t mx6dl_hdmidongle_i2c2_pads[] = {
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,	/* I2C2 SCL */
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,	/* I2C2 SDA */
+};
+
+#endif
diff --git a/arch/arm/mach-mx6/board-mx6dl_sabresd.h b/arch/arm/mach-mx6/board-mx6dl_sabresd.h
index fe278e8..7cb6924 100644
--- a/arch/arm/mach-mx6/board-mx6dl_sabresd.h
+++ b/arch/arm/mach-mx6/board-mx6dl_sabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -66,7 +66,6 @@ static iomux_v3_cfg_t mx6dl_sabresd_pads[] = {
 
 	/* I2C3 */
 	MX6DL_PAD_GPIO_3__I2C3_SCL,
-	MX6DL_PAD_GPIO_6__I2C3_SDA,
 
 	/* DISPLAY */
 	MX6DL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
@@ -167,7 +166,7 @@ static iomux_v3_cfg_t mx6dl_sabresd_pads[] = {
 	MX6DL_PAD_SD4_DAT7__USDHC4_DAT7_50MHZ,
 
 	/* HDMI_CEC_IN*/
-	MX6DL_PAD_KEY_ROW2__GPIO_4_11,
+	MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
 
 	/* CCM - Audio, Camera clock  */
 	MX6DL_PAD_GPIO_0__CCM_CLKO,
diff --git a/arch/arm/mach-mx6/board-mx6q_arm2.c b/arch/arm/mach-mx6/board-mx6q_arm2.c
index 85f9389..8280805 100644
--- a/arch/arm/mach-mx6/board-mx6q_arm2.c
+++ b/arch/arm/mach-mx6/board-mx6q_arm2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -155,6 +155,10 @@
 
 #define MX6_ARM2_CAN2_STBY		MX6_ARM2_IO_EXP_GPIO2(1)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
 
 #define BMCR_PDOWN			0x0800 /* PHY Powerdown */
 
@@ -173,6 +177,7 @@ extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
 extern int epdc_enabled;
+extern bool enet_to_gpio_6;
 static int max17135_regulator_init(struct max17135 *max17135);
 
 enum sd_pad_mode {
@@ -336,6 +341,16 @@ static int mx6_arm2_fec_phy_init(struct phy_device *phydev)
 {
 	unsigned short val;
 
+	/* Ar8031 phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, 0xd, 0x3);
+	phy_write(phydev, 0xe, 0x805d);
+	phy_write(phydev, 0xd, 0x4003);
+	val = phy_read(phydev, 0xe);
+	val &= ~(0x1 << 8);
+	phy_write(phydev, 0xe, val);
+
 	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
 	phy_write(phydev, 0xd, 0x7);
 	phy_write(phydev, 0xe, 0x8016);
@@ -377,6 +392,7 @@ static struct fec_platform_data fec_data __initdata = {
 	.init			= mx6_arm2_fec_phy_init,
 	.power_hibernate	= mx6_arm2_fec_power_hibernate,
 	.phy			= PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq = MX6_ENET_IRQ,
 };
 
 static int mx6_arm2_spi_cs[] = {
@@ -863,11 +879,7 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 	},
 };
 
-static struct imxi2c_platform_data mx6_arm2_i2c0_data = {
-	.bitrate = 100000,
-};
-
-static struct imxi2c_platform_data mx6_arm2_i2c1_data = {
+static struct imxi2c_platform_data mx6_arm2_i2c_data = {
 	.bitrate = 100000,
 };
 
@@ -1307,11 +1319,22 @@ static int mx6_arm2_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -1322,6 +1345,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6_arm2_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -1337,6 +1361,7 @@ static struct ahci_platform_data mx6_arm2_sata_data = {
 	.init	= mx6_arm2_sata_init,
 	.exit	= mx6_arm2_sata_exit,
 };
+#endif
 
 static struct imx_asrc_platform_data imx_asrc_data = {
 	.channel_bits	= 4,
@@ -2028,6 +2053,18 @@ static void __init mx6_arm2_init(void)
 		spdif_pads_cnt =  ARRAY_SIZE(mx6q_arm2_spdif_pads);
 		flexcan_pads_cnt = ARRAY_SIZE(mx6q_arm2_can_pads);
 		i2c3_pads_cnt = ARRAY_SIZE(mx6q_arm2_i2c3_pads);
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6Q_PAD_GPIO_3__MLB_MLBCLK,
+				MX6Q_PAD_GPIO_6__MLB_MLBSIG,
+				MX6Q_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	} else if (cpu_is_mx6dl()) {
 		common_pads = mx6dl_arm2_pads;
 		esai_rec_pads = mx6dl_arm2_esai_record_pads;
@@ -2042,6 +2079,18 @@ static void __init mx6_arm2_init(void)
 		flexcan_pads_cnt = ARRAY_SIZE(mx6dl_arm2_can_pads);
 		i2c3_pads_cnt = ARRAY_SIZE(mx6dl_arm2_i2c3_pads);
 		epdc_pads_cnt = ARRAY_SIZE(mx6dl_arm2_epdc_pads);
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6DL_PAD_GPIO_3__MLB_MLBCLK,
+				MX6DL_PAD_GPIO_6__MLB_MLBSIG,
+				MX6DL_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	}
 
 	BUG_ON(!common_pads);
@@ -2128,8 +2177,8 @@ static void __init mx6_arm2_init(void)
 
 	imx6q_add_imx_caam();
 
-	imx6q_add_imx_i2c(0, &mx6_arm2_i2c0_data);
-	imx6q_add_imx_i2c(1, &mx6_arm2_i2c1_data);
+	imx6q_add_imx_i2c(0, &mx6_arm2_i2c_data);
+	imx6q_add_imx_i2c(1, &mx6_arm2_i2c_data);
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 			ARRAY_SIZE(mxc_i2c0_board_info));
 	i2c_register_board_info(1, mxc_i2c1_board_info,
@@ -2141,6 +2190,8 @@ static void __init mx6_arm2_init(void)
 		i2c_register_board_info(2, mxc_i2c2_board_info,
 				ARRAY_SIZE(mxc_i2c2_board_info));
 	}
+	if (cpu_is_mx6dl())
+		imx6q_add_imx_i2c(3, &mx6_arm2_i2c_data);
 
 	/* SPI */
 	imx6q_add_ecspi(0, &mx6_arm2_spi_data);
@@ -2150,15 +2201,30 @@ static void __init mx6_arm2_init(void)
 
 	imx6q_add_anatop_thermal_imx(1, &mx6_arm2_anatop_thermal_data);
 
-	if (!esai_record)
+	if (!esai_record) {
+		if (enet_to_gpio_6)
+			/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+			mxc_iomux_set_specialbits_register(
+				IOMUX_OBSRV_MUX1_OFFSET,
+				OBSRV_MUX1_ENET_IRQ,
+				OBSRV_MUX1_MASK);
+		else
+			fec_data.gpio_irq = -1;
 		imx6_init_fec(fec_data);
+	}
 
 	imx6q_add_pm_imx(0, &mx6_arm2_pm_data);
 	imx6q_add_sdhci_usdhc_imx(3, &mx6_arm2_sd4_data);
 	imx6q_add_sdhci_usdhc_imx(2, &mx6_arm2_sd3_data);
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6_gpu_pdata);
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 		imx6q_add_ahci(0, &mx6_arm2_sata_data);
+#else
+		mx6_arm2_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	mx6_arm2_init_usb();
 	mx6_arm2_init_audio();
diff --git a/arch/arm/mach-mx6/board-mx6q_arm2.h b/arch/arm/mach-mx6/board-mx6q_arm2.h
index eb06ef8..24a894f 100644
--- a/arch/arm/mach-mx6/board-mx6q_arm2.h
+++ b/arch/arm/mach-mx6/board-mx6q_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012, 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -182,12 +182,7 @@ static iomux_v3_cfg_t mx6q_arm2_pads[] = {
 
 	/* USBOTG ID pin */
 	MX6Q_PAD_GPIO_1__USBOTG_ID,
-
-	/* MLB150 */
-	MX6Q_PAD_GPIO_3__MLB_MLBCLK,
-	MX6Q_PAD_GPIO_6__MLB_MLBSIG,
-	MX6Q_PAD_GPIO_2__MLB_MLBDAT,
-};
+ };
 
 static iomux_v3_cfg_t mx6q_arm2_i2c3_pads[] = {
 	MX6Q_PAD_GPIO_5__I2C3_SCL,
diff --git a/arch/arm/mach-mx6/board-mx6q_hdmidongle.c b/arch/arm/mach-mx6/board-mx6q_hdmidongle.c
new file mode 100644
index 0000000..ffd8d9a
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6q_hdmidongle.c
@@ -0,0 +1,800 @@
+/*
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c.h>
+#include <linux/i2c/pca953x.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
+#include <linux/fec.h>
+#include <linux/memblock.h>
+#include <linux/gpio.h>
+#include <linux/etherdevice.h>
+#include <linux/regulator/anatop-regulator.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/mfd/mxc-hdmi-core.h>
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/memory.h>
+#include <mach/iomux-mx6q.h>
+#include <mach/imx-uart.h>
+#include <mach/viv_gpu.h>
+#include <mach/ipu-v3.h>
+#include <mach/mxc_hdmi.h>
+
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#ifdef CONFIG_MFD_WM831X
+#include <linux/mfd/wm831x/core.h>
+#include <linux/mfd/wm831x/pdata.h>
+#include <linux/mfd/wm831x/regulator.h>
+#include <linux/mfd/wm831x/gpio.h>
+#endif
+
+#include "usb.h"
+#include "devices-imx6q.h"
+#include "crm_regs.h"
+#include "cpu_op-mx6.h"
+#include "board-mx6q_hdmidongle.h"
+#include "board-mx6dl_hdmidongle.h"
+
+#define HDMIDONGLE_USB_OTG_PWR	IMX_GPIO_NR(4, 15)
+#define HDMIDONGLE_USB_H1_PWR	IMX_GPIO_NR(4, 14)
+#define HDMIDONGLE_ECSPI2_CS0  IMX_GPIO_NR(2, 26)
+#define HDMIDONGLE_HDMI_CEC_IN	IMX_GPIO_NR(4, 11)
+
+
+#define HDMIDONGLE_BT_RST	IMX_GPIO_NR(3, 7)
+#define HDMIDONGLE_BT_EN	IMX_GPIO_NR(3, 9)
+#define HDMIDONGLE_WL_EN        IMX_GPIO_NR(3, 10)
+
+#define HDMIDONGLE_SD2_CD		IMX_GPIO_NR(1, 4)
+#define HDMIDONGLE_REVA_POWER_KEY	IMX_GPIO_NR(6, 16)
+#define HDMIDONGLE_REVB_POWER_KEY	IMX_GPIO_NR(1, 27)
+
+#ifdef CONFIG_IMX_PCIE
+#define HDMIDONGLE_PCIE_PWR_EN	IMX_GPIO_NR(3, 7) /*fake pcie power enable */
+#define HDMIDONGLE_PCIE_RST     IMX_GPIO_NR(3, 9)
+#define HDMIDONGLE_PCIE_WAKE	IMX_GPIO_NR(3, 22)
+#define HDMIDONGLE_PCIE_DIS		IMX_GPIO_NR(3, 10)
+#endif
+
+extern char *gp_reg_id;
+extern char *soc_reg_id;
+extern char *pu_reg_id;
+
+static const struct esdhc_platform_data mx6q_hdmidongle_sd1_data __initconst = {
+	.always_present = 1,
+};
+
+static const struct esdhc_platform_data mx6q_hdmidongle_sd2_data __initconst = {
+	.cd_gpio = HDMIDONGLE_SD2_CD,
+	.keep_power_at_suspend = 1,
+	.support_8bit = 0,
+	.delay_line = 0,
+	.cd_type = ESDHC_CD_CONTROLLER,
+};
+
+static const struct esdhc_platform_data mx6q_hdmidongle_sd3_data __initconst = {
+	.always_present = 1,
+	.keep_power_at_suspend = 1,
+	.support_8bit = 1,
+	.delay_line = 0,
+	.cd_type = ESDHC_CD_PERMANENT,
+};
+
+static const struct esdhc_platform_data mx6q_hdmidongle_revc_sd3_data __initconst = {
+	.always_present = 1,
+	.keep_power_at_suspend = 1,
+	.support_8bit = 0,
+	.delay_line = 0,
+	.cd_type = ESDHC_CD_PERMANENT,
+};
+
+
+static int __init gpmi_nand_platform_init(void)
+{
+	iomux_v3_cfg_t *nand_pads = NULL;
+	u32 nand_pads_cnt;
+
+	if (cpu_is_mx6q()) {
+		nand_pads = mx6q_gpmi_nand;
+		nand_pads_cnt = ARRAY_SIZE(mx6q_gpmi_nand);
+	} else if (cpu_is_mx6dl()) {
+		nand_pads = mx6dl_gpmi_nand;
+		nand_pads_cnt = ARRAY_SIZE(mx6dl_gpmi_nand);
+
+	}
+	BUG_ON(!nand_pads);
+	return mxc_iomux_v3_setup_multiple_pads(nand_pads, nand_pads_cnt);
+}
+
+static struct gpmi_nand_platform_data
+mx6_gpmi_nand_platform_data __initdata = {
+	.platform_init           = gpmi_nand_platform_init,
+	.min_prop_delay_in_ns    = 5,
+	.max_prop_delay_in_ns    = 9,
+	.max_chip_count          = 1,
+	.enable_bbt              = 1,
+	.enable_ddr              = 0,
+};
+
+static int __init board_support_onfi_nand(char *p)
+{
+	mx6_gpmi_nand_platform_data.enable_ddr = 1;
+	return 0;
+}
+
+early_param("onfi_support", board_support_onfi_nand);
+
+
+static const struct anatop_thermal_platform_data
+	mx6q_hdmidongle_anatop_thermal_data __initconst = {
+		.name = "anatop_thermal",
+};
+
+static inline void mx6q_hdmidongle_init_uart(void)
+{
+	if (board_is_mx6_reva())
+		imx6q_add_imx_uart(1, NULL);
+	imx6q_add_imx_uart(0, NULL);
+	imx6q_add_imx_uart(3, NULL);
+}
+
+static int mx6q_hdmidongle_spi_cs[] = {
+	HDMIDONGLE_ECSPI2_CS0,
+};
+
+static const struct spi_imx_master mx6q_hdmidongle_spi_data __initconst = {
+	.chipselect     = mx6q_hdmidongle_spi_cs,
+	.num_chipselect = ARRAY_SIZE(mx6q_hdmidongle_spi_cs),
+};
+
+
+
+#ifdef CONFIG_MFD_WM831X
+#if 0
+/* 1.4125, 1.4125. 1.5 */
+#define WM831X_DC1_ON_CONFIG_VAL            (0x48<<WM831X_DC1_ON_VSEL_SHIFT)
+#define WM831X_DC2_ON_CONFIG_VAL            (0x48<<WM831X_DC2_ON_VSEL_SHIFT)
+#define WM831X_DC3_ON_CONFIG_VAL            (0x1A<<WM831X_DC3_ON_VSEL_SHIFT)
+#else
+/* 1.375, 1.375. 1.5 */
+
+#define WM831X_DC1_ON_CONFIG_VAL            (0x44<<WM831X_DC1_ON_VSEL_SHIFT)
+#define WM831X_DC2_ON_CONFIG_VAL            (0x44<<WM831X_DC2_ON_VSEL_SHIFT)
+#define WM831X_DC3_ON_CONFIG_VAL            (0x1A<<WM831X_DC3_ON_VSEL_SHIFT)
+
+#endif
+
+#define WM831X_DC1_DVS_MODE_VAL             (0x02<<WM831X_DC1_DVS_SRC_SHIFT)
+#define WM831X_DC2_DVS_MODE_VAL             (0x02<<WM831X_DC2_DVS_SRC_SHIFT)
+
+#define WM831X_DC1_DVS_CONTROL_VAL           (0x20<<WM831X_DC1_DVS_VSEL_SHIFT)
+#define WM831X_DC2_DVS_CONTROL_VAL           (0x20<<WM831X_DC2_DVS_VSEL_SHIFT)
+
+#define WM831X_DC1_DVS_MASK                  (WM831X_DC1_DVS_SRC_MASK|WM831X_DC1_DVS_VSEL_MASK)
+#define WM831X_DC2_DVS_MASK                  (WM831X_DC2_DVS_SRC_MASK|WM831X_DC1_DVS_VSEL_MASK)
+
+#define WM831X_DC1_DVS_VAL                   (WM831X_DC1_DVS_MODE_VAL|WM831X_DC1_DVS_CONTROL_VAL)
+#define WM831X_DC2_DVS_VAL                   (WM831X_DC2_DVS_MODE_VAL|WM831X_DC2_DVS_CONTROL_VAL)
+
+#define WM831X_GPN_FN_VAL_HW_EN              (0x0A<<WM831X_GPN_FN_SHIFT)
+#define WM831X_GPN_FN_VAL_HW_CTL             (0x0C<<WM831X_GPN_FN_SHIFT)
+#define WM831X_GPN_FN_VAL_DVS1               (0x08<<WM831X_GPN_FN_SHIFT)
+
+#define WM831X_GPN_DIR_VAL                   (0x1<<WM831X_GPN_DIR_SHIFT)
+#define WM831X_GPN_PULL_VAL                  (0x3<<WM831X_GPN_PULL_SHIFT)
+#define WM831X_GPN_INT_MODE_VAL              (0x1<<WM831X_GPN_INT_MODE_SHIFT)
+#define WM831X_GPN_POL_VAL                   (0x1<<WM831X_GPN_POL_SHIFT)
+#define WM831X_GPN_ENA_VAL                   (0x1<<WM831X_GPN_ENA_SHIFT)
+
+#define WM831X_GPIO7_8_9_MASK               (WM831X_GPN_DIR_MASK|WM831X_GPN_INT_MODE_MASK|WM831X_GPN_PULL_MASK|WM831X_GPN_POL_MASK|WM831X_GPN_FN_MASK)
+
+
+#define WM831X_GPIO7_VAL                     (WM831X_GPN_DIR_VAL|WM831X_GPN_PULL_VAL|WM831X_GPN_INT_MODE_VAL|WM831X_GPN_POL_VAL|WM831X_GPN_ENA_VAL|WM831X_GPN_FN_VAL_HW_EN)
+#define WM831X_GPIO8_VAL                     (WM831X_GPN_DIR_VAL|WM831X_GPN_PULL_VAL|WM831X_GPN_INT_MODE_VAL|WM831X_GPN_POL_VAL|WM831X_GPN_ENA_VAL|WM831X_GPN_FN_VAL_HW_CTL)
+#define WM831X_GPIO9_VAL                     (WM831X_GPN_DIR_VAL|WM831X_GPN_PULL_VAL|WM831X_GPN_INT_MODE_VAL|WM831X_GPN_POL_VAL|WM831X_GPN_ENA_VAL|WM831X_GPN_FN_VAL_DVS1)
+
+#define WM831X_STATUS_LED_MASK                0xC000
+#define WM831X_STATUS_LED_ON                  (0x1 << 14)
+#define WM831X_STATUS_LED_OFF                 (0x0 << 14)
+
+static int wm8326_post_init(struct wm831x *wm831x)
+{
+	wm831x_set_bits(wm831x, WM831X_DC1_ON_CONFIG, WM831X_DC1_ON_VSEL_MASK, WM831X_DC1_ON_CONFIG_VAL);
+	wm831x_set_bits(wm831x, WM831X_DC2_ON_CONFIG, WM831X_DC2_ON_VSEL_MASK, WM831X_DC2_ON_CONFIG_VAL);
+	wm831x_set_bits(wm831x, WM831X_DC3_ON_CONFIG, WM831X_DC3_ON_VSEL_MASK, WM831X_DC3_ON_CONFIG_VAL);
+
+	wm831x_set_bits(wm831x, WM831X_DC1_DVS_CONTROL, WM831X_DC1_DVS_MASK, WM831X_DC1_DVS_VAL);
+	wm831x_set_bits(wm831x, WM831X_DC2_DVS_CONTROL, WM831X_DC2_DVS_MASK, WM831X_DC2_DVS_VAL);
+
+	wm831x_set_bits(wm831x, WM831X_GPIO7_CONTROL, WM831X_GPIO7_8_9_MASK, WM831X_GPIO7_VAL);
+	wm831x_set_bits(wm831x, WM831X_GPIO8_CONTROL, WM831X_GPIO7_8_9_MASK, WM831X_GPIO8_VAL);
+	wm831x_set_bits(wm831x, WM831X_GPIO9_CONTROL, WM831X_GPIO7_8_9_MASK, WM831X_GPIO9_VAL);
+
+    wm831x_set_bits(wm831x, WM831X_STATUS_LED_1 , WM831X_STATUS_LED_MASK, WM831X_STATUS_LED_OFF);
+    wm831x_set_bits(wm831x, WM831X_STATUS_LED_2 , WM831X_STATUS_LED_MASK, WM831X_STATUS_LED_ON);
+	return 0;
+}
+
+static struct wm831x_pdata hdmidongle_wm8326_pdata = {
+	.post_init = wm8326_post_init,
+};
+#endif
+
+static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
+	{
+#ifdef CONFIG_MFD_WM831X
+	I2C_BOARD_INFO("wm8326", 0x34),
+	.platform_data = &hdmidongle_wm8326_pdata,
+#endif
+	},
+};
+
+static struct spi_board_info wm8326_spi1_board_info[] __initdata = {
+#if defined(CONFIG_MFD_WM831X_SPI)
+	{
+	/* The modalias must be the same as spi device driver name */
+	.modalias	= "wm8326",
+	.max_speed_hz	= 20000000,
+	.bus_num	= 1,
+	.chip_select	= 0,
+	},
+#endif
+};
+
+static void spi_device_init(void)
+{
+	spi_register_board_info(wm8326_spi1_board_info,
+				ARRAY_SIZE(wm8326_spi1_board_info));
+}
+
+static struct imxi2c_platform_data mx6q_hdmidongle_i2c_data = {
+	.bitrate = 100000,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("mxc_hdmi_i2c", 0x50),
+	},
+};
+
+
+static void imx6q_hdmidongle_usbotg_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(HDMIDONGLE_USB_OTG_PWR, 1);
+	else
+		gpio_set_value(HDMIDONGLE_USB_OTG_PWR, 0);
+}
+
+static void __init imx6q_hdmidongle_init_usb(void)
+{
+	int ret = 0;
+
+	imx_otg_base = MX6_IO_ADDRESS(MX6Q_USB_OTG_BASE_ADDR);
+	/* disable external charger detect,
+	 * or it will affect signal quality at dp .
+	 */
+	ret = gpio_request(HDMIDONGLE_USB_OTG_PWR, "usb-pwr");
+	if (ret) {
+		pr_err("failed to get GPIO HDMIDONGLE_USB_OTG_PWR: %d\n",
+			ret);
+		return;
+	}
+	gpio_direction_output(HDMIDONGLE_USB_OTG_PWR, 0);
+	/* keep USB host1 VBUS always on */
+	if (board_is_mx6_reva()) {
+		ret = gpio_request(HDMIDONGLE_USB_H1_PWR, "usb-h1-pwr");
+		if (ret) {
+			pr_err("failed to get GPIO HDMIDONGLE_USB_H1_PWR: %d\n",
+				ret);
+			return;
+		}
+		gpio_direction_output(HDMIDONGLE_USB_H1_PWR, 1);
+	}
+	mxc_iomux_set_gpr_register(1, 13, 1, 1);
+
+	mx6_set_otghost_vbus_func(imx6q_hdmidongle_usbotg_vbus);
+}
+
+
+static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
+	.reserved_mem_size = SZ_128M + SZ_64M,
+};
+
+
+static struct ipuv3_fb_platform_data hdmidongle_fb_data[] = {
+	{/*fb0*/
+	.disp_dev = "hdmi",
+	.interface_pix_fmt = IPU_PIX_FMT_RGB24,
+	.mode_str = "1920x1080M@60",
+	.default_bpp = 32,
+	.int_clk = false,
+	},
+};
+
+static void hdmi_init(int ipu_id, int disp_id)
+{
+	int hdmi_mux_setting;
+
+	if ((ipu_id > 1) || (ipu_id < 0)) {
+		pr_err("Invalid IPU select for HDMI: %d. Set to 0\n", ipu_id);
+		ipu_id = 0;
+	}
+
+	if ((disp_id > 1) || (disp_id < 0)) {
+		pr_err("Invalid DI select for HDMI: %d. Set to 0\n", disp_id);
+		disp_id = 0;
+	}
+
+	/* Configure the connection between IPU1/2 and HDMI */
+	hdmi_mux_setting = 2*ipu_id + disp_id;
+
+	/* GPR3, bits 2-3 = HDMI_MUX_CTL */
+	mxc_iomux_set_gpr_register(3, 2, 2, hdmi_mux_setting);
+	/* Set HDMI event as SDMA event2 while Chip version later than TO1.2 */
+	if (hdmi_SDMA_check())
+		mxc_iomux_set_gpr_register(0, 0, 1, 1);
+}
+
+/* On mx6x sabresd board i2c2 iomux with hdmi ddc,
+ * the pins default work at i2c2 function,
+ when hdcp enable, the pins should work at ddc function */
+
+static void hdmi_enable_ddc_pin(void)
+{
+	if (cpu_is_mx6dl())
+		mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_hdmi_ddc_pads,
+			ARRAY_SIZE(mx6dl_hdmidongle_hdmi_ddc_pads));
+	else
+		mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_hdmi_ddc_pads,
+			ARRAY_SIZE(mx6q_hdmidongle_hdmi_ddc_pads));
+}
+
+static void hdmi_disable_ddc_pin(void)
+{
+	if (cpu_is_mx6dl())
+		mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_i2c2_pads,
+			ARRAY_SIZE(mx6dl_hdmidongle_i2c2_pads));
+	else
+		mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_i2c2_pads,
+			ARRAY_SIZE(mx6q_hdmidongle_i2c2_pads));
+}
+
+
+static struct fsl_mxc_hdmi_platform_data hdmi_data = {
+	.init = hdmi_init,
+	.enable_pins = hdmi_enable_ddc_pin,
+	.disable_pins = hdmi_disable_ddc_pin,
+	.phy_reg_vlev = 0x0294,
+	.phy_reg_cksymtx = 0x800d,
+};
+
+static struct fsl_mxc_hdmi_core_platform_data hdmi_core_data = {
+	.ipu_id = 0,
+	.disp_id = 0,
+};
+
+static struct imx_ipuv3_platform_data ipu_data[] = {
+	{
+	.rev = 4,
+	.csi_clk[0] = "clko_clk",
+	}, {
+	.rev = 4,
+	.csi_clk[0] = "clko_clk",
+	},
+};
+
+static void hdmidongle_suspend_enter(void)
+{
+	/* suspend preparation */
+}
+
+static void hdmidongle_suspend_exit(void)
+{
+	/* resume restore */
+}
+static const struct pm_platform_data mx6q_hdmidongle_pm_data __initconst = {
+	.name = "imx_pm",
+	.suspend_enter = hdmidongle_suspend_enter,
+	.suspend_exit = hdmidongle_suspend_exit,
+};
+
+static struct regulator_consumer_supply hdmidongle_vmmc_consumers[] = {
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.1"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.2"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.3"),
+};
+
+static struct regulator_init_data hdmidongle_vmmc_init = {
+	.num_consumer_supplies = ARRAY_SIZE(hdmidongle_vmmc_consumers),
+	.consumer_supplies = hdmidongle_vmmc_consumers,
+};
+
+static struct fixed_voltage_config hdmidongle_vmmc_reg_config = {
+	.supply_name		= "vmmc",
+	.microvolts		= 3300000,
+	.gpio			= -1,
+	.init_data		= &hdmidongle_vmmc_init,
+};
+
+static struct platform_device hdmidongle_vmmc_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id	= 3,
+	.dev	= {
+		.platform_data = &hdmidongle_vmmc_reg_config,
+	},
+};
+
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+#define GPIO_BUTTON(gpio_num, ev_code, act_low, descr, wake, debounce)	\
+{								\
+	.gpio		= gpio_num,				\
+	.type		= EV_KEY,				\
+	.code		= ev_code,				\
+	.active_low	= act_low,				\
+	.desc		= "btn " descr,				\
+	.wakeup		= wake,					\
+	.debounce_interval = debounce,				\
+}
+
+static struct gpio_keys_button hdmidongle_reva_buttons[] = {
+	GPIO_BUTTON(HDMIDONGLE_REVA_POWER_KEY, KEY_POWER, 1, "power", 1, 1),
+};
+
+static struct gpio_keys_platform_data hdmidongle_reva_button_data = {
+	.buttons	= hdmidongle_reva_buttons,
+	.nbuttons	= ARRAY_SIZE(hdmidongle_reva_buttons),
+};
+
+static struct platform_device hdmidongle_reva_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data = &hdmidongle_reva_button_data,
+	}
+};
+
+static struct gpio_keys_button hdmidongle_revb_buttons[] = {
+	GPIO_BUTTON(HDMIDONGLE_REVB_POWER_KEY, KEY_POWER, 1, "power", 1, 1),
+};
+
+static struct gpio_keys_platform_data hdmidongle_revb_button_data = {
+	.buttons	= hdmidongle_revb_buttons,
+	.nbuttons	= ARRAY_SIZE(hdmidongle_revb_buttons),
+};
+
+static struct platform_device hdmidongle_revb_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data = &hdmidongle_revb_button_data,
+	}
+};
+
+
+static void __init imx6q_add_device_buttons(void)
+{
+	if (board_is_mx6_reva())
+		platform_device_register(&hdmidongle_reva_button_device);
+	else
+		platform_device_register(&hdmidongle_revb_button_device);
+}
+#else
+static void __init imx6q_add_device_buttons(void) {}
+#endif
+
+static struct mxc_dvfs_platform_data hdmidongle_dvfscore_data = {
+	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	.reg_id = "VDDCORE",
+	#else
+	.reg_id = "cpu_vddgp",
+	.soc_id = "cpu_vddsoc",
+	.pu_id = "cpu_vddvpu",
+	#endif
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_offset = MXC_GPC_CNTR_OFFSET,
+	.ccm_cdcr_offset = MXC_CCM_CDCR_OFFSET,
+	.ccm_cacrr_offset = MXC_CCM_CACRR_OFFSET,
+	.ccm_cdhipr_offset = MXC_CCM_CDHIPR_OFFSET,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 80,
+};
+
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	char *str;
+	struct tag *t;
+	int i = 0;
+	struct ipuv3_fb_platform_data *pdata_fb = hdmidongle_fb_data;
+
+	for_each_tag(t, tags) {
+		if (t->hdr.tag == ATAG_CMDLINE) {
+			str = t->u.cmdline.cmdline;
+			str = strstr(str, "fbmem=");
+			if (str != NULL) {
+				str += 6;
+				pdata_fb[i++].res_size[0] = memparse(str, &str);
+				while (*str == ',' &&
+					i < ARRAY_SIZE(hdmidongle_fb_data)) {
+					str++;
+					pdata_fb[i++].res_size[0] = memparse(str, &str);
+				}
+			}
+			break;
+		}
+	}
+}
+
+#define SNVS_LPCR 0x38
+static void mx6_snvs_poweroff(void)
+{
+
+	void __iomem *mx6_snvs_base =  MX6_IO_ADDRESS(MX6Q_SNVS_BASE_ADDR);
+	u32 value;
+	value = readl(mx6_snvs_base + SNVS_LPCR);
+	/*set TOP and DP_EN bit*/
+	writel(value | 0x60, mx6_snvs_base + SNVS_LPCR);
+}
+
+#ifdef CONFIG_IMX_PCIE
+static const struct imx_pcie_platform_data mx6_hdmidongle_pcie_data __initconst = {
+	.pcie_pwr_en	= HDMIDONGLE_PCIE_PWR_EN,
+	.pcie_rst	= HDMIDONGLE_PCIE_RST,
+	.pcie_wake_up	= HDMIDONGLE_PCIE_WAKE,
+	.pcie_dis	= HDMIDONGLE_PCIE_DIS,
+};
+#endif
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mx6_hdmidongle_board_init(void)
+{
+	int i;
+
+	if (cpu_is_mx6q()) {
+		if (board_is_mx6_revb() || board_is_mx6_revc())
+			mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_rev_b_pads,
+				ARRAY_SIZE(mx6q_hdmidongle_rev_b_pads));
+		else
+			mxc_iomux_v3_setup_multiple_pads(mx6q_hdmidongle_rev_a_pads,
+				ARRAY_SIZE(mx6q_hdmidongle_rev_a_pads));
+	} else if (cpu_is_mx6dl()) {
+		if (board_is_mx6_revb() || board_is_mx6_revc())
+			mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_rev_b_pads,
+				ARRAY_SIZE(mx6dl_hdmidongle_rev_b_pads));
+		else
+			mxc_iomux_v3_setup_multiple_pads(mx6dl_hdmidongle_rev_a_pads,
+				ARRAY_SIZE(mx6dl_hdmidongle_rev_a_pads));
+	}
+
+	gp_reg_id = hdmidongle_dvfscore_data.reg_id;
+	soc_reg_id = hdmidongle_dvfscore_data.soc_id;
+	pu_reg_id = hdmidongle_dvfscore_data.pu_id;
+	mx6q_hdmidongle_init_uart();
+
+	/*
+	 * MX6DL/Solo only supports single IPU
+	 * The following codes are used to change ipu id
+	 * and display id information for MX6DL/Solo. Then
+	 * register 1 IPU device and up to 2 displays for
+	 * MX6DL/Solo
+	 */
+	if (cpu_is_mx6dl())
+		hdmi_core_data.disp_id = 0;
+
+	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
+
+	imx6q_add_ipuv3(0, &ipu_data[0]);
+	if (cpu_is_mx6q())
+		imx6q_add_ipuv3(1, &ipu_data[1]);
+	for (i = 0; i < ARRAY_SIZE(hdmidongle_fb_data); i++)
+		imx6q_add_ipuv3fb(i, &hdmidongle_fb_data[i]);
+
+	imx6q_add_vdoa();
+
+	imx6q_add_v4l2_output(0);
+
+	imx6q_add_imx_snvs_rtc();
+
+	imx6q_add_imx_i2c(1, &mx6q_hdmidongle_i2c_data);
+    imx6q_add_imx_i2c(2, &mx6q_hdmidongle_i2c_data);
+
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+			ARRAY_SIZE(mxc_i2c1_board_info));
+
+
+	i2c_register_board_info(2, mxc_i2c2_board_info,
+			ARRAY_SIZE(mxc_i2c2_board_info));
+
+
+	/* SPI */
+	imx6q_add_ecspi(1, &mx6q_hdmidongle_spi_data);
+	spi_device_init();
+
+	imx6q_add_mxc_hdmi(&hdmi_data);
+
+	imx6q_add_anatop_thermal_imx(1, &mx6q_hdmidongle_anatop_thermal_data);
+	imx6q_add_pm_imx(0, &mx6q_hdmidongle_pm_data);
+	/* Move sd3 to first because sd3 connect to emmc.
+	   Mfgtools want emmc is mmcblk0 and other sd card is mmcblk1.
+	*/
+	if (board_is_mx6_revc())
+		imx6q_add_sdhci_usdhc_imx(2, &mx6q_hdmidongle_revc_sd3_data);
+	else
+		imx6q_add_sdhci_usdhc_imx(2, &mx6q_hdmidongle_sd3_data);
+	imx6q_add_sdhci_usdhc_imx(1, &mx6q_hdmidongle_sd2_data);
+	if (board_is_mx6_reva())
+		imx6q_add_sdhci_usdhc_imx(0, &mx6q_hdmidongle_sd1_data);
+	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
+	imx6q_hdmidongle_init_usb();
+
+	imx6q_add_vpu();
+
+	platform_device_register(&hdmidongle_vmmc_reg_devices);
+
+	imx6q_add_otp();
+	imx6q_add_viim();
+	imx6q_add_imx2_wdt(0, NULL);
+	imx6q_add_dma();
+	if (board_is_mx6_revb() || board_is_mx6_revc())
+		imx6q_add_gpmi(&mx6_gpmi_nand_platform_data);
+
+	imx6q_add_dvfs_core(&hdmidongle_dvfscore_data);
+	#ifndef CONFIG_MX6_INTER_LDO_BYPASS
+	mx6_cpu_regulator_init();
+	#endif
+
+	imx6q_add_device_buttons();
+
+	imx6q_add_hdmi_soc();
+	imx6q_add_hdmi_soc_dai();
+
+	if (board_is_mx6_reva()) {
+		gpio_request(HDMIDONGLE_BT_RST, "bt_reset");
+		gpio_direction_output(HDMIDONGLE_BT_RST, 1);
+		gpio_set_value(HDMIDONGLE_BT_RST, 1);
+		msleep(1000);
+		gpio_request(HDMIDONGLE_BT_EN, "bt_en");
+		gpio_direction_output(HDMIDONGLE_BT_EN, 1);
+		gpio_set_value(HDMIDONGLE_BT_EN, 1);
+
+		msleep(1000);
+		gpio_request(HDMIDONGLE_WL_EN, "wl_en");
+		gpio_direction_output(HDMIDONGLE_WL_EN, 1);
+		gpio_set_value(HDMIDONGLE_WL_EN, 1);
+		msleep(1000);
+	} else if (board_is_mx6_revb() || board_is_mx6_revc()) {
+		/* Add PCIe RC interface support */
+#ifdef CONFIG_IMX_PCIE
+		imx6q_add_pcie(&mx6_hdmidongle_pcie_data);
+#endif
+	}
+	pm_power_off = mx6_snvs_poweroff;
+	imx6q_add_busfreq();
+}
+
+extern void __iomem *twd_base;
+static void __init mx6_hdmidongle_timer_init(void)
+{
+	struct clk *uart_clk;
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = ioremap(LOCAL_TWD_ADDR, SZ_256);
+	BUG_ON(!twd_base);
+#endif
+	mx6_clocks_init(32768, 24000000, 0, 0);
+
+	uart_clk = clk_get_sys("imx-uart.0", NULL);
+	early_console_setup(UART4_BASE_ADDR, uart_clk);
+}
+
+static struct sys_timer mx6_hdmidongle_timer = {
+	.init   = mx6_hdmidongle_timer_init,
+};
+
+static void __init mx6q_hdmidongle_reserve(void)
+{
+	phys_addr_t phys;
+	int i;
+
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
+	if (imx6q_gpu_pdata.reserved_mem_size) {
+		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
+					   SZ_4K, SZ_1G);
+		memblock_remove(phys, imx6q_gpu_pdata.reserved_mem_size);
+		imx6q_gpu_pdata.reserved_mem_base = phys;
+	}
+#endif
+#if defined(CONFIG_ION)
+	if (imx_ion_data.heaps[0].size) {
+		phys = memblock_alloc(imx_ion_data.heaps[0].size, SZ_4K);
+		memblock_remove(phys, imx_ion_data.heaps[0].size);
+		imx_ion_data.heaps[0].base = phys;
+	}
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(hdmidongle_fb_data); i++)
+		if (hdmidongle_fb_data[i].res_size[0]) {
+			/* reserve for background buffer */
+			phys = memblock_alloc(hdmidongle_fb_data[i].res_size[0],
+						SZ_4K);
+			memblock_remove(phys, hdmidongle_fb_data[i].res_size[0]);
+			hdmidongle_fb_data[i].res_base[0] = phys;
+		}
+}
+
+/*
+ * initialize __mach_desc_MX6Q_HDMIDONGLE data structure.
+ */
+MACHINE_START(MX6Q_HDMIDONGLE, "Freescale i.MX 6Quad/DualLite HDMI Dongle Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.boot_params = MX6_PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mx6_map_io,
+	.init_irq = mx6_init_irq,
+	.init_machine = mx6_hdmidongle_board_init,
+	.timer = &mx6_hdmidongle_timer,
+	.reserve = mx6q_hdmidongle_reserve,
+MACHINE_END
diff --git a/arch/arm/mach-mx6/board-mx6q_hdmidongle.h b/arch/arm/mach-mx6/board-mx6q_hdmidongle.h
new file mode 100644
index 0000000..9338c3e
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6q_hdmidongle.h
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _BOARD_MX6Q_HDMIDONGLE_H
+#define _BOARD_MX6Q_HDMIDONGLE_H
+#include <mach/iomux-mx6q.h>
+
+static iomux_v3_cfg_t mx6q_hdmidongle_rev_a_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6Q_PAD_EIM_OE__ECSPI2_MISO,
+	MX6Q_PAD_EIM_RW__ECSPI2_SS0,
+	MX6Q_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6Q_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6Q_PAD_EIM_A16__GPIO_2_22,
+	/*BT_WAKEUP_HOST(Combo module BT wake-up output) */
+	MX6Q_PAD_EIM_A25__GPIO_5_2,
+	/* HOST_WAKEUP_BT(CPU wakeup BT signal)*/
+	MX6Q_PAD_EIM_D16__GPIO_3_16,
+
+	/* I2C3  */
+	MX6Q_PAD_EIM_D17__I2C3_SCL,
+	MX6Q_PAD_EIM_D18__I2C3_SDA,
+
+	/* USB OC pin */
+	MX6Q_PAD_EIM_D21__USBOH3_USBOTG_OC,
+	/* WLAN_WAKEUP_HOST(Combo module WLAN host wake-up output) */
+	MX6Q_PAD_EIM_D22__GPIO_3_22,
+
+	/* BT_UART2  */
+	MX6Q_PAD_EIM_D26__UART2_TXD,
+	MX6Q_PAD_EIM_D27__UART2_RXD,
+	MX6Q_PAD_EIM_D28__UART2_CTS,
+	MX6Q_PAD_EIM_D29__UART2_RTS,
+
+	/*BT_nRST(Combo module BT reset signal)*/
+	MX6Q_PAD_EIM_DA7__GPIO_3_7,
+
+	/*BT_REG_ON(Combo module BT Internal regulators power enable/disable)*/
+	MX6Q_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WL_REG_ON(Combo module WLAN Internal regulators power enable/disable)*/
+	MX6Q_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6Q_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6Q_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6Q_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6Q_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A24__GPIO_5_4,	/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6Q_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+	/* I2C1  */
+	MX6Q_PAD_CSI0_DAT8__I2C1_SDA,
+	MX6Q_PAD_CSI0_DAT9__I2C1_SCL,
+
+	/* UART1 for debug */
+	MX6Q_PAD_CSI0_DAT10__UART1_TXD,
+	MX6Q_PAD_CSI0_DAT11__UART1_RXD,
+
+	/* SD1 (Combo module WLAN SDIO )*/
+	MX6Q_PAD_SD1_CLK__USDHC1_CLK,
+	MX6Q_PAD_SD1_CMD__USDHC1_CMD,
+	MX6Q_PAD_SD1_DAT0__USDHC1_DAT0,
+	MX6Q_PAD_SD1_DAT1__USDHC1_DAT1,
+	MX6Q_PAD_SD1_DAT2__USDHC1_DAT2,
+	MX6Q_PAD_SD1_DAT3__USDHC1_DAT3,
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6Q_PAD_SD2_CLK__USDHC2_CLK,
+	MX6Q_PAD_SD2_CMD__USDHC2_CMD,
+	MX6Q_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6Q_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6Q_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6Q_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6Q_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6Q_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6Q_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6Q_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6Q_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6Q_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6Q_PAD_KEY_COL0__UART4_TXD,
+	MX6Q_PAD_KEY_ROW0__UART4_RXD,
+
+	/*HDMI CEC communication PIN*/
+	MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/* I2C2 */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/*DCDC5V_PWREN(5V DCDC BOOST control signal)*/
+	MX6Q_PAD_KEY_COL4__GPIO_4_14,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6Q_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6Q_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C3 */
+	MX6Q_PAD_GPIO_5__I2C3_SCL,
+	MX6Q_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6Q_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6Q_PAD_NANDF_CS0__GPIO_6_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6Q_PAD_NANDF_CS1__GPIO_6_14,
+
+	/*PWRKEY_DET(Power key press detection)*/
+	MX6Q_PAD_NANDF_CS3__GPIO_6_16,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6Q_PAD_NANDF_D6__GPIO_2_6,
+
+	/*IR_RC*/
+	MX6Q_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6q_hdmidongle_rev_b_pads[] = {
+	/* SPI2 for PMIC communication port */
+	MX6Q_PAD_EIM_OE__ECSPI2_MISO,
+	MX6Q_PAD_EIM_RW__ECSPI2_SS0,
+	MX6Q_PAD_EIM_CS0__ECSPI2_SCLK,
+	MX6Q_PAD_EIM_CS1__ECSPI2_MOSI,
+
+	/*USB_OTG_DET(USB OTG cable plug detect) */
+	MX6Q_PAD_EIM_A16__GPIO_2_22,
+	/*WLAN_CLKREQn*/
+	MX6Q_PAD_EIM_A25__GPIO_5_2,
+
+	/* WLAN_ACT */
+	MX6Q_PAD_EIM_D17__GPIO_3_17,
+
+	/*BT_PERI*/
+	MX6Q_PAD_EIM_D18__GPIO_3_18,
+
+	/* USB OC pin */
+	MX6Q_PAD_EIM_D21__USBOH3_USBOTG_OC,
+
+	/* WLAN_WAKEn (PM event, OD, used to reactivate the PCIe main PWR and REF CLK) */
+	MX6Q_PAD_EIM_D22__GPIO_3_22,
+
+
+	/*WLAN_PERSTn (PCIe rst signal, avtive LOW)*/
+	MX6Q_PAD_EIM_DA9__GPIO_3_9,
+
+	/*WLAN_PDn (Externally shutdown RTL8192)*/
+	MX6Q_PAD_EIM_DA10__GPIO_3_10,
+
+	/* GPIO2 */
+	MX6Q_PAD_EIM_A22__GPIO_2_16,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A21__GPIO_2_17,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A20__GPIO_2_18,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A19__GPIO_2_19,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A18__GPIO_2_20,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A17__GPIO_2_21,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_RW__GPIO_2_26,		/* Boot Mode Select */
+	MX6Q_PAD_EIM_LBA__GPIO_2_27,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB0__GPIO_2_28,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB1__GPIO_2_29,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB2__GPIO_2_30,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_EB3__GPIO_2_31,	/* Boot Mode Select */
+
+	/* GPIO3 */
+	MX6Q_PAD_EIM_DA0__GPIO_3_0,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA1__GPIO_3_1,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA2__GPIO_3_2,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA3__GPIO_3_3,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA4__GPIO_3_4,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA5__GPIO_3_5,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA6__GPIO_3_6,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA8__GPIO_3_8,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA11__GPIO_3_11,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA12__GPIO_3_12,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA13__GPIO_3_13,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA14__GPIO_3_14,	/*  Boot Mode Select */
+	MX6Q_PAD_EIM_DA15__GPIO_3_15,	/*  Boot Mode Select */
+
+	/* GPIO5 */
+	MX6Q_PAD_EIM_WAIT__GPIO_5_0,	/* Boot Mode Select */
+	MX6Q_PAD_EIM_A24__GPIO_5_4,		/* Boot Mode Select */
+
+	/* GPIO6 */
+	MX6Q_PAD_EIM_A23__GPIO_6_6,	/* Boot Mode Select */
+
+
+	/* SD2 (MicroSD SDIO CMD)*/
+	MX6Q_PAD_SD2_CLK__USDHC2_CLK,
+	MX6Q_PAD_SD2_CMD__USDHC2_CMD,
+	MX6Q_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6Q_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6Q_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6Q_PAD_SD2_DAT3__USDHC2_DAT3,
+	/*SD_DET (SD plug-in detect interrupt)*/
+	MX6Q_PAD_GPIO_4__GPIO_1_4,
+
+	/* SD3 (eMMC SDIO)*/
+	MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6Q_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6Q_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6Q_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6Q_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6Q_PAD_SD3_RST__USDHC3_RST,
+
+	/* UART4 for debug */
+	MX6Q_PAD_KEY_COL0__UART4_TXD,
+	MX6Q_PAD_KEY_ROW0__UART4_RXD,
+
+	/*SD2_VSELECT (SD2 SDXC power exchange control signal)*/
+	MX6Q_PAD_KEY_ROW1__GPIO_4_9,
+
+	/*HDMI CEC communication PIN*/
+	MX6Q_PAD_KEY_ROW2__HDMI_TX_CEC_LINE,
+
+	/*PWRKEY_DET (Pwr button detection interrupt)*/
+	MX6Q_PAD_ENET_RXD0__GPIO_1_27,
+
+	/*USB_OTG_PWREN(USB OTG power change control signal)*/
+	MX6Q_PAD_KEY_ROW4__GPIO_4_15,
+
+	/* USBOTG ID pin */
+	MX6Q_PAD_GPIO_1__USBOTG_ID,
+
+	/* I2C2 */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+
+	/* I2C3 */
+	MX6Q_PAD_GPIO_5__I2C3_SCL,
+	MX6Q_PAD_GPIO_16__I2C3_SDA,
+
+	/*WDOG(Watch dog output)*/
+	MX6Q_PAD_GPIO_9__GPIO_1_9,
+
+	/*PMIC_nINT(PMIC interrupt signal)*/
+	MX6Q_PAD_SD4_DAT3__GPIO_2_11,
+
+	/*GPIO_nRST(GPIO shutdown control)*/
+	MX6Q_PAD_SD4_DAT1__GPIO_2_9,
+
+	/*CHG_SYS_ON(Charger auto power on control signal)*/
+	MX6Q_PAD_SD4_DAT6__GPIO_2_14,
+};
+
+/* The GPMI is conflicted with SD3, so init this in the driver. */
+static iomux_v3_cfg_t mx6q_gpmi_nand[] __initdata = {
+	MX6Q_PAD_NANDF_CLE__RAWNAND_CLE,
+	MX6Q_PAD_NANDF_ALE__RAWNAND_ALE,
+	MX6Q_PAD_NANDF_CS0__RAWNAND_CE0N,
+	MX6Q_PAD_NANDF_CS1__RAWNAND_CE1N,
+	MX6Q_PAD_NANDF_CS2__RAWNAND_CE2N,
+	MX6Q_PAD_NANDF_CS3__RAWNAND_CE3N,
+	MX6Q_PAD_NANDF_RB0__RAWNAND_READY0,
+	MX6Q_PAD_SD4_DAT0__RAWNAND_DQS,
+	MX6Q_PAD_NANDF_D0__RAWNAND_D0,
+	MX6Q_PAD_NANDF_D1__RAWNAND_D1,
+	MX6Q_PAD_NANDF_D2__RAWNAND_D2,
+	MX6Q_PAD_NANDF_D3__RAWNAND_D3,
+	MX6Q_PAD_NANDF_D4__RAWNAND_D4,
+	MX6Q_PAD_NANDF_D5__RAWNAND_D5,
+	MX6Q_PAD_NANDF_D6__RAWNAND_D6,
+	MX6Q_PAD_NANDF_D7__RAWNAND_D7,
+	MX6Q_PAD_SD4_CMD__RAWNAND_RDN,
+	MX6Q_PAD_SD4_CLK__RAWNAND_WRN,
+	MX6Q_PAD_NANDF_WP_B__RAWNAND_RESETN,
+};
+
+static iomux_v3_cfg_t mx6q_hdmidongle_hdmi_ddc_pads[] = {
+	MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL, /* HDMI DDC SCL */
+	MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA, /* HDMI DDC SDA */
+};
+
+static iomux_v3_cfg_t mx6q_hdmidongle_i2c2_pads[] = {
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* I2C2 SCL */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* I2C2 SDA */
+};
+
+#endif
diff --git a/arch/arm/mach-mx6/board-mx6q_sabreauto.c b/arch/arm/mach-mx6/board-mx6q_sabreauto.c
index bd51ddd..7c1fada 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabreauto.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabreauto.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -114,6 +114,11 @@
 #define SABREAUTO_MAX7310_2_BASE_ADDR	IMX_GPIO_NR(8, 8)
 #define SABREAUTO_MAX7310_3_BASE_ADDR	IMX_GPIO_NR(8, 16)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
+
 #define SABREAUTO_IO_EXP_GPIO1(x)	(SABREAUTO_MAX7310_1_BASE_ADDR + (x))
 #define SABREAUTO_IO_EXP_GPIO2(x)	(SABREAUTO_MAX7310_2_BASE_ADDR + (x))
 #define SABREAUTO_IO_EXP_GPIO3(x)	(SABREAUTO_MAX7310_3_BASE_ADDR + (x))
@@ -135,6 +140,7 @@
 extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
+extern bool enet_to_gpio_6;
 
 static int mma8451_position = 3;
 static int mag3110_position = 2;
@@ -346,6 +352,17 @@ static int mx6q_sabreauto_fec_phy_init(struct phy_device *phydev)
 	unsigned short val;
 
 	if (!board_is_mx6_reva()) {
+		/* Ar8031 phy SmartEEE feature cause link status generates
+		 * glitch, which cause ethernet link down/up issue, so
+		 * disable SmartEEE
+		 */
+		phy_write(phydev, 0xd, 0x3);
+		phy_write(phydev, 0xe, 0x805d);
+		phy_write(phydev, 0xd, 0x4003);
+		val = phy_read(phydev, 0xe);
+		val &= ~(0x1 << 8);
+		phy_write(phydev, 0xe, val);
+
 		/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
 		phy_write(phydev, 0xd, 0x7);
 		phy_write(phydev, 0xe, 0x8016);
@@ -393,6 +410,7 @@ static struct fec_platform_data fec_data __initdata = {
 	.init			= mx6q_sabreauto_fec_phy_init,
 	.power_hibernate	= mx6q_sabreauto_fec_power_hibernate,
 	.phy			= PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq		= MX6_ENET_IRQ,
 };
 
 static int mx6q_sabreauto_spi_cs[] = {
@@ -488,20 +506,78 @@ static struct platform_device physmap_flash_device = {
 	.num_resources	= 1,
 };
 
+/* These registers settings are just valid for Numonyx M29W256GL7AN6E. */
 static void mx6q_setup_weimcs(void)
 {
-	unsigned int reg;
 	void __iomem *nor_reg = MX6_IO_ADDRESS(WEIM_BASE_ADDR);
 	void __iomem *ccm_reg = MX6_IO_ADDRESS(CCM_BASE_ADDR);
+	unsigned int reg;
+	struct clk *clk;
+	u32 rate;
 
-	/*CCM_BASE_ADDR + CLKCTL_CCGR6*/
+	/* CLKCTL_CCGR6: Set emi_slow_clock to be on in all modes */
 	reg = readl(ccm_reg + 0x80);
 	reg |= 0x00000C00;
 	writel(reg, ccm_reg + 0x80);
 
-	__raw_writel(0x00620081, nor_reg);
-	__raw_writel(0x1C022000, nor_reg + 0x00000008);
-	__raw_writel(0x0804a240, nor_reg + 0x00000010);
+	/* Timing settings below based upon datasheet for M29W256GL7AN6E
+	   These setting assume that the EIM_SLOW_CLOCK is set to 132 MHz */
+	clk = clk_get(NULL, "emi_slow_clk");
+	if (IS_ERR(clk))
+		printk(KERN_ERR "emi_slow_clk not found\n");
+
+	rate = clk_get_rate(clk);
+	if (rate != 132000000)
+		printk(KERN_ERR "Warning: emi_slow_clk not set to 132 MHz!"
+		       " WEIM NOR timing may be incorrect!\n");
+
+	/*
+	 * For EIM General Configuration registers.
+	 *
+	 * CS0GCR1:
+	 *	GBC = 0; CSREC = 6; DSZ = 2; BL = 0;
+	 *	CREP = 1; CSEN = 1;
+	 *
+	 *	EIM Operation Mode: MUM = SRD = SWR = 0.
+	 *		(Async write/Async page read, none multiplexed)
+	 *
+	 * CS0GCR2:
+	 *	ADH = 1
+	 */
+	writel(0x00620081, nor_reg);
+	writel(0x00000001, nor_reg + 0x00000004);
+
+	/*
+	 * For EIM Read Configuration registers.
+	 *
+	 * CS0RCR1:
+	 *	RWSC = 1C;
+	 *	RADVA = 0; RADVN = 2;
+	 *	OEA = 2; OEN = 0;
+	 *	RCSA = 0; RCSN = 0
+	 *
+	 * CS0RCR2:
+	 *	APR = 1 (Async Page Read);
+	 *	PAT = 4 (6 EIM clock sycles)
+	 */
+	writel(0x1C022000, nor_reg + 0x00000008);
+	writel(0x0000C000, nor_reg + 0x0000000C);
+
+	/*
+	 * For EIM Write Configuration registers.
+	 *
+	 * CS0WCR1:
+	 *	WWSC = 20;
+	 *	WADVA = 0; WADVN = 1;
+	 *	WBEA = 1; WBEN = 2;
+	 *	WEA = 1; WEN = 6;
+	 *	WCSA = 1; WCSN = 2;
+	 *
+	 * CS0WCR2:
+	 *	WBCDD = 0
+	 */
+	writel(0x1404a38e, nor_reg + 0x00000010);
+	writel(0x00000000, nor_reg + 0x00000014);
 }
 
 static int max7310_1_setup(struct i2c_client *client,
@@ -621,16 +697,10 @@ static struct pca953x_platform_data max7310_u43_platdata = {
 
 static void adv7180_pwdn(int pwdn)
 {
-	int status = -1;
-
-	status = gpio_request(SABREAUTO_VIDEOIN_PWR, "tvin-pwr");
-
 	if (pwdn)
-		gpio_direction_output(SABREAUTO_VIDEOIN_PWR, 0);
+		gpio_set_value_cansleep(SABREAUTO_VIDEOIN_PWR, 0);
 	else
-		gpio_direction_output(SABREAUTO_VIDEOIN_PWR, 1);
-
-	gpio_free(SABREAUTO_VIDEOIN_PWR);
+		gpio_set_value_cansleep(SABREAUTO_VIDEOIN_PWR, 1);
 }
 
 static void mx6q_csi0_io_init(void)
@@ -652,6 +722,12 @@ static struct fsl_mxc_tvin_platform_data adv7180_data = {
 	.io_init	= mx6q_csi0_io_init,
 };
 
+static void mx6q_mipi_csi1_io_init(void)
+{
+	if (cpu_is_mx6dl())
+		mxc_iomux_set_gpr_register(13, 3, 3, 1);
+}
+
 static struct fsl_mxc_tvin_platform_data adv7280_data = {
 	.dvddio_reg	= NULL,
 	.dvdd_reg	= NULL,
@@ -659,15 +735,16 @@ static struct fsl_mxc_tvin_platform_data adv7280_data = {
 	.pvdd_reg	= NULL,
 	.pwdn		= NULL,
 	.cvbs		= true,
+	.io_init    = mx6q_mipi_csi1_io_init,
 	/* csi slave reg address */
-	.csi_tx_addr = 0x51,
+	.csi_tx_addr = 0x52,
 };
 
 static struct imxi2c_platform_data mx6q_sabreauto_i2c2_data = {
 	.bitrate	= 400000,
 };
 
-static struct imxi2c_platform_data mx6q_sabreauto_i2c1_data = {
+static struct imxi2c_platform_data mx6q_sabreauto_i2c_data = {
 	.bitrate	= 100000,
 };
 
@@ -845,11 +922,22 @@ static int mx6q_sabreauto_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -857,6 +945,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6q_sabreauto_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -868,6 +957,7 @@ static struct ahci_platform_data mx6q_sabreauto_sata_data = {
 	.init = mx6q_sabreauto_sata_init,
 	.exit = mx6q_sabreauto_sata_exit,
 };
+#endif
 
 static struct imx_asrc_platform_data imx_asrc_data = {
 	.channel_bits	= 4,
@@ -998,10 +1088,10 @@ static struct fsl_mxc_ldb_platform_data ldb_data = {
 static struct imx_ipuv3_platform_data ipu_data[] = {
 	{
 		.rev		= 4,
-		.csi_clk[0]	= "ccm_clk0",
+		.csi_clk[0]	= "clko_clk",
 	}, {
 		.rev		= 4,
-		.csi_clk[0]	= "ccm_clk0",
+		.csi_clk[0]	= "clko_clk",
 	},
 };
 
@@ -1026,6 +1116,15 @@ static int flexcan1_en;
 static void mx6q_flexcan_switch(void)
 {
   if (flexcan0_en || flexcan1_en) {
+	/*
+	 * The transceiver TJA1041A on sabreauto RevE baseboard will
+	 * fail to transit to Normal state if EN/STBY is high by default
+	 * after board power up. So we set the EN/STBY initial state to low
+	 * first then to high to guarantee the state transition successfully.
+	 */
+	gpio_set_value_cansleep(SABREAUTO_CAN_EN, 0);
+	gpio_set_value_cansleep(SABREAUTO_CAN_STBY, 0);
+
 	gpio_set_value_cansleep(SABREAUTO_CAN_EN, 1);
 	gpio_set_value_cansleep(SABREAUTO_CAN_STBY, 1);
 	/* Enable STEER pin if CAN1 interface is required.
@@ -1074,9 +1173,9 @@ static const struct flexcan_platform_data
 
 static struct mipi_csi2_platform_data mipi_csi2_pdata = {
 	.ipu_id		= 0,
-	.csi_id		= 0,
-	.v_channel	= 0,
-	.lanes		= 2,
+	.csi_id		= 1,
+	.v_channel	= 1,
+	.lanes		= 1,
 	.dphy_clk	= "mipi_pllref_clk",
 	.pixel_clk	= "emi_clk",
 };
@@ -1413,6 +1512,18 @@ static void __init mx6_board_init(void)
 			mxc_iomux_v3_setup_multiple_pads(extra_pads,
 					extra_pads_cnt);
 		}
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6Q_PAD_ENET_TXD1__MLB_MLBCLK,
+				MX6Q_PAD_GPIO_6__MLB_MLBSIG,
+				MX6Q_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	} else if (cpu_is_mx6dl()) {
 		common_pads = mx6dl_sabreauto_pads;
 		can0_pads = mx6dl_sabreauto_can0_pads;
@@ -1445,6 +1556,18 @@ static void __init mx6_board_init(void)
 			mxc_iomux_v3_setup_multiple_pads(extra_pads,
 					extra_pads_cnt);
 		}
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t mlb_pads[] = {
+				MX6DL_PAD_ENET_TXD1__MLB_MLBCLK,
+				MX6DL_PAD_GPIO_6__MLB_MLBSIG,
+				MX6DL_PAD_GPIO_2__MLB_MLBDAT};
+			mxc_iomux_v3_setup_multiple_pads(mlb_pads,
+				ARRAY_SIZE(mlb_pads));
+		}
 	}
 
 	BUG_ON(!common_pads);
@@ -1557,12 +1680,15 @@ static void __init mx6_board_init(void)
 
 	imx6q_add_imx_caam();
 
-	imx6q_add_imx_i2c(1, &mx6q_sabreauto_i2c1_data);
+	imx6q_add_imx_i2c(1, &mx6q_sabreauto_i2c_data);
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 			ARRAY_SIZE(mxc_i2c1_board_info));
 	imx6q_add_imx_i2c(2, &mx6q_sabreauto_i2c2_data);
 	i2c_register_board_info(2, mxc_i2c2_board_info,
 			ARRAY_SIZE(mxc_i2c2_board_info));
+	if (cpu_is_mx6dl())
+		imx6q_add_imx_i2c(3, &mx6q_sabreauto_i2c_data);
+
 
 	ret = gpio_request(SABREAUTO_PMIC_INT, "pFUZE-int");
 	if (ret) {
@@ -1584,9 +1710,17 @@ static void __init mx6_board_init(void)
 
 	imx6q_add_anatop_thermal_imx(1, &mx6q_sabreauto_anatop_thermal_data);
 
-	if (!can0_enable)
+	if (!can0_enable) {
+		if (enet_to_gpio_6)
+			/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+			mxc_iomux_set_specialbits_register(
+				IOMUX_OBSRV_MUX1_OFFSET,
+				OBSRV_MUX1_ENET_IRQ,
+				OBSRV_MUX1_MASK);
+		else
+			fec_data.gpio_irq = -1;
 		imx6_init_fec(fec_data);
-
+	}
 	imx6q_add_pm_imx(0, &mx6q_sabreauto_pm_data);
 
 	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabreauto_sd3_data);
@@ -1594,8 +1728,14 @@ static void __init mx6_board_init(void)
 
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
 	imx6q_sabreauto_init_usb();
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 		imx6q_add_ahci(0, &mx6q_sabreauto_sata_data);
+#else
+		mx6q_sabreauto_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	imx6q_init_audio();
 	platform_device_register(&sabreauto_vmmc_reg_devices);
diff --git a/arch/arm/mach-mx6/board-mx6q_sabreauto.h b/arch/arm/mach-mx6/board-mx6q_sabreauto.h
index b1e2b9e..436a11d 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabreauto.h
+++ b/arch/arm/mach-mx6/board-mx6q_sabreauto.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -207,12 +207,7 @@ static iomux_v3_cfg_t mx6q_sabreauto_pads[] = {
 
 	/* HDMI */
 	MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE,
-
-	/* MLB150 */
-	MX6Q_PAD_ENET_TXD1__MLB_MLBCLK,
-	MX6Q_PAD_GPIO_6__MLB_MLBSIG,
-	MX6Q_PAD_GPIO_2__MLB_MLBDAT,
-};
+ };
 
 static iomux_v3_cfg_t mx6q_sabreauto_can0_pads[] = {
 	/* CAN1 */
diff --git a/arch/arm/mach-mx6/board-mx6q_sabrelite.c b/arch/arm/mach-mx6/board-mx6q_sabrelite.c
index 736b423..1fe0f7b 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabrelite.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -93,6 +93,11 @@
 #define MX6Q_SABRELITE_CSI0_RST		IMX_GPIO_NR(1, 8)
 #define MX6Q_SABRELITE_CSI0_PWN		IMX_GPIO_NR(1, 6)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
+
 #define MX6Q_SABRELITE_SD3_WP_PADCFG	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
@@ -103,6 +108,7 @@ static struct clk *sata_clk;
 extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
+extern bool enet_to_gpio_6;
 static int caam_enabled;
 
 extern struct regulator *(*get_cpu_regulator)(void);
@@ -209,8 +215,8 @@ static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	MX6Q_PAD_EIM_D28__I2C1_SDA,	/* GPIO3[28] */
 
 	/* I2C2 Camera, MIPI */
-	MX6Q_PAD_KEY_COL3__I2C2_SCL,	/* GPIO4[12] */
-	MX6Q_PAD_KEY_ROW3__I2C2_SDA,	/* GPIO4[13] */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,    /* GPIO4[12] */
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,    /* GPIO4[13] */
 
 	/* I2C3 */
 	MX6Q_PAD_GPIO_5__I2C3_SCL,	/* GPIO1[5] - J7 - Display card */
@@ -321,7 +327,6 @@ static iomux_v3_cfg_t mx6q_sabrelite_csi0_sensor_pads[] = {
 	MX6Q_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
 	MX6Q_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
 	MX6Q_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
-	MX6Q_PAD_GPIO_6__GPIO_1_6,		/* J5 - Camera GP */
 	MX6Q_PAD_GPIO_8__GPIO_1_8,		/* J5 - Camera Reset */
 	MX6Q_PAD_SD1_DAT0__GPIO_1_16,		/* J5 - Camera GP */
 	MX6Q_PAD_NANDF_D5__GPIO_2_5,		/* J16 - MIPI GP */
@@ -467,6 +472,7 @@ static int mx6q_sabrelite_fec_phy_init(struct phy_device *phydev)
 static struct fec_platform_data fec_data __initdata = {
 	.init = mx6q_sabrelite_fec_phy_init,
 	.phy = PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq = MX6_ENET_IRQ,
 };
 
 static int mx6q_sabrelite_spi_cs[] = {
@@ -632,7 +638,7 @@ static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 		I2C_BOARD_INFO("mxc_hdmi_i2c", 0x50),
 	},
 	{
-		I2C_BOARD_INFO("ov5642", 0x3c),
+		I2C_BOARD_INFO("ov564x", 0x3c),
 		.platform_data = (void *)&camera_data,
 	},
 };
@@ -721,11 +727,22 @@ static int mx6q_sabrelite_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -733,6 +750,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6q_sabrelite_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -743,6 +761,7 @@ static struct ahci_platform_data mx6q_sabrelite_sata_data = {
 	.init = mx6q_sabrelite_sata_init,
 	.exit = mx6q_sabrelite_sata_exit,
 };
+#endif
 
 static struct gpio mx6q_sabrelite_flexcan_gpios[] = {
 	{ MX6Q_SABRELITE_CAN1_EN, GPIOF_OUT_INIT_LOW, "flexcan1-en" },
@@ -894,6 +913,16 @@ static struct fsl_mxc_capture_platform_data capture_data[] = {
 };
 
 
+struct imx_vout_mem {
+	resource_size_t res_mbase;
+	resource_size_t res_msize;
+};
+
+static struct imx_vout_mem vout_mem __initdata = {
+	.res_msize = SZ_128M,
+};
+
+
 static void sabrelite_suspend_enter(void)
 {
 	/* suspend preparation */
@@ -1131,10 +1160,22 @@ static void __init mx6_sabrelite_board_init(void)
 	struct clk *clko2;
 	struct clk *new_parent;
 	int rate;
+	struct platform_device *voutdev;
 
 	mxc_iomux_v3_setup_multiple_pads(mx6q_sabrelite_pads,
 					ARRAY_SIZE(mx6q_sabrelite_pads));
 
+	if (enet_to_gpio_6) {
+		iomux_v3_cfg_t enet_gpio_pad =
+			MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+		mxc_iomux_v3_setup_pad(enet_gpio_pad);
+	} else {
+		/* J5 - Camera GP */
+		iomux_v3_cfg_t camera_gpio_pad =
+			MX6Q_PAD_GPIO_6__GPIO_1_6;
+		mxc_iomux_v3_setup_pad(camera_gpio_pad);
+	}
+
 #ifdef CONFIG_FEC_1588
 	/* Set GPIO_16 input for IEEE-1588 ts_clk and RMII reference clock
 	 * For MX6 GPR1 bit21 meaning:
@@ -1159,7 +1200,17 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_vdoa();
 	imx6q_add_lcdif(&lcdif_data);
 	imx6q_add_ldb(&ldb_data);
-	imx6q_add_v4l2_output(0);
+	voutdev = imx6q_add_v4l2_output(0);
+	if (vout_mem.res_msize && voutdev) {
+		dma_declare_coherent_memory(&voutdev->dev,
+					    vout_mem.res_mbase,
+					    vout_mem.res_mbase,
+					    vout_mem.res_msize,
+					    (DMA_MEMORY_MAP |
+					     DMA_MEMORY_EXCLUSIVE));
+	}
+
+
 	imx6q_add_v4l2_capture(0, &capture_data[0]);
 	imx6q_add_v4l2_capture(1, &capture_data[1]);
 	imx6q_add_mipi_csi2(&mipi_csi2_pdata);
@@ -1185,13 +1236,30 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_mxc_hdmi(&hdmi_data);
 
 	imx6q_add_anatop_thermal_imx(1, &mx6q_sabrelite_anatop_thermal_data);
+	if (enet_to_gpio_6)
+		/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+		mxc_iomux_set_specialbits_register(
+			IOMUX_OBSRV_MUX1_OFFSET,
+			OBSRV_MUX1_ENET_IRQ,
+			OBSRV_MUX1_MASK);
+	else
+		fec_data.gpio_irq = -1;
+
 	imx6_init_fec(fec_data);
 	imx6q_add_pm_imx(0, &mx6q_sabrelite_pm_data);
 	imx6q_add_sdhci_usdhc_imx(3, &mx6q_sabrelite_sd4_data);
 	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabrelite_sd3_data);
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
 	imx6q_sabrelite_init_usb();
-	imx6q_add_ahci(0, &mx6q_sabrelite_sata_data);
+
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
+		imx6q_add_ahci(0, &mx6q_sabrelite_sata_data);
+#else
+		mx6q_sabrelite_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	imx6q_init_audio();
 	platform_device_register(&sabrelite_vmmc_reg_devices);
@@ -1266,8 +1334,8 @@ static struct sys_timer mx6_sabrelite_timer = {
 
 static void __init mx6q_sabrelite_reserve(void)
 {
-#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 	phys_addr_t phys;
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 
 	if (imx6q_gpu_pdata.reserved_mem_size) {
 		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
@@ -1276,6 +1344,13 @@ static void __init mx6q_sabrelite_reserve(void)
 		imx6q_gpu_pdata.reserved_mem_base = phys;
 	}
 #endif
+	if (vout_mem.res_msize) {
+		phys = memblock_alloc_base(vout_mem.res_msize,
+					   SZ_4K, SZ_1G);
+		memblock_remove(phys, vout_mem.res_msize);
+		vout_mem.res_mbase = phys;
+	}
+
 }
 
 /*
diff --git a/arch/arm/mach-mx6/board-mx6q_sabresd.c b/arch/arm/mach-mx6/board-mx6q_sabresd.c
index 69afc35..3f9a845 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabresd.c
+++ b/arch/arm/mach-mx6/board-mx6q_sabresd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -198,18 +198,23 @@
 #define SABRESD_ELAN_RST	IMX_GPIO_NR(3, 8)
 #define SABRESD_ELAN_INT	IMX_GPIO_NR(3, 28)
 
+#define MX6_ENET_IRQ		IMX_GPIO_NR(1, 6)
+#define IOMUX_OBSRV_MUX1_OFFSET	0x3c
+#define OBSRV_MUX1_MASK			0x3f
+#define OBSRV_MUX1_ENET_IRQ		0x9
+
 static struct clk *sata_clk;
 static struct clk *clko;
 static int mma8451_position = 1;
 static int mag3110_position = 2;
 static int max11801_mode = 1;
-static int enable_lcd_ldb;
 static int caam_enabled;
 
 extern char *gp_reg_id;
 extern char *soc_reg_id;
 extern char *pu_reg_id;
 extern int epdc_enabled;
+extern bool enet_to_gpio_6;
 
 static int max17135_regulator_init(struct max17135 *max17135);
 
@@ -254,6 +259,16 @@ static int mx6q_sabresd_fec_phy_init(struct phy_device *phydev)
 {
 	unsigned short val;
 
+	/* Ar8031 phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, 0xd, 0x3);
+	phy_write(phydev, 0xe, 0x805d);
+	phy_write(phydev, 0xd, 0x4003);
+	val = phy_read(phydev, 0xe);
+	val &= ~(0x1 << 8);
+	phy_write(phydev, 0xe, val);
+
 	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
 	phy_write(phydev, 0xd, 0x7);
 	phy_write(phydev, 0xe, 0x8016);
@@ -282,6 +297,7 @@ static int mx6q_sabresd_fec_phy_init(struct phy_device *phydev)
 static struct fec_platform_data fec_data __initdata = {
 	.init = mx6q_sabresd_fec_phy_init,
 	.phy = PHY_INTERFACE_MODE_RGMII,
+	.gpio_irq = MX6_ENET_IRQ,
 };
 
 static int mx6q_sabresd_spi_cs[] = {
@@ -782,7 +798,7 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 		I2C_BOARD_INFO("wm89**", 0x1a),
 	},
 	{
-		I2C_BOARD_INFO("ov5642", 0x3c),
+		I2C_BOARD_INFO("ov564x", 0x3c),
 		.platform_data = (void *)&camera_data,
 	},
 	{
@@ -1084,6 +1100,14 @@ static void imx6q_sabresd_usbotg_vbus(bool on)
 		gpio_set_value(SABRESD_USB_OTG_PWR, 0);
 }
 
+static void imx6q_sabresd_host1_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(SABRESD_USB_H1_PWR, 1);
+	else
+		gpio_set_value(SABRESD_USB_H1_PWR, 0);
+}
+
 static void __init imx6q_sabresd_init_usb(void)
 {
 	int ret = 0;
@@ -1106,13 +1130,14 @@ static void __init imx6q_sabresd_init_usb(void)
 			ret);
 		return;
 	}
-	gpio_direction_output(SABRESD_USB_H1_PWR, 1);
+	gpio_direction_output(SABRESD_USB_H1_PWR, 0);
 	if (board_is_mx6_reva())
 		mxc_iomux_set_gpr_register(1, 13, 1, 1);
 	else
 		mxc_iomux_set_gpr_register(1, 13, 1, 0);
 
 	mx6_set_otghost_vbus_func(imx6q_sabresd_usbotg_vbus);
+	mx6_set_host1_vbus_func(imx6q_sabresd_host1_vbus);
 
 }
 
@@ -1165,11 +1190,22 @@ static int mx6q_sabresd_sata_init(struct device *dev, void __iomem *addr)
 	tmpdata = clk_get_rate(clk) / 1000;
 	clk_put(clk);
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 	ret = sata_init(addr, tmpdata);
 	if (ret == 0)
 		return ret;
+#else
+	usleep_range(1000, 2000);
+	/* AHCI PHY enter into PDDQ mode if the AHCI module is not enabled */
+	tmpdata = readl(addr + PORT_PHY_CTL);
+	writel(tmpdata | PORT_PHY_CTL_PDDQ_LOC, addr + PORT_PHY_CTL);
+	pr_info("No AHCI save PWR: PDDQ %s\n", ((readl(addr + PORT_PHY_CTL)
+					>> 20) & 1) ? "enabled" : "disabled");
+#endif
 
 release_sata_clk:
+	/* disable SATA_PHY PLL */
+	writel((readl(IOMUXC_GPR13) & ~0x2), IOMUXC_GPR13);
 	clk_disable(sata_clk);
 put_sata_clk:
 	clk_put(sata_clk);
@@ -1177,6 +1213,7 @@ put_sata_clk:
 	return ret;
 }
 
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 static void mx6q_sabresd_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
@@ -1187,6 +1224,7 @@ static struct ahci_platform_data mx6q_sabresd_sata_data = {
 	.init = mx6q_sabresd_sata_init,
 	.exit = mx6q_sabresd_sata_exit,
 };
+#endif
 
 static void mx6q_sabresd_flexcan0_switch(int enable)
 {
@@ -1317,6 +1355,8 @@ static struct fsl_mxc_hdmi_platform_data hdmi_data = {
 	.init = hdmi_init,
 	.enable_pins = hdmi_enable_ddc_pin,
 	.disable_pins = hdmi_disable_ddc_pin,
+	.phy_reg_vlev = 0x0294,
+	.phy_reg_cksymtx = 0x800d,
 };
 
 static struct fsl_mxc_hdmi_core_platform_data hdmi_core_data = {
@@ -1332,11 +1372,11 @@ static struct fsl_mxc_lcd_platform_data lcdif_data = {
 
 static struct fsl_mxc_ldb_platform_data ldb_data = {
 	.ipu_id = 1,
-	.disp_id = 0,
+	.disp_id = 1,
 	.ext_ref = 1,
-	.mode = LDB_SEP0,
+	.mode = LDB_SEP1,
 	.sec_ipu_id = 1,
-	.sec_disp_id = 1,
+	.sec_disp_id = 0,
 };
 
 static struct max8903_pdata charger1_data = {
@@ -1384,6 +1424,15 @@ static struct fsl_mxc_capture_platform_data capture_data[] = {
 };
 
 
+struct imx_vout_mem {
+	resource_size_t res_mbase;
+	resource_size_t res_msize;
+};
+
+static struct imx_vout_mem vout_mem __initdata = {
+	.res_msize = SZ_128M,
+};
+
 static void sabresd_suspend_enter(void)
 {
 	/* suspend preparation */
@@ -1646,15 +1695,13 @@ static const struct imx_pcie_platform_data mx6_sabresd_pcie_data __initconst = {
 	.pcie_rst	= SABRESD_PCIE_RST_B_REVB,
 	.pcie_wake_up	= SABRESD_PCIE_WAKE_B,
 	.pcie_dis	= SABRESD_PCIE_DIS_B,
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+	.type_ep	= 1,
+#else
+	.type_ep	= 0,
+#endif
 };
 
-static int __init early_enable_lcd_ldb(char *p)
-{
-	enable_lcd_ldb = 1;
-	return 0;
-}
-early_param("enable_lcd_ldb", early_enable_lcd_ldb);
-
 /*!
  * Board specific initialization.
  */
@@ -1665,15 +1712,36 @@ static void __init mx6_sabresd_board_init(void)
 	struct clk *clko, *clko2;
 	struct clk *new_parent;
 	int rate;
+	struct platform_device *voutdev;
 
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
 		mxc_iomux_v3_setup_multiple_pads(mx6q_sabresd_pads,
 			ARRAY_SIZE(mx6q_sabresd_pads));
-	else if (cpu_is_mx6dl()) {
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t i2c3_pad =
+				MX6Q_PAD_GPIO_6__I2C3_SDA;
+			mxc_iomux_v3_setup_pad(i2c3_pad);
+		}
+	} else if (cpu_is_mx6dl()) {
 		mxc_iomux_v3_setup_multiple_pads(mx6dl_sabresd_pads,
 			ARRAY_SIZE(mx6dl_sabresd_pads));
+
+		if (enet_to_gpio_6) {
+			iomux_v3_cfg_t enet_gpio_pad =
+				MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6;
+			mxc_iomux_v3_setup_pad(enet_gpio_pad);
+		} else {
+			iomux_v3_cfg_t i2c3_pad =
+				MX6DL_PAD_GPIO_6__I2C3_SDA;
+			mxc_iomux_v3_setup_pad(i2c3_pad);
+		}
 	}
 
+
 #ifdef CONFIG_FEC_1588
 	/* Set GPIO_16 input for IEEE-1588 ts_clk and RMII reference clock
 	 * For MX6 GPR1 bit21 meaning:
@@ -1696,16 +1764,7 @@ static void __init mx6_sabresd_board_init(void)
 	 */
 	if (cpu_is_mx6dl()) {
 		ldb_data.ipu_id = 0;
-		ldb_data.disp_id = 0;
 		ldb_data.sec_ipu_id = 0;
-		ldb_data.sec_disp_id = 1;
-		hdmi_core_data.disp_id = 1;
-		mipi_dsi_pdata.ipu_id = 0;
-		mipi_dsi_pdata.disp_id = 1;
-		if (enable_lcd_ldb) {
-			ldb_data.disp_id = 1;
-			ldb_data.mode = LDB_SIN1;
-		}
 	}
 	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
 
@@ -1722,7 +1781,16 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_mipi_dsi(&mipi_dsi_pdata);
 	imx6q_add_lcdif(&lcdif_data);
 	imx6q_add_ldb(&ldb_data);
-	imx6q_add_v4l2_output(0);
+	voutdev = imx6q_add_v4l2_output(0);
+	if (vout_mem.res_msize && voutdev) {
+		dma_declare_coherent_memory(&voutdev->dev,
+					    vout_mem.res_mbase,
+					    vout_mem.res_mbase,
+					    vout_mem.res_msize,
+					    (DMA_MEMORY_MAP |
+					     DMA_MEMORY_EXCLUSIVE));
+	}
+
 	imx6q_add_v4l2_capture(0, &capture_data[0]);
 	imx6q_add_v4l2_capture(1, &capture_data[1]);
 	imx6q_add_mipi_csi2(&mipi_csi2_pdata);
@@ -1743,6 +1811,8 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_imx_i2c(0, &mx6q_sabresd_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabresd_i2c_data);
 	imx6q_add_imx_i2c(2, &mx6q_sabresd_i2c_data);
+	if (cpu_is_mx6dl())
+		imx6q_add_imx_i2c(3, &mx6q_sabresd_i2c_data);
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 			ARRAY_SIZE(mxc_i2c0_board_info));
 	i2c_register_board_info(1, mxc_i2c1_board_info,
@@ -1764,7 +1834,17 @@ static void __init mx6_sabresd_board_init(void)
 	imx6q_add_mxc_hdmi(&hdmi_data);
 
 	imx6q_add_anatop_thermal_imx(1, &mx6q_sabresd_anatop_thermal_data);
+
+	if (enet_to_gpio_6)
+		/* Make sure the IOMUX_OBSRV_MUX1 is set to ENET_IRQ. */
+		mxc_iomux_set_specialbits_register(
+			IOMUX_OBSRV_MUX1_OFFSET,
+			OBSRV_MUX1_ENET_IRQ,
+			OBSRV_MUX1_MASK);
+	else
+		fec_data.gpio_irq = -1;
 	imx6_init_fec(fec_data);
+
 	imx6q_add_pm_imx(0, &mx6q_sabresd_pm_data);
 
 	/* Move sd4 to first because sd4 connect to emmc.
@@ -1776,8 +1856,14 @@ static void __init mx6_sabresd_board_init(void)
 	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
 	imx6q_sabresd_init_usb();
 	/* SATA is not supported by MX6DL/Solo */
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q()) {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
 		imx6q_add_ahci(0, &mx6q_sabresd_sata_data);
+#else
+		mx6q_sabresd_sata_init(NULL,
+			(void __iomem *)ioremap(MX6Q_SATA_BASE_ADDR, SZ_4K));
+#endif
+	}
 	imx6q_add_vpu();
 	imx6q_init_audio();
 	platform_device_register(&sabresd_vmmc_reg_devices);
@@ -1925,8 +2011,8 @@ static struct sys_timer mx6_sabresd_timer = {
 
 static void __init mx6q_sabresd_reserve(void)
 {
-#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 	phys_addr_t phys;
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
 
 	if (imx6q_gpu_pdata.reserved_mem_size) {
 		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
@@ -1935,6 +2021,13 @@ static void __init mx6q_sabresd_reserve(void)
 		imx6q_gpu_pdata.reserved_mem_base = phys;
 	}
 #endif
+
+	if (vout_mem.res_msize) {
+		phys = memblock_alloc_base(vout_mem.res_msize,
+					   SZ_4K, SZ_1G);
+		memblock_remove(phys, vout_mem.res_msize);
+		vout_mem.res_mbase = phys;
+	}
 }
 
 /*
diff --git a/arch/arm/mach-mx6/board-mx6q_sabresd.h b/arch/arm/mach-mx6/board-mx6q_sabresd.h
index a1f5cd9..adb2e3e 100644
--- a/arch/arm/mach-mx6/board-mx6q_sabresd.h
+++ b/arch/arm/mach-mx6/board-mx6q_sabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -132,9 +132,8 @@ static iomux_v3_cfg_t mx6q_sabresd_pads[] = {
 	MX6Q_PAD_KEY_COL3__I2C2_SCL,
 	MX6Q_PAD_KEY_ROW3__I2C2_SDA,
 
-	/* I2C3 */
-	MX6Q_PAD_GPIO_3__I2C3_SCL,	/* GPIO1[3] */
-	MX6Q_PAD_GPIO_6__I2C3_SDA,
+	/*I2C3 */
+	MX6Q_PAD_GPIO_3__I2C3_SCL,
 
 	/* DISPLAY */
 	MX6Q_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
diff --git a/arch/arm/mach-mx6/board-mx6sl_arm2.c b/arch/arm/mach-mx6/board-mx6sl_arm2.c
index d72fc63..63fd579 100755
--- a/arch/arm/mach-mx6/board-mx6sl_arm2.c
+++ b/arch/arm/mach-mx6/board-mx6sl_arm2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -315,13 +315,13 @@ static struct platform_device max17135_sensor_device = {
 
 static struct max17135_platform_data max17135_pdata __initdata = {
 	.vneg_pwrup = 1,
-	.gvee_pwrup = 1,
-	.vpos_pwrup = 2,
-	.gvdd_pwrup = 1,
+	.gvee_pwrup = 2,
+	.vpos_pwrup = 10,
+	.gvdd_pwrup = 12,
 	.gvdd_pwrdn = 1,
 	.vpos_pwrdn = 2,
-	.gvee_pwrdn = 1,
-	.vneg_pwrdn = 1,
+	.gvee_pwrdn = 8,
+	.vneg_pwrdn = 10,
 	.gpio_pmic_pwrgood = MX6SL_BRD_EPDC_PWRSTAT,
 	.gpio_pmic_vcom_ctrl = MX6SL_BRD_EPDC_VCOM,
 	.gpio_pmic_wakeup = MX6SL_BRD_EPDC_PMIC_WAKE,
@@ -484,8 +484,8 @@ static int mxc_wm8962_init(void)
 
 	clk_set_parent(extern_audio_root, pll4);
 
-	rate = clk_round_rate(extern_audio_root, 26000000);
-	clk_set_rate(extern_audio_root, rate);
+	rate = 24000000;
+	clk_set_rate(extern_audio_root, 24000000);
 
 	wm8962_data.sysclk = rate;
 
@@ -1092,7 +1092,7 @@ static struct platform_pwm_backlight_data mx6_arm2_pwm_backlight_data = {
 static struct fb_videomode video_modes[] = {
 	{
 	 /* 800x480 @ 57 Hz , pixel clk @ 32MHz */
-	 "SEIKO-WVGA", 60, 800, 480, 29850, 99, 164, 33, 10, 10, 10,
+	 "SEIKO-WVGA", 60, 800, 480, 29850, 89, 164, 23, 10, 10, 10,
 	 FB_SYNC_CLK_LAT_FALL,
 	 FB_VMODE_NONINTERLACED,
 	 0,},
diff --git a/arch/arm/mach-mx6/board-mx6sl_common.h b/arch/arm/mach-mx6/board-mx6sl_common.h
index 1170cb6..897099f 100644
--- a/arch/arm/mach-mx6/board-mx6sl_common.h
+++ b/arch/arm/mach-mx6/board-mx6sl_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -85,6 +85,8 @@
 /* CSI */
 #define MX6SL_BRD_CSI_PWDN		IMX_GPIO_NR(1, 25)
 #define MX6SL_BRD_CSI_RST		IMX_GPIO_NR(1, 26)
+/* bt */
+#define MX6SL_BRD_BT_RESET		IMX_GPIO_NR(5, 11)
 
 static iomux_v3_cfg_t mx6sl_brd_pads[] = {
 
@@ -479,7 +481,9 @@ static iomux_v3_cfg_t suspend_enter_pads[] = {
 	MX6SL_PAD_SD3_DAT3__GPIO_5_17,
 
 	/* USBOTG ID pin */
+#ifndef CONFIG_USB_ID_WAKEUP_ENABLE
 	MX6SL_PAD_EPDC_PWRCOM__GPIO_2_11,
+#endif
 	MX6SL_PAD_HSIC_STROBE__GPIO_3_20,
 	MX6SL_PAD_HSIC_DAT__GPIO_3_19,
 
diff --git a/arch/arm/mach-mx6/board-mx6sl_evk.c b/arch/arm/mach-mx6/board-mx6sl_evk.c
index 46bacc1..082845b 100644
--- a/arch/arm/mach-mx6/board-mx6sl_evk.c
+++ b/arch/arm/mach-mx6/board-mx6sl_evk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -61,6 +61,7 @@
 #include <mach/iomux-mx6sl.h>
 #include <mach/imx-uart.h>
 #include <mach/viv_gpu.h>
+#include <mach/imx_rfkill.h>
 
 #include <asm/irq.h>
 #include <asm/setup.h>
@@ -89,6 +90,8 @@ extern int __init mx6sl_evk_init_pfuze100(u32 int_gpio);
 
 static int csi_enabled;
 
+#define SXSDMAN_BLUETOOTH_ENABLE
+
 static iomux_v3_cfg_t mx6sl_brd_csi_enable_pads[] = {
 	MX6SL_PAD_EPDC_GDRL__CSI_MCLK,
 	MX6SL_PAD_EPDC_SDCE3__I2C3_SDA,
@@ -111,6 +114,16 @@ static iomux_v3_cfg_t mx6sl_brd_csi_enable_pads[] = {
 	MX6SL_PAD_EPDC_SDOE__GPIO_1_25,		/* CMOS_PWDN GPIO */
 };
 
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+static iomux_v3_cfg_t mx6sl_uart4_pads[] = {
+	MX6SL_PAD_SD1_DAT4__UART4_RXD,
+	MX6SL_PAD_SD1_DAT5__UART4_TXD,
+	MX6SL_PAD_SD1_DAT6__UART4_RTS,
+	MX6SL_PAD_SD1_DAT7__UART4_CTS,
+	/* gpio for reset */
+	MX6SL_PAD_SD1_DAT0__GPIO_5_11,
+};
+#else
 /* uart2 pins */
 static iomux_v3_cfg_t mx6sl_uart2_pads[] = {
 	MX6SL_PAD_SD2_DAT5__UART2_TXD,
@@ -118,6 +131,7 @@ static iomux_v3_cfg_t mx6sl_uart2_pads[] = {
 	MX6SL_PAD_SD2_DAT6__UART2_RTS,
 	MX6SL_PAD_SD2_DAT7__UART2_CTS,
 };
+#endif
 
 enum sd_pad_mode {
 	SD_PAD_MODE_LOW_SPEED,
@@ -364,13 +378,13 @@ static struct platform_device max17135_sensor_device = {
 
 static struct max17135_platform_data max17135_pdata __initdata = {
 	.vneg_pwrup = 1,
-	.gvee_pwrup = 1,
-	.vpos_pwrup = 2,
-	.gvdd_pwrup = 1,
+	.gvee_pwrup = 2,
+	.vpos_pwrup = 10,
+	.gvdd_pwrup = 12,
 	.gvdd_pwrdn = 1,
 	.vpos_pwrdn = 2,
-	.gvee_pwrdn = 1,
-	.vneg_pwrdn = 1,
+	.gvee_pwrdn = 8,
+	.vneg_pwrdn = 10,
 	.gpio_pmic_pwrgood = MX6SL_BRD_EPDC_PWRSTAT,
 	.gpio_pmic_vcom_ctrl = MX6SL_BRD_EPDC_VCOM,
 	.gpio_pmic_wakeup = MX6SL_BRD_EPDC_PMIC_WAKE,
@@ -533,8 +547,8 @@ static int mxc_wm8962_init(void)
 
 	clk_set_parent(extern_audio_root, pll4);
 
-	rate = clk_round_rate(extern_audio_root, 26000000);
-	clk_set_rate(extern_audio_root, rate);
+	rate = 24000000;
+	clk_set_rate(extern_audio_root, 24000000);
 
 	wm8962_data.sysclk = rate;
 	/* set AUDMUX pads to 1.8v */
@@ -787,11 +801,19 @@ static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
 
 void __init early_console_setup(unsigned long base, struct clk *clk);
 
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+static const struct imxuart_platform_data mx6sl_evk_uart4_data __initconst = {
+	.flags      = IMXUART_HAVE_RTSCTS,
+	.dma_req_rx = MX6Q_DMA_REQ_UART4_RX,
+	.dma_req_tx = MX6Q_DMA_REQ_UART4_TX,
+};
+#else
 static const struct imxuart_platform_data mx6sl_evk_uart1_data __initconst = {
 	.flags      = IMXUART_HAVE_RTSCTS | IMXUART_SDMA,
 	.dma_req_rx = MX6Q_DMA_REQ_UART2_RX,
 	.dma_req_tx = MX6Q_DMA_REQ_UART2_TX,
 };
+#endif
 
 static inline void mx6_evk_init_uart(void)
 {
@@ -1233,6 +1255,14 @@ static void imx6_evk_usbotg_vbus(bool on)
 		gpio_set_value(MX6_BRD_USBOTG1_PWR, 0);
 }
 
+static void imx6_evk_usbh1_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(MX6_BRD_USBOTG2_PWR, 1);
+	else
+		gpio_set_value(MX6_BRD_USBOTG2_PWR, 0);
+}
+
 static void __init mx6_evk_init_usb(void)
 {
 	int ret = 0;
@@ -1255,9 +1285,10 @@ static void __init mx6_evk_init_usb(void)
 		pr_err("failed to get GPIO MX6_BRD_USBOTG2_PWR:%d\n", ret);
 		return;
 	}
-	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 1);
+	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 0);
 
 	mx6_set_otghost_vbus_func(imx6_evk_usbotg_vbus);
+	mx6_set_host1_vbus_func(imx6_evk_usbh1_vbus);
 
 #ifdef CONFIG_USB_EHCI_ARC_HSIC
 	mx6_usb_h2_init();
@@ -1273,7 +1304,7 @@ static struct platform_pwm_backlight_data mx6_evk_pwm_backlight_data = {
 static struct fb_videomode wvga_video_modes[] = {
 	{
 	 /* 800x480 @ 57 Hz , pixel clk @ 32MHz */
-	 "SEIKO-WVGA", 60, 800, 480, 29850, 99, 164, 33, 10, 10, 10,
+	 "SEIKO-WVGA", 60, 800, 480, 29850, 89, 164, 23, 10, 10, 10,
 	 FB_SYNC_CLK_LAT_FALL,
 	 FB_VMODE_NONINTERLACED,
 	 0,},
@@ -1400,6 +1431,22 @@ static void mx6_snvs_poweroff(void)
 	writel(value | 0x60, mx6_snvs_base + SNVS_LPCR);
 }
 
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+static int uart4_enabled;
+static int __init uart4_setup(char * __unused)
+{
+	uart4_enabled = 1;
+	return 1;
+}
+__setup("bluetooth", uart4_setup);
+
+static void __init uart4_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_uart4_pads,
+					ARRAY_SIZE(mx6sl_uart4_pads));
+	imx6sl_add_imx_uart(3, &mx6sl_evk_uart4_data);
+}
+#else
 static int uart2_enabled;
 static int __init uart2_setup(char * __unused)
 {
@@ -1414,6 +1461,33 @@ static void __init uart2_init(void)
 					ARRAY_SIZE(mx6sl_uart2_pads));
 	imx6sl_add_imx_uart(1, &mx6sl_evk_uart1_data);
 }
+#endif
+
+static void mx6sl_evk_bt_reset(void)
+{
+	gpio_request(MX6SL_BRD_BT_RESET, "bt-reset");
+	gpio_direction_output(MX6SL_BRD_BT_RESET, 0);
+	/* pull down reset pin at least >5ms */
+	mdelay(6);
+	/* pull up after power supply BT */
+	gpio_set_value(MX6SL_BRD_BT_RESET, 1);
+	gpio_free(MX6SL_BRD_BT_RESET);
+}
+
+static int mx6sl_evk_bt_power_change(int status)
+{
+	if (status)
+		mx6sl_evk_bt_reset();
+	return 0;
+}
+
+static struct platform_device mxc_bt_rfkill = {
+	.name = "mxc_bt_rfkill",
+};
+
+static struct imx_bt_rfkill_platform_data mxc_bt_rfkill_data = {
+	.power_change = mx6sl_evk_bt_power_change,
+};
 
 static void mx6sl_evk_suspend_enter()
 {
@@ -1539,8 +1613,15 @@ static void __init mx6_evk_init(void)
 	imx6q_init_audio();
 
 	/* uart2 for bluetooth */
+#ifdef SXSDMAN_BLUETOOTH_ENABLE
+	if (uart4_enabled)
+		uart4_init();
+#else
 	if (uart2_enabled)
 		uart2_init();
+#endif
+
+	mxc_register_device(&mxc_bt_rfkill, &mxc_bt_rfkill_data);
 
 	imx6q_add_viim();
 	imx6q_add_imx2_wdt(0, NULL);
diff --git a/arch/arm/mach-mx6/board-mx6solo_sabreauto.h b/arch/arm/mach-mx6/board-mx6solo_sabreauto.h
index 31c3a61..e4047d5 100644
--- a/arch/arm/mach-mx6/board-mx6solo_sabreauto.h
+++ b/arch/arm/mach-mx6/board-mx6solo_sabreauto.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -204,12 +204,7 @@ static iomux_v3_cfg_t mx6dl_sabreauto_pads[] = {
 
 	/* HDMI */
 	MX6DL_PAD_EIM_A25__HDMI_TX_CEC_LINE,
-
-	/* MLB150 */
-	MX6DL_PAD_ENET_TXD1__MLB_MLBCLK,
-	MX6DL_PAD_GPIO_6__MLB_MLBSIG,
-	MX6DL_PAD_GPIO_2__MLB_MLBDAT,
-};
+ };
 
 static iomux_v3_cfg_t mx6dl_sabreauto_can0_pads[] = {
 	/* CAN1 */
diff --git a/arch/arm/mach-mx6/bus_freq.c b/arch/arm/mach-mx6/bus_freq.c
index 6422052..ba26367 100644
--- a/arch/arm/mach-mx6/bus_freq.c
+++ b/arch/arm/mach-mx6/bus_freq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -47,7 +47,7 @@
 #include <linux/suspend.h>
 
 #define LPAPM_CLK		24000000
-#define DDR_AUDIO_CLK	50000000
+#define DDR_AUDIO_CLK	100000000
 #define DDR_MED_CLK		400000000
 #define DDR3_NORMAL_CLK		528000000
 #define GPC_PGC_GPU_PGCR_OFFSET	0x260
@@ -78,7 +78,8 @@ unsigned int ddr_normal_rate;
 int low_freq_bus_used(void);
 void set_ddr_freq(int ddr_freq);
 void *mx6sl_wfi_iram_base;
-void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr) = NULL;
+void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr,\
+		int audio_mode) = NULL;
 extern void mx6sl_wait (int arm_podf, unsigned long wfi_iram_addr);
 
 void *mx6sl_ddr_freq_base;
@@ -169,6 +170,10 @@ void reduce_bus_freq(void)
 			/* PLL2 is on in this mode, as DDR is at 50MHz. */
 			/* Now change DDR freq while running from IRAM. */
 
+			/* Set AHB to 24MHz. */
+			clk_set_rate(ahb_clk,
+				clk_round_rate(ahb_clk, LPAPM_CLK / 3));
+
 			spin_lock_irqsave(&freq_lock, flags);
 			mx6sl_ddr_freq_change_iram(DDR_AUDIO_CLK,
 							low_bus_freq_mode);
@@ -269,7 +274,7 @@ int set_low_bus_freq(void)
 	if (!bus_freq_scaling_initialized || !bus_freq_scaling_is_active)
 		return 0;
 
-	/* Check to see if we need to got from
+	/* Check to see if we need to get from
 	  * low bus freq mode to audio bus freq mode.
 	  * If so, the change needs to be done immediately.
 	  */
@@ -300,6 +305,8 @@ int set_high_bus_freq(int high_bus_freq)
 	if (!bus_freq_scaling_initialized || !bus_freq_scaling_is_active)
 		return 0;
 
+	if (cpu_is_mx6sl())
+		high_bus_freq = 1;
 
 	if (high_bus_freq_mode && high_bus_freq)
 		return 0;
diff --git a/arch/arm/mach-mx6/clock.c b/arch/arm/mach-mx6/clock.c
index 0a8c880..f8abae4 100644
--- a/arch/arm/mach-mx6/clock.c
+++ b/arch/arm/mach-mx6/clock.c
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -50,6 +50,8 @@ extern int lp_med_freq;
 extern int wait_mode_arm_podf;
 extern int lp_audio_freq;
 extern int cur_arm_podf;
+extern bool enet_is_active;
+extern bool enet_to_gpio_6;
 
 void __iomem *apll_base;
 
@@ -1023,7 +1025,8 @@ static int _clk_audio_video_set_rate(struct clk *clk, unsigned long rate)
 	__raw_writel(mfn, pllbase + PLL_NUM_DIV_OFFSET);
 	__raw_writel(mfd, pllbase + PLL_DENOM_DIV_OFFSET);
 
-	if (rev >= IMX_CHIP_REVISION_1_1) {
+	if ((rev >= IMX_CHIP_REVISION_1_1) &&
+		(pllbase == PLL5_VIDEO_BASE_ADDR)) {
 		reg = __raw_readl(ANA_MISC2_BASE_ADDR)
 			& ~ANADIG_ANA_MISC2_CONTROL3_MASK;
 		reg |= control3 << ANADIG_ANA_MISC2_CONTROL3_OFFSET;
@@ -1152,7 +1155,11 @@ static int _clk_pll_mlb_main_enable(struct clk *clk)
 	reg = __raw_readl(pllbase);
 	reg &= ~ANADIG_PLL_BYPASS;
 
-	reg = 0x0da20800;
+	reg = (0x3 << ANADIG_PLL_MLB_FLT_RES_CFG_OFFSET) |
+		(0x3 << ANADIG_PLL_MLB_RX_CLK_DELAY_CFG_OFFSET) |
+		(0x2 << ANADIG_PLL_MLB_VDDD_DELAY_CFG_OFFSET) |
+		(0x1 << ANADIG_PLL_MLB_VDDA_DELAY_CFG_OFFSET) |
+		(ANADIG_PLL_HOLD_RING_OFF);
 	__raw_writel(reg, pllbase);
 
 	return 0;
@@ -1859,6 +1866,8 @@ static int _clk_ipg_perclk_set_rate(struct clk *clk, unsigned long rate)
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	reg &= ~MXC_CCM_CSCMR1_PERCLK_PODF_MASK;
 	reg |= (div - 1) << MXC_CCM_CSCMR1_PERCLK_PODF_OFFSET;
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2390,6 +2399,9 @@ static int _clk_usdhc1_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC1_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2447,6 +2459,9 @@ static int _clk_usdhc2_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC2_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2504,6 +2519,9 @@ static int _clk_usdhc3_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC3_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2562,6 +2580,9 @@ static int _clk_usdhc4_set_parent(struct clk *clk, struct clk *parent)
 	if (parent == &pll2_pfd_352M)
 		reg |= (MXC_CCM_CSCMR1_USDHC4_CLK_SEL);
 
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
+
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -2677,6 +2698,8 @@ static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &pll3_pfd_508M, &pll3_pfd_454M,
 			&pll4_audio_main_clk, NULL, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -2751,6 +2774,8 @@ static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &pll3_pfd_508M, &pll3_pfd_454M,
 			&pll4_audio_main_clk, NULL, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -2824,6 +2849,8 @@ static int _clk_ssi3_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &pll3_pfd_508M, &pll3_pfd_454M,
 				&pll4_audio_main_clk, NULL, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_SSI3_CLK_SEL_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
@@ -3723,6 +3750,23 @@ static unsigned long _clk_enet_get_rate(struct clk *clk)
 	return 500000000 / div;
 }
 
+static int _clk_enet_enable(struct clk *clk)
+{
+	if (!enet_to_gpio_6)
+		enet_is_active = true;
+
+	_clk_enable(clk);
+	return 0;
+}
+
+static void _clk_enet_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+
+	if (!enet_to_gpio_6)
+		enet_is_active = false;
+}
+
 static struct clk enet_clk[] = {
 	{
 	__INIT_CLK_DEBUG(enet_clk)
@@ -3730,8 +3774,8 @@ static struct clk enet_clk[] = {
 	 .parent = &pll8_enet_main_clk,
 	 .enable_reg = MXC_CCM_CCGR1,
 	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
-	 .enable = _clk_enable,
-	 .disable = _clk_disable,
+	 .enable = _clk_enet_enable,
+	 .disable = _clk_enet_disable,
 	 .set_rate = _clk_enet_set_rate,
 	 .get_rate = _clk_enet_get_rate,
 	.secondary = &enet_clk[1],
@@ -3743,6 +3787,17 @@ static struct clk enet_clk[] = {
 	},
 };
 
+static unsigned long _clk_enet_mdc_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent);
+}
+
+static struct clk enet_mdc_clk = {
+	__INIT_CLK_DEBUG(enet_mdc_clk)
+	.parent = &ipg_clk,
+	.get_rate = _clk_enet_mdc_get_rate,
+};
+
 static struct clk ecspi_clk[] = {
 	{
 	__INIT_CLK_DEBUG(ecspi0_clk)
@@ -3825,6 +3880,8 @@ static int _clk_emi_slow_set_parent(struct clk *clk, struct clk *parent)
 	mux = _get_mux6(parent, &axi_clk, &pll3_usb_otg_main_clk,
 				&pll2_pfd_400M, &pll2_pfd_352M, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_ACLK_EMI_SLOW_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -3855,6 +3912,8 @@ static int _clk_emi_slow_set_rate(struct clk *clk, unsigned long rate)
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	reg &= ~MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_MASK;
 	reg |= (div - 1) << MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_OFFSET;
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -3899,9 +3958,11 @@ static int _clk_emi_set_parent(struct clk *clk, struct clk *parent)
 	int mux;
 	u32 reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_ACLK_EMI_MASK;
 
-	mux = _get_mux6(parent, &axi_clk, &pll3_usb_otg_main_clk,
-			&pll2_pfd_400M, &pll2_pfd_352M, NULL, NULL);
+	mux = _get_mux6(parent, &pll2_pfd_400M, &pll3_usb_otg_main_clk,
+			&axi_clk, &pll2_pfd_352M, NULL, NULL);
 	reg |= (mux << MXC_CCM_CSCMR1_ACLK_EMI_OFFSET);
+	/* aclk_podf fixup */
+	reg ^= 0x00600000;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -3911,6 +3972,7 @@ static unsigned long _clk_emi_get_rate(struct clk *clk)
 {
 	u32 reg, div;
 
+	/* ACLK_EMI_PODF read value matches with real divider value */
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	div = ((reg & MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK) >>
 			MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET) + 1;
@@ -3929,9 +3991,26 @@ static int _clk_emi_set_rate(struct clk *clk, unsigned long rate)
 	if (((parent_rate / div) != rate) || (div > 8))
 		return -EINVAL;
 
+	/*
+	 * This is a software workaround for ACLK_EMI_PODF SoC
+	 * implementation bug. The write/read/divider values
+	 * have the relationship described by the following table:
+	 *
+	 * write value       read value        description
+	 * 3b'000            3b'110            divided by 7
+	 * 3b'001            3b'111            divided by 8
+	 * 3b'010            3b'100            divided by 5
+	 * 3b'011            3b'101            divided by 6
+	 * 3b'100            3b'010            divided by 3
+	 * 3b'101            3b'011            divided by 4
+	 * 3b'110            3b'000            divided by 1
+	 * 3b'111            3b'001            divided by 2(default)
+	 *
+	 * That's why we do the xor operation below.
+	 */
 	reg = __raw_readl(MXC_CCM_CSCMR1);
 	reg &= ~MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK;
-	reg |= (div - 1) << MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET;
+	reg |= ((div - 1)^0x6) << MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET;
 	__raw_writel(reg, MXC_CCM_CSCMR1);
 
 	return 0;
@@ -4770,6 +4849,7 @@ static int _clk_pcie_enable(struct clk *clk)
 {
 	unsigned int reg;
 
+#ifndef CONFIG_IMX_PCIE_RC_MODE_IN_EP_RC_SYS
 	/* Activate LVDS CLK1 (the MiniPCIe slot clock input) */
 	reg = __raw_readl(ANADIG_MISC1_REG);
 	reg &= ~ANATOP_LVDS_CLK1_IBEN_MASK;
@@ -4782,6 +4862,7 @@ static int _clk_pcie_enable(struct clk *clk)
 	reg = __raw_readl(ANADIG_MISC1_REG);
 	reg |= ANATOP_LVDS_CLK1_OBEN_MASK;
 	__raw_writel(reg, ANADIG_MISC1_REG);
+#endif
 
 	/* Enable PCIE ref clock */
 	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
@@ -4799,9 +4880,10 @@ static void _clk_pcie_disable(struct clk *clk)
 
 	_clk_disable(clk);
 
+#ifndef CONFIG_IMX_PCIE_RC_MODE_IN_EP_RC_SYS
 	/* De-activate LVDS CLK1 (the MiniPCIe slot clock input) */
 	reg = __raw_readl(ANADIG_MISC1_REG);
-	reg &= ~ANATOP_LVDS_CLK1_IBEN_MASK;
+	reg |= ANATOP_LVDS_CLK1_IBEN_MASK;
 	__raw_writel(reg, ANADIG_MISC1_REG);
 
 	reg = __raw_readl(ANADIG_MISC1_REG);
@@ -4811,6 +4893,7 @@ static void _clk_pcie_disable(struct clk *clk)
 	reg = __raw_readl(ANADIG_MISC1_REG);
 	reg &= ~ANATOP_LVDS_CLK1_OBEN_MASK;
 	__raw_writel(reg, ANADIG_MISC1_REG);
+#endif
 
 	/* Disable PCIE ref clock */
 	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
@@ -4844,6 +4927,53 @@ static struct clk pcie_clk[] = {
 	},
 };
 
+static int _clk_pcie_ep_enable(struct clk *clk)
+{
+	unsigned int reg;
+
+	/* Enable PCIE ref clock */
+	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
+	reg |= ANADIG_PLL_ENET_EN_PCIE;
+	__raw_writel(reg, PLL8_ENET_BASE_ADDR);
+
+	_clk_enable(clk);
+
+	return 0;
+}
+
+static void _clk_pcie_ep_disable(struct clk *clk)
+{
+	unsigned int reg;
+
+	_clk_disable(clk);
+
+	/* Disable PCIE ref clock */
+	reg = __raw_readl(PLL8_ENET_BASE_ADDR);
+	reg &= ~ANADIG_PLL_ENET_EN_PCIE;
+	__raw_writel(reg, PLL8_ENET_BASE_ADDR);
+}
+
+static struct clk pcie_ep_clk[] = {
+	{
+	__INIT_CLK_DEBUG(pcie_ep_clk)
+	.parent = &pcie_axi_clk,
+	.enable = _clk_pcie_ep_enable,
+	.disable = _clk_pcie_ep_disable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.secondary = &pcie_ep_clk[1],
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	.parent = &pll8_enet_main_clk,
+	.secondary = &pcie_ep_clk[2],
+	},
+	{
+	.parent = &mmdc_ch0_axi_clk[0],
+	.secondary = &mx6fast1_clk,
+	},
+};
+
 static struct clk usboh3_clk[] = {
 	{
 	__INIT_CLK_DEBUG(usboh3_clk)
@@ -4888,6 +5018,7 @@ static int _clk_mlb_set_parent(struct clk *clk, struct clk *parent)
 static struct clk mlb150_clk = {
 	__INIT_CLK_DEBUG(mlb150_clk)
 	.id = 0,
+	.secondary = &ocram_clk,
 	.set_parent = _clk_mlb_set_parent,
 	.enable_reg = MXC_CCM_CCGR3,
 	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
@@ -5250,7 +5381,6 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("imx6q-ecspi.1", NULL, ecspi_clk[1]),
 	_REGISTER_CLOCK("imx6q-ecspi.2", NULL, ecspi_clk[2]),
 	_REGISTER_CLOCK("imx6q-ecspi.3", NULL, ecspi_clk[3]),
-	_REGISTER_CLOCK("imx6q-ecspi.4", NULL, ecspi_clk[4]),
 	_REGISTER_CLOCK(NULL, "emi_slow_clk", emi_slow_clk),
 	_REGISTER_CLOCK(NULL, "emi_clk", emi_clk),
 	_REGISTER_CLOCK(NULL, "enfc_clk", enfc_clk),
@@ -5258,6 +5388,7 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("imx-uart.1", NULL, uart_clk[0]),
 	_REGISTER_CLOCK("imx-uart.2", NULL, uart_clk[0]),
 	_REGISTER_CLOCK("imx-uart.3", NULL, uart_clk[0]),
+	_REGISTER_CLOCK("imx-uart.4", NULL, uart_clk[0]),
 	_REGISTER_CLOCK(NULL, "hsi_tx", hsi_tx_clk[0]),
 	_REGISTER_CLOCK(NULL, "caam_clk", caam_clk[0]),
 	_REGISTER_CLOCK(NULL, "asrc_clk", asrc_clk[0]),
@@ -5278,7 +5409,9 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm_clk[2]),
 	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm_clk[3]),
 	_REGISTER_CLOCK(NULL, "pcie_clk", pcie_clk[0]),
-	_REGISTER_CLOCK("enet.0", NULL, enet_clk[0]),
+	_REGISTER_CLOCK(NULL, "pcie_ep_clk", pcie_ep_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_clk", enet_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_mdc_clk", enet_mdc_clk),
 	_REGISTER_CLOCK(NULL, "imx_sata_clk", sata_clk[0]),
 	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
 	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy1_clk),
@@ -5306,6 +5439,11 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "apb_pclk", dummy_clk),
 };
 
+static struct
+clk_lookup imx6dl_i2c4 = _REGISTER_CLOCK("imx-i2c.3", NULL, ecspi_clk[4]);
+static struct
+clk_lookup imx6q_ecspi5 = _REGISTER_CLOCK("imx6q-ecspi.4", NULL, ecspi_clk[4]);
+
 static void clk_tree_init(void)
 
 {
@@ -5343,13 +5481,18 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 		clk_debug_register(lookups[i].clk);
 	}
 
-	/* Lower the ipg_perclk frequency to 22MHz.
-	  * I2C needs a minimum of 12.8MHz as its source
-	  * to acheive 400KHz speed. IPG_PERCLK sources
-	  * I2C. 22MHz when divided by the I2C divider gives the
-	  * freq closest to 400KHz.
-	  */
-	clk_set_rate(&ipg_perclk, 22000000);
+	/*
+	 * imx6q have 5 ecspi and 3 i2c
+	 * imx6dl have 4 ecspi and 4 i2c
+	 * imx6dl i2c4 use the imx6q ecspi5 clock source
+	 */
+	if (cpu_is_mx6dl()) {
+		clkdev_add(&imx6dl_i2c4);
+		clk_debug_register(imx6dl_i2c4.clk);
+	} else {
+		clkdev_add(&imx6q_ecspi5);
+		clk_debug_register(imx6q_ecspi5.clk);
+	}
 
 	/* Timer needs to be initialized first as the
 	  * the WAIT routines use GPT counter as
@@ -5368,6 +5511,15 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 
 	clk_tree_init();
 
+	/*
+	 * Lower the ipg_perclk frequency to 22MHz.
+	 * I2C needs a minimum of 12.8MHz as its source
+	 * to acheive 400KHz speed. IPG_PERCLK sources
+	 * I2C. 22MHz when divided by the I2C divider gives the
+	 * freq closest to 400KHz.
+	 */
+	clk_set_rate(&ipg_perclk, 22000000);
+
 #ifdef CONFIG_MX6_VPU_352M
 	if (cpu_is_mx6q()) {
 		clk_set_rate(&pll2_pfd_400M, 352000000);
@@ -5410,8 +5562,11 @@ int __init mx6_clocks_init(unsigned long ckil, unsigned long osc,
 	clk_set_parent(&ipu2_di_clk[1], &pll5_video_main_clk);
 
 	clk_set_parent(&emi_clk, &pll2_pfd_400M);
-	clk_set_rate(&emi_clk, 200000000);
-
+#ifdef CONFIG_MX6_VPU_352M
+	clk_set_rate(&emi_clk, 176000000);
+#else
+	clk_set_rate(&emi_clk, 198000000);
+#endif
 	/*
 	* on mx6dl, 2d core clock sources from 3d shader core clock,
 	* but 3d shader clock multiplexer of mx6dl is different from
diff --git a/arch/arm/mach-mx6/clock_mx6sl.c b/arch/arm/mach-mx6/clock_mx6sl.c
index 961e7ee..f375b4a 100755
--- a/arch/arm/mach-mx6/clock_mx6sl.c
+++ b/arch/arm/mach-mx6/clock_mx6sl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -73,6 +73,7 @@ static struct cpu_op *cpu_op_tbl;
 static int cpu_op_nr;
 static bool pll1_enabled;
 static bool arm_needs_pll2_400;
+static bool audio_pll_bypass;
 
 DEFINE_SPINLOCK(mx6sl_clk_lock);
 #define SPIN_DELAY	1200000 /* in nanoseconds */
@@ -429,7 +430,8 @@ static int _clk_pll_enable(struct clk *clk)
 	pllbase = _get_pll_base(clk);
 
 	reg = __raw_readl(pllbase);
-	reg &= ~ANADIG_PLL_POWER_DOWN;
+	if (clk != &pll4_audio_main_clk || !audio_pll_bypass)
+		reg &= ~ANADIG_PLL_POWER_DOWN;
 
 	/* The 480MHz PLLs have the opposite definition for power bit. */
 	if (clk == &pll3_usb_otg_main_clk || clk == &pll7_usb_host_main_clk)
@@ -442,14 +444,20 @@ static int _clk_pll_enable(struct clk *clk)
 		__raw_writel(BM_ANADIG_ANA_MISC2_CONTROL0, apll_base + HW_ANADIG_ANA_MISC2_CLR);
 
 	/* Wait for PLL to lock */
-	if (!WAIT((__raw_readl(pllbase) & ANADIG_PLL_LOCK),
-				SPIN_DELAY))
-		panic("pll enable failed\n");
-
+	if (clk != &pll4_audio_main_clk || !audio_pll_bypass) {
+		if (!WAIT((__raw_readl(pllbase) & ANADIG_PLL_LOCK),
+					SPIN_DELAY))
+			panic("pll enable failed\n");
+	}
 	/* Enable the PLL output now*/
 	reg = __raw_readl(pllbase);
-	reg &= ~ANADIG_PLL_BYPASS;
+
+	/* If audio PLL is set to 24MHz, leave it in bypass mode. */
+	if (clk != &pll4_audio_main_clk || !audio_pll_bypass)
+		reg &= ~ANADIG_PLL_BYPASS;
+
 	reg |= ANADIG_PLL_ENABLE;
+
 	__raw_writel(reg, pllbase);
 
 	return 0;
@@ -874,6 +882,9 @@ static unsigned long _clk_audio_video_get_rate(struct clk *clk)
 
 	pllbase = _get_pll_base(clk);
 
+	if (__raw_readl(pllbase) & ANADIG_PLL_BYPASS)
+		return 24000000;
+
 	test_div_sel = (__raw_readl(pllbase)
 		& ANADIG_PLL_AV_TEST_DIV_SEL_MASK)
 		>> ANADIG_PLL_AV_TEST_DIV_SEL_OFFSET;
@@ -917,6 +928,16 @@ static int _clk_audio_video_set_rate(struct clk *clk, unsigned long rate)
 	u32 test_div_sel = 2;
 	u32 control3 = 0;
 
+	pllbase = _get_pll_base(clk);
+
+	if (clk == &pll4_audio_main_clk && audio_pll_bypass) {
+		reg = __raw_readl(pllbase)
+				& ~ANADIG_PLL_SYS_DIV_SELECT_MASK
+				& ~ANADIG_PLL_AV_TEST_DIV_SEL_MASK;
+		__raw_writel(reg, pllbase);
+		return 0;
+	}
+
 	if (clk == &pll4_audio_main_clk)
 		min_clk_rate = AUDIO_VIDEO_MIN_CLK_FREQ / 4;
 	else
@@ -925,8 +946,6 @@ static int _clk_audio_video_set_rate(struct clk *clk, unsigned long rate)
 	if ((rate < min_clk_rate) || (rate > AUDIO_VIDEO_MAX_CLK_FREQ))
 		return -EINVAL;
 
-	pllbase = _get_pll_base(clk);
-
 	pre_div_rate = rate;
 	while (pre_div_rate < AUDIO_VIDEO_MIN_CLK_FREQ) {
 		pre_div_rate *= 2;
@@ -986,6 +1005,9 @@ static unsigned long _clk_audio_video_round_rate(struct clk *clk,
 	u32 control3 = 0;
 	unsigned long final_rate;
 
+	if (clk == &pll4_audio_main_clk && audio_pll_bypass)
+		return 24000000;
+
 	if (clk == &pll4_audio_main_clk)
 		min_clk_rate = AUDIO_VIDEO_MIN_CLK_FREQ / 4;
 	else
@@ -1681,6 +1703,7 @@ static struct clk mmdc_ch1_axi_clk[] = {
 	.secondary = &tzasc2_clk,
 	},
 };
+
 #if defined(CONFIG_SDMA_IRAM) || defined(CONFIG_SND_MXC_SOC_IRAM)
 static struct clk ocram_clk = {
 	__INIT_CLK_DEBUG(ocram_clk)
@@ -1692,6 +1715,7 @@ static struct clk ocram_clk = {
 	.disable = _clk_disable_inwait,
 };
 #endif
+
 static unsigned long _clk_ipg_perclk_get_rate(struct clk *clk)
 {
 	u32 reg, div;
@@ -2376,14 +2400,23 @@ static int _clk_extern_audio_set_rate(struct clk *clk, unsigned long rate)
 	u32 reg, div, pre, post;
 	u32 parent_rate = clk_get_rate(clk->parent);
 
-	div = parent_rate / rate;
-	if (div == 0)
-		div++;
-	if (((parent_rate / div) != rate) || div > 64)
-		return -EINVAL;
+	if (rate == 24000000 && clk->parent == &pll4_audio_main_clk) {
+		/* If the requested rate is 24MHz,
+		  * set the PLL4 to bypass mode.
+		  */
+		audio_pll_bypass = 1;
+		pre = post = 1;
+	} else {
+		div = parent_rate / rate;
+		if (div == 0)
+			div++;
+		if (((parent_rate / div) != rate) || div > 64)
+			return -EINVAL;
 
-	__calc_pre_post_dividers(1 << 3, div, &pre, &post);
+		audio_pll_bypass = 0;
 
+		__calc_pre_post_dividers(1 << 3, div, &pre, &post);
+	}
 	reg = __raw_readl(MXC_CCM_CS1CDR);
 	reg &= ~(MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK|
 		 MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK);
@@ -2427,23 +2460,25 @@ static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk ssi1_clk = {
-	__INIT_CLK_DEBUG(ssi1_clk)
-	.parent = &pll3_pfd2_508M,
-	.enable_reg = MXC_CCM_CCGR5,
-	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
-	.enable = _clk_enable,
-	.disable = _clk_disable,
-	.set_parent = _clk_ssi1_set_parent,
-	.set_rate = _clk_ssi1_set_rate,
-	.round_rate = _clk_ssi_round_rate,
-	.get_rate = _clk_ssi1_get_rate,
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &ocram_clk,
-#else
+static struct clk ssi1_clk[] = {
+	{
+	 __INIT_CLK_DEBUG(ssi1_clk)
+	 .parent = &pll3_pfd2_508M,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .set_rate = _clk_ssi1_set_rate,
+	 .round_rate = _clk_ssi_round_rate,
+	 .get_rate = _clk_ssi1_get_rate,
+	 .flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#ifndef CONFIG_SND_MXC_SOC_IRAM
 	 .secondary = &mmdc_ch1_axi_clk[0],
+#else
+	 .secondary = &ocram_clk,
 #endif
-	.flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
 };
 
 static unsigned long _clk_ssi2_get_rate(struct clk *clk)
@@ -2501,23 +2536,25 @@ static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk ssi2_clk = {
-	__INIT_CLK_DEBUG(ssi2_clk)
-	.parent = &pll3_pfd2_508M,
-	.enable_reg = MXC_CCM_CCGR5,
-	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
-	.enable = _clk_enable,
-	.disable = _clk_disable,
-	.set_parent = _clk_ssi2_set_parent,
-	.set_rate = _clk_ssi2_set_rate,
-	.round_rate = _clk_ssi_round_rate,
-	.get_rate = _clk_ssi2_get_rate,
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &ocram_clk,
-#else
+static struct clk ssi2_clk[] = {
+	{
+	 __INIT_CLK_DEBUG(ssi2_clk)
+	 .parent = &pll3_pfd2_508M,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .set_rate = _clk_ssi2_set_rate,
+	 .round_rate = _clk_ssi_round_rate,
+	 .get_rate = _clk_ssi2_get_rate,
+	 .flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#ifndef CONFIG_SND_MXC_SOC_IRAM
 	 .secondary = &mmdc_ch1_axi_clk[0],
+#else
+	 .secondary = &ocram_clk,
 #endif
-	.flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
 };
 
 static unsigned long _clk_ssi3_get_rate(struct clk *clk)
@@ -2574,23 +2611,25 @@ static int _clk_ssi3_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
-static struct clk ssi3_clk = {
-	__INIT_CLK_DEBUG(ssi3_clk)
-	.parent = &pll3_pfd2_508M,
-	.enable_reg = MXC_CCM_CCGR5,
-	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
-	.enable = _clk_enable,
-	.disable = _clk_disable,
-	.set_parent = _clk_ssi3_set_parent,
-	.set_rate = _clk_ssi3_set_rate,
-	.round_rate = _clk_ssi_round_rate,
-	.get_rate = _clk_ssi3_get_rate,
-#ifdef CONFIG_SND_MXC_SOC_IRAM
-	 .secondary = &ocram_clk,
-#else
+static struct clk ssi3_clk[] = {
+	{
+	 __INIT_CLK_DEBUG(ssi3_clk)
+	 .parent = &pll3_pfd2_508M,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .set_parent = _clk_ssi3_set_parent,
+	 .set_rate = _clk_ssi3_set_rate,
+	 .round_rate = _clk_ssi_round_rate,
+	 .get_rate = _clk_ssi3_get_rate,
+	 .flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#ifndef CONFIG_SND_MXC_SOC_IRAM
 	 .secondary = &mmdc_ch1_axi_clk[0],
+#else
+	 .secondary = &ocram_clk,
 #endif
-	.flags  = AHB_AUDIO_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
 };
 
 static unsigned long _clk_epdc_lcdif_pix_round_rate(struct clk *clk,
@@ -3156,6 +3195,17 @@ static struct clk fec_clk[] = {
 	},
 };
 
+static unsigned long _clk_fec_mdc_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent);
+}
+
+static struct clk fec_mdc_clk = {
+	__INIT_CLK_DEBUG(fec_mdc_clk)
+	.parent = &ipg_clk,
+	.get_rate = _clk_fec_mdc_get_rate,
+};
+
 static struct clk ecspi_clk[] = {
 	{
 	__INIT_CLK_DEBUG(ecspi0_clk)
@@ -3755,11 +3805,11 @@ static int _clk_clko2_set_parent(struct clk *clk, struct clk *parent)
 		sel = 14;
 	else if (parent == &usdhc2_clk)
 		sel = 17;
-	else if (parent == &ssi1_clk)
+	else if (parent == &ssi1_clk[0])
 		sel = 18;
-	else if (parent == &ssi2_clk)
+	else if (parent == &ssi2_clk[0])
 		sel = 19;
-	else if (parent == &ssi3_clk)
+	else if (parent == &ssi3_clk[0])
 		sel = 20;
 	else if (parent == &uart_clk[0])
 		sel = 28;
@@ -3912,9 +3962,9 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("sdhci-esdhc-imx.1", NULL, usdhc2_clk),
 	_REGISTER_CLOCK("sdhci-esdhc-imx.2", NULL, usdhc3_clk),
 	_REGISTER_CLOCK("sdhci-esdhc-imx.3", NULL, usdhc4_clk),
-	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk),
-	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk),
-	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk),
+	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk[0]),
+	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk[0]),
+	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk[0]),
 	_REGISTER_CLOCK(NULL, "pxp_axi", pxp_axi_clk),
 	_REGISTER_CLOCK(NULL, "epdc_axi", epdc_axi_clk),
 	_REGISTER_CLOCK(NULL, "epdc_pix", epdc_pix_clk),
@@ -3935,7 +3985,8 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm_clk[1]),
 	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm_clk[2]),
 	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm_clk[3]),
-	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_clk", fec_clk[0]),
+	_REGISTER_CLOCK(NULL, "fec_mdc_clk", fec_mdc_clk),
 	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
 	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy1_clk),
 	_REGISTER_CLOCK(NULL, "usb_phy3_clk", usb_phy3_clk),
@@ -4097,6 +4148,8 @@ int __init mx6sl_clocks_init(unsigned long ckil, unsigned long osc,
 	/* lcdif pix - PLL5 as parent */
 	clk_set_parent(&lcdif_pix_clk, &pll5_video_main_clk);
 
+	clk_set_parent(&ssi2_clk[0], &pll4_audio_main_clk);
+
 	lp_high_freq = 0;
 	lp_med_freq = 0;
 
diff --git a/arch/arm/mach-mx6/cpu.c b/arch/arm/mach-mx6/cpu.c
index 7a874da..a65ad81 100644
--- a/arch/arm/mach-mx6/cpu.c
+++ b/arch/arm/mach-mx6/cpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,6 +37,7 @@ bool enable_wait_mode = true;
 u32 enable_ldo_mode = LDO_MODE_DEFAULT;
 u32 arm_max_freq = CPU_AT_1_2GHz;
 bool mem_clk_on_in_wait;
+bool enet_to_gpio_6;
 int chip_rev;
 
 void __iomem *gpc_base;
@@ -213,6 +214,13 @@ static int __init post_cpu_init(void)
 	else
 		chip_rev = mx6sl_revision();
 
+	/* mx6sl doesn't have pcie. save power, disable PCIe PHY */
+	if (!cpu_is_mx6sl()) {
+		reg = __raw_readl(IOMUXC_GPR1);
+		reg = reg & (~IOMUXC_GPR1_PCIE_REF_CLK_EN);
+		reg |= IOMUXC_GPR1_TEST_POWERDOWN;
+		__raw_writel(reg, IOMUXC_GPR1);
+	}
 	return 0;
 }
 postcore_initcall(post_cpu_init);
@@ -269,5 +277,10 @@ static int __init enable_mem_clk_in_wait(char *p)
 
 early_param("mem_clk_on", enable_mem_clk_in_wait);
 
+static int __init set_enet_irq_to_gpio(char *p)
+{
+	enet_to_gpio_6 = true;
+	return 0;
+}
 
-
+early_param("enet_gpio_6", set_enet_irq_to_gpio);
diff --git a/arch/arm/mach-mx6/cpu_op-mx6.c b/arch/arm/mach-mx6/cpu_op-mx6.c
index 5124c5e..210fdd5 100644
--- a/arch/arm/mach-mx6/cpu_op-mx6.c
+++ b/arch/arm/mach-mx6/cpu_op-mx6.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -342,18 +342,27 @@ void mx6_cpu_op_init(void)
 {
 	unsigned int reg;
 	void __iomem *base;
-	if (cpu_is_mx6q()) {
+	if (!cpu_is_mx6sl()) {
 		/*read fuse bit to know the max cpu freq : offset 0x440
-		* bit[17:16]:SPEED_GRADING[1:0]*/
+		* bit[17:16]:SPEED_GRADING[1:0],for mx6dq/dl*/
 		base = IO_ADDRESS(OCOTP_BASE_ADDR);
 		reg = __raw_readl(base + 0x440);
 		reg &= (0x3 << OCOTP_SPEED_BIT_OFFSET);
 		reg >>= OCOTP_SPEED_BIT_OFFSET;
 		/*choose the little value to run lower max cpufreq*/
 		arm_max_freq = (reg > arm_max_freq) ? arm_max_freq : reg;
-	} else
-		arm_max_freq = CPU_AT_1GHz;/*mx6dl/sl max freq is 1Ghz*/
-	printk(KERN_INFO "arm_max_freq=%x\n", arm_max_freq);
+	} else {
+		/*
+		 * There is no SPEED_GRADING fuse bit on mx6sl,then do:
+		 * If arm_max_freq set by default on CPU_AT_1_2GHz which mean
+		 * there is no 'arm_freq' setting in cmdline from bootloader,
+		 * force arm_max_freq to 1G. Else use 'arm_freq' setting.
+		 */
+		if (arm_max_freq == CPU_AT_1_2GHz)
+			arm_max_freq = CPU_AT_1GHz;/*mx6sl max freq is 1Ghz*/
+	}
+	printk(KERN_INFO "arm_max_freq=%s\n", (arm_max_freq == CPU_AT_1_2GHz) ?
+		"1.2GHz" : ((arm_max_freq == CPU_AT_1GHz) ? "1GHz" : "800MHz"));
 	get_cpu_op = mx6_get_cpu_op;
 	set_num_cpu_op = mx6_set_num_cpu_op;
 
diff --git a/arch/arm/mach-mx6/cpu_regulator-mx6.c b/arch/arm/mach-mx6/cpu_regulator-mx6.c
index 59bc383..0e91c8c 100644
--- a/arch/arm/mach-mx6/cpu_regulator-mx6.c
+++ b/arch/arm/mach-mx6/cpu_regulator-mx6.c
@@ -85,7 +85,8 @@ void mx6_cpu_regulator_init(void)
 		soc_reg_id = "cpu_vddsoc";
 		pu_reg_id = "cpu_vddgpu";
 	}
-	printk(KERN_INFO "cpu regulator init ldo=%x\n", enable_ldo_mode);
+	printk(KERN_INFO "cpu regulator mode:%s\n", (enable_ldo_mode ==
+		LDO_MODE_BYPASSED) ? "ldo_bypass" : "ldo_enable");
 	cpu_regulator = regulator_get(NULL, gp_reg_id);
 	if (IS_ERR(cpu_regulator))
 		printk(KERN_ERR "%s: failed to get cpu regulator\n", __func__);
diff --git a/arch/arm/mach-mx6/crm_regs.h b/arch/arm/mach-mx6/crm_regs.h
index 43fcb4d..0ae8e41 100644
--- a/arch/arm/mach-mx6/crm_regs.h
+++ b/arch/arm/mach-mx6/crm_regs.h
@@ -28,6 +28,29 @@
 #define IOMUXC_GPR12			(MXC_IOMUXC_BASE + 0x30)
 #define IOMUXC_GPR13			(MXC_IOMUXC_BASE + 0x34)
 
+/* GPR1: IOMUXC_GPR1_PCIE_REF_CLK_EN(IOMUXC_GPR1[16]) */
+#define IOMUXC_GPR1_PCIE_REF_CLK_EN		(1 << 16)
+/* GPR1: IOMUXC_GPR1_TEST_POWERDOWN(IOMUXC_GPR1[18]) */
+#define IOMUXC_GPR1_TEST_POWERDOWN		(1 << 18)
+
+/* GPR8: IOMUXC_GPR8_TX_DEEMPH_GEN1(IOMUXC_GPR8[5:0]) */
+#define IOMUXC_GPR8_TX_DEEMPH_GEN1		(0x3F << 0)
+/* GPR8: IOMUXC_GPR8_TX_DEEMPH_GEN2_3P5DB(IOMUXC_GPR8[11:6]) */
+#define IOMUXC_GPR8_TX_DEEMPH_GEN2_3P5DB	(0x3F << 6)
+/* GPR8: IOMUXC_GPR8_TX_DEEMPH_GEN2_6DB(IOMUXC_GPR8[17:12]) */
+#define IOMUXC_GPR8_TX_DEEMPH_GEN2_6DB		(0x3F << 12)
+/* GPR8: IOMUXC_GPR8_TX_SWING_FULL(IOMUXC_GPR8[24:18]) */
+#define IOMUXC_GPR8_TX_SWING_FULL		(0x7F << 18)
+/* GPR8: IOMUXC_GPR8_TX_SWING_LOW(IOMUXC_GPR8[31:25]) */
+#define IOMUXC_GPR8_TX_SWING_LOW		(0x7F << 25)
+
+/* GPR12: IOMUXC_GPR12_LOS_LEVEL(IOMUXC_GPR12[8:4]) */
+#define IOMUXC_GPR12_LOS_LEVEL			(0x1F << 4)
+/* GPR12: IOMUXC_GPR12_APP_LTSSM_ENABLE(IOMUXC_GPR12[10]) */
+#define IOMUXC_GPR12_APP_LTSSM_ENABLE		(1 << 10)
+/* GPR12: IOMUXC_GPR12_DEVICE_TYPE(IOMUXC_GPR12[15:12]) */
+#define IOMUXC_GPR12_DEVICE_TYPE		(0xF << 12)
+
 #define IOMUXC_GPR3_OCRAM_CTL_EN	(0xf << 21)
 #define IOMUXC_GPR4_VDOA_CACHE_EN	(0xf << 28)
 #define IOMUXC_GPR4_VPU_CACHE_EN	(0xcc)
@@ -155,9 +178,9 @@
 #define ANADIG_ANA_MISC2_REG1_BO_EN			(1 << 13)
 #define ANADIG_ANA_MISC2_CONTROL3_MASK		0xC0000000
 #define ANADIG_ANA_MISC2_CONTROL3_OFFSET	30
-#define ANADIG_ANA_MISC2_REG0_STEP_TIME_MASK		0x30000000
-#define ANADIG_ANA_MISC2_REG1_STEP_TIME_MASK		0xC000000
-#define ANADIG_ANA_MISC2_REG2_STEP_TIME_MASK		0x3000000
+#define ANADIG_ANA_MISC2_REG0_STEP_TIME_MASK		0x03000000
+#define ANADIG_ANA_MISC2_REG1_STEP_TIME_MASK		0x0C000000
+#define ANADIG_ANA_MISC2_REG2_STEP_TIME_MASK		0x30000000
 
 #define MXC_CCM_BASE		MX6_IO_ADDRESS(CCM_BASE_ADDR)
 /* CCM Register Offsets. */
diff --git a/arch/arm/mach-mx6/irq.c b/arch/arm/mach-mx6/irq.c
index 3281693..d0bde95 100644
--- a/arch/arm/mach-mx6/irq.c
+++ b/arch/arm/mach-mx6/irq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,6 +26,9 @@
 #ifdef CONFIG_CPU_FREQ_GOV_INTERACTIVE
 #include <linux/cpufreq.h>
 #endif
+#ifdef CONFIG_PCI_MSI
+#include "msi.h"
+#endif
 
 int mx6q_register_gpios(void);
 unsigned int gpc_wake_irq[4];
@@ -131,4 +134,7 @@ void mx6_init_irq(void)
 	for (i = 0; i < ARRAY_SIZE(mxc_irq_tuner); i++)
 		cpufreq_gov_irq_tuner_register(mxc_irq_tuner[i]);
 #endif
+#ifdef CONFIG_PCI_MSI
+	imx_msi_init();
+#endif
 }
diff --git a/arch/arm/mach-mx6/localtimer.c b/arch/arm/mach-mx6/localtimer.c
index 402368b..2fac9fb 100644
--- a/arch/arm/mach-mx6/localtimer.c
+++ b/arch/arm/mach-mx6/localtimer.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,8 +24,6 @@
 #include <mach/irqs.h>
 #include <mach/hardware.h>
 
-
-extern bool enable_wait_mode;
 /*
  * Setup the local clock events for a CPU.
  */
diff --git a/arch/arm/mach-mx6/mm.c b/arch/arm/mach-mx6/mm.c
index 3cf6b22..8d2c715 100644
--- a/arch/arm/mach-mx6/mm.c
+++ b/arch/arm/mach-mx6/mm.c
@@ -111,9 +111,21 @@ int mxc_init_l2x0(void)
 	writel(0x132, IO_ADDRESS(L2_BASE_ADDR + L2X0_TAG_LATENCY_CTRL));
 	writel(0x132, IO_ADDRESS(L2_BASE_ADDR + L2X0_DATA_LATENCY_CTRL));
 
-	val = readl(IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
-	val |= 0x40800000;
-	writel(val, IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
+	/*
+	 * The L2 cache controller(PL310) version on the i.MX6D/Q is r3p1-50rel0
+	 * The L2 cache controller(PL310) version on the i.MX6DL/SOLO/SL is r3p2
+	 * But according to ARM PL310 errata: 752271
+	 * ID: 752271: Double linefill feature can cause data corruption
+	 * Fault Status: Present in: r3p0, r3p1, r3p1-50rel0. Fixed in r3p2
+	 * Workaround: The only workaround to this erratum is to disable the
+	 * double linefill feature. This is the default behavior.
+	 */
+	if (!cpu_is_mx6q()) {
+		val = readl(IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
+		val |= 0x40800000;
+		writel(val, IO_ADDRESS(L2_BASE_ADDR + L2X0_PREFETCH_CTRL));
+	}
+
 	val = readl(IO_ADDRESS(L2_BASE_ADDR + L2X0_POWER_CTRL));
 	val |= L2X0_DYNAMIC_CLK_GATING_EN;
 	val |= L2X0_STNDBY_MODE_EN;
diff --git a/arch/arm/mach-mx6/msi.c b/arch/arm/mach-mx6/msi.c
new file mode 100644
index 0000000..096d1c2
--- /dev/null
+++ b/arch/arm/mach-mx6/msi.c
@@ -0,0 +1,151 @@
+/*
+ * arch/arm/mach-mx6/msi.c
+ *
+ * PCI MSI support for the imx processor
+ *
+ * Copyright (c) 2013 Boundary Devices.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <asm/bitops.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+#include "msi.h"
+
+
+#define IMX_NUM_MSI_IRQS 128
+static DECLARE_BITMAP(msi_irq_in_use, IMX_NUM_MSI_IRQS);
+
+static void imx_msi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	int i, j;
+	unsigned int status;
+	struct irq_chip *chip = irq_get_chip(irq);
+	unsigned int base_irq = IRQ_IMX_MSI_0;
+
+	chained_irq_enter(chip, desc);
+	for (i = 0; i < 8; i++) {
+		status = imx_pcie_msi_pending(i);
+		while (status) {
+			j = __fls(status);
+			generic_handle_irq(base_irq + j);
+			status &= ~(1 << j);
+		}
+		base_irq += 32;
+	}
+	chained_irq_exit(chip, desc);
+}
+
+/*
+* Dynamic irq allocate and deallocation
+*/
+int create_irq(void)
+{
+	int irq, pos;
+
+	do {
+		pos = find_first_zero_bit(msi_irq_in_use, IMX_NUM_MSI_IRQS);
+		if ((unsigned int)pos >= IMX_NUM_MSI_IRQS)
+			return -ENOSPC;
+		/* test_and_set_bit operates on 32-bits at a time */
+	} while (test_and_set_bit(pos, msi_irq_in_use));
+
+	irq = IRQ_IMX_MSI_0 + pos;
+	dynamic_irq_init(irq);
+	return irq;
+}
+
+void destroy_irq(unsigned int irq)
+{
+	int pos = irq - IRQ_IMX_MSI_0;
+
+	dynamic_irq_cleanup(irq);
+	clear_bit(pos, msi_irq_in_use);
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+static void imx_msi_irq_ack(struct irq_data *d)
+{
+	return;
+}
+
+static void imx_msi_irq_enable(struct irq_data *d)
+{
+	imx_pcie_enable_irq(d->irq - IRQ_IMX_MSI_0, 1);
+	return unmask_msi_irq(d);
+}
+
+static void imx_msi_irq_disable(struct irq_data *d)
+{
+	imx_pcie_enable_irq(d->irq - IRQ_IMX_MSI_0, 0);
+	return mask_msi_irq(d);
+}
+
+static void imx_msi_irq_mask(struct irq_data *d)
+{
+	imx_pcie_mask_irq(d->irq - IRQ_IMX_MSI_0, 1);
+	return mask_msi_irq(d);
+}
+
+static void imx_msi_irq_unmask(struct irq_data *d)
+{
+	imx_pcie_mask_irq(d->irq - IRQ_IMX_MSI_0, 0);
+	return unmask_msi_irq(d);
+}
+
+static struct irq_chip imx_msi_chip = {
+	.name = "PCIe-MSI",
+	.irq_ack = imx_msi_irq_ack,
+	.irq_enable = imx_msi_irq_enable,
+	.irq_disable = imx_msi_irq_disable,
+	.irq_mask = imx_msi_irq_mask,
+	.irq_unmask = imx_msi_irq_unmask,
+};
+
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int irq = create_irq();
+	struct msi_msg msg;
+
+	if (irq < 0)
+		return irq;
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_hi = 0x0;
+	msg.address_lo = MSI_MATCH_ADDR;
+	/* 16bits msg.data: set cpu type to the upper 8bits*/
+	msg.data = (mxc_cpu_type << 8) | ((irq - IRQ_IMX_MSI_0) & 0xFF);
+
+	write_msi_msg(irq, &msg);
+	irq_set_chip_and_handler(irq, &imx_msi_chip, handle_simple_irq);
+	set_irq_flags(irq, IRQF_VALID);
+	pr_info("IMX-PCIe: MSI 0x%04x @%#x:%#x, irq = %d\n",
+			msg.data, msg.address_hi,
+			msg.address_lo, irq);
+	return 0;
+}
+
+void imx_msi_init(void)
+{
+	irq_set_chained_handler(MXC_INT_PCIE_0, imx_msi_handler);
+}
diff --git a/arch/arm/mach-mx6/msi.h b/arch/arm/mach-mx6/msi.h
new file mode 100644
index 0000000..ce0e467
--- /dev/null
+++ b/arch/arm/mach-mx6/msi.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2013 Boundary Devices, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+extern void imx_pcie_enable_irq(unsigned pos, int set);
+void imx_pcie_mask_irq(unsigned pos, int set);
+unsigned imx_pcie_msi_pending(unsigned index);
+
+#define MSI_MATCH_ADDR  0x01FF8000
+
+void imx_msi_init(void);
diff --git a/arch/arm/mach-mx6/mx6_bt_rfkill.c b/arch/arm/mach-mx6/mx6_bt_rfkill.c
new file mode 100644
index 0000000..3b256e9
--- /dev/null
+++ b/arch/arm/mach-mx6/mx6_bt_rfkill.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file mx6_bt_rfkill.c
+ *
+ * @brief This driver is implement a rfkill control interface of bluetooth
+ * chip on i.MX serial boards. Register the power regulator function and
+ * reset function in platform data.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+#include <linux/init.h>
+#include <linux/rfkill.h>
+#include <mach/hardware.h>
+#include <mach/imx_rfkill.h>
+
+static int system_in_suspend;
+
+static int mxc_bt_set_block(void *rfkdata, bool blocked)
+{
+	struct imx_bt_rfkill_platform_data *data = rfkdata;
+	int ret;
+
+	/* Bluetooth stack will reset the bluetooth chip during
+	 * resume, since we keep bluetooth's power during suspend,
+	 * don't let rfkill to actually reset the chip. */
+	if (system_in_suspend)
+		return 0;
+	pr_info("rfkill: BT RF going to : %s\n", blocked ? "off" : "on");
+	if (!blocked)
+		ret = data->power_change(1);
+	else
+		ret = data->power_change(0);
+
+	return ret;
+}
+
+static const struct rfkill_ops mxc_bt_rfkill_ops = {
+	.set_block = mxc_bt_set_block,
+};
+
+static int mxc_bt_power_event(struct notifier_block *this,
+			      unsigned long event, void *dummy)
+{
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+		system_in_suspend = 1;
+		/* going to suspend, don't reset chip */
+		break;
+	case PM_POST_SUSPEND:
+		system_in_suspend = 0;
+		/* System is resume, can reset chip */
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block mxc_bt_power_notifier = {
+	.notifier_call = mxc_bt_power_event,
+};
+
+static int mxc_bt_rfkill_probe(struct platform_device *dev)
+{
+	int rc;
+	struct rfkill *rfk;
+
+	struct imx_bt_rfkill_platform_data *data = dev->dev.platform_data;
+
+	if (data->power_change == NULL) {
+		rc = -EINVAL;
+		dev_err(&dev->dev, "no power_change function\n");
+		goto error_check_func;
+	}
+
+	rc = register_pm_notifier(&mxc_bt_power_notifier);
+	if (rc)
+		goto error_check_func;
+
+	rfk = rfkill_alloc("mxc-bt", &dev->dev, RFKILL_TYPE_BLUETOOTH,
+			   &mxc_bt_rfkill_ops, data);
+
+	if (!rfk) {
+		rc = -ENOMEM;
+		goto error_rfk_alloc;
+	}
+
+	rc = rfkill_register(rfk);
+	if (rc)
+		goto error_rfkill;
+
+	platform_set_drvdata(dev, rfk);
+	printk(KERN_INFO "mxc_bt_rfkill driver success loaded\n");
+	return 0;
+
+error_rfkill:
+	rfkill_destroy(rfk);
+error_rfk_alloc:
+error_check_func:
+	return rc;
+}
+
+static int __devexit mxc_bt_rfkill_remove(struct platform_device *dev)
+{
+	struct imx_bt_rfkill_platform_data *data = dev->dev.platform_data;
+	struct rfkill *rfk = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	if (rfk) {
+		rfkill_unregister(rfk);
+		rfkill_destroy(rfk);
+	}
+
+	data->power_change(0);
+
+	return 0;
+}
+
+static struct platform_driver mxc_bt_rfkill_driver = {
+	.driver = {
+		.name = "mxc_bt_rfkill",
+	},
+	.probe	= mxc_bt_rfkill_probe,
+	.remove = __devexit_p(mxc_bt_rfkill_remove),
+};
+
+static int __init mxc_bt_rfkill_init(void)
+{
+	return platform_driver_register(&mxc_bt_rfkill_driver);
+}
+
+module_init(mxc_bt_rfkill_init);
+
+static void __exit mxc_bt_rfkill_exit(void)
+{
+	platform_driver_unregister(&mxc_bt_rfkill_driver);
+}
+
+module_exit(mxc_bt_rfkill_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("RFKill control interface of BT on MX6 Platform");
diff --git a/arch/arm/mach-mx6/mx6_ddr_freq.S b/arch/arm/mach-mx6/mx6_ddr_freq.S
index 19fb491..de20f0c 100644
--- a/arch/arm/mach-mx6/mx6_ddr_freq.S
+++ b/arch/arm/mach-mx6/mx6_ddr_freq.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -103,11 +103,24 @@ periph_clk_switch4:
 	cmp     r0, #0
 	bne     periph_clk_switch4
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround1
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround1
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0xA
 	str     r0, [r6, #0x1C]
+skip_gpt_workaround1:
 	.endm
 
 	.macro   switch_to_400MHz
@@ -193,12 +206,24 @@ wait_div_update400_2:
 	cmp     r0, #0
 	bne     wait_div_update400_2
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround2
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround2
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0xA
 	str     r0, [r6, #0x1C]
-
+skip_gpt_workaround2:
 	.endm
 
 	.macro   switch_to_50MHz
@@ -265,11 +290,24 @@ periph_clk_switch2:
 	cmp    r0, #0
 	bne     periph_clk_switch2
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround3
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround3
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0x1
 	str     r0, [r6, #0x1C]
+skip_gpt_workaround3:
 
 	.endm
 
@@ -311,11 +349,24 @@ wait_div_update:
 	cmp    r0, #0
 	bne     wait_div_update
 
+	ldr     r0, =ANATOP_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0, #0x260]
+	mov	r2, r1
+	/*Is mx6q?*/
+	and	r1, r1, #0xff0000
+	cmp	r1, #0x630000
+	bne	skip_gpt_workaround4
+	/*Is mx6q TO1.0?*/
+	and	r2, r2, #0xff
+	cmp	r2, #0x0
+	bne	skip_gpt_workaround4
 	/* Change the GPT divider so that its at 6MHz. */
 	ldr     r0, [r6, #0x1C]
 	bic     r0, r0, #0x3F
 	orr     r0, r0, #0x1
 	str     r0, [r6, #0x1C]
+skip_gpt_workaround4:
 
 	.endm
 
@@ -350,20 +401,6 @@ ddr_freq_change:
 
 	adr   r10, ddr_freq_change               @Address in this function.
 
-
-	mcr   p15, 0, r10, c8, c7, 1      @//@ Make sure freq code address
-	                                       @//  @ is not already in TLB.
-	mcr   p15, 0, r6, c8, c7, 1      @//@ Make sure CCM address
-	                                         @//@ is not already in TLB.
-	mcr   p15, 0, r5, c8, c7, 1      @//@ make sure MMDC address
-	                                         @//@ is not already in TLB.
-	mcr   p15, 0, r7, c8, c7, 1      @//@ make sure IOMUX address
-	                                         @//@ is not already in TLB.
-
-	mrc   p15, 0, r0, c10, c0, 0    @//@ Read the TLB lockdown register
-	orr    r0, r0, #1                    @//@ Set the Preserve bit.
-	mcr   p15, 0, r0, c10, c0, 0    @//@ Write to the lockdown register
-
 	ldr    r2, [r6]                        @ TLB will miss,
 	                                         @CCM address will be loaded
 	ldr    r2, [r5]                        @ TLB will miss,
@@ -372,18 +409,33 @@ ddr_freq_change:
 	                                         @IOMUX will be loaded
 
 	ldr    r2, [r8]                        @ Get the DDR settings.
-
 	ldr    r2, [r10]                        @ TLB will miss
-
 	ldr    r2, [r11]				@Get the IOMUX settings
 
-	mrc  p15, 0, r0, c10, c0, 0      @//@ Read the lockdown register
-	                                             @//@ (victim will be incremented)
-	bic   r0, r0, #1                     @//@ Clear the preserve bit
-	mcr   p15, 0, r0, c10, c0, 0     @//@ Write to the lockdown register
+	/* Make sure all the L1 & L2 buffers are drained, as
+	  * we don't want any writes to the DDR when it is
+	  * in self-refresh.
+	  */
+	/* Make sure the L1 buffers are drained. */
+	dsb
 
-	/* Disable automatic power saving. */
+#ifdef CONFIG_CACHE_L2X0
+	/* Make sure the L2 buffers are drained.
+	  * Sync operation on L2 drains the buffers.
+	  */
+	ldr      r0, =L2_BASE_ADDR
+	add     r0, r0, #PERIPBASE_VIRT
+	mov    r1, #0x0
+	str      r1, [r0, #0x730]
+#endif
+
+     /* The second dsb might be needed to keep cache sync (device write)
+       * ordering with the memory accesses before it.
+       */
+	dsb
+	isb
 
+	/* Disable automatic power saving. */
 	ldr    r0, [r5, #0x404]
 	orr    r0, r0, #0x01
 	str    r0, [r5, #0x404]
diff --git a/arch/arm/mach-mx6/mx6sl_ddr.S b/arch/arm/mach-mx6/mx6sl_ddr.S
index 3059f3a..9e83985 100644
--- a/arch/arm/mach-mx6/mx6sl_ddr.S
+++ b/arch/arm/mach-mx6/mx6sl_ddr.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -116,13 +116,6 @@ mmdc_podf0:
 
 	  .macro	ddr_switch_400MHz
 
-     /* Check if we are switching between
-       * 400Mhz <-> 50MHz. If so, we only need to
-       * update MMDC divider.
-       */
-      cmp    r1, #0
-      beq     change_divider_only
-
     /* Set MMDC divider first, in case PLL3 is at 480MHz. */
       ldr     r6, [r3, #0x10]
       and    r6, r6, #0x10000
@@ -141,6 +134,13 @@ mmdc_podf:
 
 pll3_in_bypass:
 
+     /* Check if we are switching between
+       * 400Mhz <-> 100MHz.If so, we should
+       * try to source MMDC from PLL2_200M.
+       */
+      cmp    r1, #0
+      beq     not_low_bus_freq
+
      /* Ensure that MMDC is sourced from PLL2 mux first. */
      ldr     r6, [r2, #0x14]
      bic     r6, r6, #0x4000000
@@ -151,6 +151,7 @@ periph2_clk_switch4:
      cmp     r6, #0
      bne     periph2_clk_switch4
 
+not_low_bus_freq:
      /* Now ensure periph2_clk2_sel mux is set to PLL3 */
      ldr     r6, [r2, #0x18]
      bic     r6, r6, #0x100000
@@ -166,6 +167,12 @@ periph2_clk_switch5:
      cmp     r6, #0
      bne     periph2_clk_switch5
 
+     /* Check if PLL2 is already unlocked.
+       * If so do nothing with PLL2.
+       */
+     cmp    r1, #0
+     beq	pll2_already_on
+
      /* Now power up PLL2 and unbypass it. */
      ldr    r6, [r3, #0x30]
      bic    r6, r6, #0x1000
@@ -192,27 +199,43 @@ wait_for_pll_lock:
      bic    r6, r6, #0x800000
      str     r6, [r3, #0x100]
 
+pll2_already_on:
     /* Now switch MMDC clk back to pll2_mux option. */
     /* Ensure pre_periph2_clk2 is set to pll2_pfd_400M */
+    /* If switching to audio DDR freq, set the
+     * pre_periph2_clk2 to PLL2_PFD_200M
+     */
+    ldr     r6, =400000000
+    cmp   r6, r0
+    bne    use_pll2_pfd_200M
+
      ldr     r6, [r2, #0x18]
      bic     r6, r6, #0x600000
      orr     r6, r6, #0x200000
      str     r6, [r2, #0x18]
+     ldr     r6, =400000000
+     b       cont2
 
-     ldr     r6, [r2, #0x14]
-     bic     r6, r6, #0x4000000
-     str     r6, [r2, #0x14]
+use_pll2_pfd_200M:
+     ldr     r6, [r2, #0x18]
+     orr     r6, r6, #0x600000
+     str     r6, [r2, #0x18]
+     ldr     r6, =200000000
+
+cont2:
+     ldr     r4, [r2, #0x14]
+     bic     r4, r4, #0x4000000
+     str     r4, [r2, #0x14]
 
 periph2_clk_switch6:
-     ldr     r6, [r2, #0x48]
-     cmp     r6, #0
+     ldr     r4, [r2, #0x48]
+     cmp     r4, #0
      bne     periph2_clk_switch6
 
 change_divider_only:
     /* Calculate the MMDC divider
      * based on the requested freq.
      */
-    ldr    r6, =400000000
     ldr    r4, =0
 Loop2:
     sub    r6, r6, r0
@@ -306,7 +329,7 @@ force_measure1:
  */
 ENTRY(mx6sl_ddr_iram)
 
-    push {r4, r5, r6, r7, r8, r9, r10 }
+    push {r4-r10}
 
 mx6sl_ddr_freq_change:
     ldr     r3, =ANATOP_BASE_ADDR
@@ -326,6 +349,21 @@ mx6sl_ddr_freq_change:
     ldr     r6, [r3]
     ldr     r6, [r2]
 
+     /* Drain all the L1 buffers. */
+     dsb
+
+#ifdef CONFIG_CACHE_L2X0
+    /* Need to make sure the buffers in L2 are drained.
+      * Performing a sync operation does this. */
+     ldr     r7, =L2_BASE_ADDR
+     add   r7, r7, #PERIPBASE_VIRT
+     mov  r6, #0x0
+     str    r6, [r7, #0x730]
+#endif
+
+     /* The second dsb might be needed to keep cache sync (device write)
+       * ordering with the memory accesses before it.
+       */
      dsb
      isb
 
@@ -421,7 +459,7 @@ skip_power_down:
      bic     r6, r6, #0x100
      str     r6, [r8, #0x410]
 
-    pop {r4,r5, r6, r7, r8, r9, r10}
+    pop {r4-r10}
 
     /* Restore registers */
     mov     pc, lr
diff --git a/arch/arm/mach-mx6/mx6sl_wfi.S b/arch/arm/mach-mx6/mx6sl_wfi.S
index 4ec97e4..bd5a00c 100644
--- a/arch/arm/mach-mx6/mx6sl_wfi.S
+++ b/arch/arm/mach-mx6/mx6sl_wfi.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -158,9 +158,11 @@ fifo_reset2_wait:
  */
 ENTRY(mx6sl_wait)
 
-    push {r4, r5, r6, r7, r8, r9, r10}
+    push {r4-r11}
 
 mx6sl_lpm_wfi:
+    mov    r11, r2
+
     /* Get the IRAM data storage address. */
     mov    r10, r1
     mov	r9, r1 		/* get suspend_iram_base */
@@ -192,7 +194,23 @@ mx6sl_lpm_wfi:
     ldr     r6, [r2]
     ldr     r6, [r1]
 
+     /* Drain all the L1 buffers. */
+     dsb
+
+#ifdef CONFIG_CACHE_L2X0
+    /* Need to make sure the buffers in L2 are drained.
+      * Performing a sync operation does this. */
+     ldr     r7, =L2_BASE_ADDR
+     add   r7, r7, #PERIPBASE_VIRT
+     mov  r6, #0x0
+     str    r6, [r7, #0x730]
+#endif
+
+     /* The second dsb might be needed to keep cache sync (device write)
+       * ordering with the memory accesses before it.
+       */
      dsb
+     isb
 
      /* Disable Automatic power savings. */
      ldr    r6, [r8, #0x404]
@@ -215,6 +233,9 @@ poll_dvfs_set_1:
      orr     r6, r6, #0x100
      str     r6, [r8, #0x410]
 
+     cmp      r11, #1
+     beq      audio_mode
+
      /* Now set DDR rate to 1MHz. */
      /* DDR is from bypassed PLL2 on periph2_clk2 path.
        * Set the periph2_clk2_podf to divide by 8.
@@ -228,6 +249,15 @@ poll_dvfs_set_1:
      bic    r6, r6, #0x38
      orr    r6, r6, #0x10
      str     r6, [r2, #0x14]
+     b       mmdc_podf
+
+audio_mode:
+     /* MMDC is from PLL2_200M.
+       * Set the mmdc_podf to div by 8.
+       */
+     ldr    r6, [r2, #0x14]
+     orr    r6, r6, #0x38
+     str     r6, [r2, #0x14]
 
     /* Loop till podf is accepted. */
 mmdc_podf:
@@ -238,6 +268,9 @@ mmdc_podf:
       /* Set the DDR IO in LPM state. */
      sl_ddr_io_set_lpm
 
+     cmp      r11, #1
+     beq      do_audio_arm_clk
+
      /* Check if none of the PLLs are
       * locked, except PLL1 which will get
       * bypassed below.
@@ -378,6 +411,30 @@ podf_loop:
      orr     r6, r6, #0x1
      str     r6, [r3, #0x150]
 
+     b      do_wfi
+
+do_audio_arm_clk:
+    /* ARM is from PLL2_PFD2_400M here.
+      * Switch ARM to bypassed PLL1.
+      */
+     ldr    r6, [r2, #0xC]
+     bic   r6, r6, #0x4
+     str   r6, [r2, #0xC]
+
+     /* Set the ARM_PODF to divide by 2
+      * as IPG is at 4MHz, we cannot run
+      * ARM_CLK above 9.6MHz when
+      * system enters WAIT mode.
+      */
+    ldr    r6, =0x2
+    str    r6, [r2, #0x10]
+
+    /* Loop till podf is accepted. */
+podf_loop_audio:
+     ldr     r6, [r2, #0x48]
+     cmp   r6, #0x0
+     bne   podf_loop_audio
+
 do_wfi:
      /* Now do WFI. */
      wfi
@@ -391,6 +448,9 @@ podf_loop1:
      cmp   r6, #0x0
      bne   podf_loop1
 
+     cmp    r11, #1
+     beq    audio_arm_clk_restore
+
       /* Check if powered down
         * analog components.
         */
@@ -473,12 +533,24 @@ ahb_podf1:
      cmp   r6, #0x0
      bne   podf_loop1
 
-    mov	r9, r10 		/* get suspend_iram_base */
+     b     wfi_restore
+
+audio_arm_clk_restore:
+     /* Move ARM back to PLL2_PFD2_400M */
+     ldr    r6, [r2, #0xC]
+     orr   r6, r6, #0x4
+     str   r6, [r2, #0xC]
+
+wfi_restore:
+     mov	r9, r10 		/* get suspend_iram_base */
      add	r9, r9, #IRAM_WAIT_SIZE	/* 4K */
 
     /* Restore the DDR IO before exiting self-refresh. */
      sl_ddr_io_restore
 
+     cmp     r11, #1
+     beq     mmdc_audio_restore
+
     /* Set MMDC back to 24MHz. */
     /* Set periph2_clk2_podf to divide by 1. */
      /* Now set MMDC PODF to divide by 1. */
@@ -486,6 +558,15 @@ ahb_podf1:
      bic   r6, r6, #0x3f
      str    r6, [r2, #0x14]
 
+     b     mmdc_podf1
+
+mmdc_audio_restore:
+     /* Set MMDC back to 100MHz. */
+     ldr    r6, [r2, #0x14]
+     bic   r6, r6, #0x38
+     orr   r6, r6, #0x8
+     str    r6, [r2, $0x14]
+
 mmdc_podf1:
      ldr     r6, [r2, #0x48]
      cmp   r6, #0x0
@@ -549,7 +630,7 @@ poll_dvfs_clear_1:
      str     r6, [r8, #0x410]
 
 
-    pop {r4,r5, r6, r7, r8, r9, r10}
+    pop {r4-r11}
 
     /* Restore registers */
     mov     pc, lr
diff --git a/arch/arm/mach-mx6/pcie.c b/arch/arm/mach-mx6/pcie.c
index f39dd3d..fa37e07 100644
--- a/arch/arm/mach-mx6/pcie.c
+++ b/arch/arm/mach-mx6/pcie.c
@@ -3,7 +3,7 @@
  *
  * PCIe host controller driver for IMX6 SOCs
  *
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Bits taken from arch/arm/mach-dove/pcie.c
  *
@@ -29,13 +29,19 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
+#include <linux/slab.h>
 #include <linux/platform_device.h>
+#include <linux/time.h>
 
 #include <mach/pcie.h>
 
 #include <asm/sizes.h>
+#include <asm/signal.h>
 
 #include "crm_regs.h"
+#ifdef CONFIG_PCI_MSI
+#include "msi.h"
+#endif
 
 /* Register Definitions */
 #define PRT_LOG_R_BaseAddress 0x700
@@ -66,29 +72,6 @@
 #define ATU_REGION_LOW_TRGT_ADDR_R (ATU_R_BaseAddress + 0x18)
 #define ATU_REGION_UP_TRGT_ADDR_R (ATU_R_BaseAddress + 0x1C)
 
-/* GPR1: iomuxc_gpr1_pcie_ref_clk_en(iomuxc_gpr1[16]) */
-#define iomuxc_gpr1_pcie_ref_clk_en		(1 << 16)
-/* GPR1: iomuxc_gpr1_test_powerdown(iomuxc_gpr1_18) */
-#define iomuxc_gpr1_test_powerdown		(1 << 18)
-
-/* GPR12: iomuxc_gpr12_los_level(iomuxc_gpr12[8:4]) */
-#define iomuxc_gpr12_los_level			(0x1F << 4)
-/* GPR12: iomuxc_gpr12_app_ltssm_enable(iomuxc_gpr12[10]) */
-#define iomuxc_gpr12_app_ltssm_enable		(1 << 10)
-/* GPR12: iomuxc_gpr12_device_type(iomuxc_gpr12[15:12]) */
-#define iomuxc_gpr12_device_type		(0xF << 12)
-
-/* GPR8: iomuxc_gpr8_tx_deemph_gen1(iomuxc_gpr8[5:0]) */
-#define iomuxc_gpr8_tx_deemph_gen1		(0x3F << 0)
-/* GPR8: iomuxc_gpr8_tx_deemph_gen2_3p5db(iomuxc_gpr8[11:6]) */
-#define iomuxc_gpr8_tx_deemph_gen2_3p5db	(0x3F << 6)
-/* GPR8: iomuxc_gpr8_tx_deemph_gen2_6db(iomuxc_gpr8[17:12]) */
-#define iomuxc_gpr8_tx_deemph_gen2_6db		(0x3F << 12)
-/* GPR8: iomuxc_gpr8_tx_swing_full(iomuxc_gpr8[24:18]) */
-#define iomuxc_gpr8_tx_swing_full		(0x7F << 18)
-/* GPR8: iomuxc_gpr8_tx_swing_low(iomuxc_gpr8[31:25]) */
-#define iomuxc_gpr8_tx_swing_low		(0x7F << 25)
-
 /* Registers of PHY */
 /* Register PHY_STS_R */
 /* PHY Status Register */
@@ -158,6 +141,18 @@
 #define LNK_CAP_RegisterResetValue 0x011cc12
 #define LNK_CAP_RegisterResetMask 0xffffffff
 
+#ifdef CONFIG_PCI_MSI
+#define PCIE_RC_MSI_CAP   0x50
+
+#define PCIE_PL_MSICA    0x820
+#define PCIE_PL_MSICUA    0x824
+#define PCIE_PL_MSIC_INT  0x828
+
+#define MSIC_INT_EN  0x0
+#define MSIC_INT_MASK  0x4
+#define MSIC_INT_STATUS  0x8
+#endif
+
 /* End of Register Definitions */
 
 #define PCIE_DBI_BASE_ADDR	(PCIE_ARB_END_ADDR - SZ_16K + 1)
@@ -167,6 +162,21 @@
 #define  PCIE_CONF_FUNC(f)		(((f) & 0x7) << 8)
 #define  PCIE_CONF_REG(r)		((r) & ~0x3)
 
+/*
+ * The default values of the RC's reserved ddr memory
+ * used to verify EP mode.
+ * BTW, here is the layout of the 1G ddr on SD boards
+ * 0x1000_0000 ~ 0x4FFF_FFFF
+ */
+static u32 rc_ddr_test_region = 0x40000000;
+static u32 rc_ddr_test_region_size = (SZ_16M - SZ_16K);
+
+#ifdef EP_SELF_IO_TEST
+static void *rc_ddr_test_reg1, *rc_ddr_test_reg2;
+static void __iomem *pcie_arb_base_addr;
+static struct timeval tv1, tv2, tv3;
+static u32 tv_count1, tv_count2;
+#endif
 static void __iomem *base;
 static void __iomem *dbi_base;
 
@@ -235,7 +245,7 @@ static int __init imx_pcie_setup(int nr, struct pci_sys_data *sys)
 	pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
 	pp->res[0].name = pp->io_space_name;
 	if (pp->index == 0) {
-		pp->res[0].start = PCIE_ARB_BASE_ADDR;
+		pp->res[0].start = PCIE_ARB_BASE_ADDR + SZ_16M - SZ_2M;
 		pp->res[0].end = pp->res[0].start + SZ_1M - 1;
 	}
 	pp->res[0].flags = IORESOURCE_IO;
@@ -251,7 +261,7 @@ static int __init imx_pcie_setup(int nr, struct pci_sys_data *sys)
 	pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
 	pp->res[1].name = pp->mem_space_name;
 	if (pp->index == 0) {
-		pp->res[1].start = PCIE_ARB_BASE_ADDR + SZ_1M;
+		pp->res[1].start = PCIE_ARB_BASE_ADDR;
 		pp->res[1].end = pp->res[1].start + SZ_16M - SZ_2M - 1;
 	}
 	pp->res[1].flags = IORESOURCE_MEM;
@@ -299,7 +309,7 @@ static int imx_pcie_link_up(void __iomem *dbi_base)
 					0x0000);
 		}
 
-		if ((iterations < 0))
+		if (iterations == 0)
 			pr_info("link up failed, DB_R0:0x%08x, DB_R1:0x%08x!\n"
 					, readl(dbi_base + DB_R0)
 					, readl(dbi_base + DB_R1));
@@ -310,8 +320,14 @@ static int imx_pcie_link_up(void __iomem *dbi_base)
 	return 1;
 }
 
-static void imx_pcie_regions_setup(void __iomem *dbi_base)
+static void imx_pcie_regions_setup(struct device *dev, void __iomem *dbi_base)
 {
+	struct imx_pcie_platform_data *pdata = dev->platform_data;
+#ifdef CONFIG_PCI_MSI
+	unsigned int i;
+	void __iomem *p = dbi_base + PCIE_PL_MSIC_INT;
+#endif
+
 	/*
 	 * i.MX6 defines 16MB in the AXI address map for PCIe.
 	 *
@@ -319,9 +335,13 @@ static void imx_pcie_regions_setup(void __iomem *dbi_base)
 	 * split and defined into different regions by iATU,
 	 * with sizes and offsets as follows:
 	 *
-	 * 0x0100_0000 --- 0x010F_FFFF 1MB IORESOURCE_IO
-	 * 0x0110_0000 --- 0x01EF_FFFF 14MB IORESOURCE_MEM
-	 * 0x01F0_0000 --- 0x01FF_FFFF 1MB Cfg + Registers
+	 * RC:
+	 * 0x0100_0000 --- 0x01DF_FFFF 14MB IORESOURCE_MEM
+	 * 0x01E0_0000 --- 0x01EF_FFFF 1MB IORESOURCE_IO
+	 * 0x01F0_0000 --- 0x01FF_FFFF 1MB Cfg + MSI + Registers
+	 *
+	 * EP (default value):
+	 * 0x0100_0000 --- 0x01FF_C000 16MB - 16KB IORESOURCE_MEM
 	 */
 
 	/* CMD reg:I/O space, MEM space, and Bus Master Enable */
@@ -331,43 +351,187 @@ static void imx_pcie_regions_setup(void __iomem *dbi_base)
 			| PCI_COMMAND_MASTER,
 			dbi_base + PCI_COMMAND);
 
-	/* Set the CLASS_REV of RC CFG header to PCI_CLASS_BRIDGE_PCI */
-	writel(readl(dbi_base + PCI_CLASS_REVISION)
-			| (PCI_CLASS_BRIDGE_PCI << 16),
-			dbi_base + PCI_CLASS_REVISION);
+	if (pdata->type_ep) {
+		/*
+		 * configure the class_rev(emaluate one memory ram ep device),
+		 * bar0 and bar1 of ep
+		 */
+		writel(0xdeadbeaf, dbi_base + PCI_VENDOR_ID);
+		writel(readl(dbi_base + PCI_CLASS_REVISION)
+				| (PCI_CLASS_MEMORY_RAM	<< 16),
+				dbi_base + PCI_CLASS_REVISION);
+		writel(0xdeadbeaf, dbi_base + PCI_SUBSYSTEM_VENDOR_ID);
+
+		/* 32bit none-prefetchable 8M bytes memory on bar0 */
+		writel(0x0, dbi_base + PCI_BASE_ADDRESS_0);
+		writel(SZ_8M - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_0);
+
+		/* None used bar1 */
+		writel(0x0, dbi_base + PCI_BASE_ADDRESS_1);
+		writel(0, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_1);
+
+		/* 4K bytes IO on bar2 */
+		writel(0x1, dbi_base + PCI_BASE_ADDRESS_2);
+		writel(SZ_4K - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_2);
+
+		/*
+		 * 32bit prefetchable 1M bytes memory on bar3
+		 * FIXME BAR MASK3 is not changable, the size
+		 * is fixed to 256 bytes.
+		 */
+		writel(0x8, dbi_base + PCI_BASE_ADDRESS_3);
+		writel(SZ_1M - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_3);
 
-	/*
-	 * region0 outbound used to access target cfg
-	 */
-	writel(0, dbi_base + ATU_VIEWPORT_R);
-	writel(PCIE_ARB_END_ADDR - SZ_1M + 1, dbi_base + ATU_REGION_LOWBASE_R);
-	writel(PCIE_ARB_END_ADDR, dbi_base + ATU_REGION_LIMIT_ADDR_R);
-	writel(0, dbi_base + ATU_REGION_UPBASE_R);
-
-	writel(0, dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
-	writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
-	writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
-	writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+		/*
+		 * 64bit prefetchable 1M bytes memory on bar4-5.
+		 * FIXME BAR4,5 are not enabled yet
+		 */
+		writel(0xc, dbi_base + PCI_BASE_ADDRESS_4);
+		writel(SZ_1M - 1, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_4);
+		writel(0, dbi_base + (1 << 12) + PCI_BASE_ADDRESS_5);
+
+		/*
+		 * region0 outbound used to access RC's reserved ddr memory
+		 */
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(PCIE_ARB_BASE_ADDR, dbi_base + ATU_REGION_LOWBASE_R);
+		writel(0, dbi_base + ATU_REGION_UPBASE_R);
+		writel(PCIE_ARB_BASE_ADDR + rc_ddr_test_region_size,
+				dbi_base + ATU_REGION_LIMIT_ADDR_R);
+
+		writel(rc_ddr_test_region,
+				dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
+		writel(MemRdWr, dbi_base + ATU_REGION_CTRL1_R);
+		writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+	} else {
+		/* Set the CLASS_REV of RC CFG header to PCI_CLASS_BRIDGE_PCI */
+		writel(readl(dbi_base + PCI_CLASS_REVISION)
+				| (PCI_CLASS_BRIDGE_PCI << 16),
+				dbi_base + PCI_CLASS_REVISION);
+
+		/*
+		 * region0 outbound used to access target cfg
+		 */
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(PCIE_ARB_END_ADDR - SZ_1M + 1,
+				dbi_base + ATU_REGION_LOWBASE_R);
+		writel(PCIE_ARB_END_ADDR - SZ_64K,
+				dbi_base + ATU_REGION_LIMIT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UPBASE_R);
+
+		writel(0, dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		writel(0, dbi_base + ATU_REGION_UP_TRGT_ADDR_R);
+		writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
+		writel((1<<31), dbi_base + ATU_REGION_CTRL2_R);
+	}
+
+#ifdef CONFIG_PCI_MSI
+	writel(MSI_MATCH_ADDR, dbi_base + PCIE_PL_MSICA);
+	writel(0, dbi_base + PCIE_PL_MSICUA);
+	for (i = 0; i < 8 ; i++) {
+		writel(0, p + MSIC_INT_EN);
+		writel(0xFFFFFFFF, p + MSIC_INT_MASK);
+		writel(0xFFFFFFFF, p + MSIC_INT_STATUS);
+		p += 12;
+	}
+#endif
 }
 
+#ifdef CONFIG_PCI_MSI
+void imx_pcie_mask_irq(unsigned int pos, int set)
+{
+	unsigned int mask = 1 << (pos & 0x1F);
+	unsigned int val, newval;
+	void __iomem *p;
+
+	p = dbi_base + PCIE_PL_MSIC_INT + MSIC_INT_MASK + ((pos >> 5) * 12);
+
+	if (pos >= (8 * 32))
+		return;
+	val = readl(p);
+	if (set)
+		newval = val | mask;
+	else
+		newval = val & ~mask;
+	if (val != newval)
+		writel(newval, p);
+}
+
+void imx_pcie_enable_irq(unsigned int pos, int set)
+{
+	unsigned int mask = 1 << (pos & 0x1F);
+	unsigned int val, newval;
+	void __iomem *p;
+
+	p = dbi_base + PCIE_PL_MSIC_INT + MSIC_INT_EN + ((pos >> 5) * 12);
+
+	/* RC: MSI CAP enable */
+	if (set) {
+		val = readl(dbi_base + PCIE_RC_MSI_CAP);
+		val |= (PCI_MSI_FLAGS_ENABLE << 16);
+		writel(val, dbi_base + PCIE_RC_MSI_CAP);
+	}
+
+	if (pos >= (8 * 32))
+		return;
+	val = readl(p);
+	if (set)
+		newval = val | mask;
+	else
+		newval = val & ~mask;
+	if (val != newval)
+		writel(newval, p);
+	if (set && (val != newval))
+		imx_pcie_mask_irq(pos, 0);  /* unmask when enabled */
+	}
+
+unsigned int imx_pcie_msi_pending(unsigned int index)
+{
+	unsigned int val, mask;
+	void __iomem *p = dbi_base + PCIE_PL_MSIC_INT + (index * 12);
+
+	if (index >= 8)
+		return 0;
+	val = readl(p + MSIC_INT_STATUS);
+	mask = readl(p + MSIC_INT_MASK);
+	val &= ~mask;
+	writel(val, p + MSIC_INT_STATUS);
+	return val;
+}
+#endif
+
 static int imx_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
 			int size, u32 *val)
 {
 	struct imx_pcie_port *pp = bus_to_port(bus->number);
 	u32 va_address;
 
+	/*  Added to change transaction TYPE  */
+	if (bus->number < 2) {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr1, dbi_base + ATU_REGION_CTRL1_R);
+	}
+
 	if (pp) {
 		if (devfn != 0) {
-			*val = 0xffffffff;
+			*val = 0xFFFFFFFF;
 			return PCIBIOS_DEVICE_NOT_FOUND;
 		}
 
 		va_address = (u32)dbi_base + (where & ~0x3);
-	} else
-		va_address = (u32)base + (PCIE_CONF_BUS(bus->number - 1) +
-					  PCIE_CONF_DEV(PCI_SLOT(devfn)) +
-					  PCIE_CONF_FUNC(PCI_FUNC(devfn)) +
-					  PCIE_CONF_REG(where));
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+
+		writel((((PCIE_CONF_BUS(bus->number)
+				+ PCIE_CONF_DEV(PCI_SLOT(devfn))
+				+ PCIE_CONF_FUNC(PCI_FUNC(devfn)))) << 8),
+				dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		va_address = (u32)base + PCIE_CONF_REG(where);
+	}
 
 	*val = readl(va_address);
 
@@ -386,16 +550,29 @@ static int imx_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
 	u32 va_address = 0, mask = 0, tmp = 0;
 	int ret = PCIBIOS_SUCCESSFUL;
 
+	/*  Added to change transaction TYPE  */
+	if (bus->number < 2) {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr0, dbi_base + ATU_REGION_CTRL1_R);
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+		writel(CfgRdWr1, dbi_base + ATU_REGION_CTRL1_R);
+	}
+
 	if (pp) {
 		if (devfn != 0)
 			return PCIBIOS_DEVICE_NOT_FOUND;
 
 		va_address = (u32)dbi_base + (where & ~0x3);
-	} else
-		va_address = (u32)base + (PCIE_CONF_BUS(bus->number - 1) +
-					  PCIE_CONF_DEV(PCI_SLOT(devfn)) +
-					  PCIE_CONF_FUNC(PCI_FUNC(devfn)) +
-					  PCIE_CONF_REG(where));
+	} else {
+		writel(0, dbi_base + ATU_VIEWPORT_R);
+
+		writel((((PCIE_CONF_BUS(bus->number)
+				+ PCIE_CONF_DEV(PCI_SLOT(devfn))
+				+ PCIE_CONF_FUNC(PCI_FUNC(devfn)))) << 8),
+				dbi_base + ATU_REGION_LOW_TRGT_ADDR_R);
+		va_address = (u32)base + PCIE_CONF_REG(where);
+	}
 
 	if (size == 4) {
 		writel(val, va_address);
@@ -413,7 +590,6 @@ static int imx_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
 	tmp |= val << ((where & 0x3) * 8);
 	writel(tmp, va_address);
 exit:
-
 	return ret;
 }
 
@@ -439,7 +615,13 @@ imx_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 
 static int __init imx_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
-	return MXC_INT_PCIE_3;
+       switch (pin) {
+       case 1: return MXC_INT_PCIE_3;
+       case 2: return MXC_INT_PCIE_2;
+       case 3: return MXC_INT_PCIE_1;
+       case 4: return MXC_INT_PCIE_0;
+       default: return -1;
+       }
 }
 
 static struct hw_pci imx_pci __initdata = {
@@ -512,7 +694,7 @@ static int pcie_phy_cr_read(int addr , int *data)
 
 	/* after got ack return data */
 	temp_rd_data = readl(dbi_base + PHY_STS_R);
-	*data = (temp_rd_data & (0xffff << PCIE_CR_STAT_DATA_LOC)) ;
+	*data = (temp_rd_data & (0xFFFF << PCIE_CR_STAT_DATA_LOC)) ;
 
 	/* deassert rd signal */
 	temp_wr_data = 0x0;
@@ -595,18 +777,30 @@ static void imx_pcie_enable_controller(struct device *dev)
 	/* activate PCIE_PWR_EN */
 	gpio_direction_output(pdata->pcie_pwr_en, 1);
 
-	imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 0 << 18, IOMUXC_GPR1);
+	imx_pcie_clrset(IOMUXC_GPR1_TEST_POWERDOWN, 0 << 18, IOMUXC_GPR1);
+
 
 	/* enable the clks */
-	pcie_clk = clk_get(NULL, "pcie_clk");
-	if (IS_ERR(pcie_clk))
-		pr_err("no pcie clock.\n");
+	if (pdata->type_ep) {
+		pcie_clk = clk_get(NULL, "pcie_ep_clk");
+		if (IS_ERR(pcie_clk))
+			pr_err("no pcie_ep clock.\n");
 
-	if (clk_enable(pcie_clk)) {
-		pr_err("can't enable pcie clock.\n");
-		clk_put(pcie_clk);
+		if (clk_enable(pcie_clk)) {
+			pr_err("can't enable pcie_ep clock.\n");
+			clk_put(pcie_clk);
+		}
+	} else {
+		pcie_clk = clk_get(NULL, "pcie_clk");
+		if (IS_ERR(pcie_clk))
+			pr_err("no pcie clock.\n");
+
+		if (clk_enable(pcie_clk)) {
+			pr_err("can't enable pcie clock.\n");
+			clk_put(pcie_clk);
+		}
 	}
-	imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 1 << 16, IOMUXC_GPR1);
+	imx_pcie_clrset(IOMUXC_GPR1_PCIE_REF_CLK_EN, 1 << 16, IOMUXC_GPR1);
 }
 
 static void card_reset(struct device *dev)
@@ -644,8 +838,8 @@ static void __init add_pcie_port(void __iomem *base, void __iomem *dbi_base,
 		memset(pp->res, 0, sizeof(pp->res));
 	} else {
 		pr_info("IMX PCIe port: link down!\n");
-		/* Release the clocks, and disable the power */
 
+		/* Release the clocks, and disable the power */
 		pcie_clk = clk_get(NULL, "pcie_clk");
 		if (IS_ERR(pcie_clk))
 			pr_err("no pcie clock.\n");
@@ -653,7 +847,7 @@ static void __init add_pcie_port(void __iomem *base, void __iomem *dbi_base,
 		clk_disable(pcie_clk);
 		clk_put(pcie_clk);
 
-		imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 0 << 16,
+		imx_pcie_clrset(IOMUXC_GPR1_PCIE_REF_CLK_EN, 0 << 16,
 				IOMUXC_GPR1);
 
 		/* Disable PCIE power */
@@ -662,103 +856,278 @@ static void __init add_pcie_port(void __iomem *base, void __iomem *dbi_base,
 		/* activate PCIE_PWR_EN */
 		gpio_direction_output(pdata->pcie_pwr_en, 0);
 
-		imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 1 << 18,
+		imx_pcie_clrset(IOMUXC_GPR1_TEST_POWERDOWN, 1 << 18,
 				IOMUXC_GPR1);
 	}
 }
 
+/*  Added for PCI abort handling */
+static int imx6q_pcie_abort_handler(unsigned long addr,
+		unsigned int fsr, struct pt_regs *regs)
+{
+	/*
+	 * If it was an imprecise abort, then we need to correct the
+	 * return address to be _after_ the instruction.
+	 */
+	if (fsr & (1 << 10))
+		regs->ARM_pc += 4;
+	return 0;
+}
+
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+static ssize_t imx_pcie_rc_memw_info(struct device *dev,
+		struct device_attribute *devattr, char *buf)
+{
+	return sprintf(buf, "imx-pcie-rc-memw-info start 0x%08x, size 0x%08x\n",
+			rc_ddr_test_region, rc_ddr_test_region_size);
+}
+
+static ssize_t
+imx_pcie_rc_memw_start(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 memw_start;
+
+	sscanf(buf, "%x\n", &memw_start);
+
+	if (memw_start < 0x10000000) {
+		dev_err(dev, "Invalid memory start address.\n");
+		dev_info(dev, "For example: echo 0x41000000 > /sys/...");
+		return -1;
+	}
+
+	if (rc_ddr_test_region != memw_start) {
+		rc_ddr_test_region = memw_start;
+		/* Re-setup the iATU */
+		imx_pcie_regions_setup(dev, dbi_base);
+	}
+
+	return count;
+}
+
+static ssize_t
+imx_pcie_rc_memw_size(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	u32 memw_size;
+
+	sscanf(buf, "%x\n", &memw_size);
+
+	if ((memw_size > (SZ_16M - SZ_16K)) || (memw_size < SZ_64K)) {
+		dev_err(dev, "Invalid, should be [SZ_64K,SZ_16M - SZ_16KB].\n");
+		dev_info(dev, "For example: echo 0x800000 > /sys/...");
+		return -1;
+	}
+
+	if (rc_ddr_test_region_size != memw_size) {
+		rc_ddr_test_region_size = memw_size;
+		/* Re-setup the iATU */
+		imx_pcie_regions_setup(dev, dbi_base);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(rc_memw_info, S_IRUGO, imx_pcie_rc_memw_info, NULL);
+static DEVICE_ATTR(rc_memw_start_set, S_IWUGO, NULL, imx_pcie_rc_memw_start);
+static DEVICE_ATTR(rc_memw_size_set, S_IWUGO, NULL, imx_pcie_rc_memw_size);
+
+static struct attribute *imx_pcie_attrs[] = {
+	/*
+	 * The start address, and the limitation (64KB ~ (16MB - 16KB))
+	 * of the ddr mem window reserved by RC, and used for EP to access.
+	 * BTW, these attrs are only configured at EP side.
+	 */
+	&dev_attr_rc_memw_info.attr,
+	&dev_attr_rc_memw_start_set.attr,
+	&dev_attr_rc_memw_size_set.attr,
+	NULL
+};
+
+static struct attribute_group imx_pcie_attrgroup = {
+	.attrs	= imx_pcie_attrs,
+};
+#endif
+
 static int __devinit imx_pcie_pltfm_probe(struct platform_device *pdev)
 {
+#ifdef EP_SELF_IO_TEST
+	int i;
+#endif
+	int ret = 0;
 	struct resource *mem;
 	struct device *dev = &pdev->dev;
 	struct imx_pcie_platform_data *pdata = dev->platform_data;
 
+	pr_info("iMX6 PCIe %s mode %s entering.\n",
+			pdata->type_ep ? "PCIe EP" : "PCIe RC", __func__);
+
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem) {
 		dev_err(dev, "no mmio space\n");
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+	/* add attributes for device */
+	ret = sysfs_create_group(&pdev->dev.kobj, &imx_pcie_attrgroup);
+	if (ret)
+		return -EINVAL;
+#endif
+
+	/*  Added for PCI abort handling */
+	hook_fault_code(16 + 6, imx6q_pcie_abort_handler, SIGBUS, 0,
+			"imprecise external abort");
+
 	base = ioremap_nocache(PCIE_ARB_END_ADDR - SZ_1M + 1, SZ_1M - SZ_16K);
 	if (!base) {
 		pr_err("error with ioremap in function %s\n", __func__);
-		return -EIO;
+		ret = PTR_ERR(base);
+#ifdef CONFIG_IMX_PCIE_EP_MODE_IN_EP_RC_SYS
+		sysfs_remove_group(&pdev->dev.kobj, &imx_pcie_attrgroup);
+#endif
+		return ret;
 	}
 
 	dbi_base = devm_ioremap(dev, mem->start, resource_size(mem));
 	if (!dbi_base) {
 		dev_err(dev, "can't map %pR\n", mem);
-		return -ENOMEM;
+		ret = PTR_ERR(dbi_base);
+		goto err_base;
 	}
 
 	/* FIXME the field name should be aligned to RM */
-	imx_pcie_clrset(iomuxc_gpr12_app_ltssm_enable, 0 << 10, IOMUXC_GPR12);
+	imx_pcie_clrset(IOMUXC_GPR12_APP_LTSSM_ENABLE, 0 << 10, IOMUXC_GPR12);
 
 	/* configure constant input signal to the pcie ctrl and phy */
-	imx_pcie_clrset(iomuxc_gpr12_device_type, PCI_EXP_TYPE_ROOT_PORT << 12,
-			IOMUXC_GPR12);
-	imx_pcie_clrset(iomuxc_gpr12_los_level, 9 << 4, IOMUXC_GPR12);
+	if (pdata->type_ep & 1)
+		/* EP */
+		imx_pcie_clrset(IOMUXC_GPR12_DEVICE_TYPE,
+				PCI_EXP_TYPE_ENDPOINT	<< 12, IOMUXC_GPR12);
+	else
+		/* RC */
+		imx_pcie_clrset(IOMUXC_GPR12_DEVICE_TYPE,
+				PCI_EXP_TYPE_ROOT_PORT << 12, IOMUXC_GPR12);
+	imx_pcie_clrset(IOMUXC_GPR12_LOS_LEVEL, 9 << 4, IOMUXC_GPR12);
 
-	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen1, 0 << 0, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen2_3p5db, 0 << 6, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_deemph_gen2_6db, 20 << 12, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_swing_full, 127 << 18, IOMUXC_GPR8);
-	imx_pcie_clrset(iomuxc_gpr8_tx_swing_low, 127 << 25, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_DEEMPH_GEN1, 0 << 0, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_DEEMPH_GEN2_3P5DB, 0 << 6, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_DEEMPH_GEN2_6DB, 20 << 12, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_SWING_FULL, 127 << 18, IOMUXC_GPR8);
+	imx_pcie_clrset(IOMUXC_GPR8_TX_SWING_LOW, 127 << 25, IOMUXC_GPR8);
 
 	/* Enable the pwr, clks and so on */
 	imx_pcie_enable_controller(dev);
+	if (!(pdata->type_ep)) {
+		/*Only RC: togle the external card's reset */
+		card_reset(dev) ;
 
-	/* togle the external card's reset */
-	card_reset(dev) ;
-
-	usleep_range(3000, 4000);
-	imx_pcie_regions_setup(dbi_base);
-	usleep_range(3000, 4000);
+		imx_pcie_regions_setup(dev, dbi_base);
+	}
 
+	pr_info("PCIE: %s start link up.\n", __func__);
 	/* start link up */
-	imx_pcie_clrset(iomuxc_gpr12_app_ltssm_enable, 1 << 10, IOMUXC_GPR12);
-
-	/* add the pcie port */
-	add_pcie_port(base, dbi_base, pdata);
-
+	imx_pcie_clrset(IOMUXC_GPR12_APP_LTSSM_ENABLE, 1 << 10, IOMUXC_GPR12);
+
+	if (pdata->type_ep) {
+#ifdef EP_SELF_IO_TEST
+		/* Prepare the test regions and data */
+		rc_ddr_test_reg1 = kzalloc(rc_ddr_test_region_size, GFP_KERNEL);
+		if (!rc_ddr_test_reg1)
+			pr_err("PCIe EP: can't alloc the test region1.\n");
+
+		rc_ddr_test_reg2 = kzalloc(rc_ddr_test_region_size, GFP_KERNEL);
+		if (!rc_ddr_test_reg2) {
+			kfree(rc_ddr_test_reg1);
+			pr_err("PCIe EP: can't alloc the test region2.\n");
+		}
 
-	pci_common_init(&imx_pci);
-	return 0;
-}
+		pcie_arb_base_addr = ioremap_cached(PCIE_ARB_BASE_ADDR,
+				rc_ddr_test_region_size);
 
-static int __devexit imx_pcie_pltfm_remove(struct platform_device *pdev)
-{
-	struct clk *pcie_clk;
-	struct device *dev = &pdev->dev;
-	struct imx_pcie_platform_data *pdata = dev->platform_data;
-	struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!pcie_arb_base_addr) {
+			pr_err("error with ioremap in function %s\n", __func__);
+			ret = PTR_ERR(pcie_arb_base_addr);
+			kfree(rc_ddr_test_reg2);
+			kfree(rc_ddr_test_reg1);
+			goto err_base;
+		}
 
-	/* Release clocks, and disable power  */
-	pcie_clk = clk_get(NULL, "pcie_clk");
-	if (IS_ERR(pcie_clk))
-		pr_err("no pcie clock.\n");
+		for (i = 0; i < rc_ddr_test_region_size; i = i + 4) {
+			writel(0xE6600D00 + i, rc_ddr_test_reg1 + i);
+			writel(0xDEADBEAF, rc_ddr_test_reg2 + i);
+		}
+#endif
 
-	if (pcie_clk) {
-		clk_disable(pcie_clk);
-		clk_put(pcie_clk);
-	}
+		pr_info("PCIe EP: waiting for link up...\n");
+		/* link is debug bit 36 debug 1 start in bit 32 */
+		do {
+			usleep_range(10, 20);
+		} while ((readl(dbi_base + DB_R1) & 0x10) == 0);
+		/* Make sure that the PCIe link is up */
+		if (imx_pcie_link_up(dbi_base)) {
+			pr_info("PCIe EP: link up.\n");
+		} else {
+			pr_info("PCIe EP: ERROR link is down, exit!\n");
+#ifdef EP_SELF_IO_TEST
+			kfree(rc_ddr_test_reg2);
+			kfree(rc_ddr_test_reg1);
+			iounmap(pcie_arb_base_addr);
+#endif
+			goto err_link_down;
+		}
 
-	imx_pcie_clrset(iomuxc_gpr1_pcie_ref_clk_en, 0 << 16, IOMUXC_GPR1);
+		imx_pcie_regions_setup(dev, dbi_base);
+#ifdef EP_SELF_IO_TEST
+		/* PCIe EP start the data transfer after link up */
+		pr_info("PCIe EP: Starting data transfer...\n");
+		do_gettimeofday(&tv1);
+
+		memcpy((unsigned long *)pcie_arb_base_addr,
+				(unsigned long *)rc_ddr_test_reg1, 0xFFC000);
+
+		do_gettimeofday(&tv2);
+
+		memcpy((unsigned long *)rc_ddr_test_reg2,
+				(unsigned long *)pcie_arb_base_addr, 0xFFC000);
+
+		do_gettimeofday(&tv3);
+
+		if (memcmp(rc_ddr_test_reg2, rc_ddr_test_reg1, 0xFFC000) != 0) {
+			pr_info("PCIe EP: Data transfer is failed.\n");
+		} else {
+			tv_count1 = (tv2.tv_sec - tv1.tv_sec) * USEC_PER_SEC
+				+ tv2.tv_usec - tv1.tv_usec;
+			tv_count2 = (tv3.tv_sec - tv2.tv_sec) * USEC_PER_SEC
+				+ tv3.tv_usec - tv2.tv_usec;
+
+			pr_info("PCIe EP: Data transfer is successful."
+					"tv_count1 %dus, tv_count2 %dus.\n",
+					tv_count1, tv_count2);
+			pr_info("PCIe EP: Data write speed is %ldMB/s.\n",
+					((((0xFFC000/1024) * MSEC_PER_SEC)))
+					/(tv_count1));
+			pr_info("PCIe EP: Data read speed is %ldMB/s.\n",
+					((((0xFFC000/1024) * MSEC_PER_SEC)))
+					/(tv_count2));
+		}
+#endif
 
-	/* Disable PCIE power */
-	gpio_request(pdata->pcie_pwr_en, "PCIE POWER_EN");
+	} else {
+		/* add the pcie port */
+		add_pcie_port(base, dbi_base, pdata);
 
-	/* activate PCIE_PWR_EN */
-	gpio_direction_output(pdata->pcie_pwr_en, 0);
+		pci_common_init(&imx_pci);
+	}
+	return 0;
 
-	imx_pcie_clrset(iomuxc_gpr1_test_powerdown, 1 << 18, IOMUXC_GPR1);
+err_link_down:
+	iounmap(dbi_base);
 
+err_base:
 	iounmap(base);
-	iounmap(dbi_base);
-	release_mem_region(iomem->start, resource_size(iomem));
-	platform_set_drvdata(pdev, NULL);
 
-	return 0;
+	return ret;
 }
 
 static struct platform_driver imx_pcie_pltfm_driver = {
@@ -767,7 +1136,6 @@ static struct platform_driver imx_pcie_pltfm_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= imx_pcie_pltfm_probe,
-	.remove		= __devexit_p(imx_pcie_pltfm_remove),
 };
 
 /*****************************************************************************\
diff --git a/arch/arm/mach-mx6/pm.c b/arch/arm/mach-mx6/pm.c
index 998051d..d9c04e1 100644
--- a/arch/arm/mach-mx6/pm.c
+++ b/arch/arm/mach-mx6/pm.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -176,9 +176,8 @@ static void usb_power_up_handler(void)
 
 static void disp_power_down(void)
 {
-#if !defined(CONFIG_FB_MXC_ELCDIF_FB) && \
-    !defined(CONFIG_FB_MXC_ELCDIF_FB_MODULE)
-	if (cpu_is_mx6sl()) {
+	if (cpu_is_mx6sl() && (mx6sl_revision() >= IMX_CHIP_REVISION_1_2)) {
+
 		__raw_writel(0xFFFFFFFF, gpc_base + GPC_PGC_DISP_PUPSCR_OFFSET);
 		__raw_writel(0xFFFFFFFF, gpc_base + GPC_PGC_DISP_PDNSCR_OFFSET);
 
@@ -194,14 +193,11 @@ static void disp_power_down(void)
 			~MXC_CCM_CCGRx_CG1_MASK, MXC_CCM_CCGR3);
 
 	}
-#endif
 }
 
 static void disp_power_up(void)
 {
-#if !defined(CONFIG_FB_MXC_ELCDIF_FB) && \
-    !defined(CONFIG_FB_MXC_ELCDIF_FB_MODULE)
-	if (cpu_is_mx6sl()) {
+	if (cpu_is_mx6sl() && (mx6sl_revision() >= IMX_CHIP_REVISION_1_2)) {
 		/*
 		 * Need to enable EPDC/LCDIF pix clock, and
 		 * EPDC/LCDIF/PXP axi clock before power up.
@@ -217,7 +213,6 @@ static void disp_power_up(void)
 		__raw_writel(0x20, gpc_base + GPC_CNTR_OFFSET);
 		__raw_writel(0x1, gpc_base + GPC_PGC_DISP_SR_OFFSET);
 	}
-#endif
 }
 
 static void mx6_suspend_store(void)
@@ -312,9 +307,13 @@ static int mx6_suspend_enter(suspend_state_t state)
 	}
 	mx6_suspend_store();
 
-	/* i.MX6dl TO1.0 TKT094231: can't support ARM_POWER_OFF mode */
+	/*
+	 * i.MX6dl TO1.0/i.MX6dq TO1.1/1.0 TKT094231: can't support
+	 * ARM_POWER_OFF mode.
+	 */
 	if (state == PM_SUSPEND_MEM &&
-		(mx6dl_revision() == IMX_CHIP_REVISION_1_0)) {
+		((mx6dl_revision() == IMX_CHIP_REVISION_1_0) ||
+		(cpu_is_mx6q() && mx6q_revision() <= IMX_CHIP_REVISION_1_1))) {
 		state = PM_SUSPEND_STANDBY;
 	}
 
@@ -338,6 +337,14 @@ static int mx6_suspend_enter(suspend_state_t state)
 		return -EINVAL;
 	}
 
+	/*
+	 * L2 can exit by 'reset' or Inband beacon (from remote EP)
+	 * toggling phy_powerdown has same effect as 'inband beacon'
+	 * So, toggle bit18 of GPR1, to fix errata
+	 * "PCIe PCIe does not support L2 Power Down"
+	 */
+	__raw_writel(__raw_readl(IOMUXC_GPR1) | (1 << 18), IOMUXC_GPR1);
+
 	if (state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY) {
 
 		local_flush_tlb_all();
@@ -401,6 +408,14 @@ static int mx6_suspend_enter(suspend_state_t state)
 			cpu_do_idle();
 	}
 
+	/*
+	 * L2 can exit by 'reset' or Inband beacon (from remote EP)
+	 * toggling phy_powerdown has same effect as 'inband beacon'
+	 * So, toggle bit18 of GPR1, to fix errata
+	 * "PCIe PCIe does not support L2 Power Down"
+	 */
+	__raw_writel(__raw_readl(IOMUXC_GPR1) & (~(1 << 18)), IOMUXC_GPR1);
+
 	return 0;
 }
 
diff --git a/arch/arm/mach-mx6/regs-anadig.h b/arch/arm/mach-mx6/regs-anadig.h
index 773a43d..b1d1645 100644
--- a/arch/arm/mach-mx6/regs-anadig.h
+++ b/arch/arm/mach-mx6/regs-anadig.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -622,7 +622,8 @@
 #define BF_ANADIG_ANA_MISC0_OSC_I(v)  \
 	(((v) << 14) & BM_ANADIG_ANA_MISC0_OSC_I)
 #define BM_ANADIG_ANA_MISC0_RTC_RINGOSC_EN 0x00002000
-#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG 0x00001000
+#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG \
+	(cpu_is_mx6sl() ? 0x00000800 : 0x00001000)
 #define BP_ANADIG_ANA_MISC0_RSVD0      10
 #define BM_ANADIG_ANA_MISC0_RSVD0 0x00000C00
 #define BF_ANADIG_ANA_MISC0_RSVD0(v)  \
diff --git a/arch/arm/mach-mx6/system.c b/arch/arm/mach-mx6/system.c
index 61649c5..ff1feda 100644
--- a/arch/arm/mach-mx6/system.c
+++ b/arch/arm/mach-mx6/system.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,10 +57,12 @@ volatile unsigned int num_cpu_idle;
 volatile unsigned int num_cpu_idle_lock = 0x0;
 int wait_mode_arm_podf;
 int cur_arm_podf;
+bool enet_is_active;
 void arch_idle_with_workaround(int cpu);
 
 extern void *mx6sl_wfi_iram_base;
-extern void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr);
+extern void (*mx6sl_wfi_iram)(int arm_podf, unsigned long wfi_iram_addr, \
+			int audio_mode);
 extern void mx6_wait(void *num_cpu_idle_lock, void *num_cpu_idle, \
 				int wait_arm_podf, int cur_arm_podf);
 extern bool enable_wait_mode;
@@ -80,6 +82,22 @@ void gpc_set_wakeup(unsigned int irq[4])
 	return;
 }
 
+void gpc_mask_single_irq(int irq, bool enable)
+{
+	void __iomem *reg;
+	u32 val;
+
+	reg = gpc_base + 0x8 + (irq / 32 - 1) * 4;
+	val = __raw_readl(reg);
+	if (enable)
+		val |= 1 << (irq % 32);
+	else
+		val &= ~(1 << (irq % 32));
+	__raw_writel(val, reg);
+
+	return;
+}
+
 /* set cpu low power mode before WFI instruction */
 void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 {
@@ -89,6 +107,18 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	u32 ccm_clpcr, anatop_val;
 
 	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	/*
+	 * CCM state machine has restriction that, everytime enable
+	 * LPM mode, we need to make sure last wakeup from LPM mode
+	 * is a dsm_wakeup_signal, which means the wakeup source
+	 * must be seen by GPC, then CCM will clean its state machine
+	 * and re-sample necessary signal to decide whether it can
+	 * enter LPM mode. Here we use the forever pending irq #125,
+	 * unmask it before we enable LPM mode and mask it after LPM
+	 * is enabled, this flow will make sure CCM state machine in
+	 * reliable state before we enter LPM mode.
+	 */
+	gpc_mask_single_irq(MXC_INT_CHEETAH_PARITY, false);
 
 	switch (mode) {
 	case WAIT_CLOCKED:
@@ -147,6 +177,7 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		break;
 	default:
 		printk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);
+		gpc_mask_single_irq(MXC_INT_CHEETAH_PARITY, true);
 		return;
 	}
 
@@ -232,7 +263,7 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 			  */
 			reg = __raw_readl(MXC_CCM_CGPR);
 			reg |= MXC_CCM_CGPR_MEM_IPG_STOP_MASK;
-			if (!cpu_is_mx6sl()) {
+			if (!cpu_is_mx6sl() && stop_mode >= 2) {
 				/*
 				  * For MX6QTO1.2 or later and MX6DLTO1.1 or later,
 				  * ensure that the CCM_CGPR bit 17 is cleared before
@@ -244,6 +275,7 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		}
 	}
 	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	gpc_mask_single_irq(MXC_INT_CHEETAH_PARITY, true);
 }
 
 extern int tick_broadcast_oneshot_active(void);
@@ -275,8 +307,8 @@ void arch_idle_single_core(void)
 			if ((mmdc_ch0_axi != NULL))
 				ddr_usecount = clk_get_usecount(mmdc_ch0_axi);
 
-			if (cpu_is_mx6sl() && low_bus_freq_mode
-				&& ddr_usecount == 1) {
+			if (cpu_is_mx6sl() && (ddr_usecount == 1)  &&
+				(low_bus_freq_mode || audio_bus_freq_mode)) {
 				/* In this mode PLL2 i already in bypass,
 				  * ARM is sourced from PLL1. The code in IRAM
 				  * will set ARM to be sourced from STEP_CLK
@@ -289,7 +321,8 @@ void arch_idle_single_core(void)
 				  * we can lower DDR freq.
 				  */
 				mx6sl_wfi_iram(org_arm_podf,
-					(unsigned long)mx6sl_wfi_iram_base);
+					(unsigned long)mx6sl_wfi_iram_base,
+					audio_bus_freq_mode);
 			} else {
 				/* Need to set ARM to run at 24MHz since IPG
 				  * is at 12MHz. This is valid for audio mode on
@@ -350,7 +383,7 @@ void arch_idle_single_core(void)
 	}
 }
 
-void arch_idle_with_workaround(cpu)
+void arch_idle_with_workaround(int cpu)
 {
 	u32 podf = wait_mode_arm_podf;
 
@@ -369,18 +402,10 @@ void arch_idle_with_workaround(cpu)
 
 }
 
-void arch_idle_multi_core(void)
+void arch_idle_multi_core(int cpu)
 {
 	u32 reg;
-	int cpu = smp_processor_id();
-
-#ifdef CONFIG_LOCAL_TIMERS
-	if (!tick_broadcast_oneshot_active()
-		|| !tick_oneshot_mode_active())
-		return;
 
-	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
-#endif
 	/* iMX6Q and iMX6DL */
 	if ((cpu_is_mx6q() && chip_rev >= IMX_CHIP_REVISION_1_2) ||
 		(cpu_is_mx6dl() && chip_rev >= IMX_CHIP_REVISION_1_1)) {
@@ -398,24 +423,37 @@ void arch_idle_multi_core(void)
 		ca9_do_idle();
 	} else
 		arch_idle_with_workaround(cpu);
-#ifdef CONFIG_LOCAL_TIMERS
-	clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);
-#endif
-
 }
 
 void arch_idle(void)
 {
+	int cpu = smp_processor_id();
+
 	if (enable_wait_mode) {
-		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+#ifdef CONFIG_LOCAL_TIMERS
+		if (!tick_broadcast_oneshot_active()
+			|| !tick_oneshot_mode_active())
+			return;
+
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
+#endif
+		if (enet_is_active)
+			/* Don't allow the chip to enter WAIT mode if enet is active
+			  * and the GPIO workaround for ENET interrupts is not used,
+			  * since all ENET interrupts donot wake up the SOC.
+			  */
+			mxc_cpu_lp_set(WAIT_CLOCKED);
+		else
+			mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
 		if (mem_clk_on_in_wait) {
 			u32 reg;
 			/*
 			  * MX6SL, MX6Q (TO1.2 or later) and
-			  * MX6DL (TO1.1 or later) have a bit in CCM_CGPR that
-			  * when cleared keeps the clocks to memories ON
-			  * when ARM is in WFI. This mode can be used when
-			  * IPG clock is very low (12MHz) and the ARM:IPG ratio
+			  * MX6DL (TO1.1 or later) have a bit in
+			  * CCM_CGPR that when cleared keeps the
+			  * clocks to memories ON when ARM is in WFI.
+			  * This mode can be used when IPG clock is
+			  * very low (12MHz) and the ARM:IPG ratio
 			  * perhaps cannot be maintained.
 			  */
 			reg = __raw_readl(MXC_CCM_CGPR);
@@ -427,8 +465,11 @@ void arch_idle(void)
 			/* iMX6SL or iMX6DLS */
 			arch_idle_single_core();
 		else
-			arch_idle_multi_core();
-	} else {
+			arch_idle_multi_core(cpu);
+#ifdef CONFIG_LOCAL_TIMERS
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);
+#endif
+	}  else {
 		mxc_cpu_lp_set(WAIT_CLOCKED);
 		ca9_do_idle();
 	}
diff --git a/arch/arm/mach-mx6/usb_dr.c b/arch/arm/mach-mx6/usb_dr.c
index 8f90932..40bb978 100644
--- a/arch/arm/mach-mx6/usb_dr.c
+++ b/arch/arm/mach-mx6/usb_dr.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,6 +37,8 @@ static void _dr_discharge_line(bool enable);
 extern bool usb_icbug_swfix_need(void);
 static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, \
 								bool enable);
+static u32 wakeup_irq_enable_src; /* only useful at otg mode */
+static u32 low_power_enable_src; /* only useful at otg mode */
 
 /* The usb_phy1_clk do not have enable/disable function at clock.c
  * and PLL output for usb1's phy should be always enabled.
@@ -65,6 +67,7 @@ static struct fsl_usb2_platform_data dr_utmi_config = {
 	.transceiver       = "utmi",
 	.phy_regs = USB_PHY0_BASE_ADDR,
 	.dr_discharge_line = _dr_discharge_line,
+	.lowpower	   = true, /* Default driver low power is true */
 };
 
 /* Platform data for wakeup operation */
@@ -74,51 +77,6 @@ static struct fsl_usb2_wakeup_platform_data dr_wakeup_config = {
 	.usb_wakeup_exhandle = usbotg_wakeup_event_clear,
 };
 
-static void fsl_platform_otg_set_usb_phy_dis(
-		struct fsl_usb2_platform_data *pdata, bool enable)
-{
-	u32 usb_phy_ctrl_dcdt = 0;
-	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
-	usb_phy_ctrl_dcdt = __raw_readl(
-			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
-			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
-	if (enable) {
-		if (usb_phy_ctrl_dcdt == 0) {
-			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
-					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_CLR);
-
-			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
-					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_SET);
-
-			udelay(300);
-
-			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
-				MX6_IO_ADDRESS(pdata->phy_regs)
-				+ HW_USBPHY_CTRL_SET);
-
-			UOG_USBSTS |= (1 << 7);
-
-			while ((UOG_USBSTS & (1 << 7)) == 0)
-				;
-
-			udelay(2);
-
-			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
-					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_CLR);
-
-			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
-					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
-
-		}
-	} else {
-		if (usb_phy_ctrl_dcdt
-				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
-			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
-				MX6_IO_ADDRESS(pdata->phy_regs)
-				+ HW_USBPHY_CTRL_CLR);
-	}
-}
-
 static void usbotg_internal_phy_clock_gate(bool on)
 {
 	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
@@ -143,6 +101,16 @@ static int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
 	UOG_USBCMD |= UCMD_RESET;
 	while ((UOG_USBCMD) & (UCMD_RESET))
 		;
+
+	/*
+	 * If the controller reset does not put the PHY be out of
+	 * low power mode, do it manually.
+	 */
+	if (UOG_PORTSC1 & PORTSC_PHCD) {
+		UOG_PORTSC1 &= ~PORTSC_PHCD;
+		mdelay(1);
+	}
+
 	/* Reset USBPHY module */
 	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
 	tmp = __raw_readl(phy_ctrl);
@@ -188,10 +156,16 @@ static int usbotg_init_ext(struct platform_device *pdev)
 
 	ret = usbotg_init(pdev);
 	if (ret) {
+		clk_disable(usb_oh3_clk);
+		clk_put(usb_oh3_clk);
+		clk_disable(usb_phy1_clk);
+		clk_put(usb_phy1_clk);
 		printk(KERN_ERR "otg init fails......\n");
 		return ret;
 	}
 	if (!otg_used) {
+		wakeup_irq_enable_src = 0;
+		low_power_enable_src = 0;
 		usb_phy_enable(pdev->dev.platform_data);
 		enter_phy_lowpower_suspend(pdev->dev.platform_data, false);
 		/*after the phy reset,can not read the readingvalue for id/vbus at
@@ -208,13 +182,7 @@ static void usbotg_uninit_ext(struct platform_device *pdev)
 {
 	otg_used--;
 	if (!otg_used) {
-		enter_phy_lowpower_suspend(pdev->dev.platform_data, true);
-		mdelay(3);
-
-		clk_disable(usb_phy1_clk);
 		clk_put(usb_phy1_clk);
-
-		clk_disable(usb_oh3_clk);
 		clk_put(usb_oh3_clk);
 	}
 }
@@ -261,7 +229,6 @@ static void _dr_discharge_line(bool enable)
 /* Below two macros are used at otg mode to indicate usb mode*/
 #define ENABLED_BY_HOST   (0x1 << 0)
 #define ENABLED_BY_DEVICE (0x1 << 1)
-static u32 low_power_enable_src; /* only useful at otg mode */
 static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
 {
 	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
@@ -281,10 +248,12 @@ static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, boo
 		usbotg_internal_phy_clock_gate(false);
 
 	} else {
-		if (UOG_PORTSC1 & PORTSC_PHCD) {
+		if (UOG_PORTSC1 & PORTSC_PHCD)
 			UOG_PORTSC1 &= ~PORTSC_PHCD;
-			mdelay(1);
-		}
+
+		/* Wait PHY clock stable */
+		mdelay(1);
+
 		usbotg_internal_phy_clock_gate(true);
 		tmp = (BM_USBPHY_PWD_TXPWDFS
 			| BM_USBPHY_PWD_TXPWDIBIAS
@@ -294,6 +263,19 @@ static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, boo
 			| BM_USBPHY_PWD_RXPWDDIFF
 			| BM_USBPHY_PWD_RXPWDRX);
 		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+		/*
+		 * The PHY works at 32Khz clock when it is at low power mode,
+		 * it needs 10 clocks from 32Khz to normal work state, so
+		 * 500us is the safe value for PHY enters stable status
+		 * according to IC engineer.
+		 *
+		 * Besides, the digital value needs 1ms debounce time to
+		 * wait the value to be stable. We have expected the
+		 * value from OTGSC is correct after calling this API.
+		 *
+		 * So delay 2ms is a save value.
+		 */
+		mdelay(2);
 
 	}
 	pr_debug("DR: %s ends, enable is %d\n", __func__, enable);
@@ -332,6 +314,12 @@ static void otg_wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable
 				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_SET);
 		USB_OTG_CTRL |= UCTRL_OWIE;
 	} else {
+		__raw_writel(BM_USBPHY_CTRL_ENDPDMCHG_WKUP
+				| BM_USBPHY_CTRL_ENAUTOSET_USBCLKS
+				| BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD
+				| BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE
+				| BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE
+				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_CLR);
 		USB_OTG_CTRL &= ~UCTRL_OWIE;
 		/* The interrupt must be disabled for at least 3 clock
 		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
@@ -339,7 +327,6 @@ static void otg_wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable
 	}
 }
 
-static u32 wakeup_irq_enable_src; /* only useful at otg mode */
 static void __wakeup_irq_enable(struct fsl_usb2_platform_data *pdata, bool on, int source)
  {
 	/* otg host and device share the OWIE bit, only when host and device
@@ -387,6 +374,51 @@ static void usbotg_wakeup_event_clear(void)
 
 #ifdef CONFIG_USB_EHCI_ARC_OTG
 /* Beginning of host related operation for DR port */
+static void fsl_platform_otg_set_usb_phy_dis(
+		struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	u32 usb_phy_ctrl_dcdt = 0;
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	usb_phy_ctrl_dcdt = __raw_readl(
+			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
+			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	if (enable) {
+		if (usb_phy_ctrl_dcdt == 0) {
+			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_CLR);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_SET);
+
+			udelay(300);
+
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_SET);
+
+			UOG_USBSTS |= (1 << 7);
+
+			while ((UOG_USBSTS & (1 << 7)) == 0)
+				;
+
+			udelay(2);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_CLR);
+
+			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+
+		}
+	} else {
+		if (usb_phy_ctrl_dcdt
+				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_CLR);
+	}
+}
+
 static void _host_platform_rh_suspend_swfix(struct fsl_usb2_platform_data *pdata)
 {
 	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
@@ -487,8 +519,9 @@ static void _host_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, boo
 
 static void _host_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enable)
 {
-	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	void __iomem *phy_reg __maybe_unused = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
 	__wakeup_irq_enable(pdata, enable, ENABLED_BY_HOST);
+#ifdef CONFIG_USB_OTG
 	if (enable) {
 		pr_debug("host wakeup enable\n");
 		USB_OTG_CTRL |= UCTRL_WKUP_ID_EN;
@@ -502,6 +535,7 @@ static void _host_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enabl
 		udelay(100);
 	}
 	pr_debug("the otgsc is 0x%x, usbsts is 0x%x, portsc is 0x%x, otgctrl: 0x%x\n", UOG_OTGSC, UOG_USBSTS, UOG_PORTSC1, USB_OTG_CTRL);
+#endif
 }
 
 static enum usb_wakeup_event _is_host_wakeup(struct fsl_usb2_platform_data *pdata)
@@ -515,8 +549,6 @@ static enum usb_wakeup_event _is_host_wakeup(struct fsl_usb2_platform_data *pdat
 	/* if ID change sts, it is a host wakeup event */
 	if (otgsc & OTGSC_IS_USB_ID) {
 		pr_debug("otg host ID wakeup\n");
-		/* if host ID wakeup, we must clear the ID change sts */
-		otgsc |= OTGSC_IS_USB_ID;
 		return WAKEUP_EVENT_ID;
 	}
 	if (wakeup_req  && (!(otgsc & OTGSC_STS_USB_ID))) {
@@ -612,11 +644,11 @@ static int  __init mx6_usb_dr_init(void)
 	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
 	struct imx_fsl_usb2_wakeup_data imx6q_fsl_otg_wakeup_data =
 		imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 0, OTG);
-	struct imx_mxc_ehci_data imx6q_mxc_ehci_otg_data =
+	struct imx_mxc_ehci_data __maybe_unused imx6q_mxc_ehci_otg_data =
 		imx_mxc_ehci_data_entry_single(MX6Q, 0, OTG);
-	struct imx_fsl_usb2_udc_data imx6q_fsl_usb2_udc_data =
+	struct imx_fsl_usb2_udc_data __maybe_unused imx6q_fsl_usb2_udc_data =
 		imx_fsl_usb2_udc_data_entry_single(MX6Q);
-	struct imx_fsl_usb2_otg_data imx6q_fsl_usb2_otg_data  =
+	struct imx_fsl_usb2_otg_data __maybe_unused imx6q_fsl_usb2_otg_data  =
 		imx_fsl_usb2_otg_data_entry_single(MX6Q);
 
 	/* Some phy and power's special controls for otg
diff --git a/arch/arm/mach-mx6/usb_h1.c b/arch/arm/mach-mx6/usb_h1.c
index eb79bf35..657c1cb 100644
--- a/arch/arm/mach-mx6/usb_h1.c
+++ b/arch/arm/mach-mx6/usb_h1.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -111,6 +111,16 @@ static int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
 	UH1_USBCMD |= UCMD_RESET;
 	while ((UH1_USBCMD) & (UCMD_RESET))
 		;
+
+	/*
+	 * If the controller reset does not put the PHY be out of
+	 * low power mode, do it manually.
+	 */
+	if (UH1_PORTSC1 & PORTSC_PHCD) {
+		UH1_PORTSC1 &= ~PORTSC_PHCD;
+		mdelay(1);
+	}
+
 	/* Reset USBPHY module */
 	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
 	tmp = __raw_readl(phy_ctrl);
@@ -148,6 +158,8 @@ static int fsl_usb_host_init_ext(struct platform_device *pdev)
 	ret = fsl_usb_host_init(pdev);
 	if (ret) {
 		printk(KERN_ERR "host1 init fails......\n");
+		clk_disable(usb_oh3_clk);
+		clk_put(usb_oh3_clk);
 		return ret;
 	}
 	usbh1_internal_phy_clock_gate(true);
@@ -162,7 +174,6 @@ static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
 
 	fsl_usb_host_uninit(pdata);
 
-	clk_disable(usb_oh3_clk);
 	clk_put(usb_oh3_clk);
 
 }
@@ -192,9 +203,14 @@ static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
 				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_SET);
 		USB_H1_CTRL |= (UCTRL_OWIE);
 	} else {
-		USB_H1_CTRL &= ~(UCTRL_OWIE);
 		__raw_writel(BM_USBPHY_CTRL_ENIDCHG_WKUP | BM_USBPHY_CTRL_ENVBUSCHG_WKUP
-				| BM_USBPHY_CTRL_ENDPDMCHG_WKUP, phy_reg + HW_USBPHY_CTRL_CLR);
+				| BM_USBPHY_CTRL_ENDPDMCHG_WKUP
+				| BM_USBPHY_CTRL_ENAUTOSET_USBCLKS
+				| BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD
+				| BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE
+				| BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE
+				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_CLR);
+		USB_H1_CTRL &= ~(UCTRL_OWIE);
 		/* The interrupt must be disabled for at least 3
 		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
 		udelay(100);
@@ -244,7 +260,7 @@ static void usbh1_platform_rh_resume_swfix(struct fsl_usb2_platform_data *pdata)
 {
 	u32 index = 0;
 
-	if ((UOG_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
+	if ((UH1_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
 		return ;
 	while ((UH1_PORTSC1 & PORTSC_PORT_FORCE_RESUME)
 			&& (index < 1000)) {
@@ -277,7 +293,7 @@ static void usbh1_platform_rh_resume(struct fsl_usb2_platform_data *pdata)
 	/*for mx6sl ,we do not need any sw fix*/
 	if (cpu_is_mx6sl())
 		return ;
-	if ((UOG_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
+	if ((UH1_PORTSC1 & (PORTSC_PORT_SPEED_MASK)) != PORTSC_PORT_SPEED_HIGH)
 		return ;
 	while ((UH1_PORTSC1 & PORTSC_PORT_FORCE_RESUME)
 			&& (index < 1000)) {
@@ -316,10 +332,12 @@ static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool ena
 
 		usbh1_internal_phy_clock_gate(false);
 	} else {
-		if (UH1_PORTSC1 & PORTSC_PHCD) {
+		if (UH1_PORTSC1 & PORTSC_PHCD)
 			UH1_PORTSC1 &= ~PORTSC_PHCD;
-			mdelay(1);
-		}
+
+		/* Wait PHY clock stable */
+		mdelay(1);
+
 		usbh1_internal_phy_clock_gate(true);
 		tmp = (BM_USBPHY_PWD_TXPWDFS
 			| BM_USBPHY_PWD_TXPWDIBIAS
@@ -329,6 +347,13 @@ static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool ena
 			| BM_USBPHY_PWD_RXPWDDIFF
 			| BM_USBPHY_PWD_RXPWDRX);
 		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+		/*
+		 * The PHY works at 32Khz clock when it is at low power mode,
+		 * it needs 10 clocks from 32Khz to normal work state, so
+		 * 500us is the safe value for PHY enters stable status
+		 * according to IC engineer.
+		 */
+		udelay(500);
 
 	}
 }
@@ -351,13 +376,16 @@ static void h1_wakeup_handler(struct fsl_usb2_platform_data *pdata)
 
 static void usbh1_wakeup_event_clear(void)
 {
-	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
-	u32 wakeup_irq_bits;
-
-	wakeup_irq_bits = BM_USBPHY_CTRL_RESUME_IRQ | BM_USBPHY_CTRL_WAKEUP_IRQ;
-	if (__raw_readl(phy_reg + HW_USBPHY_CTRL) && wakeup_irq_bits) {
-		/* clear the wakeup interrupt status */
-		__raw_writel(wakeup_irq_bits, phy_reg + HW_USBPHY_CTRL_CLR);
+	int wakeup_req = USB_H1_CTRL & UCTRL_OWIR;
+
+	if (wakeup_req != 0) {
+		printk(KERN_INFO "Unknown wakeup.(H1 OTGSC 0x%x)\n", UH1_OTGSC);
+		/* Disable OWIE to clear OWIR, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USB_H1_CTRL &= ~UCTRL_OWIE;
+		udelay(100);
+		USB_H1_CTRL |= UCTRL_OWIE;
 	}
 }
 
@@ -401,8 +429,7 @@ static int  __init mx6_usb_h1_init(void)
 		imx_mxc_ehci_data_entry_single(MX6SL, 1, HS1)};
 
 	mx6_get_host1_vbus_func(&mx6_set_usb_host1_vbus);
-	if (mx6_set_usb_host1_vbus)
-		mx6_set_usb_host1_vbus(true);
+	usbh1_config.platform_driver_vbus = mx6_set_usb_host1_vbus;
 
 	/* Some phy and power's special controls for host1
 	 * 1. The external charger detector needs to be disabled
@@ -457,8 +484,6 @@ static void __exit mx6_usb_h1_exit(void)
 			| BM_ANADIG_USB2_PLL_480_CTRL_POWER \
 			| BM_ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS, \
 			anatop_base_addr + HW_ANADIG_USB2_PLL_480_CTRL_CLR);
-	if (mx6_set_usb_host1_vbus)
-		mx6_set_usb_host1_vbus(false);
 
 	return ;
 }
diff --git a/arch/arm/mach-mx6/usb_h2.c b/arch/arm/mach-mx6/usb_h2.c
index be092ab..6ce99ab 100644
--- a/arch/arm/mach-mx6/usb_h2.c
+++ b/arch/arm/mach-mx6/usb_h2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,12 +89,7 @@ static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
 
 	fsl_usb_host_uninit(pdata);
 
-	usbh2_internal_phy_clock_gate(false);
-
-	clk_disable(usb_phy3_clk);
 	clk_put(usb_phy3_clk);
-
-	clk_disable(usb_oh3_clk);
 	clk_put(usb_oh3_clk);
 
 }
diff --git a/arch/arm/mach-mx6/usb_h3.c b/arch/arm/mach-mx6/usb_h3.c
index e25c016..cddf552 100644
--- a/arch/arm/mach-mx6/usb_h3.c
+++ b/arch/arm/mach-mx6/usb_h3.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,12 +89,7 @@ static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
 
 	fsl_usb_host_uninit(pdata);
 
-	usbh3_internal_phy_clock_gate(false);
-
-	clk_disable(usb_phy4_clk);
 	clk_put(usb_phy4_clk);
-
-	clk_disable(usb_oh3_clk);
 	clk_put(usb_oh3_clk);
 
 }
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index 1ed1fd3..428b243 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -211,6 +211,9 @@ ENTRY(v7_coherent_user_range)
  * isn't mapped, just try the next page.
  */
 9001:
+#ifdef CONFIG_ARM_ERRATA_775420
+	dsb
+#endif
 	mov	r12, r12, lsr #12
 	mov	r12, r12, lsl #12
 	add	r12, r12, #4096
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 0f0badd..feb83cb 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -333,6 +333,23 @@ __dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp,
  * virtual and bus address for that space.
  */
 void *
+dma_alloc_noncached(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
+{
+	void *memory;
+
+	if (dma_alloc_from_coherent(dev, size, handle, &memory))
+		return memory;
+
+	return __dma_alloc(dev, size, handle, gfp,
+			   pgprot_noncached(pgprot_kernel));
+}
+EXPORT_SYMBOL(dma_alloc_noncached);
+
+/*
+ * Allocate DMA-coherent memory space and return both the kernel remapped
+ * virtual and bus address for that space.
+ */
+void *
 dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
 {
 	void *memory;
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 6ff1c90..1aa1780 100755
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := clock.o gpio.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o
+obj-y := clock.o gpio.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o fuse.o
 
 # MX51 uses the TZIC interrupt controller, older platforms use AVIC
 obj-$(CONFIG_MXC_TZIC) += tzic.o
diff --git a/arch/arm/plat-mxc/ahci_sata.c b/arch/arm/plat-mxc/ahci_sata.c
index cee34b6..de172a9 100644
--- a/arch/arm/plat-mxc/ahci_sata.c
+++ b/arch/arm/plat-mxc/ahci_sata.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -152,9 +152,8 @@ int sata_init(void __iomem *addr, unsigned long timer1ms)
 	/* Reset HBA */
 	writel(HOST_RESET, addr + HOST_CTL);
 
-	tmpdata = readl(addr + HOST_VERSIONR);
 	tmpdata = 0;
-	while (readl(addr + HOST_VERSIONR) == 0) {
+	while (readl(addr + HOST_CAP) == 0) {
 		tmpdata++;
 		if (tmpdata > 100000) {
 			pr_err("Can't recover from RESET HBA!\n");
@@ -167,7 +166,6 @@ int sata_init(void __iomem *addr, unsigned long timer1ms)
 		tmpdata |= HOST_CAP_SSS;
 		writel(tmpdata, addr + HOST_CAP);
 	}
-	tmpdata = readl(addr + HOST_CAP);
 
 	if (!(readl(addr + HOST_PORTS_IMPL) & 0x1))
 		writel((readl(addr + HOST_PORTS_IMPL) | 0x1),
@@ -178,7 +176,7 @@ int sata_init(void __iomem *addr, unsigned long timer1ms)
 	/* Release resources when there is no device on the port */
 	do {
 		if ((readl(addr + PORT_SATA_SR) & 0xF) == 0)
-			msleep(25);
+			usleep_range(1000, 2000);
 		else
 			break;
 
diff --git a/arch/arm/plat-mxc/devices/platform-ahci-imx.c b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
index 30bfeaa..90d994c 100755
--- a/arch/arm/plat-mxc/devices/platform-ahci-imx.c
+++ b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -54,6 +54,9 @@ struct platform_device *__init imx_add_ahci(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_SATA))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("ahci", 0 /* -1? */,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata),  DMA_BIT_MASK(32));
diff --git a/arch/arm/plat-mxc/devices/platform-fec.c b/arch/arm/plat-mxc/devices/platform-fec.c
index 20422cf..0a03ea9 100644
--- a/arch/arm/plat-mxc/devices/platform-fec.c
+++ b/arch/arm/plat-mxc/devices/platform-fec.c
@@ -6,7 +6,7 @@
  * the terms of the GNU General Public License version 2 as published by the
  * Free Software Foundation.
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 #include <linux/dma-mapping.h>
 #include <asm/sizes.h>
@@ -74,6 +74,9 @@ struct platform_device *__init imx_add_fec(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_ENET))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask(data->devid, 0,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
diff --git a/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c b/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
index 404a264..459e6cc 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-epdc-fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,6 +55,9 @@ struct platform_device *__init imx_add_imx_epdc(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_EPDC))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("imx_epdc_fb", -1,
 		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
index 813f954..26f4ae7 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -42,6 +42,9 @@ struct platform_device *__init imx_add_hdmi_soc_dai(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("imx-hdmi-soc-dai", 0,
 				res, ARRAY_SIZE(res), NULL, 0);
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
index 33c8a68..7be6756 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -22,7 +22,12 @@
 #include <mach/devices-common.h>
 
 struct platform_device *__init imx_add_hdmi_soc(void)
-{	return imx_add_platform_device("mxc_hdmi_soc", 0,
+{
+
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device("mxc_hdmi_soc", 0,
 				       NULL, 0, NULL, 0);
 }
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx-i2c.c b/arch/arm/plat-mxc/devices/platform-imx-i2c.c
index d11f52d..f2780ad 100755
--- a/arch/arm/plat-mxc/devices/platform-imx-i2c.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-i2c.c
@@ -102,9 +102,12 @@ const struct imx_imx_i2c_data imx53_imx_i2c_data[] __initconst = {
 const struct imx_imx_i2c_data imx6q_imx_i2c_data[] __initconst = {
 #define imx6q_imx_i2c_data_entry(_id, _hwid)				\
 	imx_imx_i2c_data_entry(MX6Q, _id, _hwid, SZ_4K)
+#define imx6dl_imx_i2c_data_entry(_id, _hwid)				\
+	imx_imx_i2c_data_entry(MX6DL, _id, _hwid, SZ_4K)
 	imx6q_imx_i2c_data_entry(0, 1),
 	imx6q_imx_i2c_data_entry(1, 2),
 	imx6q_imx_i2c_data_entry(2, 3),
+	imx6dl_imx_i2c_data_entry(3, 4),
 };
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pcie.c b/arch/arm/plat-mxc/devices/platform-imx-pcie.c
index cf36093..7e0d630 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pcie.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pcie.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,6 +55,9 @@ struct platform_device *__init imx_add_pcie(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_PCIE))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("imx-pcie", -1,
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata));
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pxp.c b/arch/arm/plat-mxc/devices/platform-imx-pxp.c
index 418489e..fed58d0 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-pxp.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-pxp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -54,18 +54,27 @@ struct platform_device *__init imx_add_imx_pxp(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("imx-pxp", -1,
 		res, ARRAY_SIZE(res), NULL, 0, DMA_BIT_MASK(32));
 }
 
 struct platform_device *__init imx_add_imx_pxp_client()
 {
-    return imx_add_platform_device("imx-pxp-client", -1,
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device("imx-pxp-client", -1,
 		NULL, 0, NULL, 0);
 }
 
 struct platform_device *__init imx_add_imx_pxp_v4l2()
 {
-    return imx_add_platform_device_dmamask("pxp-v4l2", -1,
+	if (!fuse_dev_is_available(MXC_DEV_PXP))
+		return ERR_PTR(-ENODEV);
+
+	return imx_add_platform_device_dmamask("pxp-v4l2", -1,
 		NULL, 0, NULL, 0, DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-imx-uart.c b/arch/arm/plat-mxc/devices/platform-imx-uart.c
index 7f70dc9..e76b026 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-uart.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-uart.c
@@ -134,6 +134,7 @@ const struct imx_imx_uart_1irq_data imx6q_imx_uart_data[] __initconst = {
 	imx6q_imx_uart_data_entry(1, 2),
 	imx6q_imx_uart_data_entry(2, 3),
 	imx6q_imx_uart_data_entry(3, 4),
+	imx6q_imx_uart_data_entry(4, 5),
 };
 #endif /* ifdef CONFIG_SOC_IMX6Q */
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx_vpu.c b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
index 83faed6..f0295ad 100755
--- a/arch/arm/plat-mxc/devices/platform-imx_vpu.c
+++ b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  * Jason Chen <jason.chen@freescale.com>
  *
  * This program is free software; you can redistribute it and/or modify it under
@@ -123,7 +123,7 @@ void mx6q_vpu_reset(void)
 	 __raw_writel(reg, src_base + 0x18);
 
 	reg = __raw_readl(src_base);
-	reg |= 0x5;    /* warm reset vpu */
+	reg |= 0x4;    /* warm reset vpu */
 	__raw_writel(reg, src_base);
 	while (__raw_readl(src_base) & 0x04)
 		;
@@ -167,15 +167,9 @@ struct platform_device *__init imx_add_vpu(
 	pdata.iram_enable = data->iram_enable;
 	pdata.iram_size = data->iram_size;
 
-#ifdef CONFIG_SOC_IMX6Q
-	if (cpu_is_mx6dl() || cpu_is_mx6q()) {
-		#define HW_OCOTP_CFGn(n) (0x00000410 + (n) * 0x10)
-		unsigned int vpu_disable;
-		vpu_disable = readl(MX6_IO_ADDRESS(OCOTP_BASE_ADDR) + HW_OCOTP_CFGn(3));
-		if (vpu_disable & 0x00008000)
-			return ERR_PTR(-ENODEV);
-	}
-#endif
+	if (!fuse_dev_is_available(MXC_DEV_VPU))
+		return ERR_PTR(-ENODEV);
+
 	if (cpu_is_mx6dl())
 		pdata.iram_enable = false;
 
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
index e0c1906..2c9a32a 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -45,6 +45,9 @@ struct platform_device *__init imx_add_mxc_hdmi_core(
 		},
 	};
 
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("mxc_hdmi_core", -1,
 		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
index d495262..cdbdae4 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -43,6 +43,10 @@ struct platform_device *__init imx_add_mxc_hdmi(
 			.flags = IORESOURCE_IRQ,
 		},
 	};
+
+	if (!fuse_dev_is_available(MXC_DEV_HDMI))
+		return ERR_PTR(-ENODEV);
+
 	imx_add_platform_device("mxc_hdmi_cec", 0,
 				       res, ARRAY_SIZE(res), NULL, 0);
 	return imx_add_platform_device_dmamask("mxc_hdmi", -1,
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_mlb.c b/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
index 661595f..8925f3e 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_mlb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -44,8 +44,6 @@ struct platform_device *__init imx_add_mlb(
 struct platform_device *__init imx_add_mlb(
 		const struct mxc_mlb_platform_data *pdata)
 {
-#define HW_OCOTP_CFGn(n)        (0x00000410 + (n) * 0x10)
-	unsigned int mlb_disable = 0;
 	struct resource res[] = {
 		{
 			.start = MLB_BASE_ADDR,
@@ -69,9 +67,9 @@ struct platform_device *__init imx_add_mlb(
 		},
 	};
 
-	mlb_disable = readl(MX6_IO_ADDRESS(OCOTP_BASE_ADDR) + HW_OCOTP_CFGn(2));
-	if (mlb_disable & 0x04000000)
+	if (!fuse_dev_is_available(MXC_DEV_MLB))
 		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device("mxc_mlb150", 0,
 			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
 }
diff --git a/arch/arm/plat-mxc/devices/platform-viv_gpu.c b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
index 9b02196..52c9b08 100644
--- a/arch/arm/plat-mxc/devices/platform-viv_gpu.c
+++ b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -90,13 +90,36 @@ struct platform_device *__init imx_add_viv_gpu(
 		},
 	};
 
-	if (cpu_is_mx6q() || cpu_is_mx6sl())
-		res_count = ARRAY_SIZE(res);
-	else if (cpu_is_mx6dl())
-		/* No openVG on i.mx6 Solo/DL */
-		res_count = ARRAY_SIZE(res) - 2;
+	res_count = ARRAY_SIZE(res);
 	BUG_ON(!res_count);
 
+	if (!fuse_dev_is_available(MXC_DEV_3D)) {
+		res[1].start = 0;
+		res[1].end = 0;
+		res[2].start = -1;
+		res[2].end = -1;
+	}
+
+	if (!fuse_dev_is_available(MXC_DEV_2D)) {
+		res[3].start = 0;
+		res[3].end = 0;
+		res[4].start = -1;
+		res[4].end = -1;
+	}
+
+	if (!fuse_dev_is_available(MXC_DEV_OVG)) {
+		res[5].start = 0;
+		res[5].end = 0;
+		res[6].start = -1;
+		res[6].end = -1;
+	}
+
+	/* None GPU core exists */
+	if ((res[2].start == -1) &&
+			(res[4].start == -1) &&
+			(res[6].start == -1))
+		return ERR_PTR(-ENODEV);
+
 	return imx_add_platform_device_dmamask("galcore", 0,
 			res, res_count,
 			pdata, sizeof(*pdata),
diff --git a/arch/arm/plat-mxc/fuse.c b/arch/arm/plat-mxc/fuse.c
new file mode 100644
index 0000000..1238e76
--- /dev/null
+++ b/arch/arm/plat-mxc/fuse.c
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <mach/hardware.h>
+
+#define HW_OCOTP_CFGn(n)	(0x00000410 + (n) * 0x10)
+
+/* Note: the names oder is the same as device enum order defined in mxc.h */
+static char *names[] = {
+	"pxp", "ovg", "dsi_csi2", "enet", "mlb",
+	"epdc", "hdmi", "pcie", "sata", "dtcp",
+	"2d", "3d", "vpu", "divx3", "rv",
+	"sorensen",
+};
+
+int fuse_dev_is_available(enum mxc_dev_type dev)
+{
+	u32 uninitialized_var(reg);
+	u32 uninitialized_var(mask);
+	int ret;
+
+	if (!cpu_is_mx6())
+		return 1;
+
+	/* mx6sl is still not supported */
+	if (cpu_is_mx6sl())
+		return 1;
+
+	switch (dev) {
+	case MXC_DEV_PXP:
+		if (cpu_is_mx6q())
+			return 0;
+
+		if (cpu_is_mx6dl()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x80000000;
+		}
+		break;
+	case MXC_DEV_OVG:
+		if (cpu_is_mx6dl())
+			return 0;
+
+		if (cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x40000000;
+		}
+		break;
+	case MXC_DEV_DSI_CSI2:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x10000000;
+		}
+		break;
+	case MXC_DEV_ENET:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x08000000;
+		}
+		break;
+	case MXC_DEV_MLB:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x04000000;
+		}
+		break;
+	case MXC_DEV_EPDC:
+		if (cpu_is_mx6q())
+			return 0;
+
+		if (cpu_is_mx6dl()) {
+			reg = HW_OCOTP_CFGn(2);
+			mask = 0x02000000;
+		}
+		break;
+	case MXC_DEV_HDMI:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000080;
+		}
+		break;
+	case MXC_DEV_PCIE:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000040;
+		}
+		break;
+	case MXC_DEV_SATA:
+		if (cpu_is_mx6dl())
+			return 0;
+
+		if (cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000020;
+		}
+		break;
+	case MXC_DEV_DTCP:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000010;
+		}
+		break;
+	case MXC_DEV_2D:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000008;
+		}
+		break;
+	case MXC_DEV_3D:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000004;
+		}
+		break;
+	case MXC_DEV_VPU:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00008000;
+		}
+		break;
+	case MXC_DEV_DIVX3:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000400;
+		}
+		break;
+	case MXC_DEV_RV:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000200;
+		}
+		break;
+	case MXC_DEV_SORENSEN:
+		if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+			reg = HW_OCOTP_CFGn(3);
+			mask = 0x00000100;
+		}
+		break;
+	default:
+		/* we treat the unkown device is avaiable by default */
+		return 1;
+	}
+
+	ret = readl(MX6_IO_ADDRESS(OCOTP_BASE_ADDR) + reg) & mask;
+	pr_debug("fuse_check: %s is %s\n", names[dev], ret ?
+					"unavailable" : "available");
+
+	return !ret;
+}
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
index 82b70d5..e12aee5 100755
--- a/arch/arm/plat-mxc/gpio.c
+++ b/arch/arm/plat-mxc/gpio.c
@@ -3,7 +3,7 @@
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * Based on code from Freescale,
- * Copyright (C) 2004-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2004-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -283,8 +283,13 @@ static int mxc_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
 	struct mxc_gpio_port *port =
 		container_of(chip, struct mxc_gpio_port, chip);
+	u32 gpio_direction;
 
-	return (__raw_readl(port->base + GPIO_PSR) >> offset) & 1;
+	gpio_direction = __raw_readl(port->base + GPIO_GDIR);
+	if (((gpio_direction >> offset) & 1)) /* output mode */
+		return (__raw_readl(port->base + GPIO_DR) >> offset) & 1;
+	else /* input mode */
+		return (__raw_readl(port->base + GPIO_PSR) >> offset) & 1;
 }
 
 static int mxc_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index f2bb01c..fdd8450 100755
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -121,6 +121,7 @@ extern void __iomem *imx_otg_base;
 /*      configured_flag                    (0x180)	   configflag (supports HS) */
 #define UH1_PORTSC1		USBH1_REG32(0x184)	/* port status and control */
 /* end EHCI registers: */
+#define UH1_OTGSC		USBH1_REG32(0x1a4)	/* OTG status and control */
 #define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
 
 /*
diff --git a/arch/arm/plat-mxc/include/mach/epdc.h b/arch/arm/plat-mxc/include/mach/epdc.h
index 36aac88..e6dae37d 100644
--- a/arch/arm/plat-mxc/include/mach/epdc.h
+++ b/arch/arm/plat-mxc/include/mach/epdc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h b/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
index e2740ff..59f8399 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6dl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -76,15 +76,26 @@
 #define MX6DL_ECSPI_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
 
+#define MX6DL_WEIM_NOR_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm |	\
+		PAD_CTL_SPEED_MED | PAD_CTL_PKE	| PAD_CTL_PUE | 	\
+		PAD_CTL_PUS_100K_UP)
+
 #define MX6DL_ADU_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
 		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
 		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
 
+#define MX6DL_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | \
+		PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_ODE | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
+
 #define MX6DL_GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
 #define MX6DL_GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | PAD_CTL_SRE_FAST)
 #define MX6DL_GPMI_PAD_CTRL2 (MX6DL_GPMI_PAD_CTRL0 | MX6DL_GPMI_PAD_CTRL1)
 #define MX6DL_SPDIF_OUT_PAD_CTRL (PAD_CTL_DSE_120ohm | PAD_CTL_SRE_FAST)
 
+#define ENET_IRQ_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SPEED_MED)
+
 #define MX6DL_PAD_CSI0_DAT10__IPU1_CSI0_D_10                                   \
 		IOMUX_PAD(0x0360, 0x004C, 0, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_CSI0_DAT10__AUDMUX_AUD3_RXC                                  \
@@ -1258,7 +1269,7 @@
 		IOMUX_PAD(0x04DC, NO_MUX_I, 0, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A16__WEIM_WEIM_A_16                                      \
-		IOMUX_PAD(0x04E0, 0x0110, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E0, 0x0110, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A16__IPU1_DI1_DISP_CLK                                   \
 		IOMUX_PAD(0x04E0, 0x0110, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A16__IPU1_CSI1_PIXCLK                                    \
@@ -1275,7 +1286,7 @@
 		IOMUX_PAD(0x04E0, 0x0110, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A17__WEIM_WEIM_A_17                                      \
-		IOMUX_PAD(0x04E4, 0x0114, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E4, 0x0114, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A17__IPU1_DISP1_DAT_12                                   \
 		IOMUX_PAD(0x04E4, 0x0114, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A17__IPU1_CSI1_D_12                                      \
@@ -1292,7 +1303,7 @@
 		IOMUX_PAD(0x04E4, 0x0114, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A18__WEIM_WEIM_A_18                                      \
-		IOMUX_PAD(0x04E8, 0x0118, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04E8, 0x0118, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A18__IPU1_DISP1_DAT_13                                   \
 		IOMUX_PAD(0x04E8, 0x0118, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A18__IPU1_CSI1_D_13                                      \
@@ -1309,7 +1320,7 @@
 		IOMUX_PAD(0x04E8, 0x0118, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A19__WEIM_WEIM_A_19                                      \
-		IOMUX_PAD(0x04EC, 0x011C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04EC, 0x011C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A19__IPU1_DISP1_DAT_14                                   \
 		IOMUX_PAD(0x04EC, 0x011C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A19__IPU1_CSI1_D_14                                      \
@@ -1326,7 +1337,7 @@
 		IOMUX_PAD(0x04EC, 0x011C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A20__WEIM_WEIM_A_20                                      \
-		IOMUX_PAD(0x04F0, 0x0120, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F0, 0x0120, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A20__IPU1_DISP1_DAT_15                                   \
 		IOMUX_PAD(0x04F0, 0x0120, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A20__IPU1_CSI1_D_15                                      \
@@ -1343,7 +1354,7 @@
 		IOMUX_PAD(0x04F0, 0x0120, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A21__WEIM_WEIM_A_21                                      \
-		IOMUX_PAD(0x04F4, 0x0124, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F4, 0x0124, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A21__IPU1_DISP1_DAT_16                                   \
 		IOMUX_PAD(0x04F4, 0x0124, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A21__IPU1_CSI1_D_16                                      \
@@ -1360,7 +1371,7 @@
 		IOMUX_PAD(0x04F4, 0x0124, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A22__WEIM_WEIM_A_22                                      \
-		IOMUX_PAD(0x04F8, 0x0128, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04F8, 0x0128, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A22__IPU1_DISP1_DAT_17                                   \
 		IOMUX_PAD(0x04F8, 0x0128, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A22__IPU1_CSI1_D_17                                      \
@@ -1375,7 +1386,7 @@
 		IOMUX_PAD(0x04F8, 0x0128, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_A23__WEIM_WEIM_A_23                                      \
-		IOMUX_PAD(0x04FC, 0x012C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x04FC, 0x012C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_A23__IPU1_DISP1_DAT_18                                   \
 		IOMUX_PAD(0x04FC, 0x012C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A23__IPU1_CSI1_D_18                                      \
@@ -1421,7 +1432,7 @@
 #define MX6DL_PAD_EIM_A25__GPIO_5_2                                            \
 		IOMUX_PAD(0x0504, 0x0134, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A25__HDMI_TX_CEC_LINE                                    \
-		IOMUX_PAD(0x0504, 0x0134, 6, 0x085C, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0504, 0x0134, 6, 0x085C, 0, MX6DL_HDMICEC_PAD_CTRL)
 #define MX6DL_PAD_EIM_A25__PL301_SIM_MX6DL_PER1_HBURST_0                       \
 		IOMUX_PAD(0x0504, 0x0134, 7, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_A25__EPDC_SDDO_15                                        \
@@ -1471,7 +1482,7 @@
 		IOMUX_PAD(0x0510, 0x0140, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D16__WEIM_WEIM_D_16                                      \
-		IOMUX_PAD(0x0514, 0x0144, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0514, 0x0144, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D16__ECSPI1_SCLK                                         \
 		IOMUX_PAD(0x0514, 0x0144, 1, 0x07D8, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D16__IPU1_DI0_PIN5                                       \
@@ -1490,7 +1501,7 @@
 		IOMUX_PAD(0x0514, 0x0144, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D17__WEIM_WEIM_D_17                                      \
-		IOMUX_PAD(0x0518, 0x0148, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0518, 0x0148, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D17__ECSPI1_MISO                                         \
 		IOMUX_PAD(0x0518, 0x0148, 1, 0x07DC, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D17__IPU1_DI0_PIN6                                       \
@@ -1509,7 +1520,7 @@
 		IOMUX_PAD(0x0518, 0x0148, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D18__WEIM_WEIM_D_18                                      \
-		IOMUX_PAD(0x051C, 0x014C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x051C, 0x014C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D18__ECSPI1_MOSI                                         \
 		IOMUX_PAD(0x051C, 0x014C, 1, 0x07E0, 2, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D18__IPU1_DI0_PIN7                                       \
@@ -1528,7 +1539,7 @@
 		IOMUX_PAD(0x051C, 0x014C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D19__WEIM_WEIM_D_19                                      \
-		IOMUX_PAD(0x0520, 0x0150, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0520, 0x0150, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D19__ECSPI1_SS1                                          \
 		IOMUX_PAD(0x0520, 0x0150, 1, 0x07E8, 1, MX6DL_ECSPI_PAD_CTRL)
 #define MX6DL_PAD_EIM_D19__IPU1_DI0_PIN8                                       \
@@ -1549,7 +1560,7 @@
 		IOMUX_PAD(0x0520, 0x0150, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D20__WEIM_WEIM_D_20                                      \
-		IOMUX_PAD(0x0524, 0x0154, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0524, 0x0154, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D20__ECSPI4_SS0                                          \
 		IOMUX_PAD(0x0524, 0x0154, 1, 0x0808, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D20__IPU1_DI0_PIN16                                      \
@@ -1568,7 +1579,7 @@
 		IOMUX_PAD(0x0524, 0x0154, 7, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D21__WEIM_WEIM_D_21                                      \
-		IOMUX_PAD(0x0528, 0x0158, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0528, 0x0158, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D21__ECSPI4_SCLK                                         \
 		IOMUX_PAD(0x0528, 0x0158, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D21__IPU1_DI0_PIN17                                      \
@@ -1585,7 +1596,7 @@
 		IOMUX_PAD(0x0528, 0x0158, 7, 0x08F0, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D22__WEIM_WEIM_D_22                                      \
-		IOMUX_PAD(0x052C, 0x015C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x052C, 0x015C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D22__ECSPI4_MISO                                         \
 		IOMUX_PAD(0x052C, 0x015C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D22__IPU1_DI0_PIN1                                       \
@@ -1604,7 +1615,7 @@
 		IOMUX_PAD(0x052C, 0x015C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D23__WEIM_WEIM_D_23                                      \
-		IOMUX_PAD(0x0530, 0x0160, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0530, 0x0160, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D23__IPU1_DI0_D0_CS                                      \
 		IOMUX_PAD(0x0530, 0x0160, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D23__UART3_CTS                                           \
@@ -1625,7 +1636,7 @@
 		IOMUX_PAD(0x0530, 0x0160, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D24__WEIM_WEIM_D_24                                      \
-		IOMUX_PAD(0x0534, 0x0164, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0534, 0x0164, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D24__ECSPI4_SS2                                          \
 		IOMUX_PAD(0x0534, 0x0164, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D24__UART3_TXD                                           \
@@ -1646,7 +1657,7 @@
 		IOMUX_PAD(0x0534, 0x0164, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D25__WEIM_WEIM_D_25                                      \
-		IOMUX_PAD(0x0538, 0x0168, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0538, 0x0168, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D25__ECSPI4_SS3                                          \
 		IOMUX_PAD(0x0538, 0x0168, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D25__UART3_TXD                                           \
@@ -1667,7 +1678,7 @@
 		IOMUX_PAD(0x0538, 0x0168, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D26__WEIM_WEIM_D_26                                      \
-		IOMUX_PAD(0x053C, 0x016C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x053C, 0x016C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D26__IPU1_DI1_PIN11                                      \
 		IOMUX_PAD(0x053C, 0x016C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D26__IPU1_CSI0_D_1                                       \
@@ -1688,7 +1699,7 @@
 		IOMUX_PAD(0x053C, 0x016C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D27__WEIM_WEIM_D_27                                      \
-		IOMUX_PAD(0x0540, 0x0170, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0540, 0x0170, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D27__IPU1_DI1_PIN13                                      \
 		IOMUX_PAD(0x0540, 0x0170, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D27__IPU1_CSI0_D_0                                       \
@@ -1709,7 +1720,7 @@
 		IOMUX_PAD(0x0540, 0x0170, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D28__WEIM_WEIM_D_28                                      \
-		IOMUX_PAD(0x0544, 0x0174, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0544, 0x0174, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D28__I2C1_SDA                                            \
 		IOMUX_PAD(0x0544, 0x0174, 1 | IOMUX_CONFIG_SION, 0x086C, 1, MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_EIM_D28__ECSPI4_MOSI                                         \
@@ -1730,7 +1741,7 @@
 		IOMUX_PAD(0x0544, 0x0174, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D29__WEIM_WEIM_D_29                                      \
-		IOMUX_PAD(0x0548, 0x0178, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0548, 0x0178, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D29__IPU1_DI1_PIN15                                      \
 		IOMUX_PAD(0x0548, 0x0178, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D29__ECSPI4_SS0                                          \
@@ -1749,7 +1760,7 @@
 		IOMUX_PAD(0x0548, 0x0178, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D30__WEIM_WEIM_D_30                                      \
-		IOMUX_PAD(0x054C, 0x017C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x054C, 0x017C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D30__IPU1_DISP1_DAT_21                                   \
 		IOMUX_PAD(0x054C, 0x017C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D30__IPU1_DI0_PIN11                                      \
@@ -1770,7 +1781,7 @@
 		IOMUX_PAD(0x054C, 0x017C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_D31__WEIM_WEIM_D_31                                      \
-		IOMUX_PAD(0x0550, 0x0180, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0550, 0x0180, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_D31__IPU1_DISP1_DAT_20                                   \
 		IOMUX_PAD(0x0550, 0x0180, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_D31__IPU1_DI0_PIN12                                      \
@@ -1793,7 +1804,7 @@
 		IOMUX_PAD(0x0550, 0x0180, 9, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA0__WEIM_WEIM_DA_A_0                                    \
-		IOMUX_PAD(0x0554, 0x0184, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0554, 0x0184, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA0__IPU1_DISP1_DAT_9                                    \
 		IOMUX_PAD(0x0554, 0x0184, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA0__IPU1_CSI1_D_9                                       \
@@ -1810,7 +1821,7 @@
 		IOMUX_PAD(0x0554, 0x0184, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA1__WEIM_WEIM_DA_A_1                                    \
-		IOMUX_PAD(0x0558, 0x0188, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0558, 0x0188, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA1__IPU1_DISP1_DAT_8                                    \
 		IOMUX_PAD(0x0558, 0x0188, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA1__IPU1_CSI1_D_8                                       \
@@ -1829,7 +1840,7 @@
 		IOMUX_PAD(0x0558, 0x0188, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA10__WEIM_WEIM_DA_A_10                                  \
-		IOMUX_PAD(0x055C, 0x018C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x055C, 0x018C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA10__IPU1_DI1_PIN15                                     \
 		IOMUX_PAD(0x055C, 0x018C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA10__IPU1_CSI1_DATA_EN                                  \
@@ -1846,7 +1857,7 @@
 		IOMUX_PAD(0x055C, 0x018C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA11__WEIM_WEIM_DA_A_11                                  \
-		IOMUX_PAD(0x0560, 0x0190, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0560, 0x0190, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA11__IPU1_DI1_PIN2                                      \
 		IOMUX_PAD(0x0560, 0x0190, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA11__IPU1_CSI1_HSYNC                                    \
@@ -1865,7 +1876,7 @@
 		IOMUX_PAD(0x0560, 0x0190, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA12__WEIM_WEIM_DA_A_12                                  \
-		IOMUX_PAD(0x0564, 0x0194, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0564, 0x0194, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA12__IPU1_DI1_PIN3                                      \
 		IOMUX_PAD(0x0564, 0x0194, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA12__IPU1_CSI1_VSYNC                                    \
@@ -1884,7 +1895,7 @@
 		IOMUX_PAD(0x0564, 0x0194, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA13__WEIM_WEIM_DA_A_13                                  \
-		IOMUX_PAD(0x0568, 0x0198, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0568, 0x0198, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA13__IPU1_DI1_D0_CS                                     \
 		IOMUX_PAD(0x0568, 0x0198, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA13__CCM_DI1_EXT_CLK                                    \
@@ -1903,7 +1914,7 @@
 		IOMUX_PAD(0x0568, 0x0198, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA14__WEIM_WEIM_DA_A_14                                  \
-		IOMUX_PAD(0x056C, 0x019C, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x056C, 0x019C, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA14__IPU1_DI1_D1_CS                                     \
 		IOMUX_PAD(0x056C, 0x019C, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA14__CCM_DI0_EXT_CLK                                    \
@@ -1922,7 +1933,7 @@
 		IOMUX_PAD(0x056C, 0x019C, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA15__WEIM_WEIM_DA_A_15                                  \
-		IOMUX_PAD(0x0570, 0x01A0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0570, 0x01A0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA15__IPU1_DI1_PIN1                                      \
 		IOMUX_PAD(0x0570, 0x01A0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA15__IPU1_DI1_PIN4                                      \
@@ -1939,7 +1950,7 @@
 		IOMUX_PAD(0x0570, 0x01A0, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA2__WEIM_WEIM_DA_A_2                                    \
-		IOMUX_PAD(0x0574, 0x01A4, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0574, 0x01A4, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA2__IPU1_DISP1_DAT_7                                    \
 		IOMUX_PAD(0x0574, 0x01A4, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA2__IPU1_CSI1_D_7                                       \
@@ -1958,7 +1969,7 @@
 		IOMUX_PAD(0x0574, 0x01A4, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA3__WEIM_WEIM_DA_A_3                                    \
-		IOMUX_PAD(0x0578, 0x01A8, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0578, 0x01A8, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA3__IPU1_DISP1_DAT_6                                    \
 		IOMUX_PAD(0x0578, 0x01A8, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA3__IPU1_CSI1_D_6                                       \
@@ -1977,7 +1988,7 @@
 		IOMUX_PAD(0x0578, 0x01A8, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA4__WEIM_WEIM_DA_A_4                                    \
-		IOMUX_PAD(0x057C, 0x01AC, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x057C, 0x01AC, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA4__IPU1_DISP1_DAT_5                                    \
 		IOMUX_PAD(0x057C, 0x01AC, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA4__IPU1_CSI1_D_5                                       \
@@ -1996,7 +2007,7 @@
 		IOMUX_PAD(0x057C, 0x01AC, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA5__WEIM_WEIM_DA_A_5                                    \
-		IOMUX_PAD(0x0580, 0x01B0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0580, 0x01B0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA5__IPU1_DISP1_DAT_4                                    \
 		IOMUX_PAD(0x0580, 0x01B0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA5__IPU1_CSI1_D_4                                       \
@@ -2015,7 +2026,7 @@
 		IOMUX_PAD(0x0580, 0x01B0, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA6__WEIM_WEIM_DA_A_6                                    \
-		IOMUX_PAD(0x0584, 0x01B4, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0584, 0x01B4, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA6__IPU1_DISP1_DAT_3                                    \
 		IOMUX_PAD(0x0584, 0x01B4, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA6__IPU1_CSI1_D_3                                       \
@@ -2034,7 +2045,7 @@
 		IOMUX_PAD(0x0584, 0x01B4, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA7__WEIM_WEIM_DA_A_7                                    \
-		IOMUX_PAD(0x0588, 0x01B8, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0588, 0x01B8, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA7__IPU1_DISP1_DAT_2                                    \
 		IOMUX_PAD(0x0588, 0x01B8, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA7__IPU1_CSI1_D_2                                       \
@@ -2051,7 +2062,7 @@
 		IOMUX_PAD(0x0588, 0x01B8, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA8__WEIM_WEIM_DA_A_8                                    \
-		IOMUX_PAD(0x058C, 0x01BC, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x058C, 0x01BC, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA8__IPU1_DISP1_DAT_1                                    \
 		IOMUX_PAD(0x058C, 0x01BC, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA8__IPU1_CSI1_D_1                                       \
@@ -2068,7 +2079,7 @@
 		IOMUX_PAD(0x058C, 0x01BC, 8, 0x0000, 0, NO_PAD_CTRL)
 
 #define MX6DL_PAD_EIM_DA9__WEIM_WEIM_DA_A_9                                    \
-		IOMUX_PAD(0x0590, 0x01C0, 0, 0x0000, 0, NO_PAD_CTRL)
+		IOMUX_PAD(0x0590, 0x01C0, 0, 0x0000, 0, MX6DL_WEIM_NOR_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA9__IPU1_DISP1_DAT_0                                    \
 		IOMUX_PAD(0x0590, 0x01C0, 1, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_EIM_DA9__IPU1_CSI1_D_0                                       \
@@ -2520,10 +2531,12 @@
 #define MX6DL_PAD_GPIO_5__SIMBA_EVENTI                                         \
 		IOMUX_PAD(0x0600, 0x0230, 7, 0x0000, 0, NO_PAD_CTRL)
 
-#define MX6DL_PAD_GPIO_6__ESAI1_SCKT                                           \
-		IOMUX_PAD(0x0604, 0x0234, 0, 0x0840, 1, NO_PAD_CTRL)
+#define MX6DL_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6                           \
+		IOMUX_PAD(0x0604, 0x0234, 1 | IOMUX_CONFIG_SION, 0x0000, 0, ENET_IRQ_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1                           \
 		IOMUX_PAD(0x0604, 0x0234, 1, 0x0000, 0, NO_PAD_CTRL)
+#define MX6DL_PAD_GPIO_6__ESAI1_SCKT                                           \
+		IOMUX_PAD(0x0604, 0x0234, 0, 0x0840, 1, NO_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__I2C3_SDA                                             \
 		IOMUX_PAD(0x0604, 0x0234, 2 | IOMUX_CONFIG_SION, 0x087C, 2, MX6DL_I2C_PAD_CTRL)
 #define MX6DL_PAD_GPIO_6__CCM_CCM_OUT_0                                        \
@@ -2756,7 +2769,7 @@
 #define MX6DL_PAD_KEY_ROW2__GPIO_4_11                                          \
 		IOMUX_PAD(0x0648, 0x0260, 5, 0x0000, 0, NO_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE                                   \
-		IOMUX_PAD(0x0648, 0x0260, 6, 0x085C, 1, NO_PAD_CTRL)
+		IOMUX_PAD(0x0648, 0x0260, 6, 0x085C, 1, MX6DL_HDMICEC_PAD_CTRL)
 #define MX6DL_PAD_KEY_ROW2__PL301_SIM_MX6DL_PER1_HADDR_4                       \
 		IOMUX_PAD(0x0648, 0x0260, 7, 0x0000, 0, NO_PAD_CTRL)
 
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx6q.h b/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
index cdff320..16cd87f 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -85,7 +85,7 @@
 #define MX6Q_ECSPI_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
-#define MX6Q_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_22K_UP | \
+#define MX6Q_HDMICEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | \
 		PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_ODE | PAD_CTL_SPEED_MED | \
 		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_SLOW)
 
@@ -93,6 +93,13 @@
 		PAD_CTL_DSE_40ohm | PAD_CTL_PUS_100K_DOWN |		\
 		PAD_CTL_HYS | PAD_CTL_SPEED_MED)
 
+#define MX6Q_WEIM_NOR_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm |	\
+		PAD_CTL_SPEED_MED | PAD_CTL_PKE	| PAD_CTL_PUE | 	\
+		PAD_CTL_PUS_100K_UP)
+
+#define ENET_IRQ_PAD_CTRL (PAD_CTL_SRE_FAST | PAD_CTL_DSE_40ohm | \
+		PAD_CTL_SPEED_MED)
+
 #define _MX6Q_PAD_SD2_DAT1__USDHC2_DAT1				\
 		IOMUX_PAD(0x0360, 0x004C, 0, 0x0000, 0, 0)
 #define _MX6Q_PAD_SD2_DAT1__ECSPI5_SS0				\
@@ -2249,7 +2256,7 @@
 #define _MX6Q_PAD_KEY_ROW4__KPP_ROW_4			\
 		IOMUX_PAD(0x05EC, 0x021C, 3, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__UART5_CTS			\
-		IOMUX_PAD(0x05EC, 0x021C, 4, 0x093C, 1, 0)
+		IOMUX_PAD(0x05EC, 0x021C, 4, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__GPIO_4_15			\
 		IOMUX_PAD(0x05EC, 0x021C, 5, 0x0000, 0, 0)
 #define _MX6Q_PAD_KEY_ROW4__MMDC_MMDC_DEBUG_50		\
@@ -2325,6 +2332,8 @@
 
 #define _MX6Q_PAD_GPIO_6__ESAI1_SCKT			\
 		IOMUX_PAD(0x0600, 0x0230, 0, 0x0870, 1, 0)
+#define _MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6		\
+		IOMUX_PAD(0x0600, 0x0230, 1 | IOMUX_CONFIG_SION, 0x0000, 0, 0)
 #define _MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
 		IOMUX_PAD(0x0600, 0x0230, 1, 0x0000, 0, 0)
 #define _MX6Q_PAD_GPIO_6__I2C3_SDA			\
@@ -3902,7 +3911,7 @@
 		(_MX6Q_PAD_EIM_EB2__SRC_BT_CFG_30 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16		\
-		(_MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D16__WEIM_WEIM_D_16 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D16__ECSPI1_SCLK		\
 		(_MX6Q_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D16__IPU1_DI0_PIN5		\
@@ -3917,7 +3926,7 @@
 		(_MX6Q_PAD_EIM_D16__I2C2_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17		\
-		(_MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D17__WEIM_WEIM_D_17 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D17__ECSPI1_MISO		\
 		(_MX6Q_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D17__IPU1_DI0_PIN6		\
@@ -3934,7 +3943,7 @@
 		(_MX6Q_PAD_EIM_D17__PL301_MX6QPER1_HBURST_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18		\
-		(_MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D18__WEIM_WEIM_D_18 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D18__ECSPI1_MOSI		\
 		(_MX6Q_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D18__IPU1_DI0_PIN7		\
@@ -3951,7 +3960,7 @@
 		(_MX6Q_PAD_EIM_D18__PL301_MX6QPER1_HBURST_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19		\
-		(_MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D19__WEIM_WEIM_D_19 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D19__ECSPI1_SS1		\
 		(_MX6Q_PAD_EIM_D19__ECSPI1_SS1 | MUX_PAD_CTRL(MX6Q_ECSPI_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D19__IPU1_DI0_PIN8		\
@@ -3968,7 +3977,7 @@
 		(_MX6Q_PAD_EIM_D19__PL301_MX6QPER1_HRESP | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20		\
-		(_MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D20__WEIM_WEIM_D_20 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D20__ECSPI4_SS0		\
 		(_MX6Q_PAD_EIM_D20__ECSPI4_SS0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D20__IPU1_DI0_PIN16		\
@@ -3985,7 +3994,7 @@
 		(_MX6Q_PAD_EIM_D20__EPIT2_EPITO | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21		\
-		(_MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D21__WEIM_WEIM_D_21 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D21__ECSPI4_SCLK		\
 		(_MX6Q_PAD_EIM_D21__ECSPI4_SCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D21__IPU1_DI0_PIN17		\
@@ -4002,7 +4011,7 @@
 		(_MX6Q_PAD_EIM_D21__SPDIF_IN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22		\
-		(_MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D22__WEIM_WEIM_D_22 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D22__ECSPI4_MISO		\
 		(_MX6Q_PAD_EIM_D22__ECSPI4_MISO | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D22__IPU1_DI0_PIN1		\
@@ -4019,7 +4028,7 @@
 		(_MX6Q_PAD_EIM_D22__PL301_MX6QPER1_HWRITE | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23		\
-		(_MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D23__WEIM_WEIM_D_23 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D23__IPU1_DI0_D0_CS		\
 		(_MX6Q_PAD_EIM_D23__IPU1_DI0_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D23__UART3_CTS		\
@@ -4055,7 +4064,7 @@
 		(_MX6Q_PAD_EIM_EB3__SRC_BT_CFG_31 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24		\
-		(_MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D24__WEIM_WEIM_D_24 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D24__ECSPI4_SS2		\
 		(_MX6Q_PAD_EIM_D24__ECSPI4_SS2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D24__UART3_TXD		\
@@ -4074,7 +4083,7 @@
 		(_MX6Q_PAD_EIM_D24__UART1_DTR | MUX_PAD_CTRL(MX6Q_UART_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25		\
-		(_MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D25__WEIM_WEIM_D_25 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D25__ECSPI4_SS3		\
 		(_MX6Q_PAD_EIM_D25__ECSPI4_SS3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D25__UART3_TXD		\
@@ -4093,7 +4102,7 @@
 		(_MX6Q_PAD_EIM_D25__UART1_DSR | MUX_PAD_CTRL(MX6Q_UART_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26		\
-		(_MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D26__WEIM_WEIM_D_26 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D26__IPU1_DI1_PIN11		\
 		(_MX6Q_PAD_EIM_D26__IPU1_DI1_PIN11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D26__IPU1_CSI0_D_1		\
@@ -4112,7 +4121,7 @@
 		(_MX6Q_PAD_EIM_D26__IPU1_DISP1_DAT_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27		\
-		(_MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D27__WEIM_WEIM_D_27 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D27__IPU1_DI1_PIN13		\
 		(_MX6Q_PAD_EIM_D27__IPU1_DI1_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D27__IPU1_CSI0_D_0		\
@@ -4131,7 +4140,7 @@
 		(_MX6Q_PAD_EIM_D27__IPU1_DISP1_DAT_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28		\
-		(_MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D28__WEIM_WEIM_D_28 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D28__I2C1_SDA		\
 		(_MX6Q_PAD_EIM_D28__I2C1_SDA | MUX_PAD_CTRL(MX6Q_I2C_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D28__ECSPI4_MOSI		\
@@ -4150,7 +4159,7 @@
 		(_MX6Q_PAD_EIM_D28__IPU1_DI0_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29		\
-		(_MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D29__WEIM_WEIM_D_29 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D29__IPU1_DI1_PIN15		\
 		(_MX6Q_PAD_EIM_D29__IPU1_DI1_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D29__ECSPI4_SS0		\
@@ -4167,7 +4176,7 @@
 		(_MX6Q_PAD_EIM_D29__IPU1_DI0_PIN14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30		\
-		(_MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D30__WEIM_WEIM_D_30 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D30__IPU1_DISP1_DAT_21		\
 		(_MX6Q_PAD_EIM_D30__IPU1_DISP1_DAT_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D30__IPU1_DI0_PIN11		\
@@ -4184,7 +4193,7 @@
 		(_MX6Q_PAD_EIM_D30__PL301_MX6QPER1_HPROT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31		\
-		(_MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_D31__WEIM_WEIM_D_31 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D31__IPU1_DISP1_DAT_20		\
 		(_MX6Q_PAD_EIM_D31__IPU1_DISP1_DAT_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_D31__IPU1_DI0_PIN12		\
@@ -4220,7 +4229,7 @@
 		(_MX6Q_PAD_EIM_A24__SRC_BT_CFG_24 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23		\
-		(_MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A23__WEIM_WEIM_A_23 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A23__IPU1_DISP1_DAT_18		\
 		(_MX6Q_PAD_EIM_A23__IPU1_DISP1_DAT_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A23__IPU2_CSI1_D_18		\
@@ -4237,7 +4246,7 @@
 		(_MX6Q_PAD_EIM_A23__SRC_BT_CFG_23 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22		\
-		(_MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A22__WEIM_WEIM_A_22 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A22__IPU1_DISP1_DAT_17		\
 		(_MX6Q_PAD_EIM_A22__IPU1_DISP1_DAT_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A22__IPU2_CSI1_D_17		\
@@ -4250,7 +4259,7 @@
 		(_MX6Q_PAD_EIM_A22__SRC_BT_CFG_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21		\
-		(_MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A21__WEIM_WEIM_A_21 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A21__IPU1_DISP1_DAT_16		\
 		(_MX6Q_PAD_EIM_A21__IPU1_DISP1_DAT_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A21__IPU2_CSI1_D_16		\
@@ -4267,7 +4276,7 @@
 		(_MX6Q_PAD_EIM_A21__SRC_BT_CFG_21 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20		\
-		(_MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A20__WEIM_WEIM_A_20 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A20__IPU1_DISP1_DAT_15		\
 		(_MX6Q_PAD_EIM_A20__IPU1_DISP1_DAT_15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A20__IPU2_CSI1_D_15		\
@@ -4284,7 +4293,7 @@
 		(_MX6Q_PAD_EIM_A20__SRC_BT_CFG_20 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19		\
-		(_MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A19__WEIM_WEIM_A_19 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A19__IPU1_DISP1_DAT_14		\
 		(_MX6Q_PAD_EIM_A19__IPU1_DISP1_DAT_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A19__IPU2_CSI1_D_14		\
@@ -4301,7 +4310,7 @@
 		(_MX6Q_PAD_EIM_A19__SRC_BT_CFG_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18		\
-		(_MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A18__WEIM_WEIM_A_18 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A18__IPU1_DISP1_DAT_13		\
 		(_MX6Q_PAD_EIM_A18__IPU1_DISP1_DAT_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A18__IPU2_CSI1_D_13		\
@@ -4318,7 +4327,7 @@
 		(_MX6Q_PAD_EIM_A18__SRC_BT_CFG_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17		\
-		(_MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A17__WEIM_WEIM_A_17 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A17__IPU1_DISP1_DAT_12		\
 		(_MX6Q_PAD_EIM_A17__IPU1_DISP1_DAT_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A17__IPU2_CSI1_D_12		\
@@ -4335,7 +4344,7 @@
 		(_MX6Q_PAD_EIM_A17__SRC_BT_CFG_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16		\
-		(_MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_A16__WEIM_WEIM_A_16 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A16__IPU1_DI1_DISP_CLK		\
 		(_MX6Q_PAD_EIM_A16__IPU1_DI1_DISP_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_A16__IPU2_CSI1_PIXCLK		\
@@ -4449,7 +4458,7 @@
 		(_MX6Q_PAD_EIM_EB1__SRC_BT_CFG_28 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0		\
-		(_MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA0__WEIM_WEIM_DA_A_0 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA0__IPU1_DISP1_DAT_9		\
 		(_MX6Q_PAD_EIM_DA0__IPU1_DISP1_DAT_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA0__IPU2_CSI1_D_9		\
@@ -4464,7 +4473,7 @@
 		(_MX6Q_PAD_EIM_DA0__SRC_BT_CFG_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1		\
-		(_MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA1__WEIM_WEIM_DA_A_1 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA1__IPU1_DISP1_DAT_8		\
 		(_MX6Q_PAD_EIM_DA1__IPU1_DISP1_DAT_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA1__IPU2_CSI1_D_8		\
@@ -4481,7 +4490,7 @@
 		(_MX6Q_PAD_EIM_DA1__SRC_BT_CFG_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2		\
-		(_MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA2__WEIM_WEIM_DA_A_2 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA2__IPU1_DISP1_DAT_7		\
 		(_MX6Q_PAD_EIM_DA2__IPU1_DISP1_DAT_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA2__IPU2_CSI1_D_7		\
@@ -4498,7 +4507,7 @@
 		(_MX6Q_PAD_EIM_DA2__SRC_BT_CFG_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3		\
-		(_MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA3__WEIM_WEIM_DA_A_3 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA3__IPU1_DISP1_DAT_6		\
 		(_MX6Q_PAD_EIM_DA3__IPU1_DISP1_DAT_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA3__IPU2_CSI1_D_6		\
@@ -4515,7 +4524,7 @@
 		(_MX6Q_PAD_EIM_DA3__SRC_BT_CFG_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4		\
-		(_MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA4__WEIM_WEIM_DA_A_4 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA4__IPU1_DISP1_DAT_5		\
 		(_MX6Q_PAD_EIM_DA4__IPU1_DISP1_DAT_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA4__IPU2_CSI1_D_5		\
@@ -4532,7 +4541,7 @@
 		(_MX6Q_PAD_EIM_DA4__SRC_BT_CFG_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5		\
-		(_MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA5__WEIM_WEIM_DA_A_5 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA5__IPU1_DISP1_DAT_4		\
 		(_MX6Q_PAD_EIM_DA5__IPU1_DISP1_DAT_4 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA5__IPU2_CSI1_D_4		\
@@ -4549,7 +4558,7 @@
 		(_MX6Q_PAD_EIM_DA5__SRC_BT_CFG_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6		\
-		(_MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA6__WEIM_WEIM_DA_A_6 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA6__IPU1_DISP1_DAT_3		\
 		(_MX6Q_PAD_EIM_DA6__IPU1_DISP1_DAT_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA6__IPU2_CSI1_D_3		\
@@ -4566,7 +4575,7 @@
 		(_MX6Q_PAD_EIM_DA6__SRC_BT_CFG_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7		\
-		(_MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA7__WEIM_WEIM_DA_A_7 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA7__IPU1_DISP1_DAT_2		\
 		(_MX6Q_PAD_EIM_DA7__IPU1_DISP1_DAT_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA7__IPU2_CSI1_D_2		\
@@ -4581,7 +4590,7 @@
 		(_MX6Q_PAD_EIM_DA7__SRC_BT_CFG_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8		\
-		(_MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA8__WEIM_WEIM_DA_A_8 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA8__IPU1_DISP1_DAT_1		\
 		(_MX6Q_PAD_EIM_DA8__IPU1_DISP1_DAT_1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA8__IPU2_CSI1_D_1		\
@@ -4596,7 +4605,7 @@
 		(_MX6Q_PAD_EIM_DA8__SRC_BT_CFG_8 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9		\
-		(_MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA9__WEIM_WEIM_DA_A_9 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA9__IPU1_DISP1_DAT_0		\
 		(_MX6Q_PAD_EIM_DA9__IPU1_DISP1_DAT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA9__IPU2_CSI1_D_0		\
@@ -4611,7 +4620,7 @@
 		(_MX6Q_PAD_EIM_DA9__SRC_BT_CFG_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10		\
-		(_MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA10__WEIM_WEIM_DA_A_10 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA10__IPU1_DI1_PIN15		\
 		(_MX6Q_PAD_EIM_DA10__IPU1_DI1_PIN15 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA10__IPU2_CSI1_DATA_EN		\
@@ -4626,7 +4635,7 @@
 		(_MX6Q_PAD_EIM_DA10__SRC_BT_CFG_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11		\
-		(_MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA11__WEIM_WEIM_DA_A_11 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA11__IPU1_DI1_PIN2		\
 		(_MX6Q_PAD_EIM_DA11__IPU1_DI1_PIN2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA11__IPU2_CSI1_HSYNC		\
@@ -4643,7 +4652,7 @@
 		(_MX6Q_PAD_EIM_DA11__SRC_BT_CFG_11 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12		\
-		(_MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA12__WEIM_WEIM_DA_A_12 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA12__IPU1_DI1_PIN3		\
 		(_MX6Q_PAD_EIM_DA12__IPU1_DI1_PIN3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA12__IPU2_CSI1_VSYNC		\
@@ -4660,7 +4669,7 @@
 		(_MX6Q_PAD_EIM_DA12__SRC_BT_CFG_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13		\
-		(_MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA13__WEIM_WEIM_DA_A_13 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA13__IPU1_DI1_D0_CS		\
 		(_MX6Q_PAD_EIM_DA13__IPU1_DI1_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA13__CCM_DI1_EXT_CLK		\
@@ -4677,7 +4686,7 @@
 		(_MX6Q_PAD_EIM_DA13__SRC_BT_CFG_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14		\
-		(_MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA14__WEIM_WEIM_DA_A_14 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA14__IPU1_DI1_D1_CS		\
 		(_MX6Q_PAD_EIM_DA14__IPU1_DI1_D1_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA14__CCM_DI0_EXT_CLK		\
@@ -4694,7 +4703,7 @@
 		(_MX6Q_PAD_EIM_DA14__SRC_BT_CFG_14 | MUX_PAD_CTRL(NO_PAD_CTRL))
 
 #define  MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15		\
-		(_MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15 | MUX_PAD_CTRL(NO_PAD_CTRL))
+		(_MX6Q_PAD_EIM_DA15__WEIM_WEIM_DA_A_15 | MUX_PAD_CTRL(MX6Q_WEIM_NOR_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN1		\
 		(_MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_EIM_DA15__IPU1_DI1_PIN4		\
@@ -5928,18 +5937,20 @@
 #define  MX6Q_PAD_GPIO_3__MLB_MLBCLK		\
 		(_MX6Q_PAD_GPIO_3__MLB_MLBCLK | MUX_PAD_CTRL(MX6Q_MLB150_PAD_CTRL))
 
-#define  MX6Q_PAD_GPIO_6__ESAI1_SCKT		\
-		(_MX6Q_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6		\
+		(_MX6Q_PAD_GPIO_6__ENET_IRQ_TO_GPIO_6 | MUX_PAD_CTRL(ENET_IRQ_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		\
 		(_MX6Q_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1 | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__ESAI1_SCKT		\
+		(_MX6Q_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define  MX6Q_PAD_GPIO_6__GPIO_1_6		\
+		(_MX6Q_PAD_GPIO_6__GPIO_1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__I2C3_SDA		\
 		(_MX6Q_PAD_GPIO_6__I2C3_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0		\
 		(_MX6Q_PAD_GPIO_6__CCM_CCM_OUT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__CSU_CSU_INT_DEB		\
 		(_MX6Q_PAD_GPIO_6__CSU_CSU_INT_DEB | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define  MX6Q_PAD_GPIO_6__GPIO_1_6		\
-		(_MX6Q_PAD_GPIO_6__GPIO_1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__USDHC2_LCTL		\
 		(_MX6Q_PAD_GPIO_6__USDHC2_LCTL | MUX_PAD_CTRL(MX6Q_USDHC_PAD_CTRL))
 #define  MX6Q_PAD_GPIO_6__MLB_MLBSIG		\
diff --git a/arch/arm/plat-mxc/include/mach/ipu-v3.h b/arch/arm/plat-mxc/include/mach/ipu-v3.h
index 519e628..e2265d4 100755
--- a/arch/arm/plat-mxc/include/mach/ipu-v3.h
+++ b/arch/arm/plat-mxc/include/mach/ipu-v3.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -419,10 +419,10 @@ typedef struct {
  * Enumeration of CSI data bus widths.
  */
 enum {
-	IPU_CSI_DATA_WIDTH_4,
-	IPU_CSI_DATA_WIDTH_8,
-	IPU_CSI_DATA_WIDTH_10,
-	IPU_CSI_DATA_WIDTH_16,
+	IPU_CSI_DATA_WIDTH_4 = 0,
+	IPU_CSI_DATA_WIDTH_8 = 1,
+	IPU_CSI_DATA_WIDTH_10 = 3,
+	IPU_CSI_DATA_WIDTH_16 = 9,
 };
 
 /*!
@@ -587,6 +587,7 @@ struct ipu_soc;
 struct ipu_soc *ipu_get_soc(int id);
 int32_t ipu_init_channel(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
 void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel);
+void ipu_disable_hsp_clk(struct ipu_soc *ipu);
 
 static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
 {
@@ -640,7 +641,7 @@ int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi);
 int ipu_lowpwr_display_enable(void);
 int ipu_lowpwr_display_disable(void);
 
-void ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq);
+int ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq);
 void ipu_disable_irq(struct ipu_soc *ipu, uint32_t irq);
 void ipu_clear_irq(struct ipu_soc *ipu, uint32_t irq);
 int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
diff --git a/arch/arm/plat-mxc/include/mach/irqs.h b/arch/arm/plat-mxc/include/mach/irqs.h
index 9e44eaa..62282a9 100644
--- a/arch/arm/plat-mxc/include/mach/irqs.h
+++ b/arch/arm/plat-mxc/include/mach/irqs.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -72,7 +72,14 @@
 #define MX5_IPU_IRQS 0
 #endif
 
-#define NR_IRQS	(MXC_IPU_IRQ_START + MX3_IPU_IRQS + MX5_IPU_IRQS)
+#ifdef CONFIG_ARCH_MX6
+#define MX6_MSI_IRQS 128
+#else
+#define MX6_MSI_IRQS 0
+#endif
+
+#define IRQ_IMX_MSI_0 (MXC_IPU_IRQ_START + MX3_IPU_IRQS + MX5_IPU_IRQS)
+#define NR_IRQS  (IRQ_IMX_MSI_0 + MX6_MSI_IRQS)
 
 extern int imx_irq_set_priority(unsigned char irq, unsigned char prio);
 
diff --git a/arch/arm/plat-mxc/include/mach/mx6.h b/arch/arm/plat-mxc/include/mach/mx6.h
index bb22de0..ba38b8a 100644
--- a/arch/arm/plat-mxc/include/mach/mx6.h
+++ b/arch/arm/plat-mxc/include/mach/mx6.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -283,6 +283,8 @@
 #define MX6Q_UART2_BASE_ADDR		UART2_BASE_ADDR
 #define MX6Q_UART3_BASE_ADDR		UART3_BASE_ADDR
 #define MX6Q_UART4_BASE_ADDR		UART4_BASE_ADDR
+#define MX6Q_UART5_BASE_ADDR		UART5_BASE_ADDR
+
 #define MX6Q_FEC_BASE_ADDR		ENET_BASE_ADDR
 #define MX6DL_FEC_BASE_ADDR		ENET_BASE_ADDR
 #define MX6Q_MIPI_DSI_BASE_ADDR		MIPI_DSI_BASE_ADDR
@@ -486,6 +488,7 @@
 #define MX6Q_INT_UART2			MXC_INT_UART2_ANDED
 #define MX6Q_INT_UART3			MXC_INT_UART3_ANDED
 #define MX6Q_INT_UART4			MXC_INT_UART4_ANDED
+#define MX6Q_INT_UART5			MXC_INT_UART5_ANDED
 #define MX6SL_INT_UART1			MXC_INT_UART1_ANDED
 #define MX6SL_INT_UART2			MXC_INT_UART2_ANDED
 #define MX6SL_INT_UART3			MXC_INT_UART3_ANDED
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 4260d4a..75b99af 100755
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007, 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright 2004-2007, 2011-2013 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
  *
  * This program is free software; you can redistribute it and/or
@@ -275,6 +275,28 @@ int tzic_enable_wake(int is_idle);
 
 extern void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
 extern int tzic_enable_wake(int is_idle);
+
+/* available disableable devices in fuse */
+enum mxc_dev_type {
+	MXC_DEV_PXP,
+	MXC_DEV_OVG,
+	MXC_DEV_DSI_CSI2,
+	MXC_DEV_ENET,
+	MXC_DEV_MLB,
+	MXC_DEV_EPDC,
+	MXC_DEV_HDMI,
+	MXC_DEV_PCIE,
+	MXC_DEV_SATA,
+	MXC_DEV_DTCP,
+	MXC_DEV_2D,
+	MXC_DEV_3D,
+	MXC_DEV_VPU,
+	MXC_DEV_DIVX3,
+	MXC_DEV_RV,
+	MXC_DEV_SORENSEN,
+};
+extern int fuse_dev_is_available(enum mxc_dev_type dev);
+
 #endif
 
 #if defined(CONFIG_ARCH_MX3) || defined(CONFIG_ARCH_MX2)
diff --git a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
index 60946ca..94f7638 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -1085,4 +1085,11 @@ enum {
 
 };
 
+/* IOCTL commands */
+#define HDMI_IOC_MAGIC  'H'
+
+#define HDMI_IOC_GET_RESOURCE	_IO(HDMI_IOC_MAGIC, 0)
+#define HDMI_IOC_GET_CPU_TYPE	_IO(HDMI_IOC_MAGIC, 1)
+
+
 #endif /* __MXC_HDMI_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_vpu.h b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
index 7a6e24f..7869d59 100755
--- a/arch/arm/plat-mxc/include/mach/mxc_vpu.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -16,7 +16,7 @@
  */
 
 /*!
- * @file arch-mxc/mxc_vpu.h
+ * @file plat-mxc/include/mach/mxc_vpu.h
  *
  * @brief VPU system initialization and file operation definition
  *
@@ -58,6 +58,7 @@ struct vpu_mem_desc {
 #define VPU_IOC_QUERY_BITWORK_MEM  _IO(VPU_IOC_MAGIC, 13)
 #define VPU_IOC_SET_BITWORK_MEM    _IO(VPU_IOC_MAGIC, 14)
 #define VPU_IOC_PHYMEM_CHECK	_IO(VPU_IOC_MAGIC, 15)
+#define VPU_IOC_LOCK_DEV	_IO(VPU_IOC_MAGIC, 16)
 
 #define BIT_CODE_RUN			0x000
 #define BIT_CODE_DOWN			0x004
diff --git a/arch/arm/plat-mxc/include/mach/pcie.h b/arch/arm/plat-mxc/include/mach/pcie.h
index 775f651..177410d 100644
--- a/arch/arm/plat-mxc/include/mach/pcie.h
+++ b/arch/arm/plat-mxc/include/mach/pcie.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -35,5 +35,6 @@ struct imx_pcie_platform_data {
 	unsigned int pcie_rst;
 	unsigned int pcie_wake_up;
 	unsigned int pcie_dis;
+	unsigned int type_ep; /* 1 EP, 0 RC */
 };
 #endif /* __ASM_ARCH_IMX_PCIE_H */
diff --git a/arch/arm/plat-mxc/pwm.c b/arch/arm/plat-mxc/pwm.c
index b683d2e..eb49057 100755
--- a/arch/arm/plat-mxc/pwm.c
+++ b/arch/arm/plat-mxc/pwm.c
@@ -6,7 +6,7 @@
  * published by the Free Software Foundation.
  *
  * Derived from pxa PWM driver by eric miao <eric.miao@marvell.com>
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #include <linux/module.h>
@@ -87,11 +87,7 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		prescale = period_cycles / 0x10000 + 1;
 
 		period_cycles /= prescale;
-		/* the chip document says the counter counts up to
-		 * period_cycles + 1 and then is reset to 0, so the
-		 *  actual period of the PWM wave is period_cycles + 2
-		 */
-		c = (unsigned long long)(period_cycles + 2) * duty_ns;
+		c = (unsigned long long)period_cycles * duty_ns;
 		do_div(c, period_ns);
 		duty_cycles = c;
 
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index a327d30..f6acb8a 100755
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -182,7 +182,7 @@ void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
 
 	pr_debug("%s\n", __func__);
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
-		if (g_xc_ops[i] == xcvr_ops) {
+		if (g_xc_ops[i] && (g_xc_ops[i] == xcvr_ops)) {
 			g_xc_ops[i] = NULL;
 			return;
 		}
@@ -203,7 +203,7 @@ static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
 	}
 
 	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
-		if (strcmp(g_xc_ops[i]->name, name) == 0) {
+		if (g_xc_ops[i] && (strcmp(g_xc_ops[i]->name, name) == 0)) {
 			return g_xc_ops[i];
 		}
 	}
diff --git a/arch/arm/plat-mxc/usb_wakeup.c b/arch/arm/plat-mxc/usb_wakeup.c
index 5d31d36..00af25f 100755
--- a/arch/arm/plat-mxc/usb_wakeup.c
+++ b/arch/arm/plat-mxc/usb_wakeup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,7 +37,6 @@ struct wakeup_ctrl {
 	struct task_struct *thread;
 	struct completion  event;
 };
-static struct wakeup_ctrl *g_ctrl;
 
 extern int usb_event_is_otg_wakeup(struct fsl_usb2_platform_data *pdata);
 extern void usb_debounce_id_vbus(void);
@@ -218,7 +217,7 @@ static int wakeup_dev_probe(struct platform_device *pdev)
 	status = IS_ERR(ctrl->thread) ? -1 : 0;
 	if (status)
 		goto error2;
-	g_ctrl = ctrl;
+	platform_set_drvdata(pdev, ctrl);
 
 	printk(KERN_DEBUG "the wakeup pdata is 0x%p\n", pdata);
 	return 0;
@@ -231,13 +230,14 @@ error1:
 
 static int  wakeup_dev_exit(struct platform_device *pdev)
 {
-	if (g_ctrl->thread) {
-		g_ctrl->thread_close = true;
-		complete(&g_ctrl->event);
-		kthread_stop(g_ctrl->thread);
-	}
-	free_irq(g_ctrl->wakeup_irq, (void *)g_ctrl);
-	kfree(g_ctrl);
+	struct wakeup_ctrl *wctrl = platform_get_drvdata(pdev);
+
+	wctrl->thread_close = true;
+	complete(&wctrl->event);
+	kthread_stop(wctrl->thread);
+	free_irq(wctrl->wakeup_irq, (void *)wctrl);
+	kfree(wctrl);
+
 	return 0;
 }
 static struct platform_driver wakeup_d = {
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 88210d9..f6b5c0e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1118,5 +1118,6 @@ mx6q_sabrelite		MACH_MX6Q_SABRELITE	MX6Q_SABRELITE		3769
 mx6q_sabresd		MACH_MX6Q_SABRESD	MX6Q_SABRESD		3980
 mx6q_arm2		MACH_MX6Q_ARM2		MX6Q_ARM2		3837
 mx6sl_arm2		MACH_MX6SL_ARM2		MX6SL_ARM2		4091
+mx6q_hdmidongle		MACH_MX6Q_HDMIDONGLE    MX6Q_HDMIDONGLE		4284
 mx6sl_evk		MACH_MX6SL_EVK		MX6SL_EVK		4307
 
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index f25e7ec..d4405f5 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/cpu.h>
+#include <linux/hardirq.h>
 #include <linux/kernel.h>
 #include <linux/notifier.h>
 #include <linux/signal.h>
@@ -389,7 +390,10 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 
 static void vfp_enable(void *unused)
 {
-	u32 access = get_copro_access();
+	u32 access;
+
+	BUG_ON(preemptible());
+	access = get_copro_access();
 
 	/*
 	 * Enable full access to VFP (cp10 and cp11)
@@ -529,7 +533,7 @@ static int __init vfp_init(void)
 	unsigned int cpu_arch = cpu_architecture();
 
 	if (cpu_arch >= CPU_ARCH_ARMv6)
-		vfp_enable(NULL);
+		on_each_cpu(vfp_enable, NULL, 1);
 
 	/*
 	 * First check that there is a VFP that we can use.
@@ -550,8 +554,6 @@ static int __init vfp_init(void)
 	} else {
 		hotcpu_notifier(vfp_hotplug, 0);
 
-		smp_call_function(vfp_enable, NULL, 1);
-
 		VFP_arch = (vfpsid & FPSID_ARCH_MASK) >> FPSID_ARCH_BIT;  /* Extract the architecture version */
 		printk("implementor %02x architecture %d part %02x variant %x rev %x\n",
 			(vfpsid & FPSID_IMPLEMENTER_MASK) >> FPSID_IMPLEMENTER_BIT,
diff --git a/arch/sh/boot/compressed/vmlinux.scr b/arch/sh/boot/compressed/vmlinux.scr
deleted file mode 100644
index 862d748..0000000
--- a/arch/sh/boot/compressed/vmlinux.scr
+++ /dev/null
@@ -1,10 +0,0 @@
-SECTIONS
-{
-  .rodata..compressed : {
-	input_len = .;
-	LONG(input_data_end - input_data) input_data = .;
-	*(.data)
-	output_len = . - 4;
-	input_data_end = .;
-	}
-}
diff --git a/arch/sh/boot/romimage/vmlinux.scr b/arch/sh/boot/romimage/vmlinux.scr
deleted file mode 100644
index 590394e..0000000
--- a/arch/sh/boot/romimage/vmlinux.scr
+++ /dev/null
@@ -1,8 +0,0 @@
-SECTIONS
-{
-  .text : {
-	zero_page_pos = .;
-	*(.data)
-	end_data = .;
-	}
-}
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index 2222617..2c1d3ae 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -658,21 +658,28 @@ static void test_ahash_speed(const char *algo, unsigned int sec,
 	struct tcrypt_result tresult;
 	struct ahash_request *req;
 	struct crypto_ahash *tfm;
-	static char output[1024];
+	const int output_size = 1024;
+	char *output = kmalloc(output_size, GFP_KERNEL);
 	int i, ret;
 
+	if (!output) {
+		printk(KERN_INFO "\nUnable to allocate output buffer memory\n");
+		return;
+	}
+
 	printk(KERN_INFO "\ntesting speed of async %s\n", algo);
 
 	tfm = crypto_alloc_ahash(algo, 0, 0);
 	if (IS_ERR(tfm)) {
 		pr_err("failed to load transform for %s: %ld\n",
 		       algo, PTR_ERR(tfm));
+		kfree(output);
 		return;
 	}
 
-	if (crypto_ahash_digestsize(tfm) > sizeof(output)) {
+	if (crypto_ahash_digestsize(tfm) > output_size) {
 		pr_err("digestsize(%u) > outputbuffer(%zu)\n",
-		       crypto_ahash_digestsize(tfm), sizeof(output));
+		       crypto_ahash_digestsize(tfm), output_size);
 		goto out;
 	}
 
@@ -716,6 +723,7 @@ static void test_ahash_speed(const char *algo, unsigned int sec,
 	ahash_request_free(req);
 
 out:
+	kfree(output);
 	crypto_free_ahash(tfm);
 }
 
diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index 87b365f..5929950 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -1,7 +1,7 @@
 /*
  * caam - Freescale FSL CAAM support for crypto API
  *
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc.
  *
  * Based on talitos crypto API driver.
  *
@@ -2051,6 +2051,22 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,
 	},
 	{
+		.name = "ecb(aes)",
+		.driver_name = "ecb-aes-caam",
+		.blocksize = AES_BLOCK_SIZE,
+		.type = CRYPTO_ALG_TYPE_ABLKCIPHER,
+		.template_ablkcipher = {
+			.setkey = ablkcipher_setkey,
+			.encrypt = ablkcipher_encrypt,
+			.decrypt = ablkcipher_decrypt,
+			.geniv = "eseqiv",
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize = AES_BLOCK_SIZE,
+			},
+		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_ECB,
+	},
+	{
 		.name = "cbc(des3_ede)",
 		.driver_name = "cbc-3des-caam",
 		.blocksize = DES3_EDE_BLOCK_SIZE,
diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c
index 03daad6..4338047 100644
--- a/drivers/crypto/caam/caamhash.c
+++ b/drivers/crypto/caam/caamhash.c
@@ -1,7 +1,7 @@
 /*
  * caam - Freescale FSL CAAM support for ahash functions of crypto API
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * Based on caamalg.c crypto API driver.
  *
@@ -807,7 +807,7 @@ static int ahash_update_ctx(struct ahash_request *req)
 	int *next_buflen = state->current_buf ? &state->buflen_0 :
 			   &state->buflen_1, last_buflen;
 	int in_len = *buflen + req->nbytes, to_hash;
-	u32 *sh_desc = ctx->sh_desc_update, *desc;
+	u32 *sh_desc = ctx->sh_desc_update, *desc = NULL;
 	dma_addr_t ptr = ctx->sh_desc_update_dma;
 	int src_nents, sec4_sg_bytes, sec4_sg_src_index;
 	struct ahash_edesc *edesc;
diff --git a/drivers/crypto/caam/sg_sw_sec4.h b/drivers/crypto/caam/sg_sw_sec4.h
index e05fc58..f3f5187 100644
--- a/drivers/crypto/caam/sg_sw_sec4.h
+++ b/drivers/crypto/caam/sg_sw_sec4.h
@@ -1,7 +1,7 @@
 /*
  * CAAM/SEC 4.x functions for using scatterlists in caam driver
  *
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc.
  *
  */
 
@@ -93,9 +93,13 @@ static int dma_map_sg_chained(struct device *dev, struct scatterlist *sg,
 {
 	if (unlikely(chained)) {
 		int i;
+		struct scatterlist *tsg = sg;
+		/* Needs a temp copy for sg pointer, otherwise
+		 * scatterwalke_sg_next will return null when list is
+		 * ended */
 		for (i = 0; i < nents; i++) {
-			dma_map_sg(dev, sg, 1, dir);
-			sg = scatterwalk_sg_next(sg);
+			dma_map_sg(dev, tsg, 1, dir);
+			tsg = scatterwalk_sg_next(tsg);
 		}
 	} else {
 		dma_map_sg(dev, sg, nents, dir);
diff --git a/drivers/dma/imx-sdma.c b/drivers/dma/imx-sdma.c
index 6b7af2c..81434d6 100644
--- a/drivers/dma/imx-sdma.c
+++ b/drivers/dma/imx-sdma.c
@@ -7,7 +7,7 @@
  *
  * Based on code from Freescale:
  *
- * Copyright 2004-2012 Freescale Semiconductor, Inc.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -33,11 +33,14 @@
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
 #include <linux/delay.h>
+#include <linux/genalloc.h>
 
 #include <asm/irq.h>
 #include <mach/sdma.h>
 #include <mach/dma.h>
 #include <mach/hardware.h>
+#include <mach/iram.h>
+
 
 /* SDMA registers */
 #define SDMA_H_C0PTR		0x000
@@ -328,6 +331,7 @@ struct sdma_engine {
 	struct clk			*clk;
 	struct sdma_script_start_addrs	*script_addrs;
 	spinlock_t			irq_reg_lock;
+	spinlock_t			channel_0_lock;
 };
 
 #define SDMA_H_CONFIG_DSPDMA	(1 << 12) /* indicates if the DSPDMA is used */
@@ -335,6 +339,7 @@ struct sdma_engine {
 #define SDMA_H_CONFIG_ACR	(1 << 4)  /* indicates if AHB freq /core freq = 2 or 1 */
 #define SDMA_H_CONFIG_CSM	(3)       /* indicates which context switch mode is selected*/
 
+
 static inline u32 chnenbl_ofs(struct sdma_engine *sdma, unsigned int event)
 {
 	u32 chnenbl0 = (sdma->version == 2 ? SDMA_CHNENBL0_V2 : SDMA_CHNENBL0_V1);
@@ -385,14 +390,23 @@ static int sdma_run_channel(struct sdma_channel *sdmac)
 {
 	struct sdma_engine *sdma = sdmac->sdma;
 	int channel = sdmac->channel;
+	unsigned long timeout = 1000;
 	int ret;
 
-	init_completion(&sdmac->done);
+	writel(1 << channel, sdma->regs + SDMA_H_START);
 
-	wmb();
-	writel_relaxed(1 << channel, sdma->regs + SDMA_H_START);
+	while (!(ret = readl_relaxed(sdma->regs + SDMA_H_INTR) & 1)) {
+		if (timeout-- <= 0)
+			break;
+		udelay(1);
+	}
 
-	ret = wait_for_completion_timeout(&sdmac->done, HZ);
+	if (ret) {
+		/* Clear the interrupt status */
+		writel_relaxed(ret, sdma->regs + SDMA_H_INTR);
+	} else {
+		dev_err(sdma->dev, "Timeout waiting for CH0 ready\n");
+	}
 
 	return ret ? 0 : -ETIMEDOUT;
 }
@@ -403,14 +417,21 @@ static int sdma_load_script(struct sdma_engine *sdma, void *buf, int size,
 	struct sdma_buffer_descriptor *bd0 = sdma->channel[0].bd;
 	void *buf_virt;
 	dma_addr_t buf_phys;
+	unsigned long flags;
 	int ret;
 
+#ifdef CONFIG_SDMA_IRAM
+	buf_virt = iram_alloc(size, (unsigned long *)&buf_phys);
+#else
 	buf_virt = dma_alloc_coherent(NULL,
 			size,
 			&buf_phys, GFP_KERNEL);
+#endif
 	if (!buf_virt)
 		return -ENOMEM;
 
+	spin_lock_irqsave(&sdma->channel_0_lock, flags);
+
 	bd0->mode.command = C0_SETPM;
 	bd0->mode.status = BD_DONE | BD_INTR | BD_WRAP | BD_EXTD;
 	bd0->mode.count = size / 2;
@@ -421,7 +442,12 @@ static int sdma_load_script(struct sdma_engine *sdma, void *buf, int size,
 
 	ret = sdma_run_channel(&sdma->channel[0]);
 
+	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
+#ifdef CONFIG_SDMA_IRAM
+	iram_free(buf_phys, size);
+#else
 	dma_free_coherent(NULL, size, buf_virt, buf_phys);
+#endif
 
 	return ret;
 }
@@ -518,10 +544,6 @@ static void mxc_sdma_handle_channel(struct sdma_channel *sdmac)
 {
 	complete(&sdmac->done);
 
-	/* not interested in channel 0 interrupts */
-	if (sdmac->channel == 0)
-		return;
-
 	switch (sdmac->mode) {
 	case SDMA_MODE_LOOP:
 		sdma_handle_channel_loop(sdmac);
@@ -548,6 +570,8 @@ static irqreturn_t sdma_int_handler(int irq, void *dev_id)
 
 	spin_lock_irqsave(&sdma->irq_reg_lock, flag);
 	stat = readl_relaxed(sdma->regs + SDMA_H_INTR);
+	/* not interested in channel 0 interrupts */
+	stat &= ~1;
 	writel_relaxed(stat, sdma->regs + SDMA_H_INTR);
 	spin_unlock_irqrestore(&sdma->irq_reg_lock, flag);
 
@@ -696,6 +720,7 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 	struct sdma_context_data *context = sdma->context;
 	struct sdma_buffer_descriptor *bd0 = sdma->channel[0].bd;
 	int ret;
+	unsigned long flags;
 
 
 	if (sdmac->direction == DMA_DEV_TO_MEM)
@@ -720,6 +745,7 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 	dev_dbg(sdma->dev, "event_mask0 = 0x%08x\n", sdmac->event_mask0);
 	dev_dbg(sdma->dev, "event_mask1 = 0x%08x\n", sdmac->event_mask1);
 
+	spin_lock_irqsave(&sdma->channel_0_lock, flags);
 	memset(context, 0, sizeof(*context));
 	context->channel_state.pc = load_address;
 
@@ -736,6 +762,7 @@ static int sdma_load_context(struct sdma_channel *sdmac)
 
 	ret = sdma_run_channel(&sdma->channel[0]);
 
+	spin_unlock_irqrestore(&sdma->channel_0_lock, flags);
 	return ret;
 }
 
@@ -882,7 +909,11 @@ static int sdma_request_channel(struct sdma_channel *sdmac)
 	int channel = sdmac->channel;
 	int ret = -EBUSY;
 
-	sdmac->bd = dma_alloc_coherent(NULL, PAGE_SIZE, &sdmac->bd_phys, GFP_KERNEL);
+#ifdef CONFIG_SDMA_IRAM
+	sdmac->bd = iram_alloc(PAGE_SIZE, (unsigned long *)&sdmac->bd_phys);
+#else
+	sdmac->bd = dma_alloc_noncached(NULL, PAGE_SIZE, &sdmac->bd_phys, GFP_KERNEL);
+#endif
 	if (!sdmac->bd) {
 		ret = -ENOMEM;
 		goto out;
@@ -1045,8 +1076,11 @@ static void sdma_free_chan_resources(struct dma_chan *chan)
 
 	sdma_set_channel_priority(sdmac, 0);
 
+#ifdef CONFIG_SDMA_IRAM
+	iram_free(sdmac->bd_phys, PAGE_SIZE);
+#else
 	dma_free_coherent(NULL, PAGE_SIZE, sdmac->bd, sdmac->bd_phys);
-
+#endif
 	clk_disable(sdma->clk);
 }
 
@@ -1430,10 +1464,17 @@ static int __init sdma_init(struct sdma_engine *sdma)
 	/* Be sure SDMA has not started yet */
 	writel_relaxed(0, sdma->regs + SDMA_H_C0PTR);
 
+#ifdef CONFIG_SDMA_IRAM
+	sdma->channel_control = iram_alloc(MAX_DMA_CHANNELS *
+			sizeof(struct sdma_channel_control)
+			+ sizeof(struct sdma_context_data),
+			(unsigned long *)&ccb_phys);
+#else
 	sdma->channel_control = dma_alloc_coherent(NULL,
 			MAX_DMA_CHANNELS * sizeof (struct sdma_channel_control) +
 			sizeof(struct sdma_context_data),
 			&ccb_phys, GFP_KERNEL);
+#endif
 
 	if (!sdma->channel_control) {
 		ret = -ENOMEM;
@@ -1459,7 +1500,7 @@ static int __init sdma_init(struct sdma_engine *sdma)
 
 	ret = sdma_request_channel(&sdma->channel[0]);
 	if (ret)
-		goto err_dma_alloc;
+		goto err_dma_request;
 
 	sdma_config_ownership(&sdma->channel[0], false, true, false);
 
@@ -1482,6 +1523,12 @@ static int __init sdma_init(struct sdma_engine *sdma)
 
 	return 0;
 
+err_dma_request:
+#ifdef CONFIG_SDMA_IRAM
+	iram_free((unsigned long)ccb_phys, MAX_DMA_CHANNELS
+			* sizeof(struct sdma_channel_control)
+			+ sizeof(struct sdma_context_data));
+#endif
 err_dma_alloc:
 	clk_disable(sdma->clk);
 	dev_err(sdma->dev, "initialisation failed with %d\n", ret);
@@ -1501,6 +1548,8 @@ static int __init sdma_probe(struct platform_device *pdev)
 	if (!sdma)
 		return -ENOMEM;
 
+	spin_lock_init(&sdma->channel_0_lock);
+
 	sdma->dev = &pdev->dev;
 
 	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
diff --git a/drivers/dma/pxp/pxp_dma_v2.c b/drivers/dma/pxp/pxp_dma_v2.c
index c609877..7169b44 100644
--- a/drivers/dma/pxp/pxp_dma_v2.c
+++ b/drivers/dma/pxp/pxp_dma_v2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index d2f5809..11dde5f 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/vivante/Makefile b/drivers/gpu/drm/vivante/Makefile
index 7ebc0e5..d87c8e8 100644
--- a/drivers/gpu/drm/vivante/Makefile
+++ b/drivers/gpu/drm/vivante/Makefile
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/vivante/vivante_drv.c b/drivers/gpu/drm/vivante/vivante_drv.c
index 8aa5d07..4224608 100644
--- a/drivers/gpu/drm/vivante/vivante_drv.c
+++ b/drivers/gpu/drm/vivante/vivante_drv.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/gpu/drm/vivante/vivante_drv.h b/drivers/gpu/drm/vivante/vivante_drv.h
index 83588bf..03f5884 100644
--- a/drivers/gpu/drm/vivante/vivante_drv.h
+++ b/drivers/gpu/drm/vivante/vivante_drv.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index df9fca3..8cec196 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -96,7 +96,7 @@
  * Duplicated divider values removed from list
  */
 
-static u16 __initdata i2c_clk_div[50][2] = {
+static u16 i2c_clk_div[50][2] = {
 	{ 22,	0x20 }, { 24,	0x21 }, { 26,	0x22 }, { 28,	0x23 },
 	{ 30,	0x00 },	{ 32,	0x24 }, { 36,	0x25 }, { 40,	0x26 },
 	{ 42,	0x03 }, { 44,	0x27 },	{ 48,	0x28 }, { 52,	0x05 },
@@ -123,6 +123,7 @@ struct imx_i2c_struct {
 	unsigned int 		disable_delay;
 	int			stopped;
 	unsigned int		ifdr; /* IMX_I2C_IFDR */
+	unsigned int		cur_clk;
 };
 
 /** Functions for IMX I2C adapter driver ***************************************
@@ -181,13 +182,68 @@ static int i2c_imx_acked(struct imx_i2c_struct *i2c_imx)
 	return 0;
 }
 
+static void i2c_imx_set_clk(struct imx_i2c_struct *i2c_imx,
+							unsigned int rate)
+{
+	unsigned int i2c_clk_rate;
+	unsigned int div;
+	int i;
+
+	/* Divider value calculation */
+	i2c_clk_rate = clk_get_rate(i2c_imx->clk);
+	if (i2c_imx->cur_clk == i2c_clk_rate)
+		return;
+	else
+		i2c_imx->cur_clk = i2c_clk_rate;
+	div = (i2c_clk_rate + rate - 1) / rate;
+	if (div < i2c_clk_div[0][0])
+		i = 0;
+	else if (div > i2c_clk_div[ARRAY_SIZE(i2c_clk_div) - 1][0])
+		i = ARRAY_SIZE(i2c_clk_div) - 1;
+	else
+		for (i = 0; i2c_clk_div[i][0] < div; i++)
+			;
+
+	/* Store divider value */
+	i2c_imx->ifdr = i2c_clk_div[i][1];
+
+	/*
+	 * There dummy delay is calculated.
+	 * It should be about one I2C clock period long.
+	 * This delay is used in I2C bus disable function
+	 * to fix chip hardware bug.
+	 */
+	i2c_imx->disable_delay = (500000U * i2c_clk_div[i][0]
+		+ (i2c_clk_rate / 2) - 1) / (i2c_clk_rate / 2);
+
+	/* dev_dbg() can't be used, because adapter is not yet registered */
+#ifdef CONFIG_I2C_DEBUG_BUS
+	printk(KERN_DEBUG "I2C: <%s> I2C_CLK=%d, REQ DIV=%d\n",
+		__func__, i2c_clk_rate, div);
+	printk(KERN_DEBUG "I2C: <%s> IFDR[IC]=0x%x, REAL DIV=%d\n",
+		__func__, i2c_clk_div[i][1], i2c_clk_div[i][0]);
+#endif
+}
+
 static int i2c_imx_start(struct imx_i2c_struct *i2c_imx)
 {
 	unsigned int temp = 0;
+	struct imxi2c_platform_data *pdata;
 	int result;
 
 	dev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);
 
+	/* Currently on Arik/Rigel, the I2C clk is from IPG_PERCLK which is
+	 * sourced from IPG_CLK. In low bus freq mode, IPG_CLK is at 12MHz
+	 * and IPG_PERCLK is down to 4MHz.
+	 * Update I2C divider before set i2c clock.
+	 */
+	pdata = i2c_imx->adapter.dev.parent->platform_data;
+	if (pdata && pdata->bitrate)
+		i2c_imx_set_clk(i2c_imx, pdata->bitrate);
+	else
+		i2c_imx_set_clk(i2c_imx, IMX_I2C_BIT_RATE);
+
 	clk_enable(i2c_imx->clk);
 	writeb(i2c_imx->ifdr, i2c_imx->base + IMX_I2C_IFDR);
 	/* Enable I2C controller */
@@ -240,44 +296,6 @@ static void i2c_imx_stop(struct imx_i2c_struct *i2c_imx)
 	clk_disable(i2c_imx->clk);
 }
 
-static void __init i2c_imx_set_clk(struct imx_i2c_struct *i2c_imx,
-							unsigned int rate)
-{
-	unsigned int i2c_clk_rate;
-	unsigned int div;
-	int i;
-
-	/* Divider value calculation */
-	i2c_clk_rate = clk_get_rate(i2c_imx->clk);
-	div = (i2c_clk_rate + rate - 1) / rate;
-	if (div < i2c_clk_div[0][0])
-		i = 0;
-	else if (div > i2c_clk_div[ARRAY_SIZE(i2c_clk_div) - 1][0])
-		i = ARRAY_SIZE(i2c_clk_div) - 1;
-	else
-		for (i = 0; i2c_clk_div[i][0] < div; i++);
-
-	/* Store divider value */
-	i2c_imx->ifdr = i2c_clk_div[i][1];
-
-	/*
-	 * There dummy delay is calculated.
-	 * It should be about one I2C clock period long.
-	 * This delay is used in I2C bus disable function
-	 * to fix chip hardware bug.
-	 */
-	i2c_imx->disable_delay = (500000U * i2c_clk_div[i][0]
-		+ (i2c_clk_rate / 2) - 1) / (i2c_clk_rate / 2);
-
-	/* dev_dbg() can't be used, because adapter is not yet registered */
-#ifdef CONFIG_I2C_DEBUG_BUS
-	printk(KERN_DEBUG "I2C: <%s> I2C_CLK=%d, REQ DIV=%d\n",
-		__func__, i2c_clk_rate, div);
-	printk(KERN_DEBUG "I2C: <%s> IFDR[IC]=0x%x, REAL DIV=%d\n",
-		__func__, i2c_clk_div[i][1], i2c_clk_div[i][0]);
-#endif
-}
-
 static irqreturn_t i2c_imx_isr(int irq, void *dev_id)
 {
 	struct imx_i2c_struct *i2c_imx = dev_id;
diff --git a/drivers/input/touchscreen/novatek_ts.c b/drivers/input/touchscreen/novatek_ts.c
index 84c7732..84b1024 100644
--- a/drivers/input/touchscreen/novatek_ts.c
+++ b/drivers/input/touchscreen/novatek_ts.c
@@ -2,7 +2,7 @@
  * Driver for Novatek NT11003 Multiple Touch Controller
  *
  * Copyright (C) 2012 Novatek Ltd.
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -30,6 +30,7 @@
 
 #define NOVATEK_MAX_X		1280
 #define NOVATEK_MAX_Y		800
+#define NT_QUIRK_ID		((0xFF >> 3) - 1)
 
 struct tp_event {
 	u16 x;
@@ -118,7 +119,15 @@ static irqreturn_t novatek_ts_threaded_irq_handler(int irq, void *dev_id)
 		memset(&event, 0, sizeof(event));
 		parser_finger_events(&buffer[i * FINGER_EVENT_LEN], &event);
 
-		if (event.status == 0 /* || event.id > MAX_SUPPORT_POINTS */)
+		/* workaround FW sometime report touch up is not
+		 * corrent, but report all 0xFF package, so it lost
+		 * track of ID, so workaround by add a touch ID by the
+		 * parser id. */
+		if (ts->fingers[i] == FINGER_MOVE && event.status == FINGER_UP
+		    && event.id == NT_QUIRK_ID)
+			event.id = i;
+
+		if (event.status == 0)
 			continue;
 
 		/* ignore the event already up. */
diff --git a/drivers/media/video/mxc/capture/Kconfig b/drivers/media/video/mxc/capture/Kconfig
index 243b888..a862636 100644
--- a/drivers/media/video/mxc/capture/Kconfig
+++ b/drivers/media/video/mxc/capture/Kconfig
@@ -26,11 +26,6 @@ config VIDEO_MXC_CSI_DMA
 	  with this method the CSC (Color Space Conversion) and resize are not supported.
 	  If unsure, say N.
 
-choice
-	prompt "Select Camera/TV Decoder"
-	default MXC_CAMERA_OV3640
-	depends on VIDEO_MXC_CAMERA
-
 config MXC_CAMERA_MC521DA
 	tristate "Magnachip mc521da camera support"
 	select I2C_MXC
@@ -105,7 +100,6 @@ config MXC_TVIN_ADV7180
 	---help---
 	  If you plan to use the adv7180 video decoder with your MXC system, say Y here.
 
-endchoice
 
 config MXC_CAMERA_OV5640_MIPI
 	tristate "OmniVision ov5640 camera support using mipi"
diff --git a/drivers/media/video/mxc/capture/adv7180.c b/drivers/media/video/mxc/capture/adv7180.c
index 2656afb..3c12fdc 100644
--- a/drivers/media/video/mxc/capture/adv7180.c
+++ b/drivers/media/video/mxc/capture/adv7180.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,16 +21,11 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
 #include <linux/types.h>
 #include <linux/delay.h>
-#include <linux/semaphore.h>
 #include <linux/device.h>
 #include <linux/i2c.h>
-#include <linux/wait.h>
 #include <linux/videodev2.h>
-#include <linux/workqueue.h>
 #include <linux/regulator/consumer.h>
 #include <linux/fsl_devices.h>
 #include <media/v4l2-chip-ident.h>
@@ -238,10 +233,6 @@ static void adv7180_get_std(v4l2_std_id *std)
 
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180_get_std\n");
 
-	/* Make sure power on */
-	if (tvin_plat->pwdn)
-		tvin_plat->pwdn(0);
-
 	/* Read the AD_RESULT to get the detect output video standard */
 	tmp = adv7180_read(ADV7180_STATUS_1) & 0x70;
 
@@ -332,13 +323,14 @@ static int ioctl_s_power(struct v4l2_int_device *s, int on)
 
 	if (on && !sensor->sen.on) {
 		gpio_sensor_active();
-
-		/* Make sure pwoer on */
-		if (tvin_plat->pwdn)
-			tvin_plat->pwdn(0);
-
-		if (adv7180_write_reg(ADV7180_PWR_MNG, 0) != 0)
+		if (adv7180_write_reg(ADV7180_PWR_MNG, 0x04) != 0)
 			return -EIO;
+
+		/*
+		 * FIXME:Additional 400ms to wait the chip to be stable?
+		 * This is a workaround for preview scrolling issue.
+		 */
+		msleep(400);
 	} else if (!on && sensor->sen.on) {
 		if (adv7180_write_reg(ADV7180_PWR_MNG, 0x24) != 0)
 			return -EIO;
@@ -503,10 +495,6 @@ static int ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
 
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180:ioctl_g_ctrl\n");
 
-	/* Make sure power on */
-	if (tvin_plat->pwdn)
-		tvin_plat->pwdn(0);
-
 	switch (vc->id) {
 	case V4L2_CID_BRIGHTNESS:
 		dev_dbg(&adv7180_data.sen.i2c_client->dev,
@@ -601,10 +589,6 @@ static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
 
 	dev_dbg(&adv7180_data.sen.i2c_client->dev, "In adv7180:ioctl_s_ctrl\n");
 
-	/* Make sure power on */
-	if (tvin_plat->pwdn)
-		tvin_plat->pwdn(0);
-
 	switch (vc->id) {
 	case V4L2_CID_BRIGHTNESS:
 		dev_dbg(&adv7180_data.sen.i2c_client->dev,
@@ -680,6 +664,26 @@ static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
 }
 
 /*!
+ * ioctl_enum_framesizes - V4L2 sensor interface handler for
+ *			   VIDIOC_ENUM_FRAMESIZES ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fsize: standard V4L2 VIDIOC_ENUM_FRAMESIZES ioctl structure
+ *
+ * Return 0 if successful, otherwise -EINVAL.
+ */
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+				 struct v4l2_frmsizeenum *fsize)
+{
+	if (fsize->index >= 1)
+		return -EINVAL;
+
+	fsize->discrete.width = video_fmts[video_idx].active_width;
+	fsize->discrete.height  = video_fmts[video_idx].active_height;
+
+	return 0;
+}
+
+/*!
  * ioctl_g_chip_ident - V4L2 sensor interface handler for
  *			VIDIOC_DBG_G_CHIP_IDENT ioctl
  * @s: pointer to standard V4L2 device structure
@@ -768,6 +772,8 @@ static struct v4l2_int_ioctl_desc adv7180_ioctl_desc[] = {
 	{vidioc_int_queryctrl_num, (v4l2_int_ioctl_func*)ioctl_queryctrl},
 	{vidioc_int_g_ctrl_num, (v4l2_int_ioctl_func*)ioctl_g_ctrl},
 	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func*)ioctl_s_ctrl},
+	{vidioc_int_enum_framesizes_num,
+				(v4l2_int_ioctl_func *) ioctl_enum_framesizes},
 	{vidioc_int_g_chip_ident_num,
 				(v4l2_int_ioctl_func *)ioctl_g_chip_ident},
 };
@@ -1181,14 +1187,12 @@ static int adv7180_probe(struct i2c_client *client,
  */
 static int adv7180_detach(struct i2c_client *client)
 {
-	struct fsl_mxc_tvin_platform_data *plat_data = client->dev.platform_data;
-
 	dev_dbg(&adv7180_data.sen.i2c_client->dev,
 		"%s:Removing %s video decoder @ 0x%02X from adapter %s\n",
 		__func__, IF_NAME, client->addr << 1, client->adapter->name);
 
-	if (plat_data->pwdn)
-		plat_data->pwdn(1);
+	/* Power down via i2c */
+	adv7180_write_reg(ADV7180_PWR_MNG, 0x24);
 
 	if (dvddio_regulator) {
 		regulator_disable(dvddio_regulator);
diff --git a/drivers/media/video/mxc/capture/csi_v4l2_capture.c b/drivers/media/video/mxc/capture/csi_v4l2_capture.c
index 54b073e..68dda9b 100644
--- a/drivers/media/video/mxc/capture/csi_v4l2_capture.c
+++ b/drivers/media/video/mxc/capture/csi_v4l2_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -42,10 +42,13 @@
 
 static int video_nr = -1;
 static cam_data *g_cam;
+static int req_buf_number;
 
 static int csi_v4l2_master_attach(struct v4l2_int_device *slave);
 static void csi_v4l2_master_detach(struct v4l2_int_device *slave);
 static u8 camera_power(cam_data *cam, bool cameraOn);
+struct v4l2_crop crop_current;
+struct v4l2_window win_current;
 
 /*! Information about this driver. */
 static struct v4l2_int_master csi_v4l2_master = {
@@ -62,6 +65,37 @@ static struct v4l2_int_device csi_v4l2_int_device = {
 	      },
 };
 
+static struct v4l2_queryctrl pxp_controls[] = {
+	{
+		.id 		= V4L2_CID_HFLIP,
+		.type 		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name 		= "Horizontal Flip",
+		.minimum 	= 0,
+		.maximum 	= 1,
+		.step 		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_VFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Vertical Flip",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+		.flags		= 0,
+	}, {
+		.id		= V4L2_CID_PRIVATE_BASE,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.name		= "Rotation",
+		.minimum	= 0,
+		.maximum	= 270,
+		.step		= 90,
+		.default_value	= 0,
+		.flags		= 0,
+	},
+};
+
 /* Callback function triggered after PxP receives an EOF interrupt */
 static void pxp_dma_done(void *arg)
 {
@@ -108,7 +142,7 @@ static int pxp_chan_init(cam_data *cam)
 
 /*
  * Function to call PxP DMA driver and send our new V4L2 buffer
- * through the PxP and PxP will process this buffer in place.
+ * through the PxP.
  * Note: This is a blocking call, so upon return the PxP tx should be complete.
  */
 static int pxp_process_update(cam_data *cam)
@@ -177,21 +211,41 @@ static int pxp_process_update(cam_data *cam)
 	proc_data->srect.width = pxp_conf->s0_param.width;
 	proc_data->srect.height = pxp_conf->s0_param.height;
 
-	proc_data->drect.top = 0;
+	if (crop_current.c.top != 0)
+		proc_data->srect.top = crop_current.c.top;
+	if (crop_current.c.left != 0)
+		proc_data->srect.left = crop_current.c.left;
+	if (crop_current.c.width != 0)
+		proc_data->srect.width = crop_current.c.width;
+	if (crop_current.c.height != 0)
+		proc_data->srect.height = crop_current.c.height;
+
 	proc_data->drect.left = 0;
+	proc_data->drect.top = 0;
 	proc_data->drect.width = proc_data->srect.width;
 	proc_data->drect.height = proc_data->srect.height;
-	proc_data->scaling = 0;
-	proc_data->hflip = 0;
-	proc_data->vflip = 0;
-	proc_data->rotate = 0;
-	proc_data->bgcolor = 0;
+
+	if (win_current.w.left != 0)
+		proc_data->drect.left = win_current.w.left;
+	if (win_current.w.top != 0)
+		proc_data->drect.top = win_current.w.top;
+	if (win_current.w.width != 0)
+		proc_data->drect.width = win_current.w.width;
+	if (win_current.w.height != 0)
+		proc_data->drect.height = win_current.w.height;
+
+	pr_debug("srect l: %d, t: %d, w: %d, h: %d; "
+		"drect l: %d, t: %d, w: %d, h: %d\n",
+		proc_data->srect.left, proc_data->srect.top,
+		proc_data->srect.width, proc_data->srect.height,
+		proc_data->drect.left, proc_data->drect.top,
+		proc_data->drect.width, proc_data->drect.height);
 
 	pxp_conf->out_param.pixel_fmt = PXP_PIX_FMT_RGB565;
 	pxp_conf->out_param.width = proc_data->drect.width;
 	pxp_conf->out_param.height = proc_data->drect.height;
 
-	if (cam->rotation >= IPU_ROTATE_90_RIGHT)
+	if (cam->rotation % 180)
 		pxp_conf->out_param.stride = pxp_conf->out_param.height;
 	else
 		pxp_conf->out_param.stride = pxp_conf->out_param.width;
@@ -272,43 +326,48 @@ static void camera_callback(u32 mask, void *dev)
 	if (cam == NULL)
 		return;
 
-	if (list_empty(&cam->working_q)) {
-		pr_debug("v4l2 capture: %s: "
-				"working queue empty\n", __func__);
-		return;
-	}
+	spin_lock(&cam->queue_int_lock);
+	spin_lock(&cam->dqueue_int_lock);
+	if (!list_empty(&cam->working_q)) {
+		done_frame = list_entry(cam->working_q.next,
+				struct mxc_v4l_frame, queue);
 
-	done_frame =
-		list_entry(cam->working_q.next, struct mxc_v4l_frame, queue);
-	if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
-		done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
-		done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
-		if (list_empty(&cam->ready_q)) {
-			cam->skip_frame++;
+		if (done_frame->csi_buf_num != cam->ping_pong_csi)
+			goto next;
+
+		if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+			done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
+			done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
+
+			/* Added to the done queue */
+			list_del(cam->working_q.next);
+			list_add_tail(&done_frame->queue, &cam->done_q);
+			cam->enc_counter++;
+			wake_up_interruptible(&cam->enc_queue);
 		} else {
-			ready_frame = list_entry(cam->ready_q.next,
-						 struct mxc_v4l_frame, queue);
-			list_del(cam->ready_q.next);
-			list_add_tail(&ready_frame->queue, &cam->working_q);
-
-			if (cam->ping_pong_csi == 1) {
-				__raw_writel(cam->frame[ready_frame->index].
-					     paddress, CSI_CSIDMASA_FB1);
-			} else {
-				__raw_writel(cam->frame[ready_frame->index].
-					     paddress, CSI_CSIDMASA_FB2);
-			}
+			pr_err("ERROR: v4l2 capture: %s: "
+					"buffer not queued\n", __func__);
 		}
+	}
 
-		/* Added to the done queue */
-		list_del(cam->working_q.next);
-		list_add_tail(&done_frame->queue, &cam->done_q);
-		cam->enc_counter++;
-		wake_up_interruptible(&cam->enc_queue);
+next:
+	if (!list_empty(&cam->ready_q)) {
+		ready_frame = list_entry(cam->ready_q.next,
+					 struct mxc_v4l_frame, queue);
+		list_del(cam->ready_q.next);
+		list_add_tail(&ready_frame->queue, &cam->working_q);
+
+		__raw_writel(ready_frame->paddress,
+			cam->ping_pong_csi == 1 ? CSI_CSIDMASA_FB1 :
+						  CSI_CSIDMASA_FB2);
+		ready_frame->csi_buf_num = cam->ping_pong_csi;
 	} else {
-		pr_err("ERROR: v4l2 capture: %s: "
-				"buffer not queued\n", __func__);
+		__raw_writel(cam->dummy_frame.paddress,
+			cam->ping_pong_csi == 1 ? CSI_CSIDMASA_FB1 :
+						  CSI_CSIDMASA_FB2);
 	}
+	spin_unlock(&cam->dqueue_int_lock);
+	spin_unlock(&cam->queue_int_lock);
 
 	return;
 }
@@ -325,7 +384,7 @@ static int csi_cap_image(cam_data *cam)
 	unsigned int value;
 
 	value = __raw_readl(CSI_CSICR3);
-	__raw_writel(value | BIT_DMA_REFLASH_RFF | BIT_FRMCNT_RST, CSI_CSICR3);
+	__raw_writel(value | BIT_FRMCNT_RST, CSI_CSICR3);
 	value = __raw_readl(CSI_CSISR);
 	__raw_writel(value, CSI_CSISR);
 
@@ -358,6 +417,13 @@ static int csi_free_frame_buf(cam_data *cam)
 		}
 	}
 
+	if (cam->dummy_frame.vaddress != 0) {
+		dma_free_coherent(0, cam->dummy_frame.buffer.length,
+				  cam->dummy_frame.vaddress,
+				  cam->dummy_frame.paddress);
+		cam->dummy_frame.vaddress = 0;
+	}
+
 	return 0;
 }
 
@@ -392,11 +458,11 @@ static int csi_allocate_frame_buf(cam_data *cam, int count)
 		cam->frame[i].buffer.index = i;
 		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
 		cam->frame[i].buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		cam->frame[i].buffer.length = PAGE_ALIGN(cam->v2f.fmt.
-							 pix.sizeimage);
+		cam->frame[i].buffer.length = cam->v2f.fmt.pix.sizeimage;
 		cam->frame[i].buffer.memory = V4L2_MEMORY_MMAP;
 		cam->frame[i].buffer.m.offset = cam->frame[i].paddress;
 		cam->frame[i].index = i;
+		cam->frame[i].csi_buf_num = 0;
 	}
 
 	return 0;
@@ -418,7 +484,7 @@ static void csi_free_frames(cam_data *cam)
 	for (i = 0; i < FRAME_NUM; i++)
 		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
 
-	cam->skip_frame = 0;
+	cam->enc_counter = 0;
 	INIT_LIST_HEAD(&cam->ready_q);
 	INIT_LIST_HEAD(&cam->working_q);
 	INIT_LIST_HEAD(&cam->done_q);
@@ -460,7 +526,7 @@ static int csi_v4l2_prepare_bufs(cam_data *cam, struct v4l2_buffer *buf)
 	pr_debug("In MVC:csi_v4l2_prepare_bufs\n");
 
 	if (buf->index < 0 || buf->index >= FRAME_NUM || buf->length <
-			PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage)) {
+			cam->v2f.fmt.pix.sizeimage) {
 		pr_err("ERROR: v4l2 capture: csi_v4l2_prepare_bufs buffers "
 			"not allocated,index=%d, length=%d\n", buf->index,
 			buf->length);
@@ -502,6 +568,9 @@ static inline int valid_mode(u32 palette)
 static int csi_streamon(cam_data *cam)
 {
 	struct mxc_v4l_frame *frame;
+	unsigned long flags;
+	unsigned long val;
+	int timeout, timeout2;
 
 	pr_debug("In MVC: %s\n", __func__);
 
@@ -510,32 +579,80 @@ static int csi_streamon(cam_data *cam)
 				__func__);
 		return -1;
 	}
+	cam->dummy_frame.vaddress = dma_alloc_coherent(0,
+			       PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage),
+			       &cam->dummy_frame.paddress,
+			       GFP_DMA | GFP_KERNEL);
+	if (cam->dummy_frame.vaddress == 0) {
+		pr_err("ERROR: v4l2 capture: Allocate dummy frame "
+		       "failed.\n");
+		return -ENOBUFS;
+	}
+	cam->dummy_frame.buffer.type = V4L2_BUF_TYPE_PRIVATE;
+	cam->dummy_frame.buffer.length = cam->v2f.fmt.pix.sizeimage;
+	cam->dummy_frame.buffer.m.offset = cam->dummy_frame.paddress;
 
+	spin_lock_irqsave(&cam->queue_int_lock, flags);
 	/* move the frame from readyq to workingq */
 	if (list_empty(&cam->ready_q)) {
 		pr_err("ERROR: v4l2 capture: %s: "
 				"ready_q queue empty\n", __func__);
+		spin_unlock_irqrestore(&cam->queue_int_lock, flags);
 		return -1;
 	}
 	frame = list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
 	list_del(cam->ready_q.next);
 	list_add_tail(&frame->queue, &cam->working_q);
-	__raw_writel(cam->frame[frame->index].paddress, CSI_CSIDMASA_FB1);
+	__raw_writel(frame->paddress, CSI_CSIDMASA_FB1);
+	frame->csi_buf_num = 1;
 
 	if (list_empty(&cam->ready_q)) {
 		pr_err("ERROR: v4l2 capture: %s: "
 				"ready_q queue empty\n", __func__);
+		spin_unlock_irqrestore(&cam->queue_int_lock, flags);
 		return -1;
 	}
 	frame = list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
 	list_del(cam->ready_q.next);
 	list_add_tail(&frame->queue, &cam->working_q);
-	__raw_writel(cam->frame[frame->index].paddress, CSI_CSIDMASA_FB2);
+	__raw_writel(frame->paddress, CSI_CSIDMASA_FB2);
+	frame->csi_buf_num = 2;
+	spin_unlock_irqrestore(&cam->queue_int_lock, flags);
 
 	cam->capture_pid = current->pid;
 	cam->capture_on = true;
 	csi_cap_image(cam);
-	csi_enable_int(1);
+
+	local_irq_save(flags);
+	for (timeout = 1000000; timeout > 0; timeout--) {
+		if (__raw_readl(CSI_CSISR) & BIT_SOF_INT) {
+			val = __raw_readl(CSI_CSICR3);
+			__raw_writel(val | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+			for (timeout2 = 1000000; timeout2 > 0; timeout2--) {
+				if (__raw_readl(CSI_CSICR3) &
+					BIT_DMA_REFLASH_RFF)
+					cpu_relax();
+				else
+					break;
+			}
+			if (timeout2 <= 0) {
+				pr_err("timeout when wait for reflash done.\n");
+				local_irq_restore(flags);
+				return -ETIME;
+			}
+
+			csi_dmareq_rff_enable();
+			csi_enable_int(1);
+			break;
+		} else
+			cpu_relax();
+	}
+	if (timeout <= 0) {
+		pr_err("timeout when wait for SOF\n");
+		local_irq_restore(flags);
+		return -ETIME;
+	}
+	local_irq_restore(flags);
 
 	return 0;
 }
@@ -549,21 +666,18 @@ static int csi_streamon(cam_data *cam)
  */
 static int csi_streamoff(cam_data *cam)
 {
-	unsigned int cr3;
-
 	pr_debug("In MVC: %s\n", __func__);
 
 	if (cam->capture_on == false)
 		return 0;
 
+	csi_dmareq_rff_disable();
 	csi_disable_int();
 	cam->capture_on = false;
 
 	/* set CSI_CSIDMASA_FB1 and CSI_CSIDMASA_FB2 to default value */
 	__raw_writel(0, CSI_CSIDMASA_FB1);
 	__raw_writel(0, CSI_CSIDMASA_FB2);
-	cr3 = __raw_readl(CSI_CSICR3);
-	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
 
 	csi_free_frames(cam);
 	csi_free_frame_buf(cam);
@@ -681,7 +795,7 @@ static int csi_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 			 * camera can change. */
 			pr_debug("csi_v4l2_s_fmt size changed\n");
 		}
-		if (cam->rotation >= IPU_ROTATE_90_RIGHT) {
+		if (cam->rotation % 180) {
 			height = &f->fmt.pix.width;
 			width = &f->fmt.pix.height;
 		} else {
@@ -763,6 +877,11 @@ static int csi_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 		pr_debug("   type=V4L2_BUF_TYPE_VIDEO_OVERLAY\n");
 		cam->win = f->fmt.win;
+		win_current = f->fmt.win;
+		size = win_current.w.width * win_current.w.height * 2;
+		if (cam->v2f.fmt.pix.sizeimage < size)
+			cam->v2f.fmt.pix.sizeimage = size;
+
 		break;
 	default:
 		retval = -EINVAL;
@@ -829,13 +948,53 @@ static int csi_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 
 	vidioc_int_g_ifparm(cam->sensor, &ifparm);
 	cam_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vidioc_int_g_fmt_cap(cam->sensor, &cam_fmt);
 	pr_debug("   g_fmt_cap returns widthxheight of input as %d x %d\n",
 		 cam_fmt.fmt.pix.width, cam_fmt.fmt.pix.height);
 
+	cam->crop_bounds.top = cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = cam_fmt.fmt.pix.width;
+	cam->crop_bounds.height = cam_fmt.fmt.pix.height;
+	cam->crop_current.width = cam->crop_bounds.width;
+	cam->crop_current.height = cam->crop_bounds.height;
+
 exit:
 	return err;
 }
 
+static int pxp_set_cstate(cam_data *cam, struct v4l2_control *vc)
+{
+	struct pxp_proc_data *proc_data = &cam->pxp_conf.proc_data;
+
+	if (vc->id == V4L2_CID_HFLIP) {
+		proc_data->hflip = vc->value;
+	} else if (vc->id == V4L2_CID_VFLIP) {
+		proc_data->vflip = vc->value;
+	} else if (vc->id == V4L2_CID_PRIVATE_BASE) {
+		if (vc->value % 90)
+			return -ERANGE;
+		proc_data->rotate = vc->value;
+		cam->rotation = vc->value;
+	}
+
+	return 0;
+}
+
+static int pxp_get_cstate(cam_data *cam, struct v4l2_control *vc)
+{
+	struct pxp_proc_data *proc_data = &cam->pxp_conf.proc_data;
+
+	if (vc->id == V4L2_CID_HFLIP)
+		vc->value = proc_data->hflip;
+	else if (vc->id == V4L2_CID_VFLIP)
+		vc->value = proc_data->vflip;
+	else if (vc->id == V4L2_CID_PRIVATE_BASE)
+		vc->value = proc_data->rotate;
+
+	return 0;
+}
+
+
 /*!
  * Dequeue one V4L capture buffer
  *
@@ -862,8 +1021,17 @@ static int csi_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 		return -ERESTARTSYS;
 	}
 
+	if (down_interruptible(&cam->busy_lock))
+		return -EBUSY;
+
 	spin_lock_irqsave(&cam->dqueue_int_lock, lock_flags);
 
+	if (list_empty(&cam->done_q)) {
+		spin_unlock_irqrestore(&cam->dqueue_int_lock, lock_flags);
+		up(&cam->busy_lock);
+		return -EINVAL;
+	}
+
 	cam->enc_counter--;
 
 	frame = list_entry(cam->done_q.next, struct mxc_v4l_frame, queue);
@@ -895,16 +1063,21 @@ static int csi_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
 	 * to RGB565; but for encoding, usually we don't use RGB format.
 	 */
 	if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_RGB565) {
-		/* PxP processes it in place */
 		sg_dma_address(&cam->sg[0]) = buf->m.offset;
-		sg_dma_address(&cam->sg[1]) = buf->m.offset;
+		sg_dma_address(&cam->sg[1]) =
+			cam->frame[req_buf_number].paddress;
 		retval = pxp_process_update(cam);
 		if (retval) {
 			pr_err("Unable to submit PxP update task.\n");
 			return retval;
 		}
 		pxp_complete_update(cam);
+		if (cam->frame[buf->index].vaddress)
+			memcpy(cam->frame[buf->index].vaddress,
+			cam->frame[req_buf_number].vaddress,
+			cam->v2f.fmt.pix.sizeimage);
 	}
+	up(&cam->busy_lock);
 
 	return retval;
 }
@@ -943,7 +1116,6 @@ static int csi_v4l_open(struct file *file)
 					 cam->low_power == false);
 
 		cam->enc_counter = 0;
-		cam->skip_frame = 0;
 		INIT_LIST_HEAD(&cam->ready_q);
 		INIT_LIST_HEAD(&cam->working_q);
 		INIT_LIST_HEAD(&cam->done_q);
@@ -1091,8 +1263,9 @@ static long csi_v4l_do_ioctl(struct file *file,
 	pr_debug("In MVC: %s, %x\n", __func__, ioctlnr);
 	wait_event_interruptible(cam->power_queue, cam->low_power == false);
 	/* make this _really_ smp-safe */
-	if (down_interruptible(&cam->busy_lock))
-		return -EBUSY;
+	if (ioctlnr != VIDIOC_DQBUF)
+		if (down_interruptible(&cam->busy_lock))
+			return -EBUSY;
 
 	switch (ioctlnr) {
 		/*!
@@ -1180,10 +1353,65 @@ static long csi_v4l_do_ioctl(struct file *file,
 			break;
 		}
 
+	case VIDIOC_CROPCAP:
+	{
+		struct v4l2_cropcap *cap = arg;
+
+		if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		    cap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+			retval = -EINVAL;
+			break;
+		}
+		cap->bounds = cam->crop_bounds;
+		cap->defrect = cam->crop_defrect;
+		break;
+	}
 	case VIDIOC_S_CROP:
-		pr_debug("   case not supported\n");
+	{
+		struct v4l2_crop *crop = arg;
+		struct v4l2_rect *b = &cam->crop_bounds;
+
+		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+			retval = -EINVAL;
+			break;
+		}
+
+		crop->c.top = (crop->c.top < b->top) ? b->top
+			      : crop->c.top;
+		if (crop->c.top > b->top + b->height)
+			crop->c.top = b->top + b->height - 1;
+		if (crop->c.height > b->top + b->height - crop->c.top)
+			crop->c.height =
+				b->top + b->height - crop->c.top;
+
+		crop->c.left = (crop->c.left < b->left) ? b->left
+		    : crop->c.left;
+		if (crop->c.left > b->left + b->width)
+			crop->c.left = b->left + b->width - 1;
+		if (crop->c.width > b->left - crop->c.left + b->width)
+			crop->c.width =
+				b->left - crop->c.left + b->width;
+
+		crop->c.width -= crop->c.width % 8;
+		crop->c.height -= crop->c.height % 8;
+
+		crop_current.c = crop->c;
+
+		break;
+	}
+	case VIDIOC_G_CROP:
+	{
+		struct v4l2_crop *crop = arg;
+
+		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+			retval = -EINVAL;
+			break;
+		}
+		crop->c = crop_current.c;
+
 		break;
 
+	}
 	case VIDIOC_REQBUFS: {
 		struct v4l2_requestbuffers *req = arg;
 		pr_debug("   case VIDIOC_REQBUFS\n");
@@ -1202,14 +1430,11 @@ static long csi_v4l_do_ioctl(struct file *file,
 		}
 
 		csi_streamoff(cam);
-		if (req->memory & V4L2_MEMORY_MMAP)
+		if (req->memory & V4L2_MEMORY_MMAP) {
 			csi_free_frame_buf(cam);
-		cam->skip_frame = 0;
-		INIT_LIST_HEAD(&cam->ready_q);
-		INIT_LIST_HEAD(&cam->working_q);
-		INIT_LIST_HEAD(&cam->done_q);
-		if (req->memory & V4L2_MEMORY_MMAP)
-			retval = csi_allocate_frame_buf(cam, req->count);
+			retval = csi_allocate_frame_buf(cam, req->count + 1);
+			req_buf_number = req->count;
+		}
 		break;
 	}
 
@@ -1249,22 +1474,7 @@ static long csi_v4l_do_ioctl(struct file *file,
 		if ((cam->frame[index].buffer.flags & 0x7) ==
 				V4L2_BUF_FLAG_MAPPED) {
 			cam->frame[index].buffer.flags |= V4L2_BUF_FLAG_QUEUED;
-			if (cam->skip_frame > 0) {
-				list_add_tail(&cam->frame[index].queue,
-					      &cam->working_q);
-				cam->skip_frame = 0;
-
-				if (cam->ping_pong_csi == 1) {
-					__raw_writel(cam->frame[index].paddress,
-						     CSI_CSIDMASA_FB1);
-				} else {
-					__raw_writel(cam->frame[index].paddress,
-						     CSI_CSIDMASA_FB2);
-				}
-			} else {
-				list_add_tail(&cam->frame[index].queue,
-					      &cam->ready_q);
-			}
+			list_add_tail(&cam->frame[index].queue, &cam->ready_q);
 		} else if (cam->frame[index].buffer.flags &
 				V4L2_BUF_FLAG_QUEUED) {
 			pr_err("ERROR: v4l2 capture: VIDIOC_QBUF: "
@@ -1351,16 +1561,62 @@ static long csi_v4l_do_ioctl(struct file *file,
 	}
 
 	case VIDIOC_S_CTRL:
+	{
+		struct v4l2_control *vc = arg;
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+			if (vc->id == pxp_controls[i].id) {
+				if (vc->value < pxp_controls[i].minimum ||
+				    vc->value > pxp_controls[i].maximum) {
+					retval = -ERANGE;
+					break;
+				}
+				retval = pxp_set_cstate(cam, vc);
+				break;
+			}
+
+		if (i >= ARRAY_SIZE(pxp_controls))
+			retval = -EINVAL;
+		break;
+
+	}
+	case VIDIOC_G_CTRL:
+	{
+		struct v4l2_control *vc = arg;
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+			if (vc->id == pxp_controls[i].id) {
+				retval = pxp_get_cstate(cam, vc);
+				break;
+			}
+
+		if (i >= ARRAY_SIZE(pxp_controls))
+			retval = -EINVAL;
+		break;
+	}
+	case VIDIOC_QUERYCTRL:
+	{
+		struct v4l2_queryctrl *qc = arg;
+		int i;
+
+		for (i = 0; i < ARRAY_SIZE(pxp_controls); i++)
+			if (qc->id && qc->id == pxp_controls[i].id) {
+				memcpy(qc, &(pxp_controls[i]), sizeof(*qc));
+				break;
+			}
+
+		if (i >= ARRAY_SIZE(pxp_controls))
+			retval = -EINVAL;
+		break;
+	}
 	case VIDIOC_G_STD:
 	case VIDIOC_G_OUTPUT:
 	case VIDIOC_S_OUTPUT:
 	case VIDIOC_ENUMSTD:
-	case VIDIOC_G_CROP:
-	case VIDIOC_CROPCAP:
 	case VIDIOC_S_STD:
-	case VIDIOC_G_CTRL:
 	case VIDIOC_TRY_FMT:
-	case VIDIOC_QUERYCTRL:
 	case VIDIOC_ENUMINPUT:
 	case VIDIOC_G_INPUT:
 	case VIDIOC_S_INPUT:
@@ -1375,7 +1631,8 @@ static long csi_v4l_do_ioctl(struct file *file,
 		break;
 	}
 
-	up(&cam->busy_lock);
+	if (ioctlnr != VIDIOC_DQBUF)
+		up(&cam->busy_lock);
 	return retval;
 }
 
@@ -1415,7 +1672,7 @@ static int csi_mmap(struct file *file, struct vm_area_struct *vma)
 		return -EINTR;
 
 	size = vma->vm_end - vma->vm_start;
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 
 	if (remap_pfn_range(vma, vma->vm_start,
 			    vma->vm_pgoff, size, vma->vm_page_prot)) {
@@ -1459,8 +1716,14 @@ static struct video_device csi_v4l_template = {
  */
 static void init_camera_struct(cam_data *cam)
 {
+	struct pxp_proc_data *proc_data = &cam->pxp_conf.proc_data;
 	pr_debug("In MVC: %s\n", __func__);
 
+	proc_data->hflip = 0;
+	proc_data->vflip = 0;
+	proc_data->rotate = 0;
+	proc_data->bgcolor = 0;
+
 	/* Default everything to 0 */
 	memset(cam, 0, sizeof(cam_data));
 
@@ -1492,7 +1755,6 @@ static void init_camera_struct(cam_data *cam)
 	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
 	cam->overlay_on = false;
 	cam->capture_on = false;
-	cam->skip_frame = 0;
 	cam->v4l2_fb.flags = V4L2_FBUF_FLAG_OVERLAY;
 
 	cam->v2f.fmt.pix.sizeimage = 480 * 640 * 2;
@@ -1505,6 +1767,12 @@ static void init_camera_struct(cam_data *cam)
 	cam->win.w.left = 0;
 	cam->win.w.top = 0;
 	cam->still_counter = 0;
+	/* setup cropping */
+	cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = 640;
+	cam->crop_bounds.top = 0;
+	cam->crop_bounds.height = 480;
+	cam->crop_current = cam->crop_defrect = cam->crop_bounds;
 
 	cam->enc_callback = camera_callback;
 	csi_start_callback(cam);
@@ -1548,6 +1816,8 @@ static int __devinit csi_v4l2_probe(struct platform_device *pdev)
 		err = -ENOMEM;
 		goto out;
 	}
+	memset(&crop_current, 0, sizeof(crop_current));
+	memset(&win_current, 0, sizeof(win_current));
 	init_camera_struct(g_cam);
 	platform_set_drvdata(pdev, (void *)g_cam);
 
@@ -1691,13 +1961,30 @@ static int csi_v4l2_master_attach(struct v4l2_int_device *slave)
 	}
 
 	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+	vidioc_int_s_power(cam->sensor, 1);
 	vidioc_int_dev_init(slave);
+	vidioc_int_s_power(cam->sensor, 0);
 	csi_enable_mclk(CSI_MCLK_I2C, false, false);
 	cam_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vidioc_int_g_fmt_cap(cam->sensor, &cam_fmt);
 
 	/* Used to detect TV in (type 1) vs. camera (type 0) */
 	cam->device_type = cam_fmt.fmt.pix.priv;
 
+	cam->crop_bounds.top = cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = cam_fmt.fmt.pix.width;
+	cam->crop_bounds.height = cam_fmt.fmt.pix.height;
+
+	/* This also is the max crop size for this device. */
+	cam->crop_defrect.top = cam->crop_defrect.left = 0;
+	cam->crop_defrect.width = cam_fmt.fmt.pix.width;
+	cam->crop_defrect.height = cam_fmt.fmt.pix.height;
+
+	/* At this point, this is also the current image size. */
+	cam->crop_current.top = cam->crop_current.left = 0;
+	cam->crop_current.width = cam_fmt.fmt.pix.width;
+	cam->crop_current.height = cam_fmt.fmt.pix.height;
+
 	pr_debug("End of %s: v2f pix widthxheight %d x %d\n",
 		 __func__, cam->v2f.fmt.pix.width, cam->v2f.fmt.pix.height);
 
diff --git a/drivers/media/video/mxc/capture/fsl_csi.c b/drivers/media/video/mxc/capture/fsl_csi.c
index f5677e4..5368b57 100644
--- a/drivers/media/video/mxc/capture/fsl_csi.c
+++ b/drivers/media/video/mxc/capture/fsl_csi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -45,20 +45,17 @@ static irqreturn_t csi_irq_handler(int irq, void *data)
 {
 	cam_data *cam = (cam_data *) data;
 	unsigned long status = __raw_readl(CSI_CSISR);
-	unsigned long cr3 = __raw_readl(CSI_CSICR3);
-	unsigned int frame_count = (cr3 >> 16) & 0xFFFF;
 
 	__raw_writel(status, CSI_CSISR);
 
-	if (status & BIT_SOF_INT) {
-		/* reflash the embeded DMA controller */
-		if (frame_count % 2 == 1)
-			__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
-	}
+	if (status & BIT_HRESP_ERR_INT)
+		pr_warning("Hresponse error is detected.\n");
 
 	if (status & BIT_DMA_TSF_DONE_FB1) {
 		if (cam->capture_on) {
+			spin_lock(&cam->queue_int_lock);
 			cam->ping_pong_csi = 1;
+			spin_unlock(&cam->queue_int_lock);
 			cam->enc_callback(0, cam);
 		} else {
 			cam->still_counter++;
@@ -68,7 +65,9 @@ static irqreturn_t csi_irq_handler(int irq, void *data)
 
 	if (status & BIT_DMA_TSF_DONE_FB2) {
 		if (cam->capture_on) {
+			spin_lock(&cam->queue_int_lock);
 			cam->ping_pong_csi = 2;
+			spin_unlock(&cam->queue_int_lock);
 			cam->enc_callback(0, cam);
 		} else {
 			cam->still_counter++;
@@ -260,6 +259,24 @@ void csi_mclk_disable(void)
 	clk_disable(&csi_mclk);
 }
 
+void csi_dmareq_rff_enable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 |= BIT_DMA_REQ_EN_RFF;
+	cr3 |= BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
+void csi_dmareq_rff_disable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 &= ~BIT_DMA_REQ_EN_RFF;
+	cr3 &= ~BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
 static int __devinit csi_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -289,6 +306,7 @@ static int __devinit csi_probe(struct platform_device *pdev)
 
 	csihw_reset();
 	csi_init_interface();
+	csi_dmareq_rff_disable();
 
 	per_clk = clk_get(NULL, "csi_clk");
 	if (IS_ERR(per_clk))
diff --git a/drivers/media/video/mxc/capture/fsl_csi.h b/drivers/media/video/mxc/capture/fsl_csi.h
index 8dfce28..d8096cc 100644
--- a/drivers/media/video/mxc/capture/fsl_csi.h
+++ b/drivers/media/video/mxc/capture/fsl_csi.h
@@ -195,3 +195,5 @@ void csi_enable_int(int arg);
 void csi_disable_int(void);
 void csi_mclk_enable(void);
 void csi_mclk_disable(void);
+void csi_dmareq_rff_enable(void);
+void csi_dmareq_rff_disable(void);
diff --git a/drivers/media/video/mxc/capture/ipu_csi_enc.c b/drivers/media/video/mxc/capture/ipu_csi_enc.c
index 2c8d8d0..ff90e2b 100644
--- a/drivers/media/video/mxc/capture/ipu_csi_enc.c
+++ b/drivers/media/video/mxc/capture/ipu_csi_enc.c
@@ -171,7 +171,8 @@ static int csi_enc_setup(cam_data *cam)
 	err = ipu_init_channel_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER,
 				      pixel_fmt, cam->v2f.fmt.pix.width,
 				      cam->v2f.fmt.pix.height,
-				      cam->v2f.fmt.pix.width, IPU_ROTATE_NONE,
+				      cam->v2f.fmt.pix.bytesperline,
+				      IPU_ROTATE_NONE,
 				      dummy, dummy, 0,
 				      cam->offset.u_offset,
 				      cam->offset.v_offset);
diff --git a/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c b/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c
index f324f4e..856078a 100644
--- a/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c
+++ b/drivers/media/video/mxc/capture/ipu_fg_overlay_sdc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 /* * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -55,7 +55,7 @@ static void csi_buf_work_func(struct work_struct *work)
 		task.input.paddr = cam->vf_bufs[1];
 	task.input.width = cam->crop_current.width;
 	task.input.height = cam->crop_current.height;
-	task.input.format = IPU_PIX_FMT_UYVY;
+	task.input.format = IPU_PIX_FMT_NV12;
 
 	if (buffer_num == 0)
 		task.output.paddr = fbi->fix.smem_start +
@@ -124,7 +124,7 @@ static irqreturn_t csi_enc_callback(int irq, void *dev_id)
 	ipu_select_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER, csi_buffer_num);
 	if ((cam->crop_current.width != cam->win.w.width) ||
 		(cam->crop_current.height != cam->win.w.height) ||
-		(vf_out_format != IPU_PIX_FMT_UYVY) ||
+		(vf_out_format != IPU_PIX_FMT_NV12) ||
 		(cam->rotation >= IPU_ROTATE_VERT_FLIP))
 		schedule_work(&cam->csi_work_struct);
 	csi_buffer_num = (csi_buffer_num == 0) ? 1 : 0;
@@ -134,7 +134,6 @@ static irqreturn_t csi_enc_callback(int irq, void *dev_id)
 static int csi_enc_setup(cam_data *cam)
 {
 	ipu_channel_params_t params;
-	u32 pixel_fmt;
 	int err = 0, sensor_protocol = 0;
 #ifdef CONFIG_MXC_MIPI_CSI2
 	void *mipi_csi2_info;
@@ -213,7 +212,8 @@ static int csi_enc_setup(cam_data *cam)
 				  cam->vf_bufs_vaddr[1],
 				  (dma_addr_t) cam->vf_bufs[1]);
 	}
-	csi_mem_bufsize = cam->crop_current.width * cam->crop_current.height * 2;
+	csi_mem_bufsize = cam->crop_current.width *
+			  cam->crop_current.height * 3/2;
 	cam->vf_bufs_size[0] = PAGE_ALIGN(csi_mem_bufsize);
 	cam->vf_bufs_vaddr[0] = (void *)dma_alloc_coherent(0,
 							   cam->vf_bufs_size[0],
@@ -246,13 +246,13 @@ static int csi_enc_setup(cam_data *cam)
 		goto out_1;
 	}
 
-	pixel_fmt = IPU_PIX_FMT_UYVY;
 	if ((cam->crop_current.width == cam->win.w.width) &&
 		(cam->crop_current.height == cam->win.w.height) &&
-		(vf_out_format == IPU_PIX_FMT_UYVY) &&
+		(vf_out_format == IPU_PIX_FMT_NV12) &&
 		(cam->rotation < IPU_ROTATE_VERT_FLIP)) {
 		err = ipu_init_channel_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER,
-					      pixel_fmt, cam->crop_current.width,
+					      IPU_PIX_FMT_NV12,
+					      cam->crop_current.width,
 					      cam->crop_current.height,
 					      cam->crop_current.width, IPU_ROTATE_NONE,
 					      fbi->fix.smem_start + (fbi->fix.line_length * fbvar.yres),
@@ -260,7 +260,8 @@ static int csi_enc_setup(cam_data *cam)
 					      cam->offset.u_offset, cam->offset.u_offset);
 	} else {
 		err = ipu_init_channel_buffer(cam->ipu, CSI_MEM, IPU_OUTPUT_BUFFER,
-					      pixel_fmt, cam->crop_current.width,
+					      IPU_PIX_FMT_NV12,
+					      cam->crop_current.width,
 					      cam->crop_current.height,
 					      cam->crop_current.width, IPU_ROTATE_NONE,
 					      cam->vf_bufs[0], cam->vf_bufs[1], 0,
@@ -347,8 +348,8 @@ out1:
 static int foreground_start(void *private)
 {
 	cam_data *cam = (cam_data *) private;
-	int err = 0, i = 0;
-	short *tmp, color;
+	int err = 0, i = 0, screen_size;
+	char *base;
 
 	if (!cam) {
 		printk(KERN_ERR "private is NULL\n");
@@ -383,13 +384,11 @@ static int foreground_start(void *private)
 
 	if (OVERLAY_FB_SUPPORT_NONSTD) {
 		/* Use DP to do CSC so that we can get better performance */
-		vf_out_format = IPU_PIX_FMT_UYVY;
+		vf_out_format = IPU_PIX_FMT_NV12;
 		fbvar.nonstd = vf_out_format;
-		color = 0x80;
 	} else {
 		vf_out_format = IPU_PIX_FMT_RGB565;
 		fbvar.nonstd = 0;
-		color = 0x0;
 	}
 
 	fbvar.bits_per_pixel = 16;
@@ -397,6 +396,7 @@ static int foreground_start(void *private)
 	fbvar.yres = cam->win.w.height;
 	fbvar.yres_virtual = cam->win.w.height * 2;
 	fbvar.yoffset = 0;
+	fbvar.vmode &= ~FB_VMODE_YWRAP;
 	fbvar.accel_flags = FB_ACCEL_DOUBLE_FLAG;
 	fbvar.activate |= FB_ACTIVATE_FORCE;
 	fb_set_var(fbi, &fbvar);
@@ -405,10 +405,17 @@ static int foreground_start(void *private)
 			cam->win.w.top);
 
 	/* Fill black color for framebuffer */
-	tmp = (short *) fbi->screen_base;
-	for (i = 0; i < (fbi->fix.line_length * fbi->var.yres)/2;
-			i++, tmp++)
-		*tmp = color;
+	base = (char *) fbi->screen_base;
+	screen_size = fbi->var.xres * fbi->var.yres;
+	if (OVERLAY_FB_SUPPORT_NONSTD) {
+		memset(base, 0, screen_size);
+		base += screen_size;
+		for (i = 0; i < screen_size / 2; i++, base++)
+			*base = 0x80;
+	} else {
+		for (i = 0; i < screen_size * 2; i++, base++)
+			*base = 0x00;
+	}
 
 	console_lock();
 	fb_blank(fbi, FB_BLANK_UNBLANK);
diff --git a/drivers/media/video/mxc/capture/mxc_v4l2_capture.c b/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
index 3e9346d..9130388 100644
--- a/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
+++ b/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -1331,19 +1331,11 @@ static int mxc_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
 	csi_param.csi = cam->csi;
 	csi_param.mclk = 0;
 
-	/*This may not work on other platforms. Check when adding a new one.*/
-	/*The mclk clock was never set correclty in the ipu register*/
-	/*for now we are going to use this mclk as pixel clock*/
-	/*to set csi0_data_dest register.*/
-	/*This is a workaround which should be fixed*/
 	pr_debug("   clock_curr=mclk=%d\n", ifparm.u.bt656.clock_curr);
-	if (ifparm.u.bt656.clock_curr == 0) {
+	if (ifparm.u.bt656.clock_curr == 0)
 		csi_param.clk_mode = IPU_CSI_CLK_MODE_CCIR656_INTERLACED;
-		/*protocol bt656 use 27Mhz pixel clock */
-		csi_param.mclk = 27000000;
-	} else {
+	else
 		csi_param.clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;
-	}
 
 	csi_param.pixclk_pol = ifparm.u.bt656.latch_clk_inv;
 
@@ -1413,7 +1405,8 @@ exit:
  */
 static int mxc_v4l2_s_std(cam_data *cam, v4l2_std_id e)
 {
-	printk(KERN_ERR "In mxc_v4l2_s_std %Lx\n", e);
+	pr_debug("In mxc_v4l2_s_std %Lx\n", e);
+
 	if (e == V4L2_STD_PAL) {
 		pr_debug("   Setting standard to PAL %Lx\n", V4L2_STD_PAL);
 		cam->standard.id = V4L2_STD_PAL;
@@ -2643,6 +2636,7 @@ static void init_camera_struct(cam_data *cam, struct platform_device *pdev)
 	cam->win.w.left = 0;
 	cam->win.w.top = 0;
 
+	cam->ipu_id = pdata->ipu;
 	cam->csi = pdata->csi;
 	cam->mclk_source = pdata->mclk_source;
 	cam->mclk_on[cam->mclk_source] = false;
@@ -2654,7 +2648,7 @@ static void init_camera_struct(cam_data *cam, struct platform_device *pdev)
 
 	cam->self = kmalloc(sizeof(struct v4l2_int_device), GFP_KERNEL);
 	cam->self->module = THIS_MODULE;
-	sprintf(cam->self->name, "mxc_v4l2_cap%d", cam->csi);
+	sprintf(cam->self->name, "mxc_v4l2_cap%d", pdev->id);
 	cam->self->type = v4l2_int_type_master;
 	cam->self->u.master = &mxc_v4l2_master;
 }
@@ -2687,6 +2681,17 @@ static ssize_t show_overlay(struct device *dev,
 }
 static DEVICE_ATTR(fsl_v4l2_overlay_property, S_IRUGO, show_overlay, NULL);
 
+static ssize_t show_csi(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct video_device *video_dev = container_of(dev,
+						struct video_device, dev);
+	cam_data *cam = video_get_drvdata(video_dev);
+
+	return sprintf(buf, "ipu%d_csi%d\n", cam->ipu_id, cam->csi);
+}
+static DEVICE_ATTR(fsl_csi_property, S_IRUGO, show_csi, NULL);
+
 /*!
  * This function is called to probe the devices if registered.
  *
@@ -2732,6 +2737,11 @@ static int mxc_v4l2_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Error on creating sysfs file"
 			" for overlay\n");
 
+	if (device_create_file(&cam->video_dev->dev,
+			&dev_attr_fsl_csi_property))
+		dev_err(&pdev->dev, "Error on creating sysfs file"
+			" for csi number\n");
+
 	return 0;
 }
 
@@ -2755,6 +2765,8 @@ static int mxc_v4l2_remove(struct platform_device *pdev)
 			&dev_attr_fsl_v4l2_capture_property);
 		device_remove_file(&cam->video_dev->dev,
 			&dev_attr_fsl_v4l2_overlay_property);
+		device_remove_file(&cam->video_dev->dev,
+			&dev_attr_fsl_csi_property);
 
 		pr_info("V4L2 freeing image input device\n");
 		v4l2_int_device_unregister(cam->self);
diff --git a/drivers/media/video/mxc/capture/mxc_v4l2_capture.h b/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
index d2efbe8..7edb8d6 100644
--- a/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
+++ b/drivers/media/video/mxc/capture/mxc_v4l2_capture.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -56,7 +56,10 @@ struct mxc_v4l_frame {
 	struct v4l2_buffer buffer;
 	struct list_head queue;
 	int index;
-	int ipu_buf_num;
+	union {
+		int ipu_buf_num;
+		int csi_buf_num;
+	};
 };
 
 /* Only for old version.  Will go away soon. */
@@ -119,7 +122,6 @@ typedef struct _cam_data {
 	spinlock_t dqueue_int_lock;
 	struct mxc_v4l_frame frame[FRAME_NUM];
 	struct mxc_v4l_frame dummy_frame;
-	int skip_frame;
 	wait_queue_head_t enc_queue;
 	int enc_counter;
 	dma_addr_t rot_enc_bufs[2];
@@ -196,6 +198,7 @@ typedef struct _cam_data {
 	int capture_pid;
 	bool low_power;
 	wait_queue_head_t power_queue;
+	unsigned int ipu_id;
 	unsigned int csi;
 	u8 mclk_source;
 	bool mclk_on[2];	/* two mclk sources at most now */
diff --git a/drivers/media/video/mxc/capture/ov5640.c b/drivers/media/video/mxc/capture/ov5640.c
index 2e67bfc..4ef5c42 100644
--- a/drivers/media/video/mxc/capture/ov5640.c
+++ b/drivers/media/video/mxc/capture/ov5640.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -31,6 +31,7 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-int-device.h>
 #include "mxc_v4l2_capture.h"
+#include "fsl_csi.h"
 
 #define OV5640_VOLTAGE_ANALOG               2800000
 #define OV5640_VOLTAGE_DIGITAL_CORE         1500000
@@ -43,6 +44,9 @@
 #define OV5640_XCLK_MIN 6000000
 #define OV5640_XCLK_MAX 24000000
 
+#define OV5640_CHIP_ID_HIGH_BYTE        0x300A
+#define OV5640_CHIP_ID_LOW_BYTE         0x300B
+
 enum ov5640_mode {
 	ov5640_mode_MIN = 0,
 	ov5640_mode_VGA_640_480 = 0,
@@ -52,7 +56,9 @@ enum ov5640_mode {
 	ov5640_mode_720P_1280_720 = 4,
 	ov5640_mode_1080P_1920_1080 = 5,
 	ov5640_mode_QSXGA_2592_1944 = 6,
-	ov5640_mode_MAX = 6
+	ov5640_mode_QCIF_176_144 = 7,
+	ov5640_mode_XGA_1024_768 = 8,
+	ov5640_mode_MAX = 8
 };
 
 enum ov5640_frame_rate {
@@ -60,7 +66,6 @@ enum ov5640_frame_rate {
 	ov5640_30_fps
 };
 
-
 static int ov5640_framerates[] = {
 	[ov5640_15_fps] = 15,
 	[ov5640_30_fps] = 30,
@@ -85,9 +90,37 @@ struct ov5640_mode_info {
  * Maintains the information on the current state of the sesor.
  */
 static struct sensor_data ov5640_data;
+static int prev_sysclk;
+static int AE_Target = 52, night_mode;
+static int prev_HTS;
+static int AE_high, AE_low;
 
-static struct reg_value ov5640_setting_15fps_QSXGA_2592_1944[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
+static struct reg_value ov5640_global_init_setting[] = {
+	{0x3008, 0x42, 0, 0},
+	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
+	{0x3034, 0x1a, 0, 0}, {0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0},
+	{0x3630, 0x36, 0, 0}, {0x3631, 0x0e, 0, 0}, {0x3632, 0xe2, 0, 0},
+	{0x3633, 0x12, 0, 0}, {0x3621, 0xe0, 0, 0}, {0x3704, 0xa0, 0, 0},
+	{0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0}, {0x3717, 0x01, 0, 0},
+	{0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0}, {0x3905, 0x02, 0, 0},
+	{0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0}, {0x3731, 0x12, 0, 0},
+	{0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0}, {0x302d, 0x60, 0, 0},
+	{0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0}, {0x471c, 0x50, 0, 0},
+	{0x3a13, 0x43, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0x7c, 0, 0},
+	{0x3635, 0x13, 0, 0}, {0x3636, 0x03, 0, 0}, {0x3634, 0x40, 0, 0},
+	{0x3622, 0x01, 0, 0}, {0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0},
+	{0x3c05, 0x98, 0, 0}, {0x3c06, 0x00, 0, 0}, {0x3c07, 0x07, 0, 0},
+	{0x3c08, 0x00, 0, 0}, {0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0},
+	{0x3c0b, 0x40, 0, 0}, {0x3810, 0x00, 0, 0}, {0x3811, 0x10, 0, 0},
+	{0x3812, 0x00, 0, 0}, {0x3708, 0x64, 0, 0}, {0x4001, 0x02, 0, 0},
+	{0x4005, 0x1a, 0, 0}, {0x3000, 0x00, 0, 0}, {0x3004, 0xff, 0, 0},
+	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
+	{0x501f, 0x00, 0, 0}, {0x440e, 0x00, 0, 0}, {0x5000, 0xa7, 0, 0},
+	{0x3008, 0x02, 0, 0},
+};
+
+static struct reg_value ov5640_init_setting_30fps_VGA[] = {
+	{0x3008, 0x42, 0, 0},
 	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
 	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
 	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x36, 0, 0},
@@ -121,668 +154,403 @@ static struct reg_value ov5640_setting_15fps_QSXGA_2592_1944[] = {
 	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
 	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
 	{0x440e, 0x00, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0},
-	{0x5180, 0xff, 0, 0}, {0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0},
-	{0x5183, 0x14, 0, 0}, {0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0},
-	{0x5186, 0x09, 0, 0}, {0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0},
-	{0x5189, 0x75, 0, 0}, {0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0},
-	{0x518c, 0xb2, 0, 0}, {0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0},
-	{0x518f, 0x56, 0, 0}, {0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0},
-	{0x5192, 0x04, 0, 0}, {0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0},
-	{0x5195, 0xf0, 0, 0}, {0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0},
-	{0x5198, 0x04, 0, 0}, {0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0},
-	{0x519b, 0x00, 0, 0}, {0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0},
-	{0x519e, 0x38, 0, 0}, {0x5381, 0x1e, 0, 0}, {0x5382, 0x5b, 0, 0},
-	{0x5383, 0x08, 0, 0}, {0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0},
-	{0x5386, 0x88, 0, 0}, {0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0},
-	{0x5389, 0x10, 0, 0}, {0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0},
-	{0x5300, 0x08, 0, 0}, {0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0},
-	{0x5303, 0x00, 0, 0}, {0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0},
-	{0x5306, 0x08, 0, 0}, {0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0},
-	{0x530a, 0x30, 0, 0}, {0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0},
-	{0x5480, 0x01, 0, 0}, {0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0},
-	{0x5483, 0x28, 0, 0}, {0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0},
-	{0x5486, 0x71, 0, 0}, {0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0},
-	{0x5489, 0x91, 0, 0}, {0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0},
-	{0x548c, 0xb8, 0, 0}, {0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0},
-	{0x548f, 0xea, 0, 0}, {0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0},
-	{0x5583, 0x40, 0, 0}, {0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0},
-	{0x558a, 0x00, 0, 0}, {0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0},
-	{0x5801, 0x14, 0, 0}, {0x5802, 0x0f, 0, 0}, {0x5803, 0x0f, 0, 0},
-	{0x5804, 0x12, 0, 0}, {0x5805, 0x26, 0, 0}, {0x5806, 0x0c, 0, 0},
-	{0x5807, 0x08, 0, 0}, {0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0},
-	{0x580a, 0x08, 0, 0}, {0x580b, 0x0d, 0, 0}, {0x580c, 0x08, 0, 0},
-	{0x580d, 0x03, 0, 0}, {0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0},
-	{0x5810, 0x03, 0, 0}, {0x5811, 0x09, 0, 0}, {0x5812, 0x07, 0, 0},
-	{0x5813, 0x03, 0, 0}, {0x5814, 0x00, 0, 0}, {0x5815, 0x01, 0, 0},
-	{0x5816, 0x03, 0, 0}, {0x5817, 0x08, 0, 0}, {0x5818, 0x0d, 0, 0},
-	{0x5819, 0x08, 0, 0}, {0x581a, 0x05, 0, 0}, {0x581b, 0x06, 0, 0},
-	{0x581c, 0x08, 0, 0}, {0x581d, 0x0e, 0, 0}, {0x581e, 0x29, 0, 0},
-	{0x581f, 0x17, 0, 0}, {0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0},
-	{0x5822, 0x15, 0, 0}, {0x5823, 0x28, 0, 0}, {0x5824, 0x46, 0, 0},
-	{0x5825, 0x26, 0, 0}, {0x5826, 0x08, 0, 0}, {0x5827, 0x26, 0, 0},
-	{0x5828, 0x64, 0, 0}, {0x5829, 0x26, 0, 0}, {0x582a, 0x24, 0, 0},
-	{0x582b, 0x22, 0, 0}, {0x582c, 0x24, 0, 0}, {0x582d, 0x24, 0, 0},
-	{0x582e, 0x06, 0, 0}, {0x582f, 0x22, 0, 0}, {0x5830, 0x40, 0, 0},
-	{0x5831, 0x42, 0, 0}, {0x5832, 0x24, 0, 0}, {0x5833, 0x26, 0, 0},
-	{0x5834, 0x24, 0, 0}, {0x5835, 0x22, 0, 0}, {0x5836, 0x22, 0, 0},
-	{0x5837, 0x26, 0, 0}, {0x5838, 0x44, 0, 0}, {0x5839, 0x24, 0, 0},
-	{0x583a, 0x26, 0, 0}, {0x583b, 0x28, 0, 0}, {0x583c, 0x42, 0, 0},
-	{0x583d, 0xce, 0, 0}, {0x5025, 0x00, 0, 0}, {0x3a0f, 0x30, 0, 0},
-	{0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0}, {0x3a1e, 0x26, 0, 0},
-	{0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0}, {0x3008, 0x02, 0, 0},
-	{0x3035, 0x21, 0, 0}, {0x3c01, 0xb4, 0, 0}, {0x3c00, 0x04, 0, 0},
-	{0x3a19, 0x7c, 0, 0}, {0x5800, 0x2c, 0, 0}, {0x5801, 0x17, 0, 0},
-	{0x5802, 0x11, 0, 0}, {0x5803, 0x11, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x29, 0, 0}, {0x5806, 0x08, 0, 0}, {0x5807, 0x06, 0, 0},
-	{0x5808, 0x04, 0, 0}, {0x5809, 0x04, 0, 0}, {0x580a, 0x05, 0, 0},
-	{0x580b, 0x07, 0, 0}, {0x580c, 0x06, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x01, 0, 0}, {0x580f, 0x01, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x06, 0, 0}, {0x5812, 0x06, 0, 0}, {0x5813, 0x02, 0, 0},
-	{0x5814, 0x01, 0, 0}, {0x5815, 0x01, 0, 0}, {0x5816, 0x04, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x06, 0, 0}, {0x5819, 0x07, 0, 0},
-	{0x581a, 0x06, 0, 0}, {0x581b, 0x06, 0, 0}, {0x581c, 0x06, 0, 0},
-	{0x581d, 0x0e, 0, 0}, {0x581e, 0x31, 0, 0}, {0x581f, 0x12, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x11, 0, 0},
-	{0x5823, 0x2f, 0, 0}, {0x5824, 0x12, 0, 0}, {0x5825, 0x25, 0, 0},
-	{0x5826, 0x39, 0, 0}, {0x5827, 0x29, 0, 0}, {0x5828, 0x27, 0, 0},
-	{0x5829, 0x39, 0, 0}, {0x582a, 0x26, 0, 0}, {0x582b, 0x33, 0, 0},
-	{0x582c, 0x24, 0, 0}, {0x582d, 0x39, 0, 0}, {0x582e, 0x28, 0, 0},
-	{0x582f, 0x21, 0, 0}, {0x5830, 0x40, 0, 0}, {0x5831, 0x21, 0, 0},
-	{0x5832, 0x17, 0, 0}, {0x5833, 0x17, 0, 0}, {0x5834, 0x15, 0, 0},
-	{0x5835, 0x11, 0, 0}, {0x5836, 0x24, 0, 0}, {0x5837, 0x27, 0, 0},
-	{0x5838, 0x26, 0, 0}, {0x5839, 0x26, 0, 0}, {0x583a, 0x26, 0, 0},
-	{0x583b, 0x28, 0, 0}, {0x583c, 0x14, 0, 0}, {0x583d, 0xee, 0, 0},
-	{0x4005, 0x1a, 0, 0}, {0x5381, 0x26, 0, 0}, {0x5382, 0x50, 0, 0},
-	{0x5383, 0x0c, 0, 0}, {0x5384, 0x09, 0, 0}, {0x5385, 0x74, 0, 0},
-	{0x5386, 0x7d, 0, 0}, {0x5387, 0x7e, 0, 0}, {0x5388, 0x75, 0, 0},
-	{0x5389, 0x09, 0, 0}, {0x538b, 0x98, 0, 0}, {0x538a, 0x01, 0, 0},
-	{0x5580, 0x02, 0, 0}, {0x5588, 0x01, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x0f, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0x3f, 0, 0}, {0x5308, 0x25, 0, 0}, {0x5304, 0x08, 0, 0},
-	{0x5305, 0x30, 0, 0}, {0x5306, 0x10, 0, 0}, {0x5307, 0x20, 0, 0},
-	{0x5180, 0xff, 0, 0}, {0x5181, 0xf2, 0, 0}, {0x5182, 0x11, 0, 0},
-	{0x5183, 0x14, 0, 0}, {0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0},
-	{0x5186, 0x10, 0, 0}, {0x5187, 0x12, 0, 0}, {0x5188, 0x10, 0, 0},
-	{0x5189, 0x80, 0, 0}, {0x518a, 0x54, 0, 0}, {0x518b, 0xb8, 0, 0},
-	{0x518c, 0xb2, 0, 0}, {0x518d, 0x42, 0, 0}, {0x518e, 0x3a, 0, 0},
-	{0x518f, 0x56, 0, 0}, {0x5190, 0x46, 0, 0}, {0x5191, 0xf0, 0, 0},
-	{0x5192, 0x0f, 0, 0}, {0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0},
-	{0x5195, 0xf0, 0, 0}, {0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0},
-	{0x5198, 0x06, 0, 0}, {0x5199, 0x62, 0, 0}, {0x519a, 0x04, 0, 0},
-	{0x519b, 0x00, 0, 0}, {0x519c, 0x04, 0, 0}, {0x519d, 0xe7, 0, 0},
-	{0x519e, 0x38, 0, 0}, {0x3820, 0x40, 0, 0}, {0x3821, 0x06, 0, 0},
-	{0x3814, 0x11, 0, 0}, {0x3815, 0x11, 0, 0}, {0x3803, 0x00, 0, 0},
-	{0x3807, 0x9f, 0, 0}, {0x3808, 0x0a, 0, 0}, {0x3809, 0x20, 0, 0},
-	{0x380a, 0x07, 0, 0}, {0x380b, 0x98, 0, 0}, {0x380c, 0x0b, 0, 0},
-	{0x380d, 0x1c, 0, 0}, {0x380e, 0x07, 0, 0}, {0x380f, 0xb0, 0, 0},
-	{0x3813, 0x04, 0, 0}, {0x3618, 0x04, 0, 0}, {0x3612, 0x4b, 0, 0},
-	{0x3708, 0x21, 0, 0}, {0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0},
-	{0x3a02, 0x07, 0, 0}, {0x3a03, 0xb0, 0, 0}, {0x3a0e, 0x06, 0, 0},
-	{0x3a0d, 0x08, 0, 0}, {0x3a14, 0x07, 0, 0}, {0x3a15, 0xb0, 0, 0},
-	{0x4004, 0x06, 0, 0}, {0x5000, 0x07, 0, 0}, {0x5181, 0x52, 0, 0},
-	{0x5182, 0x00, 0, 0}, {0x5197, 0x01, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x3035, 0x21, 0, 0}, {0x5000, 0x27, 0, 0}, {0x5001, 0x83, 0, 0},
-	{0x3035, 0x71, 0, 0}, {0x4713, 0x02, 0, 0}, {0x3036, 0x69, 0, 0},
-	{0x4407, 0x0c, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
-	{0x3824, 0x01, 0, 0}, {0x4005, 0x1A, 0, 0},
+	{0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0}, {0x5000, 0xa7, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0}, {0x5181, 0xf2, 0, 0},
+	{0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0}, {0x5184, 0x25, 0, 0},
+	{0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0}, {0x5187, 0x09, 0, 0},
+	{0x5188, 0x09, 0, 0}, {0x5189, 0x88, 0, 0}, {0x518a, 0x54, 0, 0},
+	{0x518b, 0xee, 0, 0}, {0x518c, 0xb2, 0, 0}, {0x518d, 0x50, 0, 0},
+	{0x518e, 0x34, 0, 0}, {0x518f, 0x6b, 0, 0}, {0x5190, 0x46, 0, 0},
+	{0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0}, {0x5193, 0x70, 0, 0},
+	{0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0}, {0x5196, 0x03, 0, 0},
+	{0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0}, {0x5199, 0x6c, 0, 0},
+	{0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0}, {0x519c, 0x09, 0, 0},
+	{0x519d, 0x2b, 0, 0}, {0x519e, 0x38, 0, 0}, {0x5381, 0x1e, 0, 0},
+	{0x5382, 0x5b, 0, 0}, {0x5383, 0x08, 0, 0}, {0x5384, 0x0a, 0, 0},
+	{0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0}, {0x5387, 0x7c, 0, 0},
+	{0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0}, {0x538a, 0x01, 0, 0},
+	{0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0}, {0x5301, 0x30, 0, 0},
+	{0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0}, {0x5304, 0x08, 0, 0},
+	{0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0}, {0x5307, 0x16, 0, 0},
+	{0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0}, {0x530b, 0x04, 0, 0},
+	{0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0}, {0x5481, 0x08, 0, 0},
+	{0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0}, {0x5484, 0x51, 0, 0},
+	{0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0}, {0x5487, 0x7d, 0, 0},
+	{0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0}, {0x548a, 0x9a, 0, 0},
+	{0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0}, {0x548d, 0xcd, 0, 0},
+	{0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0}, {0x5490, 0x1d, 0, 0},
+	{0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0}, {0x5584, 0x10, 0, 0},
+	{0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0}, {0x558b, 0xf8, 0, 0},
+	{0x5800, 0x23, 0, 0}, {0x5801, 0x14, 0, 0}, {0x5802, 0x0f, 0, 0},
+	{0x5803, 0x0f, 0, 0}, {0x5804, 0x12, 0, 0}, {0x5805, 0x26, 0, 0},
+	{0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0}, {0x5808, 0x05, 0, 0},
+	{0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0}, {0x580b, 0x0d, 0, 0},
+	{0x580c, 0x08, 0, 0}, {0x580d, 0x03, 0, 0}, {0x580e, 0x00, 0, 0},
+	{0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0}, {0x5811, 0x09, 0, 0},
+	{0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0}, {0x5814, 0x00, 0, 0},
+	{0x5815, 0x01, 0, 0}, {0x5816, 0x03, 0, 0}, {0x5817, 0x08, 0, 0},
+	{0x5818, 0x0d, 0, 0}, {0x5819, 0x08, 0, 0}, {0x581a, 0x05, 0, 0},
+	{0x581b, 0x06, 0, 0}, {0x581c, 0x08, 0, 0}, {0x581d, 0x0e, 0, 0},
+	{0x581e, 0x29, 0, 0}, {0x581f, 0x17, 0, 0}, {0x5820, 0x11, 0, 0},
+	{0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0}, {0x5823, 0x28, 0, 0},
+	{0x5824, 0x46, 0, 0}, {0x5825, 0x26, 0, 0}, {0x5826, 0x08, 0, 0},
+	{0x5827, 0x26, 0, 0}, {0x5828, 0x64, 0, 0}, {0x5829, 0x26, 0, 0},
+	{0x582a, 0x24, 0, 0}, {0x582b, 0x22, 0, 0}, {0x582c, 0x24, 0, 0},
+	{0x582d, 0x24, 0, 0}, {0x582e, 0x06, 0, 0}, {0x582f, 0x22, 0, 0},
+	{0x5830, 0x40, 0, 0}, {0x5831, 0x42, 0, 0}, {0x5832, 0x24, 0, 0},
+	{0x5833, 0x26, 0, 0}, {0x5834, 0x24, 0, 0}, {0x5835, 0x22, 0, 0},
+	{0x5836, 0x22, 0, 0}, {0x5837, 0x26, 0, 0}, {0x5838, 0x44, 0, 0},
+	{0x5839, 0x24, 0, 0}, {0x583a, 0x26, 0, 0}, {0x583b, 0x28, 0, 0},
+	{0x583c, 0x42, 0, 0}, {0x583d, 0xce, 0, 0}, {0x5025, 0x00, 0, 0},
+	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
+	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
+	{0x3008, 0x02, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_VGA_640_480[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0}, {0x380a, 0x01, 0, 0},
-	{0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0}, {0x3503, 0x00, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_VGA_640_480[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0}, {0x3503, 0x00, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_QVGA_320_240[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0x80, 0, 0}, {0x380a, 0x01, 0, 0},
-	{0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3808, 0x01, 0, 0},
-	{0x3809, 0x40, 0, 0}, {0x380a, 0x00, 0, 0}, {0x380b, 0xf0, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x01, 0, 0}, {0x3809, 0x40, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0xf0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_QVGA_320_240[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x01, 0, 0}, {0x3809, 0x40, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0xf0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_NTSC_720_480[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0}, {0x380a, 0x01, 0, 0},
-	{0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x60, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0},
+	{0x3807, 0xd4, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_NTSC_720_480[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0},
+	{0x3807, 0xd4, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x01, 0, 0}, {0x380b, 0xe0, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct reg_value ov5640_setting_30fps_PAL_720_576[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x46, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x60, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x09, 0, 0}, {0x3805, 0x7e, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x02, 0, 0}, {0x380b, 0x40, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_PAL_720_576[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x60, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x09, 0, 0}, {0x3805, 0x7e, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0},
+	{0x380a, 0x02, 0, 0}, {0x380b, 0x40, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
+	{0x3035, 0x21, 0, 0}, {0x3036, 0x69, 0, 0}, {0x3c07, 0x07, 0, 0},
 	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
 	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
-	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
-	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
-	{0x3808, 0x02, 0, 0}, {0x3809, 0xd0, 0, 0}, {0x380a, 0x02, 0, 0},
-	{0x380b, 0x40, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x68, 0, 0},
-	{0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x62, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
-	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
-	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0xfa, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0}, {0x3807, 0xa9, 0, 0},
+	{0x3808, 0x05, 0, 0}, {0x3809, 0x00, 0, 0}, {0x380a, 0x02, 0, 0},
+	{0x380b, 0xd0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x64, 0, 0},
+	{0x380e, 0x02, 0, 0}, {0x380f, 0xe4, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3709, 0x52, 0, 0},
+	{0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0}, {0x3a03, 0xe0, 0, 0},
+	{0x3a14, 0x02, 0, 0}, {0x3a15, 0xe0, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0}, {0x4713, 0x03, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
+	{0x4837, 0x16, 0, 0}, {0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x3503, 0x00, 0, 0},
 };
 
-static struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x69, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x27, 0, 0}, {0x3814, 0x31, 0, 0},
+static struct reg_value ov5640_setting_15fps_720P_1280_720[] = {
+	{0x3035, 0x41, 0, 0}, {0x3036, 0x69, 0, 0}, {0x3c07, 0x07, 0, 0},
+	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
 	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
 	{0x3802, 0x00, 0, 0}, {0x3803, 0xfa, 0, 0}, {0x3804, 0x0a, 0, 0},
 	{0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0}, {0x3807, 0xa9, 0, 0},
 	{0x3808, 0x05, 0, 0}, {0x3809, 0x00, 0, 0}, {0x380a, 0x02, 0, 0},
 	{0x380b, 0xd0, 0, 0}, {0x380c, 0x07, 0, 0}, {0x380d, 0x64, 0, 0},
-	{0x380e, 0x02, 0, 0}, {0x380f, 0xe4, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
-	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0},
-	{0x3a03, 0xe4, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0xbc, 0, 0},
-	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x72, 0, 0}, {0x3a0e, 0x01, 0, 0},
-	{0x3a0d, 0x02, 0, 0}, {0x3a14, 0x02, 0, 0}, {0x3a15, 0xe4, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x00, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xff, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x02, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0x83, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x21, 0, 0}, {0x3002, 0x1c, 0, 0},
-	{0x3006, 0xc3, 0, 0}, {0x3821, 0x07, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x460b, 0x37, 0, 0},
+	{0x380e, 0x02, 0, 0}, {0x380f, 0xe4, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3709, 0x52, 0, 0},
+	{0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0}, {0x3a03, 0xe0, 0, 0},
+	{0x3a14, 0x02, 0, 0}, {0x3a15, 0xe0, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0}, {0x4713, 0x03, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
+	{0x4837, 0x16, 0, 0}, {0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x3503, 0x00, 0, 0},
 };
 
-static struct reg_value ov5640_setting_30fps_1080P_1920_1080[] = {
-	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 0}, {0x3008, 0x42, 0, 0},
-	{0x3103, 0x03, 0, 0}, {0x3017, 0xff, 0, 0}, {0x3018, 0xff, 0, 0},
-	{0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0}, {0x3036, 0x69, 0, 0},
-	{0x3037, 0x13, 0, 0}, {0x3108, 0x01, 0, 0}, {0x3630, 0x2e, 0, 0},
-	{0x3632, 0xe2, 0, 0}, {0x3633, 0x23, 0, 0}, {0x3621, 0xe0, 0, 0},
-	{0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0}, {0x3715, 0x78, 0, 0},
-	{0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0}, {0x3705, 0x1a, 0, 0},
-	{0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0}, {0x3901, 0x0a, 0, 0},
-	{0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0}, {0x3601, 0x33, 0, 0},
-	{0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0}, {0x371b, 0x20, 0, 0},
-	{0x471c, 0x50, 0, 0}, {0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0},
-	{0x3635, 0x1c, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
-	{0x3c01, 0x34, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
-	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
-	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
-	{0x3820, 0x41, 0, 0}, {0x3821, 0x26, 0, 0}, {0x3814, 0x11, 0, 0},
-	{0x3815, 0x11, 0, 0}, {0x3800, 0x01, 0, 0}, {0x3801, 0x50, 0, 0},
-	{0x3802, 0x01, 0, 0}, {0x3803, 0xb2, 0, 0}, {0x3804, 0x08, 0, 0},
-	{0x3805, 0xef, 0, 0}, {0x3806, 0x05, 0, 0}, {0x3807, 0xf2, 0, 0},
-	{0x3808, 0x07, 0, 0}, {0x3809, 0x80, 0, 0}, {0x380a, 0x04, 0, 0},
-	{0x380b, 0x38, 0, 0}, {0x380c, 0x09, 0, 0}, {0x380d, 0xc4, 0, 0},
-	{0x380e, 0x04, 0, 0}, {0x380f, 0x60, 0, 0}, {0x3810, 0x00, 0, 0},
-	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
-	{0x3618, 0x04, 0, 0}, {0x3612, 0x2b, 0, 0}, {0x3708, 0x62, 0, 0},
-	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x04, 0, 0},
-	{0x3a03, 0x60, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x50, 0, 0},
-	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x18, 0, 0}, {0x3a0e, 0x03, 0, 0},
-	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x04, 0, 0}, {0x3a15, 0x60, 0, 0},
-	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0}, {0x3000, 0x00, 0, 0},
-	{0x3002, 0x00, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xff, 0, 0},
-	{0x300e, 0x58, 0, 0}, {0x302e, 0x00, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4713, 0x02, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x5000, 0xa7, 0, 0}, {0x5001, 0x83, 0, 0}, {0x5180, 0xff, 0, 0},
-	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
-	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
-	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x75, 0, 0},
-	{0x518a, 0x54, 0, 0}, {0x518b, 0xe0, 0, 0}, {0x518c, 0xb2, 0, 0},
-	{0x518d, 0x42, 0, 0}, {0x518e, 0x3d, 0, 0}, {0x518f, 0x56, 0, 0},
-	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
-	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
-	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
-	{0x5199, 0x12, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
-	{0x519c, 0x06, 0, 0}, {0x519d, 0x82, 0, 0}, {0x519e, 0x38, 0, 0},
-	{0x5381, 0x1c, 0, 0}, {0x5382, 0x5a, 0, 0}, {0x5383, 0x06, 0, 0},
-	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
-	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
-	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
-	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
-	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
-	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
-	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
-	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
-	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
-	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
-	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
-	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
-	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
-	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
-	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x15, 0, 0},
-	{0x5802, 0x10, 0, 0}, {0x5803, 0x10, 0, 0}, {0x5804, 0x15, 0, 0},
-	{0x5805, 0x23, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
-	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
-	{0x580b, 0x0c, 0, 0}, {0x580c, 0x07, 0, 0}, {0x580d, 0x03, 0, 0},
-	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
-	{0x5811, 0x07, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
-	{0x5814, 0x00, 0, 0}, {0x5815, 0x00, 0, 0}, {0x5816, 0x03, 0, 0},
-	{0x5817, 0x07, 0, 0}, {0x5818, 0x0b, 0, 0}, {0x5819, 0x08, 0, 0},
-	{0x581a, 0x05, 0, 0}, {0x581b, 0x05, 0, 0}, {0x581c, 0x07, 0, 0},
-	{0x581d, 0x0b, 0, 0}, {0x581e, 0x2a, 0, 0}, {0x581f, 0x16, 0, 0},
-	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
-	{0x5823, 0x29, 0, 0}, {0x5824, 0xbf, 0, 0}, {0x5825, 0xaf, 0, 0},
-	{0x5826, 0x9f, 0, 0}, {0x5827, 0xaf, 0, 0}, {0x5828, 0xdf, 0, 0},
-	{0x5829, 0x6f, 0, 0}, {0x582a, 0x8e, 0, 0}, {0x582b, 0xab, 0, 0},
-	{0x582c, 0x9e, 0, 0}, {0x582d, 0x7f, 0, 0}, {0x582e, 0x4f, 0, 0},
-	{0x582f, 0x89, 0, 0}, {0x5830, 0x86, 0, 0}, {0x5831, 0x98, 0, 0},
-	{0x5832, 0x6f, 0, 0}, {0x5833, 0x4f, 0, 0}, {0x5834, 0x6e, 0, 0},
-	{0x5835, 0x7b, 0, 0}, {0x5836, 0x7e, 0, 0}, {0x5837, 0x6f, 0, 0},
-	{0x5838, 0xde, 0, 0}, {0x5839, 0xbf, 0, 0}, {0x583a, 0x9f, 0, 0},
-	{0x583b, 0xbf, 0, 0}, {0x583c, 0xec, 0, 0}, {0x5025, 0x00, 0, 0},
-	{0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0}, {0x3a1b, 0x30, 0, 0},
-	{0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0}, {0x3a1f, 0x14, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3035, 0x21, 0, 0}, {0x3002, 0x1c, 0, 0},
-	{0x3006, 0xc3, 0, 0}, {0x3821, 0x06, 0, 0}, {0x4300, 0x30, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
-	{0x460b, 0x37, 0, 0},
+static struct reg_value ov5640_setting_30fps_QCIF_176_144[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x00, 0, 0}, {0x3809, 0xb0, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0x90, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x11, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_QCIF_176_144[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x00, 0, 0}, {0x3809, 0xb0, 0, 0},
+	{0x380a, 0x00, 0, 0}, {0x380b, 0x90, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x22, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_30fps_XGA_1024_768[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x04, 0, 0}, {0x3809, 0x00, 0, 0},
+	{0x380a, 0x03, 0, 0}, {0x380b, 0x00, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x69, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_XGA_1024_768[] = {
+	{0x3c07, 0x08, 0, 0}, {0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0},
+	{0x3814, 0x31, 0, 0}, {0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9b, 0, 0}, {0x3808, 0x04, 0, 0}, {0x3809, 0x00, 0, 0},
+	{0x380a, 0x03, 0, 0}, {0x380b, 0x00, 0, 0}, {0x380c, 0x07, 0, 0},
+	{0x380d, 0x68, 0, 0}, {0x380e, 0x03, 0, 0}, {0x380f, 0xd8, 0, 0},
+	{0x3813, 0x06, 0, 0}, {0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x0b, 0, 0},
+	{0x3a03, 0x88, 0, 0}, {0x3a14, 0x0b, 0, 0}, {0x3a15, 0x88, 0, 0},
+	{0x4004, 0x02, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x03, 0, 0}, {0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x22, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0xa3, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x46, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+
+static struct reg_value ov5640_setting_15fps_1080P_1920_1080[] = {
+	{0x3c07, 0x07, 0, 0}, {0x3820, 0x40, 0, 0}, {0x3821, 0x06, 0, 0},
+	{0x3814, 0x11, 0, 0}, {0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0xee, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x05, 0, 0},
+	{0x3807, 0xc3, 0, 0}, {0x3808, 0x07, 0, 0}, {0x3809, 0x80, 0, 0},
+	{0x380a, 0x04, 0, 0}, {0x380b, 0x38, 0, 0}, {0x380c, 0x0b, 0, 0},
+	{0x380d, 0x1c, 0, 0}, {0x380e, 0x07, 0, 0}, {0x380f, 0xb0, 0, 0},
+	{0x3813, 0x04, 0, 0}, {0x3618, 0x04, 0, 0}, {0x3612, 0x2b, 0, 0},
+	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x07, 0, 0},
+	{0x3a03, 0xae, 0, 0}, {0x3a14, 0x07, 0, 0}, {0x3a15, 0xae, 0, 0},
+	{0x4004, 0x06, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x02, 0, 0}, {0x4407, 0x0c, 0, 0}, {0x460b, 0x37, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x2c, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0x83, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x69, 0, 0}, {0x3037, 0x13, 0, 0},
+};
+
+static struct reg_value ov5640_setting_15fps_QSXGA_2592_1944[] = {
+	{0x3c07, 0x07, 0, 0}, {0x3820, 0x40, 0, 0}, {0x3821, 0x06, 0, 0},
+	{0x3814, 0x11, 0, 0}, {0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0},
+	{0x3801, 0x00, 0, 0}, {0x3802, 0x00, 0, 0}, {0x3803, 0x00, 0, 0},
+	{0x3804, 0x0a, 0, 0}, {0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0},
+	{0x3807, 0x9f, 0, 0}, {0x3808, 0x0a, 0, 0}, {0x3809, 0x20, 0, 0},
+	{0x380a, 0x07, 0, 0}, {0x380b, 0x98, 0, 0}, {0x380c, 0x0b, 0, 0},
+	{0x380d, 0x1c, 0, 0}, {0x380e, 0x07, 0, 0}, {0x380f, 0xb0, 0, 0},
+	{0x3813, 0x04, 0, 0}, {0x3618, 0x04, 0, 0}, {0x3612, 0x2b, 0, 0},
+	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x07, 0, 0},
+	{0x3a03, 0xae, 0, 0}, {0x3a14, 0x07, 0, 0}, {0x3a15, 0xae, 0, 0},
+	{0x4004, 0x06, 0, 0}, {0x3002, 0x1c, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x4713, 0x02, 0, 0}, {0x4407, 0x0c, 0, 0}, {0x460b, 0x37, 0, 0},
+	{0x460c, 0x20, 0, 0}, {0x4837, 0x2c, 0, 0}, {0x3824, 0x01, 0, 0},
+	{0x5001, 0x83, 0, 0}, {0x3034, 0x1a, 0, 0}, {0x3035, 0x21, 0, 0},
+	{0x3036, 0x69, 0, 0}, {0x3037, 0x13, 0, 0},
 };
 
 static struct ov5640_mode_info ov5640_mode_info_data[2][ov5640_mode_MAX + 1] = {
 	{
-		{ov5640_mode_VGA_640_480, 0, 0, NULL, 0},
-		{ov5640_mode_QVGA_320_240, 0, 0, NULL, 0},
-		{ov5640_mode_NTSC_720_480, 0, 0, NULL, 0},
-		{ov5640_mode_PAL_720_576, 0, 0, NULL, 0},
-		{ov5640_mode_720P_1280_720, 0, 0, NULL, 0},
-		{ov5640_mode_1080P_1920_1080, 0, 0, NULL, 0},
+		{ov5640_mode_VGA_640_480,      640,  480,
+		ov5640_setting_15fps_VGA_640_480,
+		ARRAY_SIZE(ov5640_setting_15fps_VGA_640_480)},
+		{ov5640_mode_QVGA_320_240,     320,  240,
+		ov5640_setting_15fps_QVGA_320_240,
+		ARRAY_SIZE(ov5640_setting_15fps_QVGA_320_240)},
+		{ov5640_mode_NTSC_720_480,     720,  480,
+		ov5640_setting_15fps_NTSC_720_480,
+		ARRAY_SIZE(ov5640_setting_15fps_NTSC_720_480)},
+		{ov5640_mode_PAL_720_576,      720,  576,
+		ov5640_setting_15fps_PAL_720_576,
+		ARRAY_SIZE(ov5640_setting_15fps_PAL_720_576)},
+		{ov5640_mode_720P_1280_720,   1280,  720,
+		ov5640_setting_15fps_720P_1280_720,
+		ARRAY_SIZE(ov5640_setting_15fps_720P_1280_720)},
+		{ov5640_mode_1080P_1920_1080, 1920, 1080,
+		ov5640_setting_15fps_1080P_1920_1080,
+		ARRAY_SIZE(ov5640_setting_15fps_1080P_1920_1080)},
 		{ov5640_mode_QSXGA_2592_1944, 2592, 1944,
 		ov5640_setting_15fps_QSXGA_2592_1944,
 		ARRAY_SIZE(ov5640_setting_15fps_QSXGA_2592_1944)},
+		{ov5640_mode_QCIF_176_144,     176,  144,
+		ov5640_setting_15fps_QCIF_176_144,
+		ARRAY_SIZE(ov5640_setting_15fps_QCIF_176_144)},
+		{ov5640_mode_XGA_1024_768,    1024,  768,
+		ov5640_setting_15fps_XGA_1024_768,
+		ARRAY_SIZE(ov5640_setting_15fps_XGA_1024_768)},
 	},
 	{
-		{ov5640_mode_VGA_640_480,    640,  480,
+		{ov5640_mode_VGA_640_480,      640,  480,
 		ov5640_setting_30fps_VGA_640_480,
 		ARRAY_SIZE(ov5640_setting_30fps_VGA_640_480)},
-		{ov5640_mode_QVGA_320_240,   320,  240,
+		{ov5640_mode_QVGA_320_240,     320,  240,
 		ov5640_setting_30fps_QVGA_320_240,
 		ARRAY_SIZE(ov5640_setting_30fps_QVGA_320_240)},
-		{ov5640_mode_NTSC_720_480,   720, 480,
+		{ov5640_mode_NTSC_720_480,     720,  480,
 		ov5640_setting_30fps_NTSC_720_480,
 		ARRAY_SIZE(ov5640_setting_30fps_NTSC_720_480)},
-		{ov5640_mode_PAL_720_576,    720, 576,
+		{ov5640_mode_PAL_720_576,      720,  576,
 		ov5640_setting_30fps_PAL_720_576,
 		ARRAY_SIZE(ov5640_setting_30fps_PAL_720_576)},
-		{ov5640_mode_720P_1280_720,  1280, 720,
+		{ov5640_mode_720P_1280_720,   1280,  720,
 		ov5640_setting_30fps_720P_1280_720,
 		ARRAY_SIZE(ov5640_setting_30fps_720P_1280_720)},
-		{ov5640_mode_1080P_1920_1080,  1920, 1080,
-		ov5640_setting_30fps_1080P_1920_1080,
-		ARRAY_SIZE(ov5640_setting_30fps_1080P_1920_1080)},
+		{ov5640_mode_1080P_1920_1080, 0, 0, NULL, 0},
 		{ov5640_mode_QSXGA_2592_1944, 0, 0, NULL, 0},
+		{ov5640_mode_QCIF_176_144,     176,  144,
+		ov5640_setting_30fps_QCIF_176_144,
+		ARRAY_SIZE(ov5640_setting_30fps_QCIF_176_144)},
+		{ov5640_mode_XGA_1024_768,    1024,  768,
+		ov5640_setting_30fps_XGA_1024_768,
+		ARRAY_SIZE(ov5640_setting_30fps_XGA_1024_768)},
 	},
 };
 
@@ -801,6 +569,7 @@ static s32 ov5640_write_reg(u16 reg, u8 val);
 
 static const struct i2c_device_id ov5640_id[] = {
 	{"ov5640", 0},
+	{"ov564x", 0},
 	{},
 };
 
@@ -859,36 +628,317 @@ static s32 ov5640_read_reg(u16 reg, u8 *val)
 	return u8RdVal;
 }
 
-static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,
-			    enum ov5640_mode mode)
+static void ov5640_soft_reset(void)
 {
-	struct reg_value *pModeSetting = NULL;
-	s32 i = 0;
-	s32 iModeSettingArySize = 0;
-	register u32 Delay_ms = 0;
-	register u16 RegAddr = 0;
-	register u8 Mask = 0;
-	register u8 Val = 0;
-	u8 RegVal = 0;
-	int retval = 0;
+	/* sysclk from pad */
+	ov5640_write_reg(0x3103, 0x11);
 
-	if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
-		pr_err("Wrong ov5640 mode detected!\n");
+	/* software reset */
+	ov5640_write_reg(0x3008, 0x82);
+
+	/* delay at least 5ms */
+	msleep(10);
+}
+
+/* set sensor driver capability
+ * 0x302c[7:6] - strength
+	00     - 1x
+	01     - 2x
+	10     - 3x
+	11     - 4x
+ */
+static int ov5640_driver_capability(int strength)
+{
+	u8 temp = 0;
+
+	if (strength > 4 || strength < 1) {
+		pr_err("The valid driver capability of ov5640 is 1x~4x\n");
+		return -EINVAL;
+	}
+
+	ov5640_read_reg(0x302c, &temp);
+
+	temp &= ~0xc0;	/* clear [7:6] */
+	temp |= ((strength - 1) << 6);	/* set [7:6] */
+
+	ov5640_write_reg(0x302c, temp);
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_get_sysclk(void)
+{
+	int xvclk = ov5640_data.mclk / 10000;
+	int sysclk;
+	int temp1, temp2;
+	int Multiplier, PreDiv, VCO, SysDiv, Pll_rdiv, Bit_div2x, sclk_rdiv;
+	int sclk_rdiv_map[] = {1, 2, 4, 8};
+	u8 regval = 0;
+
+	temp1 = ov5640_read_reg(0x3034, &regval);
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10) {
+		Bit_div2x = temp2 / 2;
+	} else {
+		pr_err("ov5640: unsupported bit mode %d\n", temp2);
 		return -1;
 	}
 
-	pModeSetting = ov5640_mode_info_data[frame_rate][mode].init_data_ptr;
-	iModeSettingArySize =
-		ov5640_mode_info_data[frame_rate][mode].init_data_size;
+	temp1 = ov5640_read_reg(0x3035, &regval);
+	SysDiv = temp1 >> 4;
+	if (SysDiv == 0)
+		SysDiv = 16;
 
-	ov5640_data.pix.width = ov5640_mode_info_data[frame_rate][mode].width;
-	ov5640_data.pix.height = ov5640_mode_info_data[frame_rate][mode].height;
+	temp1 = ov5640_read_reg(0x3036, &regval);
+	Multiplier = temp1;
+	temp1 = ov5640_read_reg(0x3037, &regval);
+	PreDiv = temp1 & 0x0f;
+	Pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
 
-	if (ov5640_data.pix.width == 0 || ov5640_data.pix.height == 0 ||
-	    pModeSetting == NULL || iModeSettingArySize == 0)
-		return -EINVAL;
+	temp1 = ov5640_read_reg(0x3108, &regval);
+	temp2 = temp1 & 0x03;
+
+	sclk_rdiv = sclk_rdiv_map[temp2];
+	VCO = xvclk * Multiplier / PreDiv;
+	sysclk = VCO / SysDiv / Pll_rdiv * 2 / Bit_div2x / sclk_rdiv;
 
-	for (i = 0; i < iModeSettingArySize; ++i, ++pModeSetting) {
+	return sysclk;
+}
+
+/* read HTS from register settings */
+static int ov5640_get_HTS(void)
+{
+	int HTS;
+	u8 temp = 0;
+
+	HTS = ov5640_read_reg(0x380c, &temp);
+	HTS = (HTS<<8) + ov5640_read_reg(0x380d, &temp);
+	return HTS;
+}
+
+/* read VTS from register settings */
+static int ov5640_get_VTS(void)
+{
+	int VTS;
+	u8 temp = 0;
+
+	VTS = ov5640_read_reg(0x380e, &temp);
+	VTS = (VTS<<8) + ov5640_read_reg(0x380f, &temp);
+
+	return VTS;
+}
+
+/* write VTS to registers */
+static int ov5640_set_VTS(int VTS)
+{
+	int temp;
+
+	temp = VTS & 0xff;
+	ov5640_write_reg(0x380f, temp);
+
+	temp = VTS>>8;
+	ov5640_write_reg(0x380e, temp);
+	return 0;
+}
+
+/* read shutter, in number of line period */
+static int ov5640_get_shutter(void)
+{
+	int shutter;
+	u8 regval;
+
+	shutter = (ov5640_read_reg(0x03500, &regval) & 0x0f);
+
+	shutter = (shutter<<8) + ov5640_read_reg(0x3501, &regval);
+	shutter = (shutter<<4) + (ov5640_read_reg(0x3502, &regval)>>4);
+
+	return shutter;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_set_shutter(int shutter)
+{
+	int temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp<<4;
+	ov5640_write_reg(0x3502, temp);
+
+	temp = shutter & 0xfff;
+	temp = temp>>4;
+	ov5640_write_reg(0x3501, temp);
+
+	temp = shutter>>12;
+	ov5640_write_reg(0x3500, temp);
+
+	return 0;
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_get_gain16(void)
+{
+	int gain16;
+	u8 regval;
+
+	gain16 = ov5640_read_reg(0x350a, &regval) & 0x03;
+	gain16 = (gain16<<8) + ov5640_read_reg(0x350b, &regval);
+
+	return gain16;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_set_gain16(int gain16)
+{
+	int temp;
+
+	gain16 = gain16 & 0x3ff;
+	temp = gain16 & 0xff;
+
+	ov5640_write_reg(0x350b, temp);
+	temp = gain16>>8;
+
+	ov5640_write_reg(0x350a, temp);
+	return 0;
+}
+
+/* get banding filter value */
+static int ov5640_get_light_freq(void)
+{
+	int temp, temp1, light_frequency;
+	u8 regval;
+
+	temp = ov5640_read_reg(0x3c01, &regval);
+	if (temp & 0x80) {
+		/* manual */
+		temp1 = ov5640_read_reg(0x3c00, &regval);
+		if (temp1 & 0x04) {
+			/* 50Hz */
+			light_frequency = 50;
+		} else {
+			/* 60Hz */
+			light_frequency = 60;
+		}
+	} else {
+		/* auto */
+		temp1 = ov5640_read_reg(0x3c0c, &regval);
+		if (temp1 & 0x01) {
+			/* 50Hz */
+			light_frequency = 50;
+		} else {
+			/* 60Hz */
+			light_frequency = 60;
+		}
+	}
+
+	return light_frequency;
+}
+
+static void ov5640_set_bandingfilter(void)
+{
+	int prev_VTS;
+	int band_step60, max_band60, band_step50, max_band50;
+
+	/* read preview PCLK */
+	prev_sysclk = ov5640_get_sysclk();
+
+	/* read preview HTS */
+	prev_HTS = ov5640_get_HTS();
+
+	/* read preview VTS */
+	prev_VTS = ov5640_get_VTS();
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = prev_sysclk * 100/prev_HTS * 100/120;
+	ov5640_write_reg(0x3a0a, (band_step60 >> 8));
+	ov5640_write_reg(0x3a0b, (band_step60 & 0xff));
+
+	max_band60 = (int)((prev_VTS-4)/band_step60);
+	ov5640_write_reg(0x3a0d, max_band60);
+
+	/* 50Hz */
+	band_step50 = prev_sysclk * 100/prev_HTS;
+	ov5640_write_reg(0x3a08, (band_step50 >> 8));
+	ov5640_write_reg(0x3a09, (band_step50 & 0xff));
+
+	max_band50 = (int)((prev_VTS-4)/band_step50);
+	ov5640_write_reg(0x3a0e, max_band50);
+}
+
+/* stable in high */
+static int ov5640_set_AE_target(int target)
+{
+	int fast_high, fast_low;
+
+	AE_low = target * 23 / 25; /* 0.92 */
+	AE_high = target * 27 / 25; /* 1.08 */
+	fast_high = AE_high << 1;
+
+	if (fast_high > 255)
+		fast_high = 255;
+	fast_low = AE_low >> 1;
+
+	ov5640_write_reg(0x3a0f, AE_high);
+	ov5640_write_reg(0x3a10, AE_low);
+	ov5640_write_reg(0x3a1b, AE_high);
+	ov5640_write_reg(0x3a1e, AE_low);
+	ov5640_write_reg(0x3a11, fast_high);
+	ov5640_write_reg(0x3a1f, fast_low);
+
+	return 0;
+}
+
+/* enable = 0 to turn off night mode
+   enable = 1 to turn on night mode */
+static int ov5640_set_night_mode(int enable)
+{
+	u8 mode;
+
+	ov5640_read_reg(0x3a00, &mode);
+
+	if (enable) {
+		/* night mode on */
+		mode |= 0x04;
+		ov5640_write_reg(0x3a00, mode);
+	} else {
+		/* night mode off */
+		mode &= 0xfb;
+		ov5640_write_reg(0x3a00, mode);
+	}
+
+	return 0;
+}
+
+/* enable = 0 to turn off AEC/AGC
+   enable = 1 to turn on AEC/AGC */
+void ov5640_turn_on_AE_AG(int enable)
+{
+	u8 ae_ag_ctrl;
+
+	ov5640_read_reg(0x3503, &ae_ag_ctrl);
+	if (enable) {
+		/* turn on auto AE/AG */
+		ae_ag_ctrl = ae_ag_ctrl & ~(0x03);
+	} else {
+		/* turn off AE/AG */
+		ae_ag_ctrl = ae_ag_ctrl | 0x03;
+	}
+	ov5640_write_reg(0x3503, ae_ag_ctrl);
+}
+
+/* download ov5640 settings to sensor through i2c */
+static int ov5640_download_firmware(struct reg_value *pModeSetting, s32 ArySize)
+{
+	register u32 Delay_ms = 0;
+	register u16 RegAddr = 0;
+	register u8 Mask = 0;
+	register u8 Val = 0;
+	u8 RegVal = 0;
+	int i, retval = 0;
+
+	for (i = 0; i < ArySize; ++i, ++pModeSetting) {
 		Delay_ms = pModeSetting->u32Delay_ms;
 		RegAddr = pModeSetting->u16RegAddr;
 		Val = pModeSetting->u8Val;
@@ -915,6 +965,251 @@ err:
 	return retval;
 }
 
+static int ov5640_init_mode(void)
+{
+	struct reg_value *pModeSetting = NULL;
+	int ArySize = 0, retval = 0;
+
+	ov5640_soft_reset();
+
+	pModeSetting = ov5640_global_init_setting;
+	ArySize = ARRAY_SIZE(ov5640_global_init_setting);
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+	if (retval < 0)
+		goto err;
+
+	pModeSetting = ov5640_init_setting_30fps_VGA;
+	ArySize = ARRAY_SIZE(ov5640_init_setting_30fps_VGA);
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+	if (retval < 0)
+		goto err;
+
+	/* change driver capability to 2x according to validation board.
+	 * if the image is not stable, please increase the driver strength.
+	 */
+	ov5640_driver_capability(2);
+	ov5640_set_bandingfilter();
+	ov5640_set_AE_target(AE_Target);
+	ov5640_set_night_mode(night_mode);
+
+	/* skip 9 vysnc: start capture at 10th vsync */
+	msleep(300);
+
+	/* turn off night mode */
+	night_mode = 0;
+	ov5640_data.pix.width = 640;
+	ov5640_data.pix.height = 480;
+err:
+	return retval;
+}
+
+/* change to or back to subsampling mode set the mode directly
+ * image size below 1280 * 960 is subsampling mode */
+static int ov5640_change_mode_direct(enum ov5640_frame_rate frame_rate,
+			    enum ov5640_mode mode)
+{
+	struct reg_value *pModeSetting = NULL;
+	s32 ArySize = 0;
+	int retval = 0;
+
+	if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
+		pr_err("Wrong ov5640 mode detected!\n");
+		return -1;
+	}
+
+	pModeSetting = ov5640_mode_info_data[frame_rate][mode].init_data_ptr;
+	ArySize =
+		ov5640_mode_info_data[frame_rate][mode].init_data_size;
+
+	ov5640_data.pix.width = ov5640_mode_info_data[frame_rate][mode].width;
+	ov5640_data.pix.height = ov5640_mode_info_data[frame_rate][mode].height;
+
+	if (ov5640_data.pix.width == 0 || ov5640_data.pix.height == 0 ||
+	    pModeSetting == NULL || ArySize == 0)
+		return -EINVAL;
+
+	/* set ov5640 to subsampling mode */
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+
+	/* turn on AE AG for subsampling mode, in case the firmware didn't */
+	ov5640_turn_on_AE_AG(1);
+
+	/* calculate banding filter */
+	ov5640_set_bandingfilter();
+
+	/* set AE target */
+	ov5640_set_AE_target(AE_Target);
+
+	/* update night mode setting */
+	ov5640_set_night_mode(night_mode);
+
+	/* skip 9 vysnc: start capture at 10th vsync */
+	if (mode == ov5640_mode_XGA_1024_768 && frame_rate == ov5640_30_fps) {
+		pr_warning("ov5640: actual frame rate of XGA is 22.5fps\n");
+		/* 1/22.5 * 9*/
+		msleep(400);
+		return retval;
+	}
+
+	if (frame_rate == ov5640_15_fps) {
+		/* 1/15 * 9*/
+		msleep(600);
+	} else if (frame_rate == ov5640_30_fps) {
+		/* 1/30 * 9*/
+		msleep(300);
+	}
+
+	return retval;
+}
+
+/* change to scaling mode go through exposure calucation
+ * image size above 1280 * 960 is scaling mode */
+static int ov5640_change_mode_exposure_calc(enum ov5640_frame_rate frame_rate,
+			    enum ov5640_mode mode)
+{
+	int prev_shutter, prev_gain16, average;
+	int cap_shutter, cap_gain16;
+	int cap_sysclk, cap_HTS, cap_VTS;
+	int light_freq, cap_bandfilt, cap_maxband;
+	long cap_gain16_shutter;
+	u8 temp;
+	struct reg_value *pModeSetting = NULL;
+	s32 ArySize = 0;
+	int retval = 0;
+
+	/* check if the input mode and frame rate is valid */
+	pModeSetting =
+		ov5640_mode_info_data[frame_rate][mode].init_data_ptr;
+	ArySize =
+		ov5640_mode_info_data[frame_rate][mode].init_data_size;
+
+	ov5640_data.pix.width =
+		ov5640_mode_info_data[frame_rate][mode].width;
+	ov5640_data.pix.height =
+		ov5640_mode_info_data[frame_rate][mode].height;
+
+	if (ov5640_data.pix.width == 0 || ov5640_data.pix.height == 0 ||
+		pModeSetting == NULL || ArySize == 0)
+		return -EINVAL;
+
+	/* read preview shutter */
+	prev_shutter = ov5640_get_shutter();
+
+	/* read preview gain */
+	prev_gain16 = ov5640_get_gain16();
+
+	/* get average */
+	average = ov5640_read_reg(0x56a1, &temp);
+
+	/* turn off night mode for capture */
+	ov5640_set_night_mode(0);
+
+	/* turn off overlay */
+	ov5640_write_reg(0x3022, 0x06);
+
+	/* Write capture setting */
+	retval = ov5640_download_firmware(pModeSetting, ArySize);
+	if (retval < 0)
+		goto err;
+
+	/* turn off AE AG when capture image. */
+	ov5640_turn_on_AE_AG(0);
+
+	/* read capture VTS */
+	cap_VTS = ov5640_get_VTS();
+	cap_HTS = ov5640_get_HTS();
+	cap_sysclk = ov5640_get_sysclk();
+
+	/* calculate capture banding filter */
+	light_freq = ov5640_get_light_freq();
+	if (light_freq == 60) {
+		/* 60Hz */
+		cap_bandfilt = cap_sysclk * 100 / cap_HTS * 100 / 120;
+	} else {
+		/* 50Hz */
+		cap_bandfilt = cap_sysclk * 100 / cap_HTS;
+	}
+	cap_maxband = (int)((cap_VTS - 4)/cap_bandfilt);
+	/* calculate capture shutter/gain16 */
+	if (average > AE_low && average < AE_high) {
+		/* in stable range */
+		cap_gain16_shutter =
+			prev_gain16 * prev_shutter * cap_sysclk/prev_sysclk *
+			prev_HTS/cap_HTS * AE_Target / average;
+	} else {
+		cap_gain16_shutter =
+			prev_gain16 * prev_shutter * cap_sysclk/prev_sysclk *
+			prev_HTS/cap_HTS;
+	}
+
+	/* gain to shutter */
+	if (cap_gain16_shutter < (cap_bandfilt * 16)) {
+		/* shutter < 1/100 */
+		cap_shutter = cap_gain16_shutter/16;
+		if (cap_shutter < 1)
+			cap_shutter = 1;
+		cap_gain16 = cap_gain16_shutter/cap_shutter;
+		if (cap_gain16 < 16)
+			cap_gain16 = 16;
+	} else {
+		if (cap_gain16_shutter > (cap_bandfilt*cap_maxband*16)) {
+			/* exposure reach max */
+			cap_shutter = cap_bandfilt*cap_maxband;
+			cap_gain16 = cap_gain16_shutter / cap_shutter;
+		} else {
+			/* 1/100 < cap_shutter =< max, cap_shutter = n/100 */
+			cap_shutter =
+				((int)(cap_gain16_shutter/16/cap_bandfilt))
+				* cap_bandfilt;
+			cap_gain16 = cap_gain16_shutter / cap_shutter;
+		}
+	}
+
+	/* write capture gain */
+	ov5640_set_gain16(cap_gain16);
+
+	/* write capture shutter */
+	if (cap_shutter > (cap_VTS - 4)) {
+		cap_VTS = cap_shutter + 4;
+		ov5640_set_VTS(cap_VTS);
+	}
+
+	ov5640_set_shutter(cap_shutter);
+
+	/* skip 2 vysnc: start capture at 3rd vsync
+	 * frame rate of QSXGA and 1080P is 7.5fps: 1/7.5 * 2
+	 */
+	pr_warning("ov5640: the actual frame rate of %s is 7.5fps\n",
+		mode == ov5640_mode_1080P_1920_1080 ? "1080P" : "QSXGA");
+	msleep(267);
+err:
+	return retval;
+}
+
+static int ov5640_change_mode(enum ov5640_frame_rate frame_rate,
+			    enum ov5640_mode mode)
+{
+	int retval = 0;
+
+	if (mode > ov5640_mode_MAX || mode < ov5640_mode_MIN) {
+		pr_err("Wrong ov5640 mode detected!\n");
+		return -1;
+	}
+
+	if (mode == ov5640_mode_1080P_1920_1080 ||
+			mode == ov5640_mode_QSXGA_2592_1944) {
+		/* change to scaling mode go through exposure calucation
+		 * image size above 1280 * 960 is scaling mode */
+		retval = ov5640_change_mode_exposure_calc(frame_rate, mode);
+	} else {
+		/* change back to subsampling modem download firmware directly
+		 * image size below 1280 * 960 is subsampling mode */
+		retval = ov5640_change_mode_direct(frame_rate, mode);
+	}
+
+	return retval;
+}
+
 /* --------------- IOCTL functions from v4l2_int_ioctl_desc --------------- */
 
 static int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)
@@ -1082,12 +1377,14 @@ static int ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
 			return -EINVAL;
 		}
 
+		ret = ov5640_change_mode(frame_rate,
+				a->parm.capture.capturemode);
+		if (ret < 0)
+			return ret;
+
 		sensor->streamcap.timeperframe = *timeperframe;
-		sensor->streamcap.capturemode =
-				(u32)a->parm.capture.capturemode;
+		sensor->streamcap.capturemode = a->parm.capture.capturemode;
 
-		ret = ov5640_init_mode(frame_rate,
-				       sensor->streamcap.capturemode);
 		break;
 
 	/* These are all the possible cases. */
@@ -1329,7 +1626,7 @@ static int ioctl_init(struct v4l2_int_device *s)
 static int ioctl_enum_fmt_cap(struct v4l2_int_device *s,
 			      struct v4l2_fmtdesc *fmt)
 {
-	if (fmt->index > 0)	/* only 1 pixelformat support so far */
+	if (fmt->index > ov5640_mode_MAX)
 		return -EINVAL;
 
 	fmt->pixelformat = ov5640_data.pix.pixelformat;
@@ -1349,6 +1646,7 @@ static int ioctl_dev_init(struct v4l2_int_device *s)
 	u32 tgt_xclk;	/* target xclk */
 	u32 tgt_fps;	/* target frames per secound */
 	enum ov5640_frame_rate frame_rate;
+	int ret;
 
 	ov5640_data.on = true;
 
@@ -1372,8 +1670,8 @@ static int ioctl_dev_init(struct v4l2_int_device *s)
 	else
 		return -EINVAL; /* Only support 15fps or 30fps now. */
 
-	return ov5640_init_mode(frame_rate,
-				sensor->streamcap.capturemode);
+	ret = ov5640_init_mode();
+	return ret;
 }
 
 /*!
@@ -1444,6 +1742,7 @@ static int ov5640_probe(struct i2c_client *client,
 {
 	int retval;
 	struct fsl_mxc_camera_platform_data *plat_data = client->dev.platform_data;
+	u8 chip_id_high, chip_id_low;
 
 	/* Set initial values for the sensor struct. */
 	memset(&ov5640_data, 0, sizeof(ov5640_data));
@@ -1521,13 +1820,45 @@ static int ov5640_probe(struct i2c_client *client,
 	if (plat_data->io_init)
 		plat_data->io_init();
 
+	if (plat_data->pwdn)
+		plat_data->pwdn(0);
+
+#ifdef CONFIG_SOC_IMX6SL
+	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+#endif
+	retval = ov5640_read_reg(OV5640_CHIP_ID_HIGH_BYTE, &chip_id_high);
+	if (retval < 0 || chip_id_high != 0x56) {
+		pr_warning("camera ov5640 is not found\n");
+		retval = -ENODEV;
+		goto err4;
+	}
+	retval = ov5640_read_reg(OV5640_CHIP_ID_LOW_BYTE, &chip_id_low);
+	if (retval < 0 || chip_id_low != 0x40) {
+		pr_warning("camera ov5640 is not found\n");
+		retval = -ENODEV;
+		goto err4;
+	}
+
+	if (plat_data->pwdn)
+		plat_data->pwdn(1);
+
+#ifdef CONFIG_SOC_IMX6SL
+	csi_enable_mclk(CSI_MCLK_I2C, false, false);
+#endif
+
 	camera_plat = plat_data;
 
 	ov5640_int_device.priv = &ov5640_data;
 	retval = v4l2_int_device_register(&ov5640_int_device);
 
+	pr_info("camera ov5640 is found\n");
 	return retval;
 
+err4:
+	if (analog_regulator) {
+		regulator_disable(analog_regulator);
+		regulator_put(analog_regulator);
+	}
 err3:
 	if (core_regulator) {
 		regulator_disable(core_regulator);
@@ -1539,7 +1870,7 @@ err2:
 		regulator_put(io_regulator);
 	}
 err1:
-	return -1;
+	return retval;
 }
 
 /*!
diff --git a/drivers/media/video/mxc/capture/ov5640_mipi.c b/drivers/media/video/mxc/capture/ov5640_mipi.c
index d2b79d2..a373e5b 100644
--- a/drivers/media/video/mxc/capture/ov5640_mipi.c
+++ b/drivers/media/video/mxc/capture/ov5640_mipi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -904,6 +904,7 @@ int OV5640_get_light_freq(void)
 			light_freq = 50;
 		} else {
 			/* 60Hz */
+			light_freq = 60;
 		}
 	}
 	return light_freq;
@@ -1936,13 +1937,13 @@ static int ov5640_probe(struct i2c_client *client,
 
 	retval = ov5640_read_reg(OV5640_CHIP_ID_HIGH_BYTE, &chip_id_high);
 	if (retval < 0 || chip_id_high != 0x56) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5640_mipi is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
 	retval = ov5640_read_reg(OV5640_CHIP_ID_LOW_BYTE, &chip_id_low);
 	if (retval < 0 || chip_id_low != 0x40) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5640_mipi is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
@@ -1955,6 +1956,7 @@ static int ov5640_probe(struct i2c_client *client,
 	ov5640_int_device.priv = &ov5640_data;
 	retval = v4l2_int_device_register(&ov5640_int_device);
 
+	pr_info("camera ov5640_mipi is found\n");
 	return retval;
 
 err4:
diff --git a/drivers/media/video/mxc/capture/ov5642.c b/drivers/media/video/mxc/capture/ov5642.c
index 5653a6b..6cf5af9 100644
--- a/drivers/media/video/mxc/capture/ov5642.c
+++ b/drivers/media/video/mxc/capture/ov5642.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -2999,6 +2999,7 @@ static s32 ov5642_write_reg(u16 reg, u8 val);
 
 static const struct i2c_device_id ov5642_id[] = {
 	{"ov5642", 0},
+	{"ov564x", 0},
 	{},
 };
 
@@ -4060,13 +4061,13 @@ static int ov5642_probe(struct i2c_client *client,
 
 	retval = ov5642_read_reg(OV5642_CHIP_ID_HIGH_BYTE, &chip_id_high);
 	if (retval < 0 || chip_id_high != 0x56) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5642 is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
 	retval = ov5642_read_reg(OV5642_CHIP_ID_LOW_BYTE, &chip_id_low);
 	if (retval < 0 || chip_id_low != 0x42) {
-		pr_err("%s:cannot find camera\n", __func__);
+		pr_warning("camera ov5642 is not found\n");
 		retval = -ENODEV;
 		goto err4;
 	}
@@ -4079,6 +4080,7 @@ static int ov5642_probe(struct i2c_client *client,
 	ov5642_int_device.priv = &ov5642_data;
 	retval = v4l2_int_device_register(&ov5642_int_device);
 
+	pr_info("camera ov5642 is found\n");
 	return retval;
 
 err4:
diff --git a/drivers/media/video/mxc/output/mxc_vout.c b/drivers/media/video/mxc/output/mxc_vout.c
index ec789ec..452c573 100644
--- a/drivers/media/video/mxc/output/mxc_vout.c
+++ b/drivers/media/video/mxc/output/mxc_vout.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,8 +30,8 @@
 
 #define UYVY_BLACK	(0x00800080)
 #define RGB_BLACK	(0x0)
-#define NV12_UV_BLACK	(0x80)
-#define NV12_Y_BLACK	(0x0)
+#define UV_BLACK	(0x80)
+#define Y_BLACK		(0x0)
 
 #define MAX_FB_NUM	6
 #define FB_BUFS		3
@@ -58,6 +58,16 @@
 	       ((vout)->task.input.crop.w == FRAME_WIDTH_1080P) &&	\
 	       ((vout)->task.input.height == FRAME_HEIGHT_1080P) &&	\
 	       ((vout)->task.input.crop.h == FRAME_HEIGHT_1080P))
+#define IS_PLANAR_PIXEL_FORMAT(format) \
+	(format == IPU_PIX_FMT_NV12 ||		\
+	    format == IPU_PIX_FMT_YUV420P2 ||	\
+	    format == IPU_PIX_FMT_YUV420P ||	\
+	    format == IPU_PIX_FMT_YVU420P ||	\
+	    format == IPU_PIX_FMT_YUV422P ||	\
+	    format == IPU_PIX_FMT_YVU422P ||	\
+	    format == IPU_PIX_FMT_YUV444P)
+
+#define NSEC_PER_FRAME_30FPS		(33333333)
 
 struct mxc_vout_fb {
 	char *name;
@@ -108,11 +118,12 @@ struct mxc_vout_output {
 	struct dma_mem vdoa_output[VDOA_FB_BUFS];
 
 	bool timer_stop;
-	struct timer_list timer;
+	struct hrtimer timer;
 	struct workqueue_struct *v4l_wq;
 	struct work_struct disp_work;
 	unsigned long frame_count;
-	unsigned long start_jiffies;
+	unsigned long vdi_frame_cnt;
+	ktime_t start_ktime;
 
 	int ctrl_rotate;
 	int ctrl_vflip;
@@ -120,7 +131,8 @@ struct mxc_vout_output {
 
 	dma_addr_t disp_bufs[FB_BUFS];
 
-	struct videobuf_buffer *pre_vb;
+	struct videobuf_buffer *pre1_vb;
+	struct videobuf_buffer *pre2_vb;
 };
 
 struct mxc_vout_dev {
@@ -135,6 +147,7 @@ struct mxc_vout_dev {
 
 /* Variables configurable through module params*/
 static int debug;
+static int vdi_rate_double;
 static int video_nr = 16;
 
 /* Module parameters */
@@ -142,8 +155,10 @@ module_param(video_nr, int, S_IRUGO);
 MODULE_PARM_DESC(video_nr, "video device numbers");
 module_param(debug, int, 0600);
 MODULE_PARM_DESC(debug, "Debug level (0-1)");
+module_param(vdi_rate_double, int, 0600);
+MODULE_PARM_DESC(vdi_rate_double, "vdi frame rate double on/off");
 
-const static struct v4l2_fmtdesc mxc_formats[] = {
+static const struct v4l2_fmtdesc mxc_formats[] = {
 	{
 		.description = "RGB565",
 		.pixelformat = V4L2_PIX_FMT_RGB565,
@@ -211,7 +226,8 @@ const static struct v4l2_fmtdesc mxc_formats[] = {
 #define DEF_INPUT_WIDTH		320
 #define DEF_INPUT_HEIGHT	240
 
-static int mxc_vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i);
+static int mxc_vidioc_streamoff(struct file *file, void *fh,
+					enum v4l2_buf_type i);
 
 static struct mxc_vout_fb g_fb_setting[MAX_FB_NUM];
 static int config_disp_output(struct mxc_vout_output *vout);
@@ -345,7 +361,8 @@ static int update_setting_from_fbi(struct mxc_vout_output *vout,
 			if (!strcmp(fbi->fix.id, g_fb_setting[i].name)) {
 				vout->crop_bounds = g_fb_setting[i].crop_bounds;
 				vout->disp_fmt = g_fb_setting[i].disp_fmt;
-				vout->disp_support_csc = g_fb_setting[i].disp_support_csc;
+				vout->disp_support_csc =
+					g_fb_setting[i].disp_support_csc;
 				vout->disp_support_windows =
 					g_fb_setting[i].disp_support_windows;
 				found = true;
@@ -414,6 +431,48 @@ static bool deinterlace_3_field(struct mxc_vout_output *vout)
 		(vout->task.input.deinterlace.motion != HIGH_MOTION));
 }
 
+static int set_field_fmt(struct mxc_vout_output *vout, enum v4l2_field field)
+{
+	struct ipu_deinterlace *deinterlace = &vout->task.input.deinterlace;
+
+	switch (field) {
+	/* Images are in progressive format, not interlaced */
+	case V4L2_FIELD_NONE:
+	case V4L2_FIELD_ANY:
+		deinterlace->enable = false;
+		deinterlace->field_fmt = 0;
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "Progressive frame.\n");
+		break;
+	case V4L2_FIELD_INTERLACED_TB:
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"Enable deinterlace TB.\n");
+		deinterlace->enable = true;
+		deinterlace->field_fmt = IPU_DEINTERLACE_FIELD_TOP;
+		break;
+	case V4L2_FIELD_INTERLACED_BT:
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"Enable deinterlace BT.\n");
+		deinterlace->enable = true;
+		deinterlace->field_fmt = IPU_DEINTERLACE_FIELD_BOTTOM;
+		break;
+	default:
+		v4l2_err(vout->vfd->v4l2_dev,
+			"field format:%d not supported yet!\n", field);
+		return -EINVAL;
+	}
+
+	if (IPU_PIX_FMT_TILED_NV12F == vout->task.input.format) {
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+				"tiled fmt enable deinterlace.\n");
+		deinterlace->enable = true;
+	}
+
+	if (deinterlace->enable && vdi_rate_double)
+		deinterlace->field_fmt |= IPU_DEINTERLACE_RATE_EN;
+
+	return 0;
+}
+
 static bool is_pp_bypass(struct mxc_vout_output *vout)
 {
 	if ((IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
@@ -429,11 +488,15 @@ static bool is_pp_bypass(struct mxc_vout_output *vout)
 			return true;
 		else if (!need_csc(vout->task.input.format, vout->disp_fmt))
 			return true;
-	/* input crop show to full output which can show based on xres_virtual/yres_virtual */
+	/*
+	 * input crop show to full output which can show based on
+	 * xres_virtual/yres_virtual
+	 */
 	} else if ((vout->task.input.crop.w == vout->task.output.crop.w) &&
 			(vout->task.output.crop.w == vout->task.output.width) &&
 			(vout->task.input.crop.h == vout->task.output.crop.h) &&
-			(vout->task.output.crop.h == vout->task.output.height) &&
+			(vout->task.output.crop.h ==
+				vout->task.output.height) &&
 			(vout->task.output.rotate < IPU_ROTATE_HORIZ_FLIP) &&
 			!vout->task.input.deinterlace.enable) {
 		if (vout->disp_support_csc)
@@ -447,29 +510,26 @@ static bool is_pp_bypass(struct mxc_vout_output *vout)
 static void setup_buf_timer(struct mxc_vout_output *vout,
 			struct videobuf_buffer *vb)
 {
-	unsigned long timeout;
+	ktime_t expiry_time, now;
 
 	/* if timestamp is 0, then default to 30fps */
-	if ((vb->ts.tv_sec == 0)
-			&& (vb->ts.tv_usec == 0)
-			&& vout->start_jiffies)
-		timeout =
-			vout->start_jiffies + vout->frame_count * HZ / 30;
+	if ((vb->ts.tv_sec == 0) && (vb->ts.tv_usec == 0))
+		expiry_time = ktime_add_ns(vout->start_ktime,
+				NSEC_PER_FRAME_30FPS * vout->frame_count);
 	else
-		timeout = get_jiffies(&vb->ts);
+		expiry_time = timeval_to_ktime(vb->ts);
 
-	if (jiffies >= timeout) {
+	now = hrtimer_cb_get_time(&vout->timer);
+	if ((now.tv64 > expiry_time.tv64)) {
 		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
 				"warning: timer timeout already expired.\n");
+		expiry_time = now;
 	}
 
-	if (mod_timer(&vout->timer, timeout)) {
-		v4l2_warn(vout->vfd->v4l2_dev,
-				"warning: timer was already set\n");
-	}
+	hrtimer_start(&vout->timer, expiry_time, HRTIMER_MODE_ABS);
 
-	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
-			"timer handler next schedule: %lu\n", timeout);
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "timer handler next "
+		"schedule: %lldnsecs\n", expiry_time.tv64);
 }
 
 static int show_buf(struct mxc_vout_output *vout, int idx,
@@ -493,12 +553,14 @@ static int show_buf(struct mxc_vout_output *vout, int idx,
 		fbi->var.yoffset = ipos->y + 1;
 		var.xoffset = ipos->x;
 		var.yoffset = ipos->y;
+		var.vmode |= FB_VMODE_YWRAP;
 		ret = fb_pan_display(fbi, &var);
 		fbi->fix.smem_start = fb_base;
 		console_unlock();
 	} else {
 		console_lock();
 		var.yoffset = idx * fbi->var.yres;
+		var.vmode &= ~FB_VMODE_YWRAP;
 		ret = fb_pan_display(fbi, &var);
 		console_unlock();
 	}
@@ -516,6 +578,9 @@ static void disp_work_func(struct work_struct *work)
 	struct ipu_pos ipos;
 	int ret = 0;
 	u32 in_fmt = 0;
+	u32 vdi_cnt = 0;
+	u32 vdi_frame;
+	u32 index = 0;
 	u32 ocrop_h = 0;
 	u32 o_height = 0;
 	u32 tiled_interlaced = 0;
@@ -525,37 +590,67 @@ static void disp_work_func(struct work_struct *work)
 
 	spin_lock_irqsave(q->irqlock, flags);
 
-	if (deinterlace_3_field(vout)) {
-		if (list_is_singular(&vout->active_list)) {
-			v4l2_warn(vout->vfd->v4l2_dev,
-					"deinterlacing: no enough entry in active_list\n");
-			spin_unlock_irqrestore(q->irqlock, flags);
-			return;
-		}
-	} else {
-		if (list_empty(&vout->active_list)) {
-			v4l2_warn(vout->vfd->v4l2_dev,
-					"no entry in active_list, should not be here\n");
-			spin_unlock_irqrestore(q->irqlock, flags);
-			return;
-		}
+	if (list_empty(&vout->active_list)) {
+		v4l2_warn(vout->vfd->v4l2_dev,
+			"no entry in active_list, should not be here\n");
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return;
 	}
+
 	vb = list_first_entry(&vout->active_list,
 			struct videobuf_buffer, queue);
+	ret = set_field_fmt(vout, vb->field);
+	if (ret < 0) {
+		spin_unlock_irqrestore(q->irqlock, flags);
+		return;
+	}
+	if (deinterlace_3_field(vout)) {
+		if (list_is_singular(&vout->active_list)) {
+			if (list_empty(&vout->queue_list)) {
+				vout->timer_stop = true;
+				spin_unlock_irqrestore(q->irqlock, flags);
+				v4l2_warn(vout->vfd->v4l2_dev,
+					"no enough entry for 3 fields "
+					"deinterlacer\n");
+				return;
+			}
 
-	if (deinterlace_3_field(vout))
-		vb_next = list_first_entry(vout->active_list.next,
-				struct videobuf_buffer, queue);
+			/*
+			 * We need to use the next vb even if it is
+			 * not on the active list.
+			 */
+			vb_next = list_first_entry(&vout->queue_list,
+					struct videobuf_buffer, queue);
+		} else
+			vb_next = list_first_entry(vout->active_list.next,
+						struct videobuf_buffer, queue);
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"cur field_fmt:%d, next field_fmt:%d.\n",
+			vb->field, vb_next->field);
+		/* repeat the last field during field format changing */
+		if ((vb->field != vb_next->field) &&
+			(vb_next->field != V4L2_FIELD_NONE))
+			vb_next = vb;
+	}
 
 	spin_unlock_irqrestore(q->irqlock, flags);
 
+vdi_frame_rate_double:
 	mutex_lock(&vout->task_lock);
 
+	v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+		"v4l2 frame_cnt:%ld, vb_field:%d, fmt:%d\n",
+		vout->frame_count, vb->field,
+		vout->task.input.deinterlace.field_fmt);
 	if (vb->memory == V4L2_MEMORY_USERPTR)
 		vout->task.input.paddr = vb->baddr;
 	else
 		vout->task.input.paddr = videobuf_to_dma_contig(vb);
 
+	if (vout->task.input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN)
+		index = vout->vdi_frame_cnt % FB_BUFS;
+	else
+		index = vout->frame_count % FB_BUFS;
 	if (vout->linear_bypass_pp) {
 		vout->task.output.paddr = vout->task.input.paddr;
 		ipos.x = vout->task.input.crop.pos.x;
@@ -568,15 +663,15 @@ static void disp_work_func(struct work_struct *work)
 				vout->task.input.paddr_n =
 					videobuf_to_dma_contig(vb_next);
 		}
-		vout->task.output.paddr =
-			vout->disp_bufs[vout->frame_count % FB_BUFS];
+		vout->task.output.paddr = vout->disp_bufs[index];
 		if (vout->vdoa_1080p) {
 			o_height =  vout->task.output.height;
 			ocrop_h = vout->task.output.crop.h;
 			vout->task.output.height = FRAME_HEIGHT_1080P;
 			vout->task.output.crop.h = FRAME_HEIGHT_1080P;
 		}
-		tiled_fmt = (IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
+		tiled_fmt =
+			(IPU_PIX_FMT_TILED_NV12 == vout->task.input.format) ||
 			(IPU_PIX_FMT_TILED_NV12F == vout->task.input.format);
 		if (vout->tiled_bypass_pp) {
 			ipos.x = vout->task.input.crop.pos.x;
@@ -619,30 +714,52 @@ static void disp_work_func(struct work_struct *work)
 
 	mutex_unlock(&vout->task_lock);
 
-	ret = show_buf(vout, vout->frame_count % FB_BUFS, &ipos);
+	ret = show_buf(vout, index, &ipos);
 	if (ret < 0)
-		v4l2_dbg(1, debug, vout->vfd->v4l2_dev, "show buf with ret %d\n", ret);
-
+		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
+			"show buf with ret %d\n", ret);
+
+	if (vout->task.input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN) {
+		vdi_frame = vout->task.input.deinterlace.field_fmt
+				& IPU_DEINTERLACE_RATE_FRAME1;
+		if (vdi_frame)
+			vout->task.input.deinterlace.field_fmt &=
+			~IPU_DEINTERLACE_RATE_FRAME1;
+		else
+			vout->task.input.deinterlace.field_fmt |=
+			IPU_DEINTERLACE_RATE_FRAME1;
+		vout->vdi_frame_cnt++;
+		vdi_cnt++;
+		if (vdi_cnt < IPU_DEINTERLACE_MAX_FRAME)
+			goto vdi_frame_rate_double;
+	}
 	spin_lock_irqsave(q->irqlock, flags);
 
 	list_del(&vb->queue);
 
 	/*
-	 * previous videobuf finish show, set VIDEOBUF_DONE state here
-	 * to avoid tearing issue in pp bypass case, which make sure
-	 * showing buffer will not be dequeue to write new data. It also
-	 * bring side-effect that the last buffer can not be dequeue
-	 * correctly, app need take care about it.
+	 * The videobuf before the last one has been shown. Set
+	 * VIDEOBUF_DONE state here to avoid tearing issue in ic bypass
+	 * case, which makes sure a buffer being shown will not be
+	 * dequeued to be overwritten. It also brings side-effect that
+	 * the last 2 buffers can not be dequeued correctly, apps need
+	 * to take care of it.
 	 */
-	if (vout->pre_vb) {
-		vout->pre_vb->state = VIDEOBUF_DONE;
-		wake_up_interruptible(&vout->pre_vb->done);
+	if (vout->pre2_vb) {
+		vout->pre2_vb->state = VIDEOBUF_DONE;
+		wake_up_interruptible(&vout->pre2_vb->done);
+		vout->pre2_vb = NULL;
 	}
 
-	if (vout->linear_bypass_pp)
-		vout->pre_vb = vb;
-	else {
-		vout->pre_vb = NULL;
+	if (vout->linear_bypass_pp) {
+		vout->pre2_vb = vout->pre1_vb;
+		vout->pre1_vb = vb;
+	} else {
+		if (vout->pre1_vb) {
+			vout->pre1_vb->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->pre1_vb->done);
+			vout->pre1_vb = NULL;
+		}
 		vb->state = VIDEOBUF_DONE;
 		wake_up_interruptible(&vb->done);
 	}
@@ -670,10 +787,11 @@ err:
 	return;
 }
 
-static void mxc_vout_timer_handler(unsigned long arg)
+static enum hrtimer_restart mxc_vout_timer_handler(struct hrtimer *timer)
 {
-	struct mxc_vout_output *vout =
-			(struct mxc_vout_output *) arg;
+	struct mxc_vout_output *vout = container_of(timer,
+						    struct mxc_vout_output,
+						    timer);
 	struct videobuf_queue *q = &vout->vbq;
 	struct videobuf_buffer *vb;
 	unsigned long flags = 0;
@@ -686,7 +804,7 @@ static void mxc_vout_timer_handler(unsigned long arg)
 	 */
 	if (list_empty(&vout->queue_list)) {
 		spin_unlock_irqrestore(q->irqlock, flags);
-		return;
+		return HRTIMER_NORESTART;
 	}
 
 	/* move videobuf from queued list to active list */
@@ -697,16 +815,18 @@ static void mxc_vout_timer_handler(unsigned long arg)
 
 	if (queue_work(vout->v4l_wq, &vout->disp_work) == 0) {
 		v4l2_warn(vout->vfd->v4l2_dev,
-			"disp work was in queue already, queue buf again next time\n");
+		"disp work was in queue already, queue buf again next time\n");
 		list_del(&vb->queue);
 		list_add(&vb->queue, &vout->queue_list);
 		spin_unlock_irqrestore(q->irqlock, flags);
-		return;
+		return HRTIMER_NORESTART;
 	}
 
 	vb->state = VIDEOBUF_ACTIVE;
 
 	spin_unlock_irqrestore(q->irqlock, flags);
+
+	return HRTIMER_NORESTART;
 }
 
 /* Video buffer call backs */
@@ -759,21 +879,21 @@ static void mxc_vout_buffer_queue(struct videobuf_queue *q,
 			  struct videobuf_buffer *vb)
 {
 	struct mxc_vout_output *vout = q->priv_data;
+	struct videobuf_buffer *active_vb;
 
 	list_add_tail(&vb->queue, &vout->queue_list);
 	vb->state = VIDEOBUF_QUEUED;
 
 	if (vout->timer_stop) {
 		if (deinterlace_3_field(vout) &&
-			list_empty(&vout->active_list)) {
-			vb = list_first_entry(&vout->queue_list,
+			!list_empty(&vout->active_list)) {
+			active_vb = list_first_entry(&vout->active_list,
 					struct videobuf_buffer, queue);
-			list_del(&vb->queue);
-			list_add_tail(&vb->queue, &vout->active_list);
+			setup_buf_timer(vout, active_vb);
 		} else {
 			setup_buf_timer(vout, vb);
-			vout->timer_stop = false;
 		}
+		vout->timer_stop = false;
 	}
 }
 
@@ -862,6 +982,7 @@ static int mxc_vout_open(struct file *file)
 
 		vout->fmt_init = false;
 		vout->frame_count = 0;
+		vout->vdi_frame_cnt = 0;
 
 		vout->win_pos.x = 0;
 		vout->win_pos.y = 0;
@@ -951,7 +1072,8 @@ again:
 			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER) {
 				if (vout->disp_support_windows) {
 					task->output.width -= 8;
-					task->output.crop.w = task->output.width;
+					task->output.crop.w =
+						task->output.width;
 				} else
 					task->output.crop.w -= 8;
 				goto again;
@@ -959,7 +1081,8 @@ again:
 			if (ret == IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER) {
 				if (vout->disp_support_windows) {
 					task->output.height -= 8;
-					task->output.crop.h = task->output.height;
+					task->output.crop.h =
+						task->output.height;
 				} else
 					task->output.crop.h -= 8;
 				goto again;
@@ -1131,7 +1254,8 @@ static int mxc_vout_try_task(struct mxc_vout_output *vout)
 	return ret;
 }
 
-static int mxc_vout_try_format(struct mxc_vout_output *vout, struct v4l2_format *f)
+static int mxc_vout_try_format(struct mxc_vout_output *vout,
+				struct v4l2_format *f)
 {
 	int ret = 0;
 	struct v4l2_rect rect;
@@ -1151,38 +1275,9 @@ static int mxc_vout_try_format(struct mxc_vout_output *vout, struct v4l2_format
 	vout->task.input.height = f->fmt.pix.height;
 	vout->task.input.format = f->fmt.pix.pixelformat;
 
-	if (IPU_PIX_FMT_TILED_NV12F == vout->task.input.format) {
-		v4l2_dbg(1, debug, vout->vfd->v4l2_dev,
-				"tiled fmt enable deinterlace.\n");
-		vout->task.input.deinterlace.enable = true;
-		vout->task.input.deinterlace.field_fmt =
-				IPU_DEINTERLACE_FIELD_TOP;
-	}
-	switch (f->fmt.pix.field) {
-	/* Images are in progressive format, not interlaced */
-	case V4L2_FIELD_NONE:
-		break;
-	/* The two fields of a frame are passed in separate buffers,
-	   in temporal order, i. e. the older one first. */
-	case V4L2_FIELD_ALTERNATE:
-		v4l2_err(vout->vfd->v4l2_dev,
-			"V4L2_FIELD_ALTERNATE field format not supported yet!\n");
-		break;
-	case V4L2_FIELD_INTERLACED_TB:
-		v4l2_info(vout->vfd->v4l2_dev, "Enable deinterlace TB.\n");
-		vout->task.input.deinterlace.enable = true;
-		vout->task.input.deinterlace.field_fmt =
-				IPU_DEINTERLACE_FIELD_TOP;
-		break;
-	case V4L2_FIELD_INTERLACED_BT:
-		v4l2_info(vout->vfd->v4l2_dev, "Enable deinterlace BT.\n");
-		vout->task.input.deinterlace.enable = true;
-		vout->task.input.deinterlace.field_fmt =
-				IPU_DEINTERLACE_FIELD_BOTTOM;
-		break;
-	default:
-		break;
-	}
+	ret = set_field_fmt(vout, f->fmt.pix.field);
+	if (ret < 0)
+		return ret;
 
 	if (f->fmt.pix.priv) {
 		vout->task.input.crop.pos.x = rect.left;
@@ -1246,7 +1341,8 @@ static int mxc_vidioc_cropcap(struct file *file, void *fh,
 	return 0;
 }
 
-static int mxc_vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *crop)
+static int mxc_vidioc_g_crop(struct file *file, void *fh,
+				struct v4l2_crop *crop)
 {
 	struct mxc_vout_output *vout = fh;
 
@@ -1275,7 +1371,8 @@ static int mxc_vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *crop
 	return 0;
 }
 
-static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop)
+static int mxc_vidioc_s_crop(struct file *file, void *fh,
+				struct v4l2_crop *crop)
 {
 	struct mxc_vout_output *vout = fh;
 	struct v4l2_rect *b = &vout->crop_bounds;
@@ -1311,6 +1408,14 @@ static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop
 	/* stride line limitation */
 	crop->c.height -= crop->c.height % 8;
 	crop->c.width -= crop->c.width % 8;
+	if ((crop->c.width <= 0) || (crop->c.height <= 0) ||
+		((crop->c.left + crop->c.width) > (b->left + b->width)) ||
+		((crop->c.top + crop->c.height) > (b->top + b->height))) {
+		v4l2_err(vout->vfd->v4l2_dev, "s_crop err: %d, %d, %d, %d",
+			crop->c.left, crop->c.top,
+			crop->c.width, crop->c.height);
+		return -EINVAL;
+	}
 
 	/* the same setting, return */
 	if (vout->disp_support_windows) {
@@ -1329,7 +1434,7 @@ static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop
 
 	/* wait current work finish */
 	if (vout->vbq.streaming)
-		cancel_work_sync(&vout->disp_work);
+		flush_workqueue(vout->v4l_wq);
 
 	mutex_lock(&vout->task_lock);
 
@@ -1369,7 +1474,7 @@ static int mxc_vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop
 			ret = config_disp_output(vout);
 			if (ret < 0) {
 				v4l2_err(vout->vfd->v4l2_dev,
-						"Config display output failed\n");
+					"Config display output failed\n");
 				goto done;
 			}
 		}
@@ -1406,7 +1511,8 @@ static int mxc_vidioc_queryctrl(struct file *file, void *fh,
 	return ret;
 }
 
-static int mxc_vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)
+static int mxc_vidioc_g_ctrl(struct file *file, void *fh,
+				struct v4l2_control *ctrl)
 {
 	int ret = 0;
 	struct mxc_vout_output *vout = fh;
@@ -1474,14 +1580,15 @@ static void setup_task_rotation(struct mxc_vout_output *vout)
 	}
 }
 
-static int mxc_vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)
+static int mxc_vidioc_s_ctrl(struct file *file, void *fh,
+				struct v4l2_control *ctrl)
 {
 	int ret = 0;
 	struct mxc_vout_output *vout = fh;
 
 	/* wait current work finish */
 	if (vout->vbq.streaming)
-		cancel_work_sync(&vout->disp_work);
+		flush_workqueue(vout->v4l_wq);
 
 	mutex_lock(&vout->task_lock);
 	switch (ctrl->id) {
@@ -1531,7 +1638,7 @@ static int mxc_vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *c
 			ret = config_disp_output(vout);
 			if (ret < 0) {
 				v4l2_err(vout->vfd->v4l2_dev,
-						"Config display output failed\n");
+					"Config display output failed\n");
 				goto done;
 			}
 		}
@@ -1600,7 +1707,8 @@ static int mxc_vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
 		return videobuf_dqbuf(&vout->vbq, (struct v4l2_buffer *)b, 0);
 }
 
-static int set_window_position(struct mxc_vout_output *vout, struct mxcfb_pos *pos)
+static int set_window_position(struct mxc_vout_output *vout,
+				struct mxcfb_pos *pos)
 {
 	struct fb_info *fbi = vout->fbi;
 	mm_segment_t old_fs;
@@ -1680,7 +1788,10 @@ static int config_disp_output(struct mxc_vout_output *vout)
 				"ERR:%s fb_set_var ret:%d\n", __func__, ret);
 		return ret;
 	}
-	display_buf_size = fbi->fix.line_length * fbi->var.yres;
+	if (vout->linear_bypass_pp || vout->tiled_bypass_pp)
+		display_buf_size = fbi->fix.line_length * fbi->var.yres_virtual;
+	else
+		display_buf_size = fbi->fix.line_length * fbi->var.yres;
 	for (i = 0; i < fb_num; i++)
 		vout->disp_bufs[i] = fbi->fix.smem_start + i * display_buf_size;
 	if (vout->tiled_bypass_pp) {
@@ -1713,11 +1824,11 @@ static int config_disp_output(struct mxc_vout_output *vout)
 	/* fill black when video config changed */
 	color = colorspaceofpixel(vout->task.output.format) == YUV_CS ?
 			UYVY_BLACK : RGB_BLACK;
-	if (vout->task.output.format == IPU_PIX_FMT_NV12) {
+	if (IS_PLANAR_PIXEL_FORMAT(vout->task.output.format)) {
 		size = display_buf_size * 8 /
 			fmt_to_bpp(vout->task.output.format);
-		memset(fbi->screen_base, NV12_Y_BLACK, size);
-		memset(fbi->screen_base + size, NV12_UV_BLACK,
+		memset(fbi->screen_base, Y_BLACK, size);
+		memset(fbi->screen_base + size, UV_BLACK,
 				display_buf_size - size);
 	} else {
 		pixel = (u32 *)fbi->screen_base;
@@ -1741,6 +1852,22 @@ err:
 	return ret;
 }
 
+static inline void wait_for_vsync(struct mxc_vout_output *vout)
+{
+	struct fb_info *fbi = vout->fbi;
+	mm_segment_t old_fs;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi, MXCFB_WAIT_FOR_VSYNC,
+				(unsigned long)NULL);
+		set_fs(old_fs);
+	}
+
+	return;
+}
+
 static void release_disp_output(struct mxc_vout_output *vout)
 {
 	struct fb_info *fbi = vout->fbi;
@@ -1772,7 +1899,8 @@ static void release_disp_output(struct mxc_vout_output *vout)
 	vout->release = true;
 }
 
-static int mxc_vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
+static int mxc_vidioc_streamon(struct file *file, void *fh,
+				enum v4l2_buf_type i)
 {
 	struct mxc_vout_output *vout = fh;
 	struct videobuf_queue *q = &vout->vbq;
@@ -1787,7 +1915,7 @@ static int mxc_vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i
 
 	if (deinterlace_3_field(vout) && list_is_singular(&q->stream)) {
 		v4l2_err(vout->vfd->v4l2_dev,
-				"deinterlacing: need queue 2 frame before streamon\n");
+			"deinterlacing: need queue 2 frame before streamon\n");
 		ret = -EINVAL;
 		goto done;
 	}
@@ -1799,31 +1927,39 @@ static int mxc_vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i
 		goto done;
 	}
 
-	init_timer(&vout->timer);
+	hrtimer_init(&vout->timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);
 	vout->timer.function = mxc_vout_timer_handler;
-	vout->timer.data = (unsigned long)vout;
 	vout->timer_stop = true;
 
-	vout->start_jiffies = jiffies;
+	vout->start_ktime = hrtimer_cb_get_time(&vout->timer);
 
-	vout->pre_vb = NULL;
+	vout->pre1_vb = NULL;
+	vout->pre2_vb = NULL;
 
 	ret = videobuf_streamon(q);
 done:
 	return ret;
 }
 
-static int mxc_vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
+static int mxc_vidioc_streamoff(struct file *file, void *fh,
+				enum v4l2_buf_type i)
 {
 	struct mxc_vout_output *vout = fh;
 	struct videobuf_queue *q = &vout->vbq;
 	int ret = 0;
 
 	if (q->streaming) {
-		cancel_work_sync(&vout->disp_work);
 		flush_workqueue(vout->v4l_wq);
 
-		del_timer_sync(&vout->timer);
+		hrtimer_cancel(&vout->timer);
+
+		/*
+		 * Wait for 2 vsyncs to make sure
+		 * frames are drained on triple
+		 * buffer.
+		 */
+		wait_for_vsync(vout);
+		wait_for_vsync(vout);
 
 		release_disp_output(vout);
 
@@ -1836,16 +1972,16 @@ static int mxc_vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type
 }
 
 static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
-	.vidioc_querycap      			= mxc_vidioc_querycap,
-	.vidioc_enum_fmt_vid_out 		= mxc_vidioc_enum_fmt_vid_out,
+	.vidioc_querycap			= mxc_vidioc_querycap,
+	.vidioc_enum_fmt_vid_out		= mxc_vidioc_enum_fmt_vid_out,
 	.vidioc_g_fmt_vid_out			= mxc_vidioc_g_fmt_vid_out,
 	.vidioc_s_fmt_vid_out			= mxc_vidioc_s_fmt_vid_out,
 	.vidioc_cropcap				= mxc_vidioc_cropcap,
 	.vidioc_g_crop				= mxc_vidioc_g_crop,
 	.vidioc_s_crop				= mxc_vidioc_s_crop,
-	.vidioc_queryctrl    			= mxc_vidioc_queryctrl,
-	.vidioc_g_ctrl       			= mxc_vidioc_g_ctrl,
-	.vidioc_s_ctrl       			= mxc_vidioc_s_ctrl,
+	.vidioc_queryctrl			= mxc_vidioc_queryctrl,
+	.vidioc_g_ctrl				= mxc_vidioc_g_ctrl,
+	.vidioc_s_ctrl				= mxc_vidioc_s_ctrl,
 	.vidioc_reqbufs				= mxc_vidioc_reqbufs,
 	.vidioc_querybuf			= mxc_vidioc_querybuf,
 	.vidioc_qbuf				= mxc_vidioc_qbuf,
@@ -1855,17 +1991,17 @@ static const struct v4l2_ioctl_ops mxc_vout_ioctl_ops = {
 };
 
 static const struct v4l2_file_operations mxc_vout_fops = {
-	.owner 		= THIS_MODULE,
+	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= video_ioctl2,
-	.mmap 		= mxc_vout_mmap,
-	.open 		= mxc_vout_open,
-	.release 	= mxc_vout_release,
+	.mmap		= mxc_vout_mmap,
+	.open		= mxc_vout_open,
+	.release	= mxc_vout_release,
 };
 
 static struct video_device mxc_vout_template = {
-	.name 		= "MXC Video Output",
+	.name		= "MXC Video Output",
 	.fops           = &mxc_vout_fops,
-	.ioctl_ops 	= &mxc_vout_ioctl_ops,
+	.ioctl_ops	= &mxc_vout_ioctl_ops,
 	.release	= video_device_release,
 };
 
@@ -1975,9 +2111,13 @@ static int mxc_vout_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	dev->dev = &pdev->dev;
-	dev->dev->dma_mask = kmalloc(sizeof(*dev->dev->dma_mask), GFP_KERNEL);
-	*dev->dev->dma_mask = DMA_BIT_MASK(32);
-	dev->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	if (!dev->dev->dma_mask) {
+		dev->dev->dma_mask = kmalloc(sizeof(*dev->dev->dma_mask),
+					     GFP_KERNEL);
+		if (dev->dev->dma_mask)
+			*dev->dev->dma_mask = DMA_BIT_MASK(32);
+		dev->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	}
 
 	ret = v4l2_device_register(dev->dev, &dev->v4l2_dev);
 	if (ret) {
diff --git a/drivers/media/video/videobuf-dma-contig.c b/drivers/media/video/videobuf-dma-contig.c
index af7ff78..92cf704 100644
--- a/drivers/media/video/videobuf-dma-contig.c
+++ b/drivers/media/video/videobuf-dma-contig.c
@@ -284,7 +284,8 @@ static int __videobuf_mmap_mapper(struct videobuf_queue *q,
 
 	mem->size = PAGE_ALIGN(buf->bsize);
 	mem->vaddr = dma_alloc_coherent(q->dev, mem->size,
-					&mem->dma_handle, GFP_DMA);
+					&mem->dma_handle,
+					GFP_DMA | GFP_KERNEL);
 	if (!mem->vaddr) {
 		dev_err(q->dev, "dma_alloc_coherent size %ld failed\n",
 			mem->size);
diff --git a/drivers/mfd/wm831x-i2c.c b/drivers/mfd/wm831x-i2c.c
old mode 100644
new mode 100755
index a06cbc7..7a4f998
--- a/drivers/mfd/wm831x-i2c.c
+++ b/drivers/mfd/wm831x-i2c.c
@@ -53,23 +53,21 @@ static int wm831x_i2c_write_device(struct wm831x *wm831x, unsigned short reg,
 	struct i2c_client *i2c = wm831x->control_data;
 	struct i2c_msg xfer[2];
 	int ret;
+    char buf_to_write[4];
 
 	reg = cpu_to_be16(reg);
+    memcpy( buf_to_write, &reg, 2);
+    memcpy( buf_to_write + 2, src, 2);
 
 	xfer[0].addr = i2c->addr;
 	xfer[0].flags = 0;
-	xfer[0].len = 2;
-	xfer[0].buf = (char *)&reg;
+	xfer[0].len = 4;
+	xfer[0].buf = buf_to_write;
 
-	xfer[1].addr = i2c->addr;
-	xfer[1].flags = I2C_M_NOSTART;
-	xfer[1].len = bytes;
-	xfer[1].buf = (char *)src;
-
-	ret = i2c_transfer(i2c->adapter, xfer, 2);
+	ret = i2c_transfer(i2c->adapter, xfer, 1);
 	if (ret < 0)
 		return ret;
-	if (ret != 2)
+	if (ret != 1)
 		return -EIO;
 
 	return 0;
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index ce5e63c..2bd67d5 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -496,7 +496,7 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	int err, busy = 0;
-	u32 part, new_part;
+	u32 part;
 	u8 *ext_csd, boot_config;
 	struct mmc_command cmd;
 	struct mmc_card *card = container_of(dev, struct mmc_card, dev);
@@ -514,12 +514,28 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 
 	/* it's a normal SD/MMC but user request to configure boot partition */
 	if (card->ext_csd.boot_size <= 0) {
-		printk(KERN_ERR "%s: this is a normal SD/MMC card"
-			" but you request to access boot partition!\n",
+		pr_err("%s: fail to send SWITCH command to card " \
+				"to update boot_config of the EXT_CSD!\n",
 			mmc_hostname(card->host));
 		return -EINVAL;
 	}
 
+	/*
+	 * partition must be -
+	 * 0 - user area
+	 * 1 - boot partition 1
+	 * 2 - boot partition 2
+	 * DO NOT switch the partitions that used to be accessed
+	 * in OS layer HERE
+	 */
+	if (part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK) {
+		pr_err("%s: DO NOT switch the partitions that used to be\n" \
+			" accessed in OS layer HERE. please following the\n" \
+			" guidance of Documentation/mmc/mmc-dev-parts.txt.\n",
+			mmc_hostname(card->host));
+		return -EINVAL;
+       }
+
 	ext_csd = kmalloc(512, GFP_KERNEL);
 	if (!ext_csd) {
 		printk(KERN_ERR "%s: could not allocate a buffer to "
@@ -574,29 +590,11 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 		goto err_rtn;
 	}
 
-	/* switch the partitions that used to be accessed in OS layer */
-	/* partition must be -
-	 * 0 - user area
-	 * 1 - boot partition 1
-	 * 2 - boot partition 2
-	 */
-	if ((part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK) > 2) {
-		printk(KERN_ERR "%s: wrong partition id"
-			" 0 (user area), 1 (boot1), 2 (boot2)\n",
-			mmc_hostname(card->host));
-		err = -EINVAL;
-		goto err_rtn;
-	}
-
-
-	/* Send SWITCH command to change partition for access */
-	boot_config &= ~EXT_CSD_BOOT_PARTITION_ACCESS_MASK;
-	boot_config |= (part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK);
 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 		EXT_CSD_PART_CONFIG, boot_config, card->ext_csd.part_time);
 	if (err) {
-		printk(KERN_ERR "%s: fail to send SWITCH command"
-				" to card to swich partition for access!\n",
+		pr_err("%s: fail to send SWITCH command to card " \
+				"to update boot_config of the EXT_CSD!\n",
 			mmc_hostname(card->host));
 		goto err_rtn;
 	}
@@ -634,14 +632,6 @@ setup_boot_partitions(struct device *dev, struct device_attribute *attr,
 		goto err_rtn;
 	}
 
-	new_part = ext_csd[EXT_CSD_PART_CONFIG] &
-		EXT_CSD_BOOT_PARTITION_ACCESS_MASK;
-	if ((part & EXT_CSD_BOOT_PARTITION_ACCESS_MASK) != new_part) {
-		printk(KERN_ERR "%s: after SWITCH, current part id %d is not"
-				" same as requested partition %d!\n",
-			mmc_hostname(card->host), new_part, part);
-		goto err_rtn;
-	}
 	card->ext_csd.boot_config = ext_csd[EXT_CSD_PART_CONFIG];
 
 err_rtn:
@@ -669,8 +659,8 @@ setup_boot_bus(struct device *dev, struct device_attribute *attr,
 	sscanf(buf, "%d\n", &boot_bus);
 
 	if (card->csd.mmca_vsn < CSD_SPEC_VER_4) {
-		printk(KERN_ERR "%s: invalid mmc version"
-			" mmc version is below version 4!)\n",
+		pr_err("%s: fail to send SWITCH command to card " \
+				"to update boot_config of the EXT_CSD!\n",
 			mmc_hostname(card->host));
 		return -EINVAL;
 	}
@@ -794,16 +784,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 		"Reserved",
 		"User area enabled for boot"};
 
-	char *boot_partition_access[8] = {
-		"No access to boot partition",
-		"R/W boot partition 1",
-		"R/W boot partition 2",
-		"R/W Replay Protected Memory Block (RPMB)",
-		"Access to General Purpose partition 1",
-		"Access to General Purpose partition 2",
-		"Access to General Purpose partition 3",
-		"Access to General Purpose partition 4"};
-
 	char *bus_width[4] = {
 		"x1 (sdr) or x4 (ddr) bus width in boot operation mode",
 		"x4 (sdr/ddr) bus width in boot operation mode",
@@ -817,7 +797,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 	"Reserved"};
 
 	int partition;
-	int access;
 	int width;
 	int mode;
 	u8 *ext_csd = NULL;
@@ -830,7 +809,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 	mmc_read_ext_csd(card, ext_csd);
 
 	partition = (card->ext_csd.boot_config >> 3) & 0x7;
-	access = card->ext_csd.boot_config & 0x7;
 	width =  card->ext_csd.boot_bus_width & 0x3;
 	mode = (card->ext_csd.boot_bus_width >> 3) & 0x3;
 
@@ -843,7 +821,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 		"boot_partition:0x%02x;\n"
 		"  BOOT_ACK:%x - %s\n"
 		"  BOOT_PARTITION-ENABLE: %x - %s\n"
-		"  PARTITION_ACCESS:%x - %s\n"
 		"boot_bus:0x%02x\n"
 		"  BOOT_MODE:%x - %s\n"
 		"  RESET_BOOT_BUS_WIDTH:%x - %s\n"
@@ -863,7 +840,7 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 			"Supports high speed timing during boot" :
 			"Does not support high speed timing during boot",
 
-		card->ext_csd.boot_size * 128,
+		card->ext_csd.boot_size >> 10,
 
 		card->ext_csd.boot_config,
 		!!(card->ext_csd.boot_config & 0x40),
@@ -872,8 +849,6 @@ static ssize_t mmc_boot_info_show(struct device *dev,
 			"No boot acknowledge sent",
 		partition,
 		boot_partition[partition],
-		access,
-		boot_partition_access[access],
 
 		card->ext_csd.boot_bus_width,
 		mode,
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 23175ed..f3626b0 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -59,6 +59,9 @@ static void cfi_amdstd_resume (struct mtd_info *);
 static int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);
 static int cfi_amdstd_secsi_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 
+static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf);
+
 static void cfi_amdstd_destroy(struct mtd_info *);
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *, int);
@@ -145,8 +148,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 	if (((major << 8) | minor) < 0x3131) {
 		/* CFI version 1.0 => don't trust bootloc */
 
-		DEBUG(MTD_DEBUG_LEVEL1,
-			"%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",
+		pr_debug("%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",
 			map->name, cfi->mfr, cfi->id);
 
 		/* AFAICS all 29LV400 with a bottom boot block have a device ID
@@ -166,8 +168,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 			 * the 8-bit device ID.
 			 */
 			(cfi->mfr == CFI_MFR_MACRONIX)) {
-			DEBUG(MTD_DEBUG_LEVEL1,
-				"%s: Macronix MX29LV400C with bottom boot block"
+			pr_debug("%s: Macronix MX29LV400C with bottom boot block"
 				" detected\n", map->name);
 			extp->TopBottom = 2;	/* bottom boot */
 		} else
@@ -178,8 +179,7 @@ static void fixup_amd_bootblock(struct mtd_info *mtd)
 			extp->TopBottom = 2;	/* bottom boot */
 		}
 
-		DEBUG(MTD_DEBUG_LEVEL1,
-			"%s: AMD CFI PRI V%c.%c has no boot block field;"
+		pr_debug("%s: AMD CFI PRI V%c.%c has no boot block field;"
 			" deduced %s from Device ID\n", map->name, major, minor,
 			extp->TopBottom == 2 ? "bottom" : "top");
 	}
@@ -191,7 +191,7 @@ static void fixup_use_write_buffers(struct mtd_info *mtd)
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
 	if (cfi->cfiq->BufWriteTimeoutTyp) {
-		DEBUG(MTD_DEBUG_LEVEL1, "Using buffer write method\n" );
+		pr_debug("Using buffer write method\n" );
 		mtd->write = cfi_amdstd_write_buffers;
 	}
 }
@@ -317,7 +317,7 @@ static void fixup_s29gl064n_sectors(struct mtd_info *mtd)
 
 	if ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0x003f) {
 		cfi->cfiq->EraseRegionInfo[0] |= 0x0040;
-		pr_warning("%s: Bad S29GL064N CFI data, adjust from 64 to 128 sectors\n", mtd->name);
+		pr_warning("%s: Bad S29GL064N CFI data; adjust from 64 to 128 sectors\n", mtd->name);
 	}
 }
 
@@ -328,10 +328,23 @@ static void fixup_s29gl032n_sectors(struct mtd_info *mtd)
 
 	if ((cfi->cfiq->EraseRegionInfo[1] & 0xffff) == 0x007e) {
 		cfi->cfiq->EraseRegionInfo[1] &= ~0x0040;
-		pr_warning("%s: Bad S29GL032N CFI data, adjust from 127 to 63 sectors\n", mtd->name);
+		pr_warning("%s: Bad S29GL032N CFI data; adjust from 127 to 63 sectors\n", mtd->name);
 	}
 }
 
+static void fixup_s29ns512p_sectors(struct mtd_info *mtd)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	/*
+	 *  S29NS512P flash uses more than 8bits to report number of sectors,
+	 * which is not permitted by CFI.
+	 */
+	cfi->cfiq->EraseRegionInfo[0] = 0x020001ff;
+	pr_warning("%s: Bad S29NS512P CFI data; adjust to 512 sectors\n", mtd->name);
+}
+
 /* Used to fix CFI-Tables of chips without Extended Query Tables */
 static struct cfi_fixup cfi_nopri_fixup_table[] = {
 	{ CFI_MFR_SST, 0x234a, fixup_sst39vf }, /* SST39VF1602 */
@@ -362,6 +375,7 @@ static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors },
 	{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors },
 	{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors },
+	{ CFI_MFR_AMD, 0x3f00, fixup_s29ns512p_sectors },
 	{ CFI_MFR_SST, 0x536a, fixup_sst38vf640x_sectorsize }, /* SST38VF6402 */
 	{ CFI_MFR_SST, 0x536b, fixup_sst38vf640x_sectorsize }, /* SST38VF6401 */
 	{ CFI_MFR_SST, 0x536c, fixup_sst38vf640x_sectorsize }, /* SST38VF6404 */
@@ -417,6 +431,68 @@ static void cfi_fixup_major_minor(struct cfi_private *cfi,
 	}
 }
 
+static int is_m29ew(struct cfi_private *cfi)
+{
+	if (cfi->mfr == CFI_MFR_INTEL &&
+	    ((cfi->device_type == CFI_DEVICETYPE_X8 && (cfi->id & 0xff) == 0x7e) ||
+	     (cfi->device_type == CFI_DEVICETYPE_X16 && cfi->id == 0x227e)))
+		return 1;
+	return 0;
+}
+
+/*
+ * From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 20:
+ * Some revisions of the M29EW suffer from erase suspend hang ups. In
+ * particular, it can occur when the sequence
+ * Erase Confirm -> Suspend -> Program -> Resume
+ * causes a lockup due to internal timing issues. The consequence is that the
+ * erase cannot be resumed without inserting a dummy command after programming
+ * and prior to resuming. [...] The work-around is to issue a dummy write cycle
+ * that writes an F0 command code before the RESUME command.
+ */
+static void cfi_fixup_m29ew_erase_suspend(struct map_info *map,
+					  unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	/* before resume, insert a dummy 0xF0 cycle for Micron M29EW devices */
+	if (is_m29ew(cfi))
+		map_write(map, CMD(0xF0), adr);
+}
+
+/*
+ * From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 22:
+ *
+ * Some revisions of the M29EW (for example, A1 and A2 step revisions)
+ * are affected by a problem that could cause a hang up when an ERASE SUSPEND
+ * command is issued after an ERASE RESUME operation without waiting for a
+ * minimum delay.  The result is that once the ERASE seems to be completed
+ * (no bits are toggling), the contents of the Flash memory block on which
+ * the erase was ongoing could be inconsistent with the expected values
+ * (typically, the array value is stuck to the 0xC0, 0xC4, 0x80, or 0x84
+ * values), causing a consequent failure of the ERASE operation.
+ * The occurrence of this issue could be high, especially when file system
+ * operations on the Flash are intensive.  As a result, it is recommended
+ * that a patch be applied.  Intensive file system operations can cause many
+ * calls to the garbage routine to free Flash space (also by erasing physical
+ * Flash blocks) and as a result, many consecutive SUSPEND and RESUME
+ * commands can occur.  The problem disappears when a delay is inserted after
+ * the RESUME command by using the udelay() function available in Linux.
+ * The DELAY value must be tuned based on the customer's platform.
+ * The maximum value that fixes the problem in all cases is 500us.
+ * But, in our experience, a delay of 30 µs to 50 µs is sufficient
+ * in most cases.
+ * We have chosen 500µs because this latency is acceptable.
+ */
+static void cfi_fixup_m29ew_delay_after_resume(struct cfi_private *cfi)
+{
+	/*
+	 * Resolving the Delay After Resume Issue see Micron TN-13-07
+	 * Worst case delay must be 500µs but 30-50µs should be ok as well
+	 */
+	if (is_m29ew(cfi))
+		cfi_udelay(500);
+}
+
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -443,9 +519,10 @@ struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 	mtd->writesize = 1;
 	mtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): write buffer size %d\n",
-		__func__, mtd->writebufsize);
+	pr_debug("MTD %s(): write buffer size %d\n", __func__,
+			mtd->writebufsize);
 
+	mtd->panic_write = cfi_amdstd_panic_write;
 	mtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;
 
 	if (cfi->cfi_mode==CFI_MODE_CFI){
@@ -761,7 +838,10 @@ static void put_chip(struct map_info *map, struct flchip *chip, unsigned long ad
 
 	switch(chip->oldstate) {
 	case FL_ERASING:
+		cfi_fixup_m29ew_erase_suspend(map,
+			chip->in_progress_block_addr);
 		map_write(map, cfi->sector_erase_cmd, chip->in_progress_block_addr);
+		cfi_fixup_m29ew_delay_after_resume(cfi);
 		chip->oldstate = FL_READY;
 		chip->state = FL_ERASING;
 		break;
@@ -773,8 +853,6 @@ static void put_chip(struct map_info *map, struct flchip *chip, unsigned long ad
 
 	case FL_READY:
 	case FL_STATUS:
-		/* We should really make set_vpp() count, rather than doing this */
-		DISABLE_VPP(map);
 		break;
 	default:
 		printk(KERN_ERR "MTD: put_chip() called with oldstate %d!!\n", chip->oldstate);
@@ -903,6 +981,8 @@ static void __xipram xip_udelay(struct map_info *map, struct flchip *chip,
 			/* Disallow XIP again */
 			local_irq_disable();
 
+			/* Correct Erase Suspend Hangups for M29EW */
+			cfi_fixup_m29ew_erase_suspend(map, adr);
 			/* Resume the write or erase operation */
 			map_write(map, cfi->sector_erase_cmd, adr);
 			chip->state = oldstate;
@@ -960,17 +1040,13 @@ static void __xipram xip_udelay(struct map_info *map, struct flchip *chip,
 
 #define UDELAY(map, chip, adr, usec)  \
 do {  \
-	mutex_unlock(&chip->mutex);  \
 	cfi_udelay(usec);  \
-	mutex_lock(&chip->mutex);  \
 } while (0)
 
 #define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \
 do {  \
-	mutex_unlock(&chip->mutex);  \
 	INVALIDATE_CACHED_RANGE(map, adr, len);  \
 	cfi_udelay(usec);  \
-	mutex_lock(&chip->mutex);  \
 } while (0)
 
 #endif
@@ -1163,7 +1239,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 		return ret;
 	}
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
+	pr_debug("MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
 	       __func__, adr, datum.x[0] );
 
 	/*
@@ -1174,7 +1250,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	 */
 	oldd = map_read(map, adr);
 	if (map_word_equal(map, oldd, datum)) {
-		DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): NOP\n",
+		pr_debug("MTD %s(): NOP\n",
 		       __func__);
 		goto op_done;
 	}
@@ -1237,6 +1313,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	xip_enable(map, chip, adr);
  op_done:
 	chip->state = FL_READY;
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 
@@ -1400,7 +1477,7 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 
 	datum = map_word_load(map, buf);
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
+	pr_debug("MTD %s(): WRITE 0x%.8lx(0x%.8lx)\n",
 	       __func__, adr, datum.x[0] );
 
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
@@ -1468,17 +1545,30 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 		UDELAY(map, chip, adr, 1);
 	}
 
-	/* reset on all failures. */
-	map_write( map, CMD(0xF0), chip->start );
+	/*
+	 * Recovery from write-buffer programming failures requires
+	 * the write-to-buffer-reset sequence.  Since the last part
+	 * of the sequence also works as a normal reset, we can run
+	 * the same commands regardless of why we are here.
+	 * See e.g.
+	 * http://www.spansion.com/Support/Application%20Notes/MirrorBit_Write_Buffer_Prog_Page_Buffer_Read_AN.pdf
+	 */
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
+			 cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
+			 cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, chip->start, map, cfi,
+			 cfi->device_type, NULL);
 	xip_enable(map, chip, adr);
 	/* FIXME - should have reset delay before continuing */
 
-	printk(KERN_WARNING "MTD %s(): software timeout\n",
-	       __func__ );
+	printk(KERN_WARNING "MTD %s(): software timeout, address:0x%.8lx.\n",
+	       __func__, adr);
 
 	ret = -EIO;
  op_done:
 	chip->state = FL_READY;
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 
@@ -1565,6 +1655,242 @@ static int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,
 	return 0;
 }
 
+/*
+ * Wait for the flash chip to become ready to write data
+ *
+ * This is only called during the panic_write() path. When panic_write()
+ * is called, the kernel is in the process of a panic, and will soon be
+ * dead. Therefore we don't take any locks, and attempt to get access
+ * to the chip as soon as possible.
+ */
+static int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,
+				 unsigned long adr)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	int retries = 10;
+	int i;
+
+	/*
+	 * If the driver thinks the chip is idle, and no toggle bits
+	 * are changing, then the chip is actually idle for sure.
+	 */
+	if (chip->state == FL_READY && chip_ready(map, adr))
+		return 0;
+
+	/*
+	 * Try several times to reset the chip and then wait for it
+	 * to become idle. The upper limit of a few milliseconds of
+	 * delay isn't a big problem: the kernel is dying anyway. It
+	 * is more important to save the messages.
+	 */
+	while (retries > 0) {
+		const unsigned long timeo = (HZ / 1000) + 1;
+
+		/* send the reset command */
+		map_write(map, CMD(0xF0), chip->start);
+
+		/* wait for the chip to become ready */
+		for (i = 0; i < jiffies_to_usecs(timeo); i++) {
+			if (chip_ready(map, adr))
+				return 0;
+
+			udelay(1);
+		}
+	}
+
+	/* the chip never became ready */
+	return -EBUSY;
+}
+
+/*
+ * Write out one word of data to a single flash chip during a kernel panic
+ *
+ * This is only called during the panic_write() path. When panic_write()
+ * is called, the kernel is in the process of a panic, and will soon be
+ * dead. Therefore we don't take any locks, and attempt to get access
+ * to the chip as soon as possible.
+ *
+ * The implementation of this routine is intentionally similar to
+ * do_write_oneword(), in order to ease code maintenance.
+ */
+static int do_panic_write_oneword(struct map_info *map, struct flchip *chip,
+				  unsigned long adr, map_word datum)
+{
+	const unsigned long uWriteTimeout = (HZ / 1000) + 1;
+	struct cfi_private *cfi = map->fldrv_priv;
+	int retry_cnt = 0;
+	map_word oldd;
+	int ret = 0;
+	int i;
+
+	adr += chip->start;
+
+	ret = cfi_amdstd_panic_wait(map, chip, adr);
+	if (ret)
+		return ret;
+
+	pr_debug("MTD %s(): PANIC WRITE 0x%.8lx(0x%.8lx)\n",
+			__func__, adr, datum.x[0]);
+
+	/*
+	 * Check for a NOP for the case when the datum to write is already
+	 * present - it saves time and works around buggy chips that corrupt
+	 * data at other locations when 0xff is written to a location that
+	 * already contains 0xff.
+	 */
+	oldd = map_read(map, adr);
+	if (map_word_equal(map, oldd, datum)) {
+		pr_debug("MTD %s(): NOP\n", __func__);
+		goto op_done;
+	}
+
+	ENABLE_VPP(map);
+
+retry:
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	map_write(map, datum, adr);
+
+	for (i = 0; i < jiffies_to_usecs(uWriteTimeout); i++) {
+		if (chip_ready(map, adr))
+			break;
+
+		udelay(1);
+	}
+
+	if (!chip_good(map, adr, datum)) {
+		/* reset on all failures. */
+		map_write(map, CMD(0xF0), chip->start);
+		/* FIXME - should have reset delay before continuing */
+
+		if (++retry_cnt <= MAX_WORD_RETRIES)
+			goto retry;
+
+		ret = -EIO;
+	}
+
+op_done:
+	DISABLE_VPP(map);
+	return ret;
+}
+
+/*
+ * Write out some data during a kernel panic
+ *
+ * This is used by the mtdoops driver to save the dying messages from a
+ * kernel which has panic'd.
+ *
+ * This routine ignores all of the locking used throughout the rest of the
+ * driver, in order to ensure that the data gets written out no matter what
+ * state this driver (and the flash chip itself) was in when the kernel crashed.
+ *
+ * The implementation of this routine is intentionally similar to
+ * cfi_amdstd_write_words(), in order to ease code maintenance.
+ */
+static int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+	unsigned long ofs, chipstart;
+	int ret = 0;
+	int chipnum;
+
+	*retlen = 0;
+	if (!len)
+		return 0;
+
+	chipnum = to >> cfi->chipshift;
+	ofs = to - (chipnum << cfi->chipshift);
+	chipstart = cfi->chips[chipnum].start;
+
+	/* If it's not bus aligned, do the first byte write */
+	if (ofs & (map_bankwidth(map) - 1)) {
+		unsigned long bus_ofs = ofs & ~(map_bankwidth(map) - 1);
+		int i = ofs - bus_ofs;
+		int n = 0;
+		map_word tmp_buf;
+
+		ret = cfi_amdstd_panic_wait(map, &cfi->chips[chipnum], bus_ofs);
+		if (ret)
+			return ret;
+
+		/* Load 'tmp_buf' with old contents of flash */
+		tmp_buf = map_read(map, bus_ofs + chipstart);
+
+		/* Number of bytes to copy from buffer */
+		n = min_t(int, len, map_bankwidth(map) - i);
+
+		tmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);
+
+		ret = do_panic_write_oneword(map, &cfi->chips[chipnum],
+					     bus_ofs, tmp_buf);
+		if (ret)
+			return ret;
+
+		ofs += n;
+		buf += n;
+		(*retlen) += n;
+		len -= n;
+
+		if (ofs >> cfi->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+		}
+	}
+
+	/* We are now aligned, write as much as possible */
+	while (len >= map_bankwidth(map)) {
+		map_word datum;
+
+		datum = map_word_load(map, buf);
+
+		ret = do_panic_write_oneword(map, &cfi->chips[chipnum],
+					     ofs, datum);
+		if (ret)
+			return ret;
+
+		ofs += map_bankwidth(map);
+		buf += map_bankwidth(map);
+		(*retlen) += map_bankwidth(map);
+		len -= map_bankwidth(map);
+
+		if (ofs >> cfi->chipshift) {
+			chipnum++;
+			ofs = 0;
+			if (chipnum == cfi->numchips)
+				return 0;
+
+			chipstart = cfi->chips[chipnum].start;
+		}
+	}
+
+	/* Write the trailing bytes if any */
+	if (len & (map_bankwidth(map) - 1)) {
+		map_word tmp_buf;
+
+		ret = cfi_amdstd_panic_wait(map, &cfi->chips[chipnum], ofs);
+		if (ret)
+			return ret;
+
+		tmp_buf = map_read(map, ofs + chipstart);
+
+		tmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);
+
+		ret = do_panic_write_oneword(map, &cfi->chips[chipnum],
+					     ofs, tmp_buf);
+		if (ret)
+			return ret;
+
+		(*retlen) += len;
+	}
+
+	return 0;
+}
+
 
 /*
  * Handle devices with one erase region, that only implement
@@ -1587,7 +1913,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 		return ret;
 	}
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",
+	pr_debug("MTD %s(): ERASE 0x%.8lx\n",
 	       __func__, chip->start );
 
 	XIP_INVAL_CACHED_RANGE(map, adr, map->size);
@@ -1652,6 +1978,7 @@ static int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)
 
 	chip->state = FL_READY;
 	xip_enable(map, chip, adr);
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 
@@ -1675,7 +2002,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 		return ret;
 	}
 
-	DEBUG( MTD_DEBUG_LEVEL3, "MTD %s(): ERASE 0x%.8lx\n",
+	pr_debug("MTD %s(): ERASE 0x%.8lx\n",
 	       __func__, adr );
 
 	XIP_INVAL_CACHED_RANGE(map, adr, len);
@@ -1742,6 +2069,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 	}
 
 	chip->state = FL_READY;
+	DISABLE_VPP(map);
 	put_chip(map, chip, adr);
 	mutex_unlock(&chip->mutex);
 	return ret;
@@ -1801,8 +2129,7 @@ static int do_atmel_lock(struct map_info *map, struct flchip *chip,
 		goto out_unlock;
 	chip->state = FL_LOCKING;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): LOCK 0x%08lx len %d\n",
-	      __func__, adr, len);
+	pr_debug("MTD %s(): LOCK 0x%08lx len %d\n", __func__, adr, len);
 
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
 			 cfi->device_type, NULL);
@@ -1837,8 +2164,7 @@ static int do_atmel_unlock(struct map_info *map, struct flchip *chip,
 		goto out_unlock;
 	chip->state = FL_UNLOCKING;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): LOCK 0x%08lx len %d\n",
-	      __func__, adr, len);
+	pr_debug("MTD %s(): LOCK 0x%08lx len %d\n", __func__, adr, len);
 
 	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
 			 cfi->device_type, NULL);
diff --git a/drivers/mtd/nand/gpmi-nand/gpmi-lib.c b/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
index 2138dcb..5c8f3bc 100644
--- a/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
+++ b/drivers/mtd/nand/gpmi-nand/gpmi-lib.c
@@ -1,7 +1,7 @@
 /*
  * Freescale GPMI NAND Flash Driver
  *
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Embedded Alley Solutions, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -1160,7 +1160,7 @@ void gpmi_begin(struct gpmi_nand_data *this)
 	unsigned int   clock_period_in_ns;
 	uint32_t       reg;
 	unsigned int   dll_wait_time_in_us;
-	struct gpmi_nfc_hardware_timing  hw;
+	struct gpmi_nfc_hardware_timing  hw = {};
 	int ret;
 
 	/* Enable the clock. */
diff --git a/drivers/mxc/asrc/mxc_asrc.c b/drivers/mxc/asrc/mxc_asrc.c
index 9962698..ea65738 100644
--- a/drivers/mxc/asrc/mxc_asrc.c
+++ b/drivers/mxc/asrc/mxc_asrc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -53,18 +53,18 @@ DEFINE_SPINLOCK(pair_lock);
 DEFINE_SPINLOCK(input_int_lock);
 DEFINE_SPINLOCK(output_int_lock);
 
-#define AICPA		0	/* Input Clock Divider A Offset */
-#define AICDA		3	/* Input Clock Prescaler A Offset */
-#define AICPB           6	/* Input Clock Divider B Offset */
-#define AICDB           9	/* Input Clock Prescaler B Offset */
-#define AOCPA           12	/* Output Clock Divider A Offset */
-#define AOCDA           15	/* Output Clock Prescaler A Offset */
-#define AOCPB           18	/* Output Clock Divider B Offset */
-#define AOCDB           21	/* Output Clock Prescaler B Offset */
-#define AICPC           0	/* Input Clock Divider C Offset */
-#define AICDC           3	/* Input Clock Prescaler C Offset */
-#define AOCDC           6	/* Output Clock Prescaler C Offset */
-#define AOCPC           9	/* Output Clock Divider C Offset */
+#define AICPA		0	/* Input Clock Prescaler A Offset */
+#define AICDA		3	/* Input Clock Divider A Offset */
+#define AICPB           6	/* Input Clock Prescaler B Offset */
+#define AICDB           9	/* Input Clock Divider B Offset */
+#define AOCPA           12	/* Output Clock Prescaler A Offset */
+#define AOCDA           15	/* Output Clock Divider A Offset */
+#define AOCPB           18	/* Output Clock Prescaler B Offset */
+#define AOCDB           21	/* Output Clock Divider B Offset */
+#define AICPC           0	/* Input Clock Prescaler C Offset */
+#define AICDC           3	/* Input Clock Divider C Offset */
+#define AOCPC           6	/* Output Clock Prescaler C Offset */
+#define AOCDC           9	/* Output Clock Divider C Offset */
 
 char *asrc_pair_id[] = {
 	[0] = "ASRC RX PAIR A",
@@ -144,12 +144,15 @@ static unsigned char output_clk_map_v1[] = {
 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
 };
 
+/* V2 uses the same map for input and output */
 static unsigned char input_clk_map_v2[] = {
-	0, 1, 2, 3, 4, 5, 0xf, 0xf, 0xf, 8, 9, 0xa, 0xb, 0xc, 0xf, 0xd,
+/*	0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xa  0xb  0xc  0xd  0xe  0xf*/
+	0x0, 0x1, 0x2, 0x7, 0x4, 0x5, 0x6, 0x3, 0x8, 0x9, 0xa, 0xb, 0xc, 0xf, 0xe, 0xd,
 };
 
 static unsigned char output_clk_map_v2[] = {
-	8, 9, 0xa, 0, 0xc, 0x5, 0xf, 0xf, 0, 1, 2, 0xf, 0xf, 4, 0xf, 0xd,
+/*	0x0  0x1  0x2  0x3  0x4  0x5  0x6  0x7  0x8  0x9  0xa  0xb  0xc  0xd  0xe  0xf*/
+	0x8, 0x9, 0xa, 0x7, 0xc, 0x5, 0x6, 0xb, 0x0, 0x1, 0x2, 0x3, 0x4, 0xf, 0xe, 0xd,
 };
 
 static unsigned char *input_clk_map, *output_clk_map;
@@ -318,34 +321,42 @@ int asrc_req_pair(int chn_num, enum asrc_pair_index *index)
 	int err = 0;
 	unsigned long lock_flags;
 	struct asrc_pair *pair;
+	int imax = 0, busy = 0, i;
+
 	spin_lock_irqsave(&data_lock, lock_flags);
 
-	if (chn_num > 2) {
-		pair = &g_asrc->asrc_pair[ASRC_PAIR_B];
-		if (pair->active || (chn_num > pair->chn_max))
-			err = -EBUSY;
-		else {
-			*index = ASRC_PAIR_B;
-			pair->chn_num = chn_num;
-			pair->active = 1;
+	for (i = ASRC_PAIR_A; i < ASRC_PAIR_MAX_NUM; i++) {
+		pair = &g_asrc->asrc_pair[i];
+		if (chn_num > pair->chn_max) {
+			imax++;
+			continue;
+		} else if (pair->active) {
+			busy++;
+			continue;
 		}
+		/* Save the current qualified pair */
+		*index = i;
+
+		/* Check if this pair is a perfect one */
+		if (chn_num == pair->chn_max)
+			break;
+	}
+
+	if (imax >= ASRC_PAIR_MAX_NUM) {
+		pr_err("No pair could afford requested channel number.\n");
+		err = -EINVAL;
+	} else if (busy >= ASRC_PAIR_MAX_NUM) {
+		pr_err("All pairs are busy now.\n");
+		err = -EBUSY;
+	} else if (busy + imax >= ASRC_PAIR_MAX_NUM) {
+		pr_err("All affordable pairs are busy now.\n");
+		err = -EBUSY;
 	} else {
-		pair = &g_asrc->asrc_pair[ASRC_PAIR_A];
-		if (pair->active || (pair->chn_max == 0)) {
-			pair = &g_asrc->asrc_pair[ASRC_PAIR_C];
-			if (pair->active || (pair->chn_max == 0))
-				err = -EBUSY;
-			else {
-				*index = ASRC_PAIR_C;
-				pair->chn_num = 2;
-				pair->active = 1;
-			}
-		} else {
-			*index = ASRC_PAIR_A;
-			pair->chn_num = 2;
-			pair->active = 1;
-		}
+		pair = &g_asrc->asrc_pair[*index];
+		pair->chn_num = chn_num;
+		pair->active = 1;
 	}
+
 	spin_unlock_irqrestore(&data_lock, lock_flags);
 
 	if (!err) {
@@ -381,6 +392,9 @@ int asrc_config_pair(struct asrc_config *config)
 	int err = 0;
 	int reg, tmp, channel_num;
 	unsigned long lock_flags;
+	unsigned long aicp_shift, aocp_shift;
+	unsigned long asrc_asrcdr_reg, dp_clear_mask;
+
 	/* Set the channel number */
 	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCNCR_REG);
 	spin_lock_irqsave(&data_lock, lock_flags);
@@ -426,142 +440,68 @@ int asrc_config_pair(struct asrc_config *config)
 	__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCTR_REG);
 
 	/* Default Clock Divider Setting */
-	reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR1_REG);
-	if (config->pair == ASRC_PAIR_A) {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR1_REG);
-		reg &= 0xfc0fc0;
-		/* Input Part */
-		if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
-			reg |= 7 << AICPA;
-		else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
-			reg |= 6 << AICPA;
-		else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 input_sample_rate);
-			reg |= tmp << AICPA;
-		} else {
-			if (config->input_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AICPA;
-			else if (config->input_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AICPA;
-			else
-				err = -EFAULT;
-		}
-		/* Output Part */
-		if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
-			reg |= 7 << AOCPA;
-		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
-			reg |= 6 << AOCPA;
-		else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) &&
-				((config->inclk & 0x0f) == INCLK_NONE))
-			reg |= 5 << AOCPA;
-		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 output_sample_rate);
-			reg |= tmp << AOCPA;
-		} else {
-			if (config->output_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AOCPA;
-			else if (config->output_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AOCPA;
-			else
-				err = -EFAULT;
-		}
-
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCDR1_REG);
-
-	} else if (config->pair == ASRC_PAIR_B) {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR1_REG);
-		reg &= 0x03f03f;
-		/* Input Part */
-		if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
-			reg |= 7 << AICPB;
-		else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
-			reg |= 6 << AICPB;
-		else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 input_sample_rate);
-			reg |= tmp << AICPB;
-		} else {
-			if (config->input_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AICPB;
-			else if (config->input_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AICPB;
-			else
-				err = -EFAULT;
-		}
-		/* Output Part */
-		if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
-			reg |= 7 << AOCPB;
-		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
-			reg |= 6 << AOCPB;
-		else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) &&
-				((config->inclk & 0x0f) == INCLK_NONE))
-			reg |= 5 << AOCPB;
-		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 output_sample_rate);
-			reg |= tmp << AOCPB;
-		} else {
-			if (config->output_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AOCPB;
-			else if (config->output_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AOCPB;
-			else
-				err = -EFAULT;
-		}
-
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCDR1_REG);
+	switch (config->pair) {
+	case ASRC_PAIR_A:
+		asrc_asrcdr_reg = ASRC_ASRCDR1_REG;
+		dp_clear_mask = 0xfc0fc0;
+		aicp_shift = AICPA;
+		aocp_shift = AOCPA;
+		break;
+	case ASRC_PAIR_B:
+		asrc_asrcdr_reg = ASRC_ASRCDR1_REG;
+		dp_clear_mask = 0x03f03f;
+		aicp_shift = AICPB;
+		aocp_shift = AOCPB;
+		break;
+	case ASRC_PAIR_C:
+		asrc_asrcdr_reg = ASRC_ASRCDR2_REG;
+		dp_clear_mask = 0x00;
+		aicp_shift = AICPC;
+		aocp_shift = AOCPC;
+		break;
+	default:
+		pr_err("Invalid Pair number %d\n", config->pair);
+		return -EFAULT;
+	}
 
+	reg = __raw_readl(g_asrc->vaddr + asrc_asrcdr_reg);
+	reg &= dp_clear_mask;
+	/* Input Part */
+	if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
+		reg |= 7 << aicp_shift;
+	else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
+		reg |= 6 << aicp_shift;
+	else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
+		tmp = asrc_get_asrck_clock_divider(config->input_sample_rate);
+		reg |= tmp << aicp_shift;
 	} else {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCDR2_REG);
-		reg &= 0;
-		/* Input Part */
-		if ((config->inclk & 0x0f) == INCLK_SPDIF_RX)
-			reg |= 7 << AICPC;
-		else if ((config->inclk & 0x0f) == INCLK_SPDIF_TX)
-			reg |= 6 << AICPC;
-		else if ((config->inclk & 0x0f) == INCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 input_sample_rate);
-			reg |= tmp << AICPC;
-		} else {
-			if (config->input_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AICPC;
-			else if (config->input_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AICPC;
-			else
-				err = -EFAULT;
-		}
-		/* Output Part */
-		if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
-			reg |= 7 << AOCPC;
-		else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
-			reg |= 6 << AOCPC;
-		else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) &&
-				((config->inclk & 0x0f) == INCLK_NONE))
-			reg |= 5 << AOCPC;
-		else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
-			tmp =
-			    asrc_get_asrck_clock_divider(config->
-							 output_sample_rate);
-			reg |= tmp << AOCPC;
-		} else {
-			if (config->output_word_width == ASRC_WIDTH_16_BIT)
-				reg |= 5 << AOCPC;
-			else if (config->output_word_width == ASRC_WIDTH_24_BIT)
-				reg |= 6 << AOCPC;
-			else
-				err = -EFAULT;
-		}
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCDR2_REG);
-
+		if (config->input_word_width == ASRC_WIDTH_16_BIT)
+			reg |= 5 << aicp_shift;
+		else if (config->input_word_width == ASRC_WIDTH_24_BIT)
+			reg |= 6 << aicp_shift;
+		else
+			err = -EFAULT;
+	}
+	/* Output Part */
+	if ((config->outclk & 0x0f) == OUTCLK_SPDIF_RX)
+		reg |= 7 << aocp_shift;
+	else if ((config->outclk & 0x0f) == OUTCLK_SPDIF_TX)
+		reg |= 6 << aocp_shift;
+	else if (((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK)
+			&& ((config->inclk & 0x0f) == INCLK_NONE))
+		reg |= 5 << aocp_shift;
+	else if ((config->outclk & 0x0f) == OUTCLK_ASRCK1_CLK) {
+		tmp = asrc_get_asrck_clock_divider(config->output_sample_rate);
+		reg |= tmp << aocp_shift;
+	} else {
+		if (config->output_word_width == ASRC_WIDTH_16_BIT)
+			reg |= 5 << aocp_shift;
+		else if (config->output_word_width == ASRC_WIDTH_24_BIT)
+			reg |= 6 << aocp_shift;
+		else
+			err = -EFAULT;
 	}
+	__raw_writel(reg, g_asrc->vaddr + asrc_asrcdr_reg);
 
 	/* check whether ideal ratio is a must */
 	if ((config->inclk & 0x0f) == INCLK_NONE) {
@@ -597,25 +537,6 @@ int asrc_config_pair(struct asrc_config *config)
 		}
 	}
 
-	if ((config->inclk == INCLK_NONE) &&
-			(config->outclk == OUTCLK_ESAI_TX)) {
-		reg = __raw_readl(g_asrc->vaddr + ASRC_ASRCTR_REG);
-		reg &= ~(1 << (20 + config->pair));
-		reg |= (0x03 << (13 + (config->pair << 1)));
-		__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCTR_REG);
-		err = asrc_set_clock_ratio(config->pair,
-					   config->input_sample_rate,
-					   config->output_sample_rate);
-		if (err < 0)
-			return err;
-		err = asrc_set_process_configuration(config->pair,
-						     config->input_sample_rate,
-						     config->
-						     output_sample_rate);
-		if (err < 0)
-			return err;
-	}
-
 	/* Config input and output wordwidth */
 	reg = __raw_readl(
 		g_asrc->vaddr + ASRC_ASRMCR1A_REG + (config->pair << 2));
@@ -877,10 +798,10 @@ static int mxc_init_asrc(void)
 	__raw_writel(0x001f00, g_asrc->vaddr + ASRC_ASRTFR1);
 
 	/* Set the processing clock for 76KHz, 133M  */
-	__raw_writel(0x30E, g_asrc->vaddr + ASRC_ASR76K_REG);
+	__raw_writel(0x06D6, g_asrc->vaddr + ASRC_ASR76K_REG);
 
 	/* Set the processing clock for 56KHz, 133M */
-	__raw_writel(0x0426, g_asrc->vaddr + ASRC_ASR56K_REG);
+	__raw_writel(0x0947, g_asrc->vaddr + ASRC_ASR56K_REG);
 
 	return 0;
 }
@@ -946,6 +867,7 @@ static void asrc_read_output_FIFO_S16(struct asrc_pair_params *params)
 	u16 *index = params->output_last_period.dma_vaddr;
 
 	t_size = 0;
+	udelay(100);
 	size = asrc_get_output_FIFO_size(params->index);
 	while (size) {
 		for (i = 0; i < size; i++) {
@@ -972,6 +894,7 @@ static void asrc_read_output_FIFO_S24(struct asrc_pair_params *params)
 	u32 *index = params->output_last_period.dma_vaddr;
 
 	t_size = 0;
+	udelay(100);
 	size = asrc_get_output_FIFO_size(params->index);
 	while (size) {
 		for (i = 0; i < size; i++) {
@@ -1033,7 +956,7 @@ static void mxc_free_dma_buf(struct asrc_pair_params *params)
 	}
 
 	if (params->output_dma_total.dma_vaddr != NULL) {
-		kfree(params->input_dma_total.dma_vaddr);
+		kfree(params->output_dma_total.dma_vaddr);
 		params->output_dma_total.dma_vaddr = NULL;
 	}
 
@@ -1533,6 +1456,13 @@ static long asrc_ioctl(struct file *file,
 				err = -EFAULT;
 				break;
 			}
+
+			if (index < 0) {
+				pr_err("unvalid index: %d!\n", index);
+				err = -EFAULT;
+				break;
+			}
+
 			params->asrc_active = 0;
 
 			spin_lock_irqsave(&pair_lock, lock_flags);
@@ -1838,13 +1768,26 @@ static int asrc_write_proc_attr(struct file *file, const char *buffer,
 		total = 10;
 	else
 		total = 5;
-	if ((na + nb + nc) != total) {
-		pr_info("Wrong ASRCNR settings\n");
-		return -EFAULT;
+
+	if ((na + nb + nc) > total) {
+		pr_err("Don't surpass %d for total.\n", total);
+		return -EINVAL;
+	} else if (na % 2 != 0 || nb % 2 != 0 || nc % 2 != 0) {
+		pr_err("Please set an even number for each pair.\n");
+		return -EINVAL;
+	} else if (na < 0 || nb < 0 || nc < 0) {
+		pr_err("Please set an positive number for each pair.\n");
+		return -EINVAL;
 	}
+
 	reg = na | (nb << g_asrc->mxc_asrc_data->channel_bits) |
 		(nc << (g_asrc->mxc_asrc_data->channel_bits * 2));
 
+	/* Update chn_max */
+	g_asrc->asrc_pair[ASRC_PAIR_A].chn_max = na;
+	g_asrc->asrc_pair[ASRC_PAIR_B].chn_max = nb;
+	g_asrc->asrc_pair[ASRC_PAIR_C].chn_max = nc;
+
 	clk_enable(g_asrc->mxc_asrc_data->asrc_core_clk);
 	__raw_writel(reg, g_asrc->vaddr + ASRC_ASRCNCR_REG);
 	clk_disable(g_asrc->mxc_asrc_data->asrc_core_clk);
diff --git a/drivers/mxc/gpu-viv/Kbuild b/drivers/mxc/gpu-viv/Kbuild
index bc5ec02..93b1259 100644
--- a/drivers/mxc/gpu-viv/Kbuild
+++ b/drivers/mxc/gpu-viv/Kbuild
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
@@ -54,7 +54,8 @@ OBJS += $(HAL_KERNEL_DIR)/gc_hal_kernel.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_event.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_heap.o \
         $(HAL_KERNEL_DIR)/gc_hal_kernel_mmu.o \
-        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o
+        $(HAL_KERNEL_DIR)/gc_hal_kernel_video_memory.o \
+        $(HAL_KERNEL_DIR)/gc_hal_kernel_power.o
 
 OBJS += $(ARCH_KERNEL_DIR)/gc_hal_kernel_context.o \
         $(ARCH_KERNEL_DIR)/gc_hal_kernel_hardware.o
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
index a8b9922..cf40e3f 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
index e2a9f8e..aa767ee 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_command_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_kernel_hardware_command_vg_h_
 #define __gc_hal_kernel_hardware_command_vg_h_
 
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
index ec5d858..70c2cd6 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_hardware_command_vg.h"
@@ -219,7 +217,6 @@ _IdentifyHardware(
     return status;
 }
 
-#if gcdPOWER_MANAGEMENT
 static gctTHREADFUNCRESULT gctTHREADFUNCTYPE
 _TimeIdleThread(
     gctTHREADFUNCPARAMETER ThreadParameter
@@ -264,8 +261,6 @@ _TimeIdleThread(
     }
     return 0;
 }
-#endif
-
 
 /******************************************************************************\
 ****************************** gckVGHARDWARE API code *****************************
@@ -310,6 +305,8 @@ gckVGHARDWARE_Construct(
 
     do
     {
+        gcmkERR_BREAK(gckOS_SetGPUPower(Os, gcvCORE_VG, gcvTRUE, gcvTRUE));
+
         status = _ResetGPU(Os);
 
         if (status != gcvSTATUS_OK)
@@ -342,10 +339,10 @@ gckVGHARDWARE_Construct(
 
         hardware->powerMutex            = gcvNULL;
         hardware->idleSignal            = gcvNULL;
-        hardware->chipPowerState        = gcvPOWER_OFF;
+        hardware->chipPowerState        = gcvPOWER_ON;
         hardware->chipPowerStateGlobal  = gcvPOWER_ON;
-        hardware->clockState            = gcvFALSE;
-        hardware->powerState            = gcvFALSE;
+        hardware->clockState            = gcvTRUE;
+        hardware->powerState            = gcvTRUE;
         hardware->powerOffTimeout       = gcdPOWEROFF_TIMEOUT;
         hardware->powerOffTime          = 0;
         hardware->timeIdleThread        = gcvNULL;
@@ -369,14 +366,17 @@ gckVGHARDWARE_Construct(
 
         gcmkERR_BREAK(gckOS_CreateMutex(Os, &hardware->powerMutex));
         gcmkERR_BREAK(gckOS_CreateSignal(Os, gcvFALSE, &hardware->idleSignal));
-#if gcdPOWER_MANAGEMENT
+
+        /* Enable power management by default. */
+        hardware->powerManagement = gcvTRUE;
+
         gcmkERR_BREAK(gckOS_StartThread(
             hardware->os,
             _TimeIdleThread,
             hardware,
             &hardware->timeIdleThread
             ));
-#endif
+
         /* Return pointer to the gckVGHARDWARE object. */
         *Hardware = hardware;
 
@@ -396,6 +396,8 @@ gckVGHARDWARE_Construct(
         gcmkVERIFY_OK(gckOS_Free(Os, hardware));
     }
 
+    gcmkVERIFY_OK(gckOS_SetGPUPower(Os, gcvCORE_VG, gcvFALSE, gcvFALSE));
+
     gcmkFOOTER();
     /* Return the status. */
     return status;
@@ -426,11 +428,10 @@ gckVGHARDWARE_Destroy(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-#if gcdPOWER_MANAGEMENT
     Hardware->killThread  = gcvTRUE;
     gcmkVERIFY_OK(gckOS_Signal(Hardware->os, Hardware->idleSignal, gcvTRUE));
     gcmkVERIFY_OK(gckOS_StopThread(Hardware->os, Hardware->timeIdleThread));
-#endif
+
     /* Mark the object as unknown. */
     Hardware->object.type = gcvOBJ_UNKNOWN;
 
@@ -1433,7 +1434,6 @@ gckVGHARDWARE_ReadInterrupt(
     return status;
 }
 
-#if gcdPOWER_MANAGEMENT
 static gceSTATUS _CommandStall(
     gckVGHARDWARE Hardware)
 {
@@ -1478,7 +1478,6 @@ static gceSTATUS _CommandStall(
     /* Return the status. */
     return status;
 }
-#endif
 
 /*******************************************************************************
 **
@@ -1501,7 +1500,6 @@ gckVGHARDWARE_SetPowerManagementState(
     IN gceCHIPPOWERSTATE State
     )
 {
-#if gcdPOWER_MANAGEMENT
     gceSTATUS status;
     gckVGCOMMAND command = gcvNULL;
     gckOS os;
@@ -1601,6 +1599,12 @@ gckVGHARDWARE_SetPowerManagementState(
     command = Hardware->kernel->command;
     gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
 
+    if (Hardware->powerManagement == gcvFALSE)
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
     /* Start profiler. */
     gcmkPROFILE_INIT(freq, time);
 
@@ -1801,6 +1805,8 @@ gckVGHARDWARE_SetPowerManagementState(
 
     if (flag & gcvPOWER_FLAG_INITIALIZE)
     {
+        gcmkONERROR(gckVGHARDWARE_SetMMU(Hardware, Hardware->kernel->mmu->pageTableLogical));
+
         /* Force the command queue to reload the next context. */
         command->currentContext = 0;
     }
@@ -1913,10 +1919,6 @@ OnError:
     /* Return the status. */
     gcmkFOOTER();
     return status;
-#else /* gcdPOWER_MANAGEMENT */
-    /* Do nothing */
-    return gcvSTATUS_OK;
-#endif
 }
 
 /*******************************************************************************
@@ -1954,6 +1956,40 @@ gckVGHARDWARE_QueryPowerManagementState(
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckVGHARDWARE_SetPowerManagement
+**
+**  Configure GPU power management function.
+**  Only used in driver initialization stage.
+**
+**  INPUT:
+**
+**      gckVGHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**      gctBOOL PowerManagement
+**          Power Mangement State.
+**
+*/
+gceSTATUS
+gckVGHARDWARE_SetPowerManagement(
+    IN gckVGHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    )
+{
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    Hardware->powerManagement = PowerManagement;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 gceSTATUS
 gckVGHARDWARE_SetPowerOffTimeout(
     IN gckVGHARDWARE  Hardware,
diff --git a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
index e3714b7..16b81ae 100644
--- a/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
+++ b/drivers/mxc/gpu-viv/arch/GC350/hal/kernel/gc_hal_kernel_hardware_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_kernel_hardware_vg_h_
 #define __gc_hal_kernel_hardware_vg_h_
 
@@ -69,6 +66,8 @@ struct _gckVGHARDWARE
     gctTHREAD                   timeIdleThread;
     gctBOOL                     killThread;
     gctPOINTER                  pageTableDirty;
+
+    gctBOOL                     powerManagement;
 };
 
 #endif /* __gc_hal_kernel_hardware_h_ */
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
index a52c1c8..24003e7 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_context.h"
@@ -474,7 +471,7 @@ _InitializeContextBuffer(
     index += _SwitchPipe(Context, index, gcvPIPE_3D);
 
     /* Current context pointer. */
-#if gcdDEBUG && 1
+#if gcdDEBUG
     index += _State(Context, index, 0x03850 >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
 #endif
 
@@ -1257,11 +1254,11 @@ gckCONTEXT_Construct(
             }
 
             /* Copy the current context. */
-            gcmkONERROR(gckOS_MemCopy(
+            gckOS_MemCopy(
                 tempContext->logical,
                 currContext->logical,
                 context->totalSize
-                ));
+                );
 
             /* Get the next context buffer. */
             tempContext = tempContext->next;
@@ -1442,7 +1439,7 @@ gckCONTEXT_Update(
             gcmkONERROR(gckKERNEL_OpenUserData(
                 kernel, needCopy,
                 Context->recordArray,
-                kDelta->recordArray, Context->recordArraySize,
+                gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
 
@@ -1551,13 +1548,13 @@ gckCONTEXT_Update(
             gcmkASSERT(kDelta->refCount >= 0);
 
             /* Get the next state delta. */
-            nDelta = kDelta->next;
+            nDelta = gcmUINT64_TO_PTR(kDelta->next);
 
             /* Get access to the state records. */
             gcmkONERROR(gckKERNEL_CloseUserData(
                 kernel, needCopy,
                 gcvFALSE,
-                kDelta->recordArray, Context->recordArraySize,
+                gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
                 (gctPOINTER *) &recordArray
                 ));
 
@@ -1704,7 +1701,7 @@ OnError:
         gcmkVERIFY_OK(gckKERNEL_CloseUserData(
             kernel, needCopy,
             gcvFALSE,
-            kDelta->recordArray, Context->recordArraySize,
+            gcmUINT64_TO_PTR(kDelta->recordArray), Context->recordArraySize,
             (gctPOINTER *) &recordArray
             ));
 	}
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
index a5030de..7554045 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_context.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_context_h_
 #define __gc_hal_kernel_context_h_
 
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
index 2812582..00f3839 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,13 +19,24 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_HARDWARE
 
+typedef struct _gcsiDEBUG_REGISTERS * gcsiDEBUG_REGISTERS_PTR;
+typedef struct _gcsiDEBUG_REGISTERS
+{
+    gctSTRING       module;
+    gctUINT         index;
+    gctUINT         shift;
+    gctUINT         data;
+    gctUINT         count;
+    gctUINT32       signature;
+}
+gcsiDEBUG_REGISTERS;
+
+extern int gpu3DMinClock;
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
@@ -165,6 +176,7 @@ _IdentifyHardware(
         Identity->chipMinorFeatures1 = 0;
         Identity->chipMinorFeatures2 = 0;
         Identity->chipMinorFeatures3 = 0;
+        Identity->chipMinorFeatures4 = 0;
     }
     else
     {
@@ -196,13 +208,20 @@ _IdentifyHardware(
                 gckOS_ReadRegisterEx(Os, Core,
                                      0x00088,
                                      &Identity->chipMinorFeatures3));
+
+            /* Read chip minor featuress register #4. */
+            gcmkONERROR(
+                gckOS_ReadRegisterEx(Os, Core,
+                                     0x00094,
+                                     &Identity->chipMinorFeatures4));
         }
         else
         {
-            /* Chip doesn't has minor features register #1 or 2 or 3. */
+            /* Chip doesn't has minor features register #1 or 2 or 3 or 4. */
             Identity->chipMinorFeatures1 = 0;
             Identity->chipMinorFeatures2 = 0;
             Identity->chipMinorFeatures3 = 0;
+            Identity->chipMinorFeatures4 = 0;
         }
     }
 
@@ -221,6 +240,16 @@ _IdentifyHardware(
         Identity->superTileMode = 0;
     }
 
+    /* Exception for GC1000, revision 5035 &  GC800, revision 4612 */
+    if (((Identity->chipModel == gcv1000) && ((Identity->chipRevision == 0x5035)
+                                           || (Identity->chipRevision == 0x5036)
+                                           || (Identity->chipRevision == 0x5037)))
+	 || ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4612)))
+    {
+        Identity->superTileMode = 1;
+    }
+
+
 	/* Disable HZ when EZ is present for older chips. */
 	if (!((((gctUINT32) (Identity->chipFeatures)) >> (0 ? 16:16) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))))
     {
@@ -237,6 +266,13 @@ _IdentifyHardware(
             = ((((gctUINT32) (Identity->chipMinorFeatures2)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
     }
 
+    if ((Identity->chipModel == gcv800) && (Identity->chipRevision == 0x4605))
+    {
+        /* Correct feature bit: RTL does not have such feature. */
+        Identity->chipFeatures
+            = ((((gctUINT32) (Identity->chipFeatures)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 31:31) - (0 ? 31:31) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)));
+    }
+
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
                    "Identity: chipFeatures=0x%08X",
                    Identity->chipFeatures);
@@ -257,6 +293,10 @@ _IdentifyHardware(
                    "Identity: chipMinorFeatures3=0x%08X",
                    Identity->chipMinorFeatures3);
 
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
+                   "Identity: chipMinorFeatures4=0x%08X",
+                   Identity->chipMinorFeatures4);
+
     /***************************************************************************
     ** Get chip specs.
     */
@@ -452,6 +492,157 @@ _PowerTimerFunction(
 }
 #endif
 
+static gceSTATUS
+_VerifyDMA(
+    IN gckOS Os,
+    IN gceCORE Core,
+    gctUINT32_PTR Address1,
+    gctUINT32_PTR Address2,
+    gctUINT32_PTR State1,
+    gctUINT32_PTR State2
+    )
+{
+    gceSTATUS status;
+    gctUINT32 i;
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State1));
+    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address1));
+
+    for (i = 0; i < 500; i += 1)
+    {
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State2));
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address2));
+
+        if (*Address1 != *Address2)
+        {
+            break;
+        }
+
+        if (*State1 != *State2)
+        {
+            break;
+        }
+    }
+
+OnError:
+    return status;
+}
+
+static gceSTATUS
+_DumpDebugRegisters(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gcsiDEBUG_REGISTERS_PTR Descriptor
+    )
+{
+    gceSTATUS status;
+    gctUINT32 select;
+    gctUINT32 data;
+    gctUINT i;
+
+    gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
+
+    gcmkPRINT_N(4, "    %s debug registers:\n", Descriptor->module);
+
+    for (i = 0; i < Descriptor->count; i += 1)
+    {
+        select = i << Descriptor->shift;
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, Descriptor->index, select));
+#if gcdFPGA_BUILD
+        gcmkONERROR(gckOS_Delay(Os, 1000));
+#endif
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, Descriptor->data, &data));
+
+        gcmkPRINT_N(12, "      [0x%02X] 0x%08X\n", i, data);
+    }
+
+    select = 0xF << Descriptor->shift;
+
+    for (i = 0; i < 500; i += 1)
+    {
+        gcmkONERROR(gckOS_WriteRegisterEx(Os, Core, Descriptor->index, select));
+#if gcdFPGA_BUILD
+        gcmkONERROR(gckOS_Delay(Os, 1000));
+#endif
+        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, Descriptor->data, &data));
+
+        if (data == Descriptor->signature)
+        {
+            break;
+        }
+    }
+
+    if (i == 500)
+    {
+        gcmkPRINT_N(4, "      failed to obtain the signature (read 0x%08X).\n", data);
+    }
+    else
+    {
+        gcmkPRINT_N(8, "      signature = 0x%08X (%d read attempt(s))\n", data, i + 1);
+    }
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
+static gceSTATUS
+_IsGPUPresent(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gcsHAL_QUERY_CHIP_IDENTITY identity;
+    gctUINT32 control;
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &control));
+
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)));
+    control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      control));
+
+    /* Identify the hardware. */
+    gcmkONERROR(_IdentifyHardware(Hardware->os,
+                                  Hardware->core,
+                                  &identity));
+
+    /* Check if these are the same values as saved before. */
+    if ((Hardware->identity.chipModel          != identity.chipModel)
+    ||  (Hardware->identity.chipRevision       != identity.chipRevision)
+    ||  (Hardware->identity.chipFeatures       != identity.chipFeatures)
+    ||  (Hardware->identity.chipMinorFeatures  != identity.chipMinorFeatures)
+    ||  (Hardware->identity.chipMinorFeatures1 != identity.chipMinorFeatures1)
+    ||  (Hardware->identity.chipMinorFeatures2 != identity.chipMinorFeatures2)
+    )
+    {
+        gcmkPRINT("[galcore]: GPU is not present.");
+        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
+    }
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
 /******************************************************************************\
 ****************************** gckHARDWARE API code *****************************
 \******************************************************************************/
@@ -527,6 +718,7 @@ gckHARDWARE_Construct(
 
     case gcv300:
     case gcv320:
+    case gcv420:
         hardware->type = gcvHARDWARE_2D;
         /*set outstanding limit*/
         gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x00414, &axi_ot));
@@ -572,7 +764,7 @@ gckHARDWARE_Construct(
     /* Initialize the fast clear. */
     gcmkONERROR(gckHARDWARE_SetFastClear(hardware, -1, -1));
 
-#if !gcdENABLE_128B_MERGE && 1 && 1
+#if !gcdENABLE_128B_MERGE
 
     if (((((gctUINT32) (hardware->identity.chipMinorFeatures2)) >> (0 ? 21:21) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))))
     {
@@ -608,6 +800,15 @@ gckHARDWARE_Construct(
 
     gcmkONERROR(gckOS_AtomConstruct(Os, &hardware->pageTableDirty));
 
+#if gcdLINK_QUEUE_SIZE
+    hardware->linkQueue.front = 0;
+    hardware->linkQueue.rear = 0;
+    hardware->linkQueue.count = 0;
+#endif
+
+    /* Enable power management by default. */
+    hardware->powerManagement = gcvTRUE;
+
     /* Return pointer to the gckHARDWARE object. */
     *Hardware = hardware;
 
@@ -639,7 +840,7 @@ OnError:
         if (hardware->powerOffTimer != gcvNULL)
         {
             gcmkVERIFY_OK(gckOS_StopTimer(Os, hardware->powerOffTimer));
-            gcmkVERIFY_OK(gckOS_DestoryTimer(Os, hardware->powerOffTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, hardware->powerOffTimer));
         }
 #endif
 
@@ -692,7 +893,7 @@ gckHARDWARE_Destroy(
 
 #if gcdPOWEROFF_TIMEOUT
     gcmkVERIFY_OK(gckOS_StopTimer(Hardware->os, Hardware->powerOffTimer));
-    gcmkVERIFY_OK(gckOS_DestoryTimer(Hardware->os, Hardware->powerOffTimer));
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Hardware->os, Hardware->powerOffTimer));
 #endif
 
     gcmkVERIFY_OK(gckOS_AtomDestroy(Hardware->os, Hardware->pageTableDirty));
@@ -842,7 +1043,7 @@ gckHARDWARE_InitializeHardware(
                                       0x00424,
                                       baseAddress));
 
-#if !VIVANTE_PROFILER && 1
+#if !VIVANTE_PROFILER
     {
         gctUINT32 data;
 
@@ -973,6 +1174,29 @@ gckHARDWARE_InitializeHardware(
                                   data));
     }
 
+#if gcdHZ_L2_DISALBE
+    /* Disable HZ-L2. */
+    if (((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 26:26) & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 26:26) - (0 ? 26:26) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 26:26) - (0 ? 26:26) + 1))))))) == gcvTRUE ||
+            ((((gctUINT32) (Hardware->identity.chipMinorFeatures3)) >> (0 ? 8:8) & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 8:8) - (0 ? 8:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:8) - (0 ? 8:8) + 1))))))) == gcvTRUE)
+    {
+		gctUINT32 data;
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 0x00414,
+                                 &data));
+
+        data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)));
+
+        gcmkONERROR(
+            gckOS_WriteRegisterEx(Hardware->os,
+                                  Hardware->core,
+                                  0x00414,
+                                  data));
+    }
+#endif
+
     /* Limit 2D outstanding request. */
     if ((Hardware->identity.chipModel == gcv320)
         && ((Hardware->identity.chipRevision == 0x5007)
@@ -1194,6 +1418,7 @@ gckHARDWARE_QueryChipIdentity(
     Identity->chipMinorFeatures1 = Hardware->identity.chipMinorFeatures1;
     Identity->chipMinorFeatures2 = Hardware->identity.chipMinorFeatures2;
     Identity->chipMinorFeatures3 = Hardware->identity.chipMinorFeatures3;
+    Identity->chipMinorFeatures4 = Hardware->identity.chipMinorFeatures4;
 
     /* Return chip specs. */
     Identity->streamCount            = Hardware->identity.streamCount;
@@ -2217,6 +2442,13 @@ gckHARDWARE_Link(
         /* Memory barrier. */
         gcmkONERROR(
             gckOS_MemoryBarrier(Hardware->os, logical));
+
+#if gcdLINK_QUEUE_SIZE && gcdVIRTUAL_COMMAND_BUFFER
+        if (address >= 0x80000000)
+        {
+            gckLINKQUEUE_Enqueue(&Hardware->linkQueue, address, address + bytes);
+        }
+#endif
     }
 
     if (Bytes != gcvNULL)
@@ -2912,7 +3144,7 @@ gckHARDWARE_FlushMMU(
             | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
         buffer[9]
-            = (((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) &  ((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) );
+            = (((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4))) &  ((((gctUINT32) (~0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))) | (((gctUINT32) (0x0 & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7))));
 
         /* Arm the PE-FE Semaphore. */
         buffer[10]
@@ -3443,7 +3675,7 @@ typedef enum
 }
 gcePOWER_FLAGS;
 
-#if gcmIS_DEBUG(gcdDEBUG_TRACE) && gcdPOWER_MANAGEMENT
+#if gcmIS_DEBUG(gcdDEBUG_TRACE)
 static gctCONST_STRING
 _PowerEnum(gceCHIPPOWERSTATE State)
 {
@@ -3492,7 +3724,6 @@ gckHARDWARE_SetPowerManagementState(
     IN gceCHIPPOWERSTATE State
     )
 {
-#if gcdPOWER_MANAGEMENT
     gceSTATUS status;
     gckCOMMAND command = gcvNULL;
     gckOS os;
@@ -3624,6 +3855,12 @@ gckHARDWARE_SetPowerManagementState(
     command = Hardware->kernel->command;
     gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
 
+    if (Hardware->powerManagement == gcvFALSE)
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
     /* Start profiler. */
     gcmkPROFILE_INIT(freq, time);
 
@@ -3916,6 +4153,43 @@ gckHARDWARE_SetPowerManagementState(
         /* Mark clock and power as enabled. */
         Hardware->clockState = gcvTRUE;
         Hardware->powerState = gcvTRUE;
+
+        for (;;)
+        {
+            /* Check if GPU is present and awake. */
+            status = _IsGPUPresent(Hardware);
+
+            /* Check if the GPU is not responding. */
+            if (status == gcvSTATUS_GPU_NOT_RESPONDING)
+            {
+                /* Turn off the power and clock. */
+                gcmkONERROR(gckOS_SetGPUPower(os, Hardware->core, gcvFALSE, gcvFALSE));
+
+                Hardware->clockState = gcvFALSE;
+                Hardware->powerState = gcvFALSE;
+
+                /* Wait a little. */
+                gckOS_Delay(os, 1);
+
+                /* Turn on the power and clock. */
+                gcmkONERROR(gckOS_SetGPUPower(os, Hardware->core, gcvTRUE, gcvTRUE));
+
+                Hardware->clockState = gcvTRUE;
+                Hardware->powerState = gcvTRUE;
+
+                /* We need to initialize the hardware and start the command
+                 * processor. */
+                flag |= gcvPOWER_FLAG_INITIALIZE | gcvPOWER_FLAG_START;
+            }
+            else
+            {
+                /* Test for error. */
+                gcmkONERROR(status);
+
+                /* Break out of loop. */
+                break;
+            }
+        }
     }
 
     /* Get time until powered on. */
@@ -4015,7 +4289,10 @@ gckHARDWARE_SetPowerManagementState(
     gcmkPROFILE_QUERY(time, stopTime);
 
     /* Only process this when hardware is enabled. */
-    if (Hardware->clockState && Hardware->powerState)
+    if (Hardware->clockState && Hardware->powerState
+    /* Don't touch clock control if dynamic frequency scaling is available. */
+    && gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_DYNAMIC_FREQUENCY_SCALING) != gcvTRUE
+    )
     {
         if (flag & (gcvPOWER_FLAG_POWER_OFF | gcvPOWER_FLAG_CLOCK_OFF))
         {
@@ -4149,6 +4426,13 @@ gckHARDWARE_SetPowerManagementState(
     /* Save the new power state. */
     Hardware->chipPowerState = State;
 
+#if gcdDVFS
+    if (State == gcvPOWER_ON && Hardware->kernel->dvfs)
+    {
+        gckDVFS_Start(Hardware->kernel->dvfs);
+    }
+#endif
+
 #if gcdPOWEROFF_TIMEOUT
     /* Reset power off time */
     gcmkONERROR(gckOS_GetTicks(&currentTime));
@@ -4227,10 +4511,6 @@ OnError:
     /* Return the status. */
     gcmkFOOTER();
     return status;
-#else /* gcdPOWER_MANAGEMENT */
-    /* Do nothing */
-    return gcvSTATUS_OK;
-#endif
 }
 
 /*******************************************************************************
@@ -4268,6 +4548,40 @@ gckHARDWARE_QueryPowerManagementState(
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_SetPowerManagement
+**
+**  Configure GPU power management function.
+**  Only used in driver initialization stage.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**      gctBOOL PowerManagement
+**          Power Mangement State.
+**
+*/
+gceSTATUS
+gckHARDWARE_SetPowerManagement(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    )
+{
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    Hardware->powerManagement = PowerManagement;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 #if gcdENABLE_FSCALE_VAL_ADJUST
 gceSTATUS
 gckHARDWARE_SetFscaleValue(
@@ -4367,7 +4681,10 @@ gckHARDWARE_GetFscaleValue(
     )
 {
     *FscaleValue = Hardware->powerOnFscaleVal;
-    *MinFscaleValue = 1;
+    if ((gpu3DMinClock > 0) && (gpu3DMinClock <= 64) && (Hardware->core == gcvCORE_MAJOR))
+        *MinFscaleValue = gpu3DMinClock;
+    else
+        *MinFscaleValue = 1;
     *MaxFscaleValue = 64;
 
     return gcvSTATUS_OK;
@@ -4500,6 +4817,21 @@ OnError:
                              GC_DEBUG_SIGNALS_##block##_Address, \
                              &profiler->data))
 
+#define gcmkREAD_DEBUG_REGISTER_N(control, block, index, data) \
+    gcmkONERROR(\
+        gckOS_WriteRegisterEx(Hardware->os, \
+                              Hardware->core, \
+                              GC_DEBUG_CONTROL##control##_Address, \
+                              gcmSETFIELD(0, \
+                                          GC_DEBUG_CONTROL##control, \
+                                          block, \
+                                          index))); \
+    gcmkONERROR(\
+        gckOS_ReadRegisterEx(Hardware->os, \
+                             Hardware->core, \
+                             GC_DEBUG_SIGNALS_##block##_Address, \
+                             &data))
+
 #define gcmkRESET_DEBUG_REGISTER(control, block) \
     gcmkONERROR(\
         gckOS_WriteRegisterEx(Hardware->os, \
@@ -4584,11 +4916,15 @@ OnError:
 gceSTATUS
 gckHARDWARE_QueryProfileRegisters(
     IN gckHARDWARE Hardware,
+    IN gctBOOL   Reset,
     OUT gcsPROFILER_COUNTERS * Counters
     )
 {
     gceSTATUS status;
     gcsPROFILER_COUNTERS * profiler = Counters;
+    gctUINT i, clock;
+    gctUINT32 colorKilled, colorDrawn, depthKilled, depthDrawn;
+    gctUINT32 totalRead, totalWrite;
 
     gcmkHEADER_ARG("Hardware=0x%x Counters=0x%x", Hardware, Counters);
 
@@ -4599,16 +4935,6 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(
         gckOS_ReadRegisterEx(Hardware->os,
                              Hardware->core,
-                             0x00040,
-                             &profiler->gpuTotalRead64BytesPerFrame));
-    gcmkONERROR(
-        gckOS_ReadRegisterEx(Hardware->os,
-                             Hardware->core,
-                             0x00044,
-                             &profiler->gpuTotalWrite64BytesPerFrame));
-    gcmkONERROR(
-        gckOS_ReadRegisterEx(Hardware->os,
-                             Hardware->core,
                              0x00438,
                              &profiler->gpuCyclesCounter));
 
@@ -4624,28 +4950,76 @@ gckHARDWARE_QueryProfileRegisters(
                              0x0007C,
                              &profiler->gpuIdleCyclesCounter));
 
-    /* Reset counters. */
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
-
-    /* PE */
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_killed_by_color_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_killed_by_depth_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_drawn_by_color_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
-gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &profiler->pe_pixel_count_drawn_by_depth_pipe));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+
+    /* Read clock control register. */
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x00000,
+                                     &clock));
+
+    profiler->gpuTotalRead64BytesPerFrame = 0;
+    profiler->gpuTotalWrite64BytesPerFrame = 0;
+    profiler->pe_pixel_count_killed_by_color_pipe = 0;
+    profiler->pe_pixel_count_killed_by_depth_pipe = 0;
+    profiler->pe_pixel_count_drawn_by_color_pipe = 0;
+    profiler->pe_pixel_count_drawn_by_depth_pipe = 0;
+
+     /* Walk through all avaiable pixel pipes. */
+    for (i = 0; i < Hardware->identity.pixelPipes; ++i)
+    {
+        /* Select proper pipe. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                           Hardware->core,
+                                           0x00000,
+                                           ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:20) - (0 ? 23:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:20) - (0 ? 23:20) + 1))))))) << (0 ? 23:20))) | (((gctUINT32) ((gctUINT32) (i) & ((gctUINT32) ((((1 ? 23:20) - (0 ? 23:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:20) - (0 ? 23:20) + 1))))))) << (0 ? 23:20)))));
+
+        /* BW */
+        gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00040,
+                             &totalRead));
+        gcmkONERROR(
+        gckOS_ReadRegisterEx(Hardware->os,
+                             Hardware->core,
+                             0x00044,
+                             &totalWrite));
+
+        profiler->gpuTotalRead64BytesPerFrame += totalRead;
+        profiler->gpuTotalWrite64BytesPerFrame += totalWrite;
+
+        /* PE */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorKilled));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &depthKilled));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &colorDrawn));
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))));gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00454, &depthDrawn));
+
+        profiler->pe_pixel_count_killed_by_color_pipe += colorKilled;
+        profiler->pe_pixel_count_killed_by_depth_pipe += depthKilled;
+        profiler->pe_pixel_count_drawn_by_color_pipe += colorDrawn;
+        profiler->pe_pixel_count_drawn_by_depth_pipe += depthDrawn;
+    }
+
+    /* Reset clock control register. */
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x00000,
+                                      clock));
+
+    if(Reset){
+            /* Reset counters. */
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 1));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0003C, 0));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+            gcmkONERROR(
+                gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
+            gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
 ));
+    }
 
     /* SH */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (7) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
@@ -4664,9 +5038,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_branch_inst_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0045C, &profiler->pxl_texld_inst_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    if(Reset){  gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00470,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
-));
+));}
 
     /* PA */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
@@ -4681,18 +5055,18 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_trivial_rejected_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00460, &profiler->pa_culled_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
-));
+));}
 
     /* SE */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_triangle_count));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00464, &profiler->se_culled_lines_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
-));
+));}
 
     /* RA */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
@@ -4707,9 +5081,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_pipe_cache_miss_counter));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 23:16) - (0 ? 23:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:16) - (0 ? 23:16) + 1))))))) << (0 ? 23:16)))
-));
+));}
 
     /* TX */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
@@ -4730,9 +5104,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_hit_texel_count));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0044C, &profiler->tx_cache_miss_texel_count));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00474,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 31:24) - (0 ? 31:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
-));
+));}
 
     /* MC */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
@@ -4741,9 +5115,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_read_req_8B_from_IP));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 7:0) - (0 ? 7:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
-));
+));}
 
     /* HI */
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
@@ -4752,9 +5126,9 @@ gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profile
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_request_stalled));
     gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, Hardware->core, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
-    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
+    if(Reset){ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) ));
 gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
-));
+));}
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -5222,6 +5596,11 @@ gckHARDWARE_IsFeatureAvailable(
     case gcvFEATURE_MC20:
         available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures)) >> (0 ? 22:22) & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1)))))) == (0x1  & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1)))))));
         break;
+    case gcvFEATURE_DYNAMIC_FREQUENCY_SCALING:
+        /* This feature doesn't apply for 2D cores. */
+        available = ((((gctUINT32) (Hardware->identity.chipMinorFeatures2)) >> (0 ? 14:14) & ((gctUINT32) ((((1 ? 14:14) - (0 ? 14:14) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 14:14) - (0 ? 14:14) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 14:14) - (0 ? 14:14) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 14:14) - (0 ? 14:14) + 1)))))))
+            &&      ((((gctUINT32) (Hardware->identity.chipFeatures)) >> (0 ? 2:2) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))));
+        break;
 
     default:
         gcmkFATAL("Invalid feature has been requested.");
@@ -5264,8 +5643,14 @@ gckHARDWARE_DumpMMUException(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-    gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                   "  *** MMU ERROR ***\n");
+    gcmkPRINT("GPU[%d](ChipModel=0x%x ChipRevision=0x%x):\n",
+              Hardware->core,
+              Hardware->identity.chipModel,
+              Hardware->identity.chipRevision);
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("***   MMU ERROR DUMP   ***\n");
+    gcmkPRINT("**************************\n");
 
     gcmkVERIFY_OK(
         gckOS_ReadRegisterEx(Hardware->os,
@@ -5273,9 +5658,7 @@ gckHARDWARE_DumpMMUException(
                              0x00188,
                              &mmuStatus));
 
-    gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                   "  MMU status = 0x%08X\n",
-                   mmuStatus);
+    gcmkPRINT("  MMU status = 0x%08X\n", mmuStatus);
 
     for (i = 0; i < 4; i += 1)
     {
@@ -5290,56 +5673,41 @@ gckHARDWARE_DumpMMUException(
         switch (mmu)
         {
         case 1:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: slave not present\n",
-                            i);
+              gcmkPRINT("  MMU%d: slave not present\n", i);
               break;
 
         case 2:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: page not present\n",
-                            i);
+              gcmkPRINT("  MMU%d: page not present\n", i);
               break;
 
         case 3:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: write violation\n",
-                            i);
+              gcmkPRINT("  MMU%d: write violation\n", i);
               break;
 
         default:
-              gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                            "  MMU%d: unknown state\n",
-                            i);
+              gcmkPRINT("  MMU%d: unknown state\n", i);
         }
 
         gcmkVERIFY_OK(
             gckOS_ReadRegisterEx(Hardware->os,
                                  Hardware->core,
-                                 0x00190 + i,
+                                 0x00190 + i * 4,
                                  &address));
 
-#if gcdDEBUG
         mtlb   = (address & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT;
         stlb   = (address & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
         offset =  address & gcdMMU_OFFSET_4K_MASK;
-#endif
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "  MMU%d: exception address = 0x%08X\n",
-                     i, address);
+        gcmkPRINT("  MMU%d: exception address = 0x%08X\n", i, address);
+
+        gcmkPRINT("    MTLB entry = %d\n", mtlb);
+
+        gcmkPRINT("    STLB entry = %d\n", stlb);
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "    MTLB entry = %d\n",
-                     mtlb);
+        gcmkPRINT("    Offset = 0x%08X (%d)\n", offset, offset);
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "    STLB entry = %d\n",
-                     stlb);
+        gckMMU_DumpPageTableEntry(Hardware->kernel->mmu, address);
 
-        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_HARDWARE,
-                     "    Offset = 0x%08X (%d)\n",
-                     offset, offset);
     }
 
 	gcmkFOOTER_NO();
@@ -5353,6 +5721,240 @@ gckHARDWARE_DumpMMUException(
     return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_DumpGPUState
+**
+**  Dump the GPU debug registers.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckHARDWARE_DumpGPUState(
+    IN gckHARDWARE Hardware
+    )
+{
+    static gctCONST_STRING _cmdState[] =
+    {
+        "PAR_IDLE_ST", "PAR_DEC_ST", "PAR_ADR0_ST", "PAR_LOAD0_ST",
+        "PAR_ADR1_ST", "PAR_LOAD1_ST", "PAR_3DADR_ST", "PAR_3DCMD_ST",
+        "PAR_3DCNTL_ST", "PAR_3DIDXCNTL_ST", "PAR_INITREQDMA_ST",
+        "PAR_DRAWIDX_ST", "PAR_DRAW_ST", "PAR_2DRECT0_ST", "PAR_2DRECT1_ST",
+        "PAR_2DDATA0_ST", "PAR_2DDATA1_ST", "PAR_WAITFIFO_ST", "PAR_WAIT_ST",
+        "PAR_LINK_ST", "PAR_END_ST", "PAR_STALL_ST"
+    };
+
+    static gctCONST_STRING _cmdDmaState[] =
+    {
+        "CMD_IDLE_ST", "CMD_START_ST", "CMD_REQ_ST", "CMD_END_ST"
+    };
+
+    static gctCONST_STRING _cmdFetState[] =
+    {
+        "FET_IDLE_ST", "FET_RAMVALID_ST", "FET_VALID_ST"
+    };
+
+    static gctCONST_STRING _reqDmaState[] =
+    {
+        "REQ_IDLE_ST", "REQ_WAITIDX_ST", "REQ_CAL_ST"
+    };
+
+    static gctCONST_STRING _calState[] =
+    {
+        "CAL_IDLE_ST", "CAL_LDADR_ST", "CAL_IDXCALC_ST"
+    };
+
+    static gctCONST_STRING _veReqState[] =
+    {
+        "VER_IDLE_ST", "VER_CKCACHE_ST", "VER_MISS_ST"
+    };
+
+    static gcsiDEBUG_REGISTERS _dbgRegs[] =
+    {
+        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
+        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
+        { "FE", 0x470, 0, 0x450, 16, 0xBABEF00D },
+        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
+        { "DE", 0x470, 8, 0x458, 16, 0xBABEF00D },
+        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
+        { "PA", 0x474, 0, 0x460, 16, 0x0000AAAA },
+        { "SE", 0x474, 8, 0x464, 16, 0x5E5E5E5E },
+        { "MC", 0x478, 0, 0x468, 16, 0x12345678 },
+        { "HI", 0x478, 8, 0x46C, 16, 0xAAAAAAAA }
+    };
+
+    static gctUINT32 _otherRegs[] =
+    {
+        0x040, 0x044, 0x04C, 0x050, 0x054, 0x058, 0x05C, 0x060,
+        0x43c, 0x440, 0x444, 0x414,
+    };
+
+    gceSTATUS status;
+    gckKERNEL kernel;
+    gctUINT32 idle, axi;
+    gctUINT32 dmaAddress1, dmaAddress2;
+    gctUINT32 dmaState1, dmaState2;
+    gctUINT32 dmaLow, dmaHigh;
+    gctUINT32 cmdState, cmdDmaState, cmdFetState;
+    gctUINT32 dmaReqState, calState, veReqState;
+    gctUINT i;
+    gctUINT pipe, pixelPipes;
+    gctUINT32 control, oldControl;
+    gckOS os = Hardware->os;
+    gceCORE core = Hardware->core;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    kernel = Hardware->kernel;
+
+    gcmkPRINT_N(12, "GPU[%d](ChipModel=0x%x ChipRevision=0x%x):\n",
+                core,
+                Hardware->identity.chipModel,
+                Hardware->identity.chipRevision);
+
+    pixelPipes = Hardware->identity.pixelPipes
+               ? Hardware->identity.pixelPipes
+               : 1;
+
+    /* Reset register values. */
+    idle        = axi         =
+    dmaState1   = dmaState2   =
+    dmaAddress1 = dmaAddress2 =
+    dmaLow      = dmaHigh     = 0;
+
+    /* Verify whether DMA is running. */
+    gcmkONERROR(_VerifyDMA(
+        os, core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
+        ));
+
+    cmdState    =  dmaState2        & 0x1F;
+    cmdDmaState = (dmaState2 >>  8) & 0x03;
+    cmdFetState = (dmaState2 >> 10) & 0x03;
+    dmaReqState = (dmaState2 >> 12) & 0x03;
+    calState    = (dmaState2 >> 14) & 0x03;
+    veReqState  = (dmaState2 >> 16) & 0x03;
+
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x004, &idle));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00C, &axi));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x668, &dmaLow));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x66C, &dmaHigh));
+
+    gcmkPRINT_N(0, "**************************\n");
+    gcmkPRINT_N(0, "***   GPU STATE DUMP   ***\n");
+    gcmkPRINT_N(0, "**************************\n");
+
+    gcmkPRINT_N(4, "  axi      = 0x%08X\n", axi);
+
+    gcmkPRINT_N(4, "  idle     = 0x%08X\n", idle);
+    if ((idle & 0x00000001) == 0) gcmkPRINT_N(0, "    FE not idle\n");
+    if ((idle & 0x00000002) == 0) gcmkPRINT_N(0, "    DE not idle\n");
+    if ((idle & 0x00000004) == 0) gcmkPRINT_N(0, "    PE not idle\n");
+    if ((idle & 0x00000008) == 0) gcmkPRINT_N(0, "    SH not idle\n");
+    if ((idle & 0x00000010) == 0) gcmkPRINT_N(0, "    PA not idle\n");
+    if ((idle & 0x00000020) == 0) gcmkPRINT_N(0, "    SE not idle\n");
+    if ((idle & 0x00000040) == 0) gcmkPRINT_N(0, "    RA not idle\n");
+    if ((idle & 0x00000080) == 0) gcmkPRINT_N(0, "    TX not idle\n");
+    if ((idle & 0x00000100) == 0) gcmkPRINT_N(0, "    VG not idle\n");
+    if ((idle & 0x00000200) == 0) gcmkPRINT_N(0, "    IM not idle\n");
+    if ((idle & 0x00000400) == 0) gcmkPRINT_N(0, "    FP not idle\n");
+    if ((idle & 0x00000800) == 0) gcmkPRINT_N(0, "    TS not idle\n");
+    if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
+
+    if (
+        (dmaAddress1 == dmaAddress2)
+     && (dmaState1 == dmaState2)
+    )
+    {
+        gcmkPRINT_N(0, "  DMA appears to be stuck at this address:\n");
+        gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
+    }
+    else
+    {
+        if (dmaAddress1 == dmaAddress2)
+        {
+            gcmkPRINT_N(0, "  DMA address is constant, but state is changing:\n");
+            gcmkPRINT_N(4, "    0x%08X\n", dmaState1);
+            gcmkPRINT_N(4, "    0x%08X\n", dmaState2);
+        }
+        else
+        {
+            gcmkPRINT_N(0, "  DMA is running; known addresses are:\n");
+            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
+            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress2);
+        }
+    }
+    gcmkPRINT_N(4, "  dmaLow   = 0x%08X\n", dmaLow);
+    gcmkPRINT_N(4, "  dmaHigh  = 0x%08X\n", dmaHigh);
+    gcmkPRINT_N(4, "  dmaState = 0x%08X\n", dmaState2);
+    gcmkPRINT_N(8, "    command state       = %d (%s)\n", cmdState, _cmdState   [cmdState]);
+    gcmkPRINT_N(8, "    command DMA state   = %d (%s)\n", cmdDmaState, _cmdDmaState[cmdDmaState]);
+    gcmkPRINT_N(8, "    command fetch state = %d (%s)\n", cmdFetState, _cmdFetState[cmdFetState]);
+    gcmkPRINT_N(8, "    DMA request state   = %d (%s)\n", dmaReqState, _reqDmaState[dmaReqState]);
+    gcmkPRINT_N(8, "    cal state           = %d (%s)\n", calState, _calState   [calState]);
+    gcmkPRINT_N(8, "    VE request state    = %d (%s)\n", veReqState, _veReqState [veReqState]);
+
+    /* Record control. */
+    gckOS_ReadRegisterEx(os, core, 0x0, &oldControl);
+
+    for (pipe = 0; pipe < pixelPipes; pipe++)
+    {
+        gcmkPRINT_N(4, "  Debug registers of pipe[%d]:\n", pipe);
+
+        /* Switch pipe. */
+        gckOS_ReadRegisterEx(os, core, 0x0, &control);
+        control &= ~(0xF << 20);
+        control |= (pipe << 20);
+        gckOS_WriteRegisterEx(os, core, 0x0, control);
+
+        for (i = 0; i < gcmCOUNTOF(_dbgRegs); i += 1)
+        {
+            gcmkONERROR(_DumpDebugRegisters(os, core, &_dbgRegs[i]));
+        }
+
+        gcmkPRINT_N(0, "    Other Registers:\n");
+        for (i = 0; i < gcmCOUNTOF(_otherRegs); i += 1)
+        {
+            gctUINT32 read;
+            gcmkONERROR(gckOS_ReadRegisterEx(os, core, _otherRegs[i], &read));
+            gcmkPRINT_N(12, "      [0x%04X] 0x%08X\n", _otherRegs[i], read);
+        }
+    }
+
+    if (kernel->hardware->identity.chipFeatures & (1 << 4))
+    {
+        gctUINT32 read0, read1, write;
+
+        read0 = read1 = write = 0;
+
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x43C, &read0));
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x440, &read1));
+        gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x444, &write));
+
+        gcmkPRINT_N(4, "  read0    = 0x%08X\n", read0);
+        gcmkPRINT_N(4, "  read1    = 0x%08X\n", read1);
+        gcmkPRINT_N(4, "  write    = 0x%08X\n", write);
+    }
+
+    /* Restore control. */
+    gckOS_WriteRegisterEx(os, core, 0x0, oldControl);
+
+    /* dump stack. */
+    gckOS_DumpCallStack(os);
+
+OnError:
+
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
+}
+
 
 #if gcdFRAME_DB
 static gceSTATUS
@@ -5752,3 +6354,194 @@ OnError:
 }
 #endif
 
+#if gcdDVFS
+#define READ_FROM_EATER1 0
+
+gceSTATUS
+gckHARDWARE_QueryLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 * Load
+    )
+{
+    gctUINT32 debug1;
+    gceSTATUS status;
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Load != gcvNULL);
+
+    gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE);
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00110,
+                                         Load));
+#if READ_FROM_EATER1
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00134,
+                                         Load));
+#endif
+
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00114,
+                                         &debug1));
+
+        /* Patch result of 0x110 with result of 0x114. */
+        if ((debug1 & 0xFF) == 1)
+        {
+            *Load &= ~0xFF;
+            *Load |= 1;
+        }
+
+        if (((debug1 & 0xFF00) >> 8) == 1)
+        {
+            *Load &= ~(0xFF << 8);
+            *Load |= 1 << 8;
+        }
+
+        if (((debug1 & 0xFF0000) >> 16) == 1)
+        {
+            *Load &= ~(0xFF << 16);
+            *Load |= 1 << 16;
+        }
+
+        if (((debug1 & 0xFF000000) >> 24) == 1)
+        {
+            *Load &= ~(0xFF << 24);
+            *Load |= 1 << 24;
+        }
+    }
+    else
+    {
+        status = gcvSTATUS_INVALID_REQUEST;
+    }
+
+OnError:
+
+    gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_SetDVFSPeroid(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 Frequency
+    )
+{
+    gceSTATUS status;
+    gctUINT32 period;
+    gctUINT32 eater;
+
+#if READ_FROM_EATER1
+    gctUINT32 period1;
+    gctUINT32 eater1;
+#endif
+
+    gcmkHEADER_ARG("Hardware=0x%X Frequency=%d", Hardware, Frequency);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    period = 0;
+
+    while((64 << period) < (gcdDVFS_ANAYLSE_WINDOW * Frequency * 1000) )
+    {
+        period++;
+    }
+
+#if READ_FROM_EATER1
+    /*
+    *  Peroid = F * 1000 * 1000 / (60 * 16 * 1024);
+    */
+    period1 = Frequency * 6250 / 6114;
+#endif
+
+    gckOS_AcquireMutex(Hardware->os, Hardware->powerMutex, gcvINFINITE);
+
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        /* Get current configure. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x0010C,
+                                         &eater));
+
+        /* Change peroid. */
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x0010C,
+                                          ((((gctUINT32) (eater)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8))) | (((gctUINT32) ((gctUINT32) (period) & ((gctUINT32) ((((1 ? 15:8) - (0 ? 15:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))));
+
+#if READ_FROM_EATER1
+        /* Config eater1. */
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                         Hardware->core,
+                                         0x00130,
+                                         &eater1));
+
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                          Hardware->core,
+                                          0x00130,
+                                          ((((gctUINT32) (eater1)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16))) | (((gctUINT32) ((gctUINT32) (period1) & ((gctUINT32) ((((1 ? 31:16) - (0 ? 31:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16)))));
+#endif
+    }
+    else
+    {
+        status = gcvSTATUS_INVALID_REQUEST;
+    }
+
+OnError:
+    gckOS_ReleaseMutex(Hardware->os, Hardware->powerMutex);
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_InitDVFS(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status;
+    gctUINT32 data;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+
+    gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os,
+                                     Hardware->core,
+                                     0x0010C,
+                                     &data));
+
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 18:18) - (0 ? 18:18) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 18:18) - (0 ? 18:18) + 1))))))) << (0 ? 18:18))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 18:18) - (0 ? 18:18) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 18:18) - (0 ? 18:18) + 1))))))) << (0 ? 18:18)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 23:23) - (0 ? 23:23) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 23:23) - (0 ? 23:23) + 1))))))) << (0 ? 23:23)));
+    data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 22:22) - (0 ? 22:22) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22)));
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
+                   "DVFS Configure=0x%X",
+                   data);
+
+    gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os,
+                                      Hardware->core,
+                                      0x0010C,
+                                      data));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+#endif
+
+
diff --git a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
index 8a96d1f..37226b7 100644
--- a/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
+++ b/drivers/mxc/gpu-viv/arch/XAQ2/hal/kernel/gc_hal_kernel_hardware.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_hardware_h_
 #define __gc_hal_kernel_hardware_h_
 
@@ -88,6 +86,12 @@ struct _gckHARDWARE
     /* FSCALE_VAL when gcvPOWER_ON. */
     gctUINT32                   powerOnFscaleVal;
 #endif
+
+#if gcdLINK_QUEUE_SIZE
+    struct _gckLINKQUEUE        linkQueue;
+#endif
+
+    gctBOOL                     powerManagement;
 };
 
 gceSTATUS
diff --git a/drivers/mxc/gpu-viv/config b/drivers/mxc/gpu-viv/config
index 7e6e867..cdd143e 100644
--- a/drivers/mxc/gpu-viv/config
+++ b/drivers/mxc/gpu-viv/config
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (C) 2005 - 2012 by Vivante Corp.
+#    Copyright (C) 2005 - 2013 by Vivante Corp.
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
@@ -22,7 +22,6 @@
 ARCH_TYPE                         ?= arm
 SDK_DIR                           ?= $(AQROOT)/build/sdk
 USE_3D_VG                         ?= 1
-USE_POWER_MANAGEMENT              ?= 1
 FORCE_ALL_VIDEO_MEMORY_CACHED     ?= 0
 NONPAGED_MEMORY_CACHEABLE         ?= 0
 NONPAGED_MEMORY_BUFFERABLE        ?= 1
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
index 3a5ba82..b7b0d28 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
@@ -70,6 +68,9 @@ gctCONST_STRING _DispatchText[] =
     gcmDEFINE2TEXT(gcvHAL_GET_PROFILE_SETTING),
     gcmDEFINE2TEXT(gcvHAL_SET_PROFILE_SETTING),
     gcmDEFINE2TEXT(gcvHAL_READ_ALL_PROFILE_REGISTERS),
+#if VIVANTE_PROFILER_PERDRAW
+    gcmDEFINE2TEXT(gcvHAL_READ_PROFILER_REGISTER_SETTING),
+#endif
     gcmDEFINE2TEXT(gcvHAL_PROFILE_REGISTERS_2D),
     gcmDEFINE2TEXT(gcvHAL_SET_POWER_MANAGEMENT_STATE),
     gcmDEFINE2TEXT(gcvHAL_QUERY_POWER_MANAGEMENT_STATE),
@@ -173,6 +174,15 @@ gckKERNEL_Construct(
     kernel->command      = gcvNULL;
     kernel->eventObj     = gcvNULL;
     kernel->mmu          = gcvNULL;
+#if gcdDVFS
+    kernel->dvfs         = gcvNULL;
+#endif
+
+    /* Initialize the gckKERNEL object. */
+    kernel->object.type = gcvOBJ_KERNEL;
+    kernel->os          = Os;
+    kernel->core        = Core;
+
 
     if (SharedDB == gcvNULL)
     {
@@ -197,6 +207,12 @@ gckKERNEL_Construct(
 
         /* Construct a database mutex. */
         gcmkONERROR(gckOS_CreateMutex(Os, &kernel->db->dbMutex));
+
+        /* Construct a id-pointer database. */
+        gcmkONERROR(gckKERNEL_CreateIntegerDatabase(kernel, &kernel->db->pointerDatabase));
+
+        /* Construct a id-pointer database mutex. */
+        gcmkONERROR(gckOS_CreateMutex(Os, &kernel->db->pointerDatabaseMutex));
     }
     else
     {
@@ -212,11 +228,6 @@ gckKERNEL_Construct(
 
     kernel->timeOut      = gcdGPU_TIMEOUT;
 
-    /* Initialize the gckKERNEL object. */
-    kernel->object.type = gcvOBJ_KERNEL;
-    kernel->os          = Os;
-    kernel->core        = Core;
-
     /* Save context. */
     kernel->context = Context;
 
@@ -276,6 +287,16 @@ gckKERNEL_Construct(
                               (gctTIMERFUNCTION)_ResetFinishFunction,
                               (gctPOINTER)kernel,
                               &kernel->resetFlagClearTimer));
+        kernel->resetTimeStamp = 0;
+#endif
+
+#if gcdDVFS
+        if (gckHARDWARE_IsFeatureAvailable(kernel->hardware,
+                                           gcvFEATURE_DYNAMIC_FREQUENCY_SCALING))
+        {
+            gcmkONERROR(gckDVFS_Construct(kernel->hardware, &kernel->dvfs));
+            gcmkONERROR(gckDVFS_Start(kernel->dvfs));
+        }
 #endif
     }
 
@@ -286,6 +307,7 @@ gckKERNEL_Construct(
 #else
     kernel->profileEnable = gcvTRUE;
 #endif
+    kernel->profileCleanRegister = gcvTRUE;
 
     gcmkVERIFY_OK(
         gckOS_MemCopy(kernel->profileFileName,
@@ -342,7 +364,7 @@ OnError:
         if (kernel->resetFlagClearTimer)
         {
             gcmkVERIFY_OK(gckOS_StopTimer(Os, kernel->resetFlagClearTimer));
-            gcmkVERIFY_OK(gckOS_DestoryTimer(Os, kernel->resetFlagClearTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Os, kernel->resetFlagClearTimer));
         }
 #endif
 
@@ -365,6 +387,14 @@ OnError:
         }
 #endif
 
+#if gcdDVFS
+        if (kernel->dvfs)
+        {
+            gcmkVERIFY_OK(gckDVFS_Stop(kernel->dvfs));
+            gcmkVERIFY_OK(gckDVFS_Destroy(kernel->dvfs));
+        }
+#endif
+
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Os, kernel));
     }
 
@@ -440,6 +470,13 @@ gckKERNEL_Destroy(
 
         /* Destroy the database mutex. */
         gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->db->dbMutex));
+
+
+        /* Destroy id-pointer database. */
+        gcmkVERIFY_OK(gckKERNEL_DestroyIntegerDatabase(Kernel, Kernel->db->pointerDatabase));
+
+        /* Destroy id-pointer database mutex. */
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->db->pointerDatabaseMutex));
     }
 
 #if gcdENABLE_VG
@@ -468,7 +505,7 @@ gckKERNEL_Destroy(
         if (Kernel->resetFlagClearTimer)
         {
             gcmkVERIFY_OK(gckOS_StopTimer(Kernel->os, Kernel->resetFlagClearTimer));
-            gcmkVERIFY_OK(gckOS_DestoryTimer(Kernel->os, Kernel->resetFlagClearTimer));
+            gcmkVERIFY_OK(gckOS_DestroyTimer(Kernel->os, Kernel->resetFlagClearTimer));
         }
 #endif
     }
@@ -480,6 +517,14 @@ gckKERNEL_Destroy(
     gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, Kernel->virtualBufferLock));
 #endif
 
+#if gcdDVFS
+    if (Kernel->dvfs)
+    {
+        gcmkVERIFY_OK(gckDVFS_Stop(Kernel->dvfs));
+        gcmkVERIFY_OK(gckDVFS_Destroy(Kernel->dvfs));
+    }
+#endif
+
     /* Mark the gckKERNEL object as unknown. */
     Kernel->object.type = gcvOBJ_UNKNOWN;
 
@@ -491,6 +536,97 @@ gckKERNEL_Destroy(
     return gcvSTATUS_OK;
 }
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/oom.h>
+#include <linux/sched.h>
+#include <linux/notifier.h>
+
+extern struct task_struct *lowmem_deathpending;
+static unsigned long lowmem_deathpending_timeout;
+
+static int force_contiguous_lowmem_shrink(IN gckKERNEL Kernel)
+{
+	struct task_struct *p;
+	struct task_struct *selected = NULL;
+	int tasksize;
+        int ret = -1;
+	int min_adj = 0;
+	int selected_tasksize = 0;
+	int selected_oom_adj;
+	/*
+	 * If we already have a death outstanding, then
+	 * bail out right away; indicating to vmscan
+	 * that we have nothing further to offer on
+	 * this pass.
+	 *
+	 */
+	if (lowmem_deathpending &&
+	    time_before_eq(jiffies, lowmem_deathpending_timeout))
+		return 0;
+	selected_oom_adj = min_adj;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		struct mm_struct *mm;
+		struct signal_struct *sig;
+                gcuDATABASE_INFO info;
+		int oom_adj;
+
+		task_lock(p);
+		mm = p->mm;
+		sig = p->signal;
+		if (!mm || !sig) {
+			task_unlock(p);
+			continue;
+		}
+		oom_adj = sig->oom_adj;
+		if (oom_adj < min_adj) {
+			task_unlock(p);
+			continue;
+		}
+
+		tasksize = 0;
+		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_VIDEO_MEMORY, &info) == gcvSTATUS_OK){
+			tasksize += info.counters.bytes / PAGE_SIZE;
+		}
+		if (gckKERNEL_QueryProcessDB(Kernel, p->pid, gcvFALSE, gcvDB_CONTIGUOUS, &info) == gcvSTATUS_OK){
+			tasksize += info.counters.bytes / PAGE_SIZE;
+		}
+
+		task_unlock(p);
+
+		if (tasksize <= 0)
+			continue;
+
+		gckOS_Print("<gpu> pid %d (%s), adj %d, size %d \n", p->pid, p->comm, oom_adj, tasksize);
+
+		if (selected) {
+			if (oom_adj < selected_oom_adj)
+				continue;
+			if (oom_adj == selected_oom_adj &&
+			    tasksize <= selected_tasksize)
+				continue;
+		}
+		selected = p;
+		selected_tasksize = tasksize;
+		selected_oom_adj = oom_adj;
+	}
+	if (selected) {
+		gckOS_Print("<gpu> send sigkill to %d (%s), adj %d, size %d\n",
+			     selected->pid, selected->comm,
+			     selected_oom_adj, selected_tasksize);
+		lowmem_deathpending = selected;
+		lowmem_deathpending_timeout = jiffies + HZ;
+		force_sig(SIGKILL, selected);
+		ret = 0;
+	}
+	read_unlock(&tasklist_lock);
+	return ret;
+}
+
+#endif
 
 /*******************************************************************************
 **
@@ -538,6 +674,9 @@ _AllocateMemory(
     gcmkVERIFY_ARGUMENT(Pool != gcvNULL);
     gcmkVERIFY_ARGUMENT(Bytes != 0);
 
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+_AllocateMemory_Retry:
+#endif
     /* Get initial pool. */
     switch (pool = *Pool)
     {
@@ -683,11 +822,22 @@ _AllocateMemory(
 
     if (node == gcvNULL)
     {
+
+#ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+        if(forceContiguous == gcvTRUE)
+        {
+            if(force_contiguous_lowmem_shrink(Kernel) == 0)
+            {
+                 /* Sleep 1 millisecond. */
+                 gckOS_Delay(gcvNULL, 1);
+                 goto _AllocateMemory_Retry;
+            }
+        }
+#endif
         /* Nothing allocated. */
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-
     /* Return node and pool used for allocation. */
     *Node = node;
     *Pool = pool;
@@ -739,11 +889,14 @@ gckKERNEL_Dispatch(
     gcuVIDMEM_NODE_PTR node;
     gctBOOL locked = gcvFALSE;
     gctPHYS_ADDR physical = gcvNULL;
+    gctPOINTER logical = gcvNULL;
+    gctPOINTER info = gcvNULL;
+    gckCONTEXT context = gcvNULL;
     gctUINT32 address;
     gctUINT32 processID;
+    gckKERNEL kernel = Kernel;
 #if gcdSECURE_USER
     gcskSECURE_CACHE_PTR cache;
-    gctPOINTER logical;
 #endif
     gctBOOL asynchronous;
     gctPOINTER paddr = gcvNULL;
@@ -751,9 +904,6 @@ gckKERNEL_Dispatch(
     gctSIGNAL   signal;
 #endif
 
-    gcsDATABASE_RECORD record;
-    gctPOINTER    data;
-
     gcmkHEADER_ARG("Kernel=0x%x FromUser=%d Interface=0x%x",
                    Kernel, FromUser, Interface);
 
@@ -801,156 +951,185 @@ gckKERNEL_Dispatch(
         break;
 
     case gcvHAL_MAP_MEMORY:
-        physical = Interface->u.MapMemory.physical;
+        physical = gcmINT2PTR(Interface->u.MapMemory.physical);
 
         /* Map memory. */
         gcmkONERROR(
             gckKERNEL_MapMemory(Kernel,
                                 physical,
-                                Interface->u.MapMemory.bytes,
-                                &Interface->u.MapMemory.logical));
+                                (gctSIZE_T) Interface->u.MapMemory.bytes,
+                                &logical));
+
+        Interface->u.MapMemory.logical = gcmPTR_TO_UINT64(logical);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_MAP_MEMORY,
-                                   Interface->u.MapMemory.logical,
+                                   logical,
                                    physical,
-                                   Interface->u.MapMemory.bytes));
+                                   (gctSIZE_T) Interface->u.MapMemory.bytes));
         break;
 
     case gcvHAL_UNMAP_MEMORY:
-        physical = Interface->u.UnmapMemory.physical;
+        physical = gcmINT2PTR(Interface->u.UnmapMemory.physical);
 
         /* Unmap memory. */
         gcmkONERROR(
             gckKERNEL_UnmapMemory(Kernel,
                                   physical,
-                                  Interface->u.UnmapMemory.bytes,
-                                  Interface->u.UnmapMemory.logical));
+                                  (gctSIZE_T) Interface->u.UnmapMemory.bytes,
+                                  gcmUINT64_TO_PTR(Interface->u.UnmapMemory.logical)));
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_MAP_MEMORY,
-                                      Interface->u.UnmapMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.UnmapMemory.logical)));
         break;
 
     case gcvHAL_ALLOCATE_NON_PAGED_MEMORY:
+        bytes = (gctSIZE_T) Interface->u.AllocateNonPagedMemory.bytes;
+
         /* Allocate non-paged memory. */
         gcmkONERROR(
             gckOS_AllocateNonPagedMemory(
                 Kernel->os,
                 FromUser,
-                &Interface->u.AllocateNonPagedMemory.bytes,
-                &Interface->u.AllocateNonPagedMemory.physical,
-                &Interface->u.AllocateNonPagedMemory.logical));
+                &bytes,
+                &physical,
+                &logical));
+
+        Interface->u.AllocateNonPagedMemory.bytes    = bytes;
+        Interface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
 
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_NON_PAGED,
-                                   Interface->u.AllocateNonPagedMemory.logical,
-                                   Interface->u.AllocateNonPagedMemory.physical,
-                                   Interface->u.AllocateNonPagedMemory.bytes));
+                                   logical,
+                                   gcmINT2PTR(Interface->u.AllocateNonPagedMemory.physical),
+                                   bytes));
+
         break;
 
     case gcvHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER:
 #if gcdVIRTUAL_COMMAND_BUFFER
+        bytes = (gctSIZE_T) Interface->u.AllocateVirtualCommandBuffer.bytes;
+
         gcmkONERROR(
             gckKERNEL_AllocateVirtualCommandBuffer(
                 Kernel,
                 FromUser,
-                &Interface->u.AllocateVirtualCommandBuffer.bytes,
-                &Interface->u.AllocateVirtualCommandBuffer.physical,
-                &Interface->u.AllocateVirtualCommandBuffer.logical));
+                &bytes,
+                &physical,
+                &logical));
+
+        Interface->u.AllocateVirtualCommandBuffer.bytes    = bytes;
+        Interface->u.AllocateVirtualCommandBuffer.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateVirtualCommandBuffer.physical = gcmPTR_TO_NAME(physical);
 
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_COMMAND_BUFFER,
-                                   Interface->u.AllocateVirtualCommandBuffer.logical,
-                                   Interface->u.AllocateVirtualCommandBuffer.physical,
-                                   Interface->u.AllocateVirtualCommandBuffer.bytes));
+                                   logical,
+                                   gcmINT2PTR(Interface->u.AllocateVirtualCommandBuffer.physical),
+                                   bytes));
 #else
         status = gcvSTATUS_NOT_SUPPORTED;
 #endif
         break;
 
     case gcvHAL_FREE_NON_PAGED_MEMORY:
-        physical = Interface->u.FreeNonPagedMemory.physical;
+        physical = gcmNAME_TO_PTR(Interface->u.FreeNonPagedMemory.physical);
 
         /* Unmap user logical out of physical memory first. */
         gcmkONERROR(gckOS_UnmapUserLogical(Kernel->os,
                                            physical,
-                                           Interface->u.FreeNonPagedMemory.bytes,
-                                           Interface->u.FreeNonPagedMemory.logical));
+                                           (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
+                                           gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
         /* Free non-paged memory. */
         gcmkONERROR(
             gckOS_FreeNonPagedMemory(Kernel->os,
-                                     Interface->u.FreeNonPagedMemory.bytes,
+                                     (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
                                      physical,
-                                     Interface->u.FreeNonPagedMemory.logical));
+                                     gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_NON_PAGED,
-                                      Interface->u.FreeNonPagedMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.FreeNonPagedMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical),
             Interface->u.FreeNonPagedMemory.bytes));
 #endif
+
+        gcmRELEASE_NAME(Interface->u.FreeNonPagedMemory.physical);
+
         break;
 
     case gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY:
+        bytes = (gctSIZE_T) Interface->u.AllocateContiguousMemory.bytes;
+
         /* Allocate contiguous memory. */
         gcmkONERROR(gckOS_AllocateContiguous(
             Kernel->os,
             FromUser,
-            &Interface->u.AllocateContiguousMemory.bytes,
-            &Interface->u.AllocateContiguousMemory.physical,
-            &Interface->u.AllocateContiguousMemory.logical));
+            &bytes,
+            &physical,
+            &logical));
+
+        Interface->u.AllocateContiguousMemory.bytes    = bytes;
+        Interface->u.AllocateContiguousMemory.logical  = gcmPTR_TO_UINT64(logical);
+        Interface->u.AllocateContiguousMemory.physical = gcmPTR_TO_NAME(physical);
 
         gcmkONERROR(gckHARDWARE_ConvertLogical(
             Kernel->hardware,
-            Interface->u.AllocateContiguousMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.AllocateContiguousMemory.logical),
             &Interface->u.AllocateContiguousMemory.address));
 
         gcmkVERIFY_OK(gckKERNEL_AddProcessDB(
             Kernel,
             processID, gcvDB_CONTIGUOUS,
-            Interface->u.AllocateContiguousMemory.logical,
-            Interface->u.AllocateContiguousMemory.physical,
-            Interface->u.AllocateContiguousMemory.bytes));
+            logical,
+            gcmINT2PTR(Interface->u.AllocateContiguousMemory.physical),
+            bytes));
+
         break;
 
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
-        physical = Interface->u.FreeContiguousMemory.physical;
+        physical = gcmNAME_TO_PTR(Interface->u.FreeContiguousMemory.physical);
 
         /* Unmap user logical out of physical memory first. */
         gcmkONERROR(gckOS_UnmapUserLogical(Kernel->os,
                                            physical,
-                                           Interface->u.FreeContiguousMemory.bytes,
-                                           Interface->u.FreeContiguousMemory.logical));
+                                           (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes,
+                                           gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical)));
 
         /* Free contiguous memory. */
         gcmkONERROR(
             gckOS_FreeContiguous(Kernel->os,
                                  physical,
-                                 Interface->u.FreeContiguousMemory.logical,
-                                 Interface->u.FreeContiguousMemory.bytes));
+                                 gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical),
+                                 (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_CONTIGUOUS,
-                                      Interface->u.FreeNonPagedMemory.logical));
+                                      gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.FreeContiguousMemory.logical,
+            gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical),
             Interface->u.FreeContiguousMemory.bytes));
 #endif
+
+        gcmRELEASE_NAME(Interface->u.FreeContiguousMemory.physical);
+
         break;
 
     case gcvHAL_ALLOCATE_VIDEO_MEMORY:
@@ -967,10 +1146,8 @@ gckKERNEL_Dispatch(
                             Interface->u.AllocateLinearVideoMemory.bytes,
                             Interface->u.AllocateLinearVideoMemory.alignment,
                             Interface->u.AllocateLinearVideoMemory.type,
-                            &Interface->u.AllocateLinearVideoMemory.node));
+                            &node));
 
-        /* Get actual size of node. */
-        node = Interface->u.AllocateLinearVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             bytes = node->VidMem.bytes;
@@ -983,14 +1160,17 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY,
-                                   Interface->u.AllocateLinearVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    bytes));
+
+        /* Get the node. */
+        Interface->u.AllocateLinearVideoMemory.node = gcmPTR_TO_UINT64(node);
         break;
 
     case gcvHAL_FREE_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.FreeVideoMemory.node);
 #ifdef __QNXNTO__
-        node = Interface->u.FreeVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM
          && node->VidMem.logical != gcvNULL)
         {
@@ -1004,25 +1184,27 @@ gckKERNEL_Dispatch(
 #endif
         /* Free video memory. */
         gcmkONERROR(
-            gckVIDMEM_Free(Interface->u.FreeVideoMemory.node));
+            gckVIDMEM_Free(node));
 
         gcmkONERROR(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_VIDEO_MEMORY,
-                                      Interface->u.FreeVideoMemory.node));
+                                      node));
+
         break;
 
     case gcvHAL_LOCK_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node);
+
         /* Lock video memory. */
         gcmkONERROR(
             gckVIDMEM_Lock(Kernel,
-                           Interface->u.LockVideoMemory.node,
+                           node,
                            Interface->u.LockVideoMemory.cacheable,
                            &Interface->u.LockVideoMemory.address));
 
         locked = gcvTRUE;
 
-        node = Interface->u.LockVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Map video memory address into user space. */
@@ -1039,18 +1221,20 @@ gckKERNEL_Dispatch(
         }
         gcmkASSERT(node->VidMem.logical != gcvNULL);
 
-        Interface->u.LockVideoMemory.memory = node->VidMem.logical;
+        Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->VidMem.logical);
 #else
             gcmkONERROR(
                 gckKERNEL_MapVideoMemory(Kernel,
                                          FromUser,
                                          Interface->u.LockVideoMemory.address,
-                                         &Interface->u.LockVideoMemory.memory));
+                                         &logical));
+
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(logical);
 #endif
         }
         else
         {
-            Interface->u.LockVideoMemory.memory = node->Virtual.logical;
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->Virtual.logical);
 
             /* Success. */
             status = gcvSTATUS_OK;
@@ -1059,12 +1243,12 @@ gckKERNEL_Dispatch(
 #if gcdSECURE_USER
         /* Return logical address as physical address. */
         Interface->u.LockVideoMemory.address =
-            gcmPTR2INT(Interface->u.LockVideoMemory.memory);
+            Interface->u.LockVideoMemory.memory;
 #endif
         gcmkONERROR(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                   Interface->u.LockVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    0));
 
@@ -1072,7 +1256,7 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         /* Unlock video memory. */
-        node = Interface->u.UnlockVideoMemory.node;
+        node = gcmUINT64_TO_PTR(Interface->u.UnlockVideoMemory.node);
 
 #if gcdSECURE_USER
         /* Save node information before it disappears. */
@@ -1111,26 +1295,25 @@ gckKERNEL_Dispatch(
             gcmkONERROR(
                 gckKERNEL_RemoveProcessDB(Kernel,
                                           processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                          Interface->u.UnlockVideoMemory.node));
+                                          node));
         }
-
         break;
 
     case gcvHAL_EVENT_COMMIT:
         /* Commit an event queue. */
         gcmkONERROR(
             gckEVENT_Commit(Kernel->eventObj,
-                            Interface->u.Event.queue));
+                            gcmUINT64_TO_PTR(Interface->u.Event.queue)));
         break;
 
     case gcvHAL_COMMIT:
         /* Commit a command and context buffer. */
         gcmkONERROR(
             gckCOMMAND_Commit(Kernel->command,
-                              Interface->u.Commit.context,
-                              Interface->u.Commit.commandBuffer,
-                              Interface->u.Commit.delta,
-                              Interface->u.Commit.queue,
+                              gcmNAME_TO_PTR(Interface->u.Commit.context),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.commandBuffer),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.delta),
+                              gcmUINT64_TO_PTR(Interface->u.Commit.queue),
                               processID));
         break;
 
@@ -1144,42 +1327,49 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckOS_MapUserMemory(Kernel->os,
                                 Kernel->core,
-                                Interface->u.MapUserMemory.memory,
+                                gcmUINT64_TO_PTR(Interface->u.MapUserMemory.memory),
                                 Interface->u.MapUserMemory.physical,
-                                Interface->u.MapUserMemory.size,
-                                &Interface->u.MapUserMemory.info,
+                                (gctSIZE_T) Interface->u.MapUserMemory.size,
+                                &info,
                                 &Interface->u.MapUserMemory.address));
+
+        Interface->u.MapUserMemory.info = gcmPTR_TO_NAME(info);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_MAP_USER_MEMORY,
-                                   Interface->u.MapUserMemory.info,
-                                   Interface->u.MapUserMemory.memory,
-                                   Interface->u.MapUserMemory.size));
+                                   gcmINT2PTR(Interface->u.MapUserMemory.info),
+                                   gcmUINT64_TO_PTR(Interface->u.MapUserMemory.memory),
+                                   (gctSIZE_T) Interface->u.MapUserMemory.size));
         break;
 
     case gcvHAL_UNMAP_USER_MEMORY:
         address = Interface->u.UnmapUserMemory.address;
+        info = gcmNAME_TO_PTR(Interface->u.UnmapUserMemory.info);
 
         /* Unmap user memory. */
         gcmkONERROR(
             gckOS_UnmapUserMemory(Kernel->os,
                                   Kernel->core,
-                                  Interface->u.UnmapUserMemory.memory,
-                                  Interface->u.UnmapUserMemory.size,
-                                  Interface->u.UnmapUserMemory.info,
+                                  gcmUINT64_TO_PTR(Interface->u.UnmapUserMemory.memory),
+                                  (gctSIZE_T) Interface->u.UnmapUserMemory.size,
+                                  info,
                                   address));
 
 #if gcdSECURE_USER
         gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
             Kernel,
             cache,
-            Interface->u.UnmapUserMemory.memory,
+            gcmUINT64_TO_PTR(Interface->u.UnmapUserMemory.memory),
             Interface->u.UnmapUserMemory.size));
 #endif
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                                       processID, gcvDB_MAP_USER_MEMORY,
-                                      Interface->u.UnmapUserMemory.info));
+                                      gcmINT2PTR(Interface->u.UnmapUserMemory.info)));
+
+        gcmRELEASE_NAME(Interface->u.UnmapUserMemory.info);
+
         break;
 
 #if !USE_NEW_LINUX_SIGNAL
@@ -1415,6 +1605,7 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckHARDWARE_QueryProfileRegisters(
                 Kernel->hardware,
+                Kernel->profileCleanRegister,
                 &Interface->u.RegisterProfileData.counters));
 #else
         status = gcvSTATUS_OK;
@@ -1427,7 +1618,7 @@ gckKERNEL_Dispatch(
         gcmkONERROR(
             gckHARDWARE_ProfileEngine2D(
                 Kernel->hardware,
-                Interface->u.RegisterProfileData2D.hwProfile2D));
+                gcmUINT64_TO_PTR(Interface->u.RegisterProfileData2D.hwProfile2D)));
 #else
         status = gcvSTATUS_OK;
 #endif
@@ -1446,7 +1637,6 @@ gckKERNEL_Dispatch(
 
         status = gcvSTATUS_OK;
         break;
-
     case gcvHAL_SET_PROFILE_SETTING:
 #if VIVANTE_PROFILER
         /* Set profile setting */
@@ -1461,6 +1651,15 @@ gckKERNEL_Dispatch(
         status = gcvSTATUS_OK;
         break;
 
+#if VIVANTE_PROFILER_PERDRAW
+    case gcvHAL_READ_PROFILER_REGISTER_SETTING:
+    #if VIVANTE_PROFILER
+        Kernel->profileCleanRegister = Interface->u.SetProfilerRegisterClear.bclear;
+    #endif
+        status = gcvSTATUS_OK;
+        break;
+#endif
+
     case gcvHAL_QUERY_KERNEL_SETTINGS:
         /* Get kernel settings. */
         gcmkONERROR(
@@ -1511,7 +1710,11 @@ gckKERNEL_Dispatch(
             {
                 Interface->u.ReadRegisterData.data = 1;
                 gcmkVERIFY_OK(
-                    gckOS_DumpGPUState(Kernel->os, Kernel->core));
+                    gckHARDWARE_DumpGPUState(Kernel->hardware));
+#if gcdVIRTUAL_COMMAND_BUFFER
+                gcmkVERIFY_OK(
+                    gckCOMMAND_DumpExecutingBuffer(Kernel->command));
+#endif
             }
             else
             {
@@ -1523,19 +1726,22 @@ gckKERNEL_Dispatch(
 
     case gcvHAL_DUMP_EVENT:
         /* Dump GPU event */
-        gcmkVERIFY_OK(
-            gckEVENT_Dump(Kernel->eventObj));
+        gcmkVERIFY_OK(gckEVENT_Dump(Kernel->eventObj));
+
+        /* Dump Process DB. */
+        gcmkVERIFY_OK(gckKERNEL_DumpProcessDB(Kernel));
         break;
 
     case gcvHAL_CACHE:
-        if (Interface->u.Cache.node == gcvNULL)
+        node = gcmUINT64_TO_PTR(Interface->u.Cache.node);
+        if (node == gcvNULL)
         {
             /* FIXME Surface wrap some memory which is not allocated by us,
             ** So we don't have physical address to handle outer cache, ignore it*/
             status = gcvSTATUS_OK;
             break;
         }
-        else if (Interface->u.Cache.node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+        else if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Video memory has no physical handles. */
             physical = gcvNULL;
@@ -1543,9 +1749,11 @@ gckKERNEL_Dispatch(
         else
         {
             /* Grab physical handle. */
-            physical = Interface->u.Cache.node->Virtual.physical;
+            physical = node->Virtual.physical;
         }
 
+        logical = gcmUINT64_TO_PTR(Interface->u.Cache.logical);
+        bytes = (gctSIZE_T) Interface->u.Cache.bytes;
         switch(Interface->u.Cache.operation)
         {
         case gcvCACHE_FLUSH:
@@ -1554,8 +1762,8 @@ gckKERNEL_Dispatch(
                                       processID,
                                       physical,
                                       paddr,
-                                      Interface->u.Cache.logical,
-                                      Interface->u.Cache.bytes);
+                                      logical,
+                                      bytes);
             break;
         case gcvCACHE_CLEAN:
             /* Clean the cache. */
@@ -1563,8 +1771,8 @@ gckKERNEL_Dispatch(
                                       processID,
                                       physical,
                                       paddr,
-                                      Interface->u.Cache.logical,
-                                      Interface->u.Cache.bytes);
+                                      logical,
+                                      bytes);
             break;
         case gcvCACHE_INVALIDATE:
             /* Invalidate the cache. */
@@ -1572,13 +1780,13 @@ gckKERNEL_Dispatch(
                                            processID,
                                            physical,
                                            paddr,
-                                           Interface->u.Cache.logical,
-                                           Interface->u.Cache.bytes);
+                                           logical,
+                                           bytes);
             break;
 
 	case gcvCACHE_MEMORY_BARRIER:
 	   status = gckOS_MemoryBarrier(Kernel->os,
-                                        Interface->u.Cache.logical);
+                                        logical);
 	   break;
         default:
             status = gcvSTATUS_INVALID_ARGUMENT;
@@ -1678,14 +1886,17 @@ gckKERNEL_Dispatch(
         /* Attach user process. */
         gcmkONERROR(
             gckCOMMAND_Attach(Kernel->command,
-                              &Interface->u.Attach.context,
-                              &Interface->u.Attach.stateCount,
+                              &context,
+                              &bytes,
                               processID));
 
+        Interface->u.Attach.stateCount = bytes;
+        Interface->u.Attach.context = gcmPTR_TO_NAME(context);
+
         gcmkVERIFY_OK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_CONTEXT,
-                                   Interface->u.Attach.context,
+                                   gcmINT2PTR(Interface->u.Attach.context),
                                    gcvNULL,
                                    0));
         break;
@@ -1694,15 +1905,18 @@ gckKERNEL_Dispatch(
         /* Detach user process. */
         gcmkONERROR(
             gckCOMMAND_Detach(Kernel->command,
-                              Interface->u.Detach.context));
+                              gcmNAME_TO_PTR(Interface->u.Detach.context)));
 
         gcmkVERIFY_OK(
             gckKERNEL_RemoveProcessDB(Kernel,
                               processID, gcvDB_CONTEXT,
-                              Interface->u.Detach.context));
+                              gcmINT2PTR(Interface->u.Detach.context)));
+
+        gcmRELEASE_NAME(Interface->u.Detach.context);
         break;
 
     case gcvHAL_COMPOSE:
+        Interface->u.Compose.physical = gcmPTR_TO_UINT64(gcmNAME_TO_PTR(Interface->u.Compose.physical));
         /* Start composition. */
         gcmkONERROR(
             gckEVENT_Compose(Kernel->eventObj,
@@ -1718,250 +1932,138 @@ gckKERNEL_Dispatch(
     case gcvHAL_GET_FRAME_INFO:
         gcmkONERROR(gckHARDWARE_GetFrameInfo(
             Kernel->hardware,
-            Interface->u.GetFrameInfo.frameInfo));
+            gcmUINT64_TO_PTR(Interface->u.GetFrameInfo.frameInfo)));
         break;
 #endif
 
     case gcvHAL_GET_SHARED_INFO:
-        if (Interface->u.GetSharedInfo.dataId != 0)
+        if (Interface->u.GetSharedInfo.data == gcvNULL)
         {
-            gcmkONERROR(gckKERNEL_FindProcessDB(Kernel,
-                        Interface->u.GetSharedInfo.pid,
-                        0,
-                        gcvDB_SHARED_INFO,
-                        gcmINT2PTR(Interface->u.GetSharedInfo.dataId),
-                        &record));
-
-            /* find a record in db, check size */
-            if (record.bytes != Interface->u.GetSharedInfo.size)
-            {
-                /* Size change is not allowed */
-                gcmkONERROR(gcvSTATUS_INVALID_DATA);
-            }
-
-            /* fetch data */
-            gcmkONERROR(gckOS_CopyToUserData(
-                Kernel->os,
-                record.physical,
-                Interface->u.GetSharedInfo.data,
-                Interface->u.GetSharedInfo.size
-                ));
-
+            gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
         }
-
-        if ((node = Interface->u.GetSharedInfo.node) != gcvNULL)
+        else
         {
-            switch (Interface->u.GetSharedInfo.infoType)
-                {
-                case gcvVIDMEM_INFO_GENERIC:
-                    { /* Generic data stored */
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            data = &node->VidMem.sharedInfo;
+            gctUINT32 pid    = Interface->u.GetSharedInfo.pid;
+            gctUINT32 dataId = Interface->u.GetSharedInfo.dataId;
+            gctSIZE_T bytes  = Interface->u.GetSharedInfo.bytes;
+            gctPOINTER data  = Interface->u.GetSharedInfo.data;
+            gcsDATABASE_RECORD record;
 
-                        }
-                        else
-                        {
-                            data = &node->Virtual.sharedInfo;
-                        }
-
-                         gcmkONERROR(gckOS_CopyToUserData(
-                             Kernel->os,
-                             data,
-                             Interface->u.GetSharedInfo.nodeData,
-                             sizeof(gcsVIDMEM_NODE_SHARED_INFO)
-                             ));
-                    }
-                    break;
-
-                case gcvVIDMEM_INFO_DIRTY_RECTANGLE:
-                    { /* Dirty rectangle stored */
-                        gcsVIDMEM_NODE_SHARED_INFO *storedSharedInfo;
-                        gcsVIDMEM_NODE_SHARED_INFO alignedSharedInfo;
-
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            storedSharedInfo = &node->VidMem.sharedInfo;
-                        }
-                        else
-                        {
-                            storedSharedInfo = &node->Virtual.sharedInfo;
-                        }
-
-                        /* Stored shared info holds the unaligned dirty rectangle.
-                           Align it first.                                         */
-
-                        /* Hardware requires 64-byte aligned address, and 16x4 pixel aligned rectsize.
-                           We simply align to 32 pixels which covers both 16- and 32-bpp formats. */
-
-                        /* Make sure we have a legit rectangle. */
-                        gcmkASSERT((storedSharedInfo->RectSize.width != 0) && (storedSharedInfo->RectSize.height != 0));
-
-                        alignedSharedInfo.SrcOrigin.x = gcmALIGN_BASE(storedSharedInfo->SrcOrigin.x, 32);
-                        alignedSharedInfo.RectSize.width = gcmALIGN((storedSharedInfo->RectSize.width + (storedSharedInfo->SrcOrigin.x - alignedSharedInfo.SrcOrigin.x)), 16);
-
-                        alignedSharedInfo.SrcOrigin.y = gcmALIGN_BASE(storedSharedInfo->SrcOrigin.y, 4);
-                        alignedSharedInfo.RectSize.height = gcmALIGN((storedSharedInfo->RectSize.height + (storedSharedInfo->SrcOrigin.y - alignedSharedInfo.SrcOrigin.y)), 4);
-
-                        gcmkONERROR(gckOS_CopyToUserData(
-                            Kernel->os,
-                            &alignedSharedInfo,
-                            Interface->u.GetSharedInfo.nodeData,
-                            sizeof(gcsVIDMEM_NODE_SHARED_INFO)
-                            ));
-
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL,
-                                        "Node = %p, unaligned rectangle (l=%d, t=%d, w=%d, h=%d) aligned to (l=%d, t=%d, w=%d, h=%d)", node,
-                                        storedSharedInfo->SrcOrigin.x, storedSharedInfo->SrcOrigin.y,
-                                        storedSharedInfo->RectSize.width, storedSharedInfo->RectSize.height,
-                                        alignedSharedInfo.SrcOrigin.x, alignedSharedInfo.SrcOrigin.y,
-                                        alignedSharedInfo.RectSize.width, alignedSharedInfo.RectSize.height);
+            /* Find record. */
+            gcmkONERROR(
+                gckKERNEL_FindProcessDB(Kernel,
+                                        pid,
+                                        0,
+                                        gcvDB_SHARED_INFO,
+                                        gcmINT2PTR(dataId),
+                                        &record));
+
+            /* Check memory size. */
+            if (bytes < record.bytes)
+            {
+                /* Insufficient memory to hold shared data. */
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+            }
 
-                        /* Rectangle */
-                        storedSharedInfo->SrcOrigin.x =
-                        storedSharedInfo->SrcOrigin.y =
-                        storedSharedInfo->RectSize.width =
-                        storedSharedInfo->RectSize.height = 0;
-                    }
-                    break;
-                }
+            /* Copy to user. */
+            status = gckOS_CopyToUserData(Kernel->os,
+                                          record.physical,
+                                          data,
+                                          record.bytes);
+
+            /*
+             * Remove from process db.
+             * Every time when shared info is taken, the record is erased in
+             * kernel side.
+             */
+            gcmkVERIFY_OK(
+                gckKERNEL_RemoveProcessDB(Kernel,
+                                          pid,
+                                          gcvDB_SHARED_INFO,
+                                          gcmINT2PTR(dataId)));
+            /* Free existed data. */
+            gcmkVERIFY_OK(
+                gckOS_FreeMemory(Kernel->os, record.physical));
         }
         break;
 
     case gcvHAL_SET_SHARED_INFO:
-        if (Interface->u.SetSharedInfo.dataId != 0)
         {
-            status = gckKERNEL_FindProcessDB(Kernel, processID, 0,
-                        gcvDB_SHARED_INFO,
-                        gcmINT2PTR(Interface->u.SetSharedInfo.dataId),
-                        &record);
-
-            if (status == gcvSTATUS_INVALID_DATA)
+            gctUINT32 dataId = Interface->u.SetSharedInfo.dataId;
+            gctPOINTER data  = Interface->u.SetSharedInfo.data;
+            gctUINT32 bytes  = Interface->u.SetSharedInfo.bytes;
+            gctPOINTER memory = gcvNULL;
+            gcsDATABASE_RECORD record;
+
+            if (gcmIS_SUCCESS(gckKERNEL_FindProcessDB(Kernel,
+                                                     processID,
+                                                     0,
+                                                     gcvDB_SHARED_INFO,
+                                                     gcmINT2PTR(dataId),
+                                                     &record)))
             {
-                /* private data has not been created yet */
-                /* Note: we count on DestoryProcessDB to free it */
-                gcmkONERROR(gckOS_AllocateMemory(
-                    Kernel->os,
-                    Interface->u.SetSharedInfo.size,
-                    &data
-                    ));
-
-                gcmkONERROR(
-                    gckKERNEL_AddProcessDB(Kernel, processID,
-                        gcvDB_SHARED_INFO,
-                        gcmINT2PTR(Interface->u.SetSharedInfo.dataId),
-                        data,
-                        Interface->u.SetSharedInfo.size
-                        ));
-            }
-            else
-            {
-                /* bail on other errors */
-                gcmkONERROR(status);
-
-                /* find a record in db, check size */
-                if (record.bytes != Interface->u.SetSharedInfo.size)
+                /* Find a record with the same id. */
+                if (bytes != record.bytes)
                 {
-                    /* Size change is not allowed */
-                    gcmkONERROR(gcvSTATUS_INVALID_DATA);
+                    /* Remove from process db. */
+                    gcmkVERIFY_OK(
+                        gckKERNEL_RemoveProcessDB(Kernel,
+                                                  processID,
+                                                  gcvDB_SHARED_INFO,
+                                                  gcmINT2PTR(dataId)));
+
+                    /* Free existed data. */
+                    gcmkVERIFY_OK(
+                        gckOS_FreeMemory(Kernel->os, record.physical));
                 }
-
-                /* get storage address */
-                data = record.physical;
-            }
-
-            gcmkONERROR(gckOS_CopyFromUserData(
-                Kernel->os,
-                data,
-                Interface->u.SetSharedInfo.data,
-                Interface->u.SetSharedInfo.size
-                ));
-        }
-
-        if ((node = Interface->u.SetSharedInfo.node) != gcvNULL)
-        {
-            switch (Interface->u.SetSharedInfo.infoType)
+                else
                 {
-                case gcvVIDMEM_INFO_GENERIC:
-                    { /* Generic data stored */
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            data = &node->VidMem.sharedInfo;
-                        }
-                        else
-                        {
-                            data = &node->Virtual.sharedInfo;
-                        }
-
-                        gcmkONERROR(gckOS_CopyFromUserData(
-                            Kernel->os,
-                            data,
-                            Interface->u.SetSharedInfo.nodeData,
-                            sizeof(gcsVIDMEM_NODE_SHARED_INFO)
-                            ));
-                    }
-                    break;
+                    /* Re-use allocated memory. */
+                    memory = record.physical;
+                }
+            }
 
-                case gcvVIDMEM_INFO_DIRTY_RECTANGLE:
-                    { /* Dirty rectangle stored */
-                        gcsVIDMEM_NODE_SHARED_INFO newSharedInfo;
-                        gcsVIDMEM_NODE_SHARED_INFO *currentSharedInfo;
-                        gctINT dirtyX, dirtyY, right, bottom;
-
-                        /* Expand the dirty rectangle stored in the node to include the rectangle passed in. */
-                        gcmkONERROR(gckOS_CopyFromUserData(
-                            Kernel->os,
-                            &newSharedInfo,
-                            Interface->u.SetSharedInfo.nodeData,
-                            gcmSIZEOF(gcsVIDMEM_NODE_SHARED_INFO)
-                            ));
-
-                        if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-                        {
-                            currentSharedInfo = &node->VidMem.sharedInfo;
-                        }
-                        else
-                        {
-                            currentSharedInfo = &node->Virtual.sharedInfo;
-                        }
+            if ((data == gcvNULL) || (bytes == 0))
+            {
+                /* Nothing to record. */
+                break;
+            }
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL, "Node = %p Stored rectangle (l=%d, t=%d, w=%d, h=%d)", node,
-                                        currentSharedInfo->SrcOrigin.x, currentSharedInfo->SrcOrigin.y,
-                                        currentSharedInfo->RectSize.width, currentSharedInfo->RectSize.height);
+            if (bytes > 1024)
+            {
+                /* Limite data size. */
+                gcmkONERROR(gcvSTATUS_TOO_COMPLEX);
+            }
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL, "To combine with (l=%d, t=%d, w=%d, h=%d)",
-                                        newSharedInfo.SrcOrigin.x, newSharedInfo.SrcOrigin.y,
-                                        newSharedInfo.RectSize.width, newSharedInfo.RectSize.height);
+            if (memory == gcvNULL)
+            {
+                /* Allocate memory for holding shared data. */
+                gcmkONERROR(
+                    gckOS_AllocateMemory(Kernel->os, bytes, &memory));
 
-                        if ((currentSharedInfo->RectSize.width == 0) || (currentSharedInfo->RectSize.height == 0))
-                        { /* Setting it for the first time */
-                            currentSharedInfo->SrcOrigin.x = newSharedInfo.SrcOrigin.x;
-                            currentSharedInfo->SrcOrigin.y = newSharedInfo.SrcOrigin.y;
-                            currentSharedInfo->RectSize.width = newSharedInfo.RectSize.width;
-                            currentSharedInfo->RectSize.height = newSharedInfo.RectSize.height;
-                        }
-                        else
-                        {
-                            /* Expand the stored rectangle to include newly locked rectangle */
-                            dirtyX = (newSharedInfo.SrcOrigin.x < currentSharedInfo->SrcOrigin.x) ? newSharedInfo.SrcOrigin.x : currentSharedInfo->SrcOrigin.x;
-                            right = gcmMAX((currentSharedInfo->SrcOrigin.x + currentSharedInfo->RectSize.width), (newSharedInfo.SrcOrigin.x + newSharedInfo.RectSize.width));
-                            currentSharedInfo->RectSize.width = right - dirtyX;
-                            currentSharedInfo->SrcOrigin.x = dirtyX;
-
-                            dirtyY = (newSharedInfo.SrcOrigin.y < currentSharedInfo->SrcOrigin.y) ? newSharedInfo.SrcOrigin.y : currentSharedInfo->SrcOrigin.y;
-                            bottom = gcmMAX((currentSharedInfo->SrcOrigin.y + currentSharedInfo->RectSize.height), (newSharedInfo.SrcOrigin.y + newSharedInfo.RectSize.height));
-                            currentSharedInfo->RectSize.height = bottom - dirtyY;
-                            currentSharedInfo->SrcOrigin.y = dirtyY;
-                        }
+                /* Add to process db. */
+                status = gckKERNEL_AddProcessDB(Kernel,
+                                                processID,
+                                                gcvDB_SHARED_INFO,
+                                                gcmINT2PTR(dataId),
+                                                memory,
+                                                bytes);
 
-                        gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_KERNEL, "Combined rectangle (l=%d, t=%d, w=%d, h=%d)",
-                                       currentSharedInfo->SrcOrigin.x, currentSharedInfo->SrcOrigin.y,
-                                       currentSharedInfo->RectSize.width, currentSharedInfo->RectSize.height);
-                    }
+                if (gcmIS_ERROR(status))
+                {
+                    /* Failed to add process db. Free allocated memory. */
+                    gcmkVERIFY_OK(gckOS_FreeMemory(Kernel->os, memory));
                     break;
                 }
-        }
+            }
 
+            /* Copy shared data to kernel memory. */
+            gcmkONERROR(
+                gckOS_CopyFromUserData(Kernel->os,
+                                       memory,
+                                       data,
+                                       bytes));
+        }
         break;
 
     case gcvHAL_SET_FSCALE_VALUE:
@@ -1983,6 +2085,14 @@ gckKERNEL_Dispatch(
 #endif
         break;
 
+    case gcvHAL_QUERY_RESET_TIME_STAMP:
+#if gcdENABLE_RECOVERY
+        Interface->u.QueryResetTimeStamp.timeStamp = Kernel->resetTimeStamp;
+#else
+        Interface->u.QueryResetTimeStamp.timeStamp = 0;
+#endif
+        break;
+
     default:
         /* Invalid command. */
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -1999,7 +2109,7 @@ OnError:
             /* Roll back the lock. */
             gcmkVERIFY_OK(
                 gckVIDMEM_Unlock(Kernel,
-                                 Interface->u.LockVideoMemory.node,
+                                 gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node),
                                  gcvSURF_TYPE_UNKNOWN,
                                  &asynchronous));
 
@@ -2008,7 +2118,7 @@ OnError:
                 /* Bottom Half */
                 gcmkVERIFY_OK(
                     gckVIDMEM_Unlock(Kernel,
-                                     Interface->u.LockVideoMemory.node,
+                                     gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node),
                                      gcvSURF_TYPE_UNKNOWN,
                                      gcvNULL));
             }
@@ -2786,6 +2896,8 @@ gckKERNEL_Recovery(
 #endif
     gcmkONERROR(gckEVENT_Notify(eventObj, 2));
 
+    Kernel->resetTimeStamp++;
+
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -3230,8 +3342,445 @@ gckKERNEL_GetGPUAddress(
     gcmkFOOTER_NO();
     return status;
 }
+
+gceSTATUS
+gckKERNEL_QueryGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 GpuAddress,
+    OUT gckVIRTUAL_COMMAND_BUFFER_PTR * Buffer
+    )
+{
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctUINT32 start;
+    gceSTATUS status = gcvSTATUS_NOT_SUPPORTED;
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(Kernel->os, Kernel->virtualBufferLock, gcvINFINITE));
+
+    /* Walk all command buffers. */
+    for (buffer = Kernel->virtualBufferHead; buffer != gcvNULL; buffer = buffer->next)
+    {
+        start = (gctUINT32)buffer->gpuAddress;
+
+        if (GpuAddress >= start && GpuAddress < (start + buffer->pageCount * 4096))
+        {
+            /* Find a range matched. */
+            *Buffer = buffer;
+            status = gcvSTATUS_OK;
+            break;
+        }
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->virtualBufferLock));
+
+    return status;
+}
+#endif
+
+#if gcdLINK_QUEUE_SIZE
+static void
+gckLINKQUEUE_Dequeue(
+    IN gckLINKQUEUE LinkQueue
+    )
+{
+    gcmASSERT(LinkQueue->count == gcdLINK_QUEUE_SIZE);
+
+    LinkQueue->count--;
+    LinkQueue->front = (LinkQueue->front + 1) % gcdLINK_QUEUE_SIZE;
+}
+
+void
+gckLINKQUEUE_Enqueue(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 start,
+    IN gctUINT32 end
+    )
+{
+    if (LinkQueue->count == gcdLINK_QUEUE_SIZE)
+    {
+        gckLINKQUEUE_Dequeue(LinkQueue);
+    }
+
+    gcmkASSERT(LinkQueue->count < gcdLINK_QUEUE_SIZE);
+
+    LinkQueue->count++;
+
+    LinkQueue->data[LinkQueue->rear].start = start;
+    LinkQueue->data[LinkQueue->rear].end = end;
+
+    gcmkVERIFY_OK(
+        gckOS_GetProcessID(&LinkQueue->data[LinkQueue->rear].pid));
+
+    LinkQueue->rear = (LinkQueue->rear + 1) % gcdLINK_QUEUE_SIZE;
+}
+
+void
+gckLINKQUEUE_GetData(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 Index,
+    OUT gckLINKDATA * Data
+    )
+{
+    gcmkASSERT(Index >= 0 && Index < gcdLINK_QUEUE_SIZE);
+
+    *Data = &LinkQueue->data[(Index + LinkQueue->front) % gcdLINK_QUEUE_SIZE];
+}
 #endif
 
+/******************************************************************************\
+*************************** Pointer - ID translation ***************************
+\******************************************************************************/
+#define gcdID_TABLE_LENGTH 1024
+typedef struct _gcsINTEGERDB * gckINTEGERDB;
+typedef struct _gcsINTEGERDB
+{
+    gckOS                       os;
+    gctPOINTER*                 table;
+    gctPOINTER                  mutex;
+    gctUINT32                   tableLen;
+    gctUINT32                   currentID;
+    gctUINT32                   unused;
+}
+gcsINTEGERDB;
+
+gceSTATUS
+gckKERNEL_CreateIntegerDatabase(
+    IN gckKERNEL Kernel,
+    OUT gctPOINTER * Database
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = gcvNULL;
+
+    gcmkHEADER_ARG("Kernel=0x%08X Datbase=0x%08X", Kernel, Database);
+
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Database != gcvNULL);
+
+    /* Allocate a database. */
+    gcmkONERROR(gckOS_Allocate(
+        Kernel->os, gcmSIZEOF(gcsINTEGERDB), (gctPOINTER *)&database));
+
+    gckOS_ZeroMemory(database, gcmSIZEOF(gcsINTEGERDB));
+
+    /* Allocate a pointer table. */
+    gcmkONERROR(gckOS_Allocate(
+        Kernel->os, gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH, (gctPOINTER *)&database->table));
+
+    gckOS_ZeroMemory(database->table, gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH);
+
+    /* Allocate a database mutex. */
+    gcmkONERROR(gckOS_CreateMutex(Kernel->os, &database->mutex));
+
+    /* Initialize. */
+    database->currentID = 0;
+    database->unused = gcdID_TABLE_LENGTH;
+    database->os = Kernel->os;
+    database->tableLen = gcdID_TABLE_LENGTH;
+
+    *Database = database;
+
+    gcmkFOOTER_ARG("*Database=0x%08X", *Database);
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Rollback. */
+    if (database)
+    {
+        if (database->table)
+        {
+            gcmkOS_SAFE_FREE(Kernel->os, database->table);
+        }
+
+        gcmkOS_SAFE_FREE(Kernel->os, database);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_DestroyIntegerDatabase(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Database
+    )
+{
+    gckINTEGERDB database = Database;
+
+    gcmkHEADER_ARG("Kernel=0x%08X Datbase=0x%08X", Kernel, Database);
+
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Database != gcvNULL);
+
+    /* Destroy pointer table. */
+    gcmkOS_SAFE_FREE(Kernel->os, database->table);
+
+    /* Destroy database mutex. */
+    gcmkVERIFY_OK(gckOS_DeleteMutex(Kernel->os, database->mutex));
+
+    /* Destroy database. */
+    gcmkOS_SAFE_FREE(Kernel->os, database);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckKERNEL_AllocateIntegerId(
+    IN gctPOINTER Database,
+    IN gctPOINTER Pointer,
+    OUT gctUINT32 * Id
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gctUINT32 i, unused, currentID, tableLen;
+    gctPOINTER * table;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Pointer=0x%08X", Database, Pointer);
+
+    gcmkVERIFY_ARGUMENT(Id != gcvNULL);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (database->unused < 1)
+    {
+        /* Extend table. */
+        gcmkONERROR(
+            gckOS_Allocate(os,
+                           gcmSIZEOF(gctPOINTER) * (database->tableLen + gcdID_TABLE_LENGTH),
+                           (gctPOINTER *)&table));
+
+        gckOS_ZeroMemory(table + database->tableLen,
+                         gcmSIZEOF(gctPOINTER) * gcdID_TABLE_LENGTH);
+
+        /* Copy data from old table. */
+        gckOS_MemCopy(table,
+                      database->table,
+                      database->tableLen * gcmSIZEOF(gctPOINTER));
+
+        gcmkOS_SAFE_FREE(os, database->table);
+
+        /* Update databse with new allocated table. */
+        database->table = table;
+        database->currentID = database->tableLen;
+        database->tableLen += gcdID_TABLE_LENGTH;
+        database->unused += gcdID_TABLE_LENGTH;
+    }
+
+    table = database->table;
+    currentID = database->currentID;
+    tableLen = database->tableLen;
+    unused = database->unused;
+
+    /* Connect id with pointer. */
+    table[currentID] = Pointer;
+
+    *Id = currentID + 1;
+
+    /* Update the currentID. */
+    if (--unused > 0)
+    {
+        for (i = 0; i < tableLen; i++)
+        {
+            if (++currentID >= tableLen)
+            {
+                /* Wrap to the begin. */
+                currentID = 0;
+            }
+
+            if (table[currentID] == gcvNULL)
+            {
+                break;
+            }
+        }
+    }
+
+    database->table = table;
+    database->currentID = currentID;
+    database->tableLen = tableLen;
+    database->unused = unused;
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    gcmkFOOTER_ARG("*Id=%d", *Id);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_FreeIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Id=%d", Database, Id);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (!(Id > 0 && Id <= database->tableLen))
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    Id -= 1;
+
+    database->table[Id] = gcvNULL;
+
+    if (database->unused++ == 0)
+    {
+        database->currentID = Id;
+    }
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckKERNEL_QueryIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id,
+    OUT gctPOINTER * Pointer
+    )
+{
+    gceSTATUS status;
+    gckINTEGERDB database = Database;
+    gctPOINTER pointer;
+    gckOS os = database->os;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Database=0x%08X Id=%d", Database, Id);
+    gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
+
+    gcmkVERIFY_OK(gckOS_AcquireMutex(os, database->mutex, gcvINFINITE));
+    acquired = gcvTRUE;
+
+    if (!(Id > 0 && Id <= database->tableLen))
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    Id -= 1;
+
+    pointer = database->table[Id];
+
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    acquired = gcvFALSE;
+
+    if (pointer)
+    {
+        *Pointer = pointer;
+    }
+    else
+    {
+        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+    }
+
+    gcmkFOOTER_ARG("*Pointer=0x%08X", *Pointer);
+    return gcvSTATUS_OK;
+
+OnError:
+    if (acquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, database->mutex));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+
+gctUINT32
+gckKERNEL_AllocateNameFromPointer(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Pointer
+    )
+{
+    gceSTATUS status;
+    gctUINT32 name;
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Pointer=0x%X", Kernel, Pointer);
+
+    gcmkONERROR(
+        gckKERNEL_AllocateIntegerId(database, Pointer, &name));
+
+    gcmkFOOTER_ARG("name=%d", name);
+    return name;
+
+OnError:
+    gcmkFOOTER();
+    return 0;
+}
+
+gctPOINTER
+gckKERNEL_QueryPointerFromName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    )
+{
+    gceSTATUS status;
+    gctPOINTER pointer = gcvNULL;
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Name=%d", Kernel, Name);
+
+    /* Lookup in database to get pointer. */
+    gcmkONERROR(gckKERNEL_QueryIntegerId(database, Name, &pointer));
+
+    gcmkFOOTER_ARG("pointer=0x%X", pointer);
+    return pointer;
+
+OnError:
+    gcmkFOOTER();
+    return gcvNULL;
+}
+
+gceSTATUS
+gckKERNEL_DeleteName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    )
+{
+    gctPOINTER database = Kernel->db->pointerDatabase;
+
+    gcmkHEADER_ARG("Kernel=0x%X Name=0x%X", Kernel, Name);
+
+    /* Free name if exists. */
+    gcmkVERIFY_OK(gckKERNEL_FreeIntegerId(database, Name));
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
 /*******************************************************************************
 ***** Test Code ****************************************************************
 *******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
index 908f925..5896e93 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_h_
 #define __gc_hal_kernel_h_
 
@@ -188,12 +186,15 @@ typedef struct _gcsDATABASE
     gctUINT64                           idle;
 
     /* Pointer to database. */
-    gcsDATABASE_RECORD_PTR              list;
+    gcsDATABASE_RECORD_PTR              list[48];
 
 #if gcdSECURE_USER
     /* Secure cache. */
     gcskSECURE_CACHE                    cache;
 #endif
+
+    gctPOINTER                          handleDatabase;
+    gctPOINTER                          handleDatabaseMutex;
 }
 gcsDATABASE;
 
@@ -252,6 +253,63 @@ gckKERNEL_QueryProcessDB(
     OUT gcuDATABASE_INFO * Info
     );
 
+/* Dump the process database. */
+gceSTATUS
+gckKERNEL_DumpProcessDB(
+    IN gckKERNEL Kernel
+    );
+
+/* ID database */
+gceSTATUS
+gckKERNEL_CreateIntegerDatabase(
+    IN gckKERNEL Kernel,
+    OUT gctPOINTER * Database
+    );
+
+gceSTATUS
+gckKERNEL_DestroyIntegerDatabase(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Database
+    );
+
+gceSTATUS
+gckKERNEL_AllocateIntegerId(
+    IN gctPOINTER Database,
+    IN gctPOINTER Pointer,
+    OUT gctUINT32 * Id
+    );
+
+gceSTATUS
+gckKERNEL_FreeIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id
+    );
+
+gceSTATUS
+gckKERNEL_QueryIntegerId(
+    IN gctPOINTER Database,
+    IN gctUINT32 Id,
+    OUT gctPOINTER * Pointer
+    );
+
+gctUINT32
+gckKERNEL_AllocateNameFromPointer(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Pointer
+    );
+
+gctPOINTER
+gckKERNEL_QueryPointerFromName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    );
+
+gceSTATUS
+gckKERNEL_DeleteName(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 Name
+    );
+
 #if gcdSECURE_USER
 /* Get secure cache from the process database. */
 gceSTATUS
@@ -291,6 +349,9 @@ struct _gckDB
     gctUINT64                   idleTime;
     gctUINT64                   lastSlowdown;
     gctUINT64                   lastSlowdownIdle;
+    /* ID - Pointer database*/
+    gctPOINTER                  pointerDatabase;
+    gctPOINTER                  pointerDatabaseMutex;
 };
 
 #if gcdVIRTUAL_COMMAND_BUFFER
@@ -347,6 +408,10 @@ struct _gckKERNEL
 
     /* The profile file name */
     gctCHAR                     profileFileName[gcdMAX_PROFILE_FILE_NAME];
+
+    /* Clear profile register or not*/
+    gctBOOL                     profileCleanRegister;
+
 #endif
 
 #ifdef QNX_SINGLE_THREADED_DEBUGGING
@@ -360,6 +425,7 @@ struct _gckKERNEL
 #if gcdENABLE_RECOVERY
     gctPOINTER                  resetFlagClearTimer;
     gctPOINTER                  resetAtom;
+    gctUINT64                   resetTimeStamp;
 #endif
 
     /* Pointer to gckEVENT object. */
@@ -375,6 +441,30 @@ struct _gckKERNEL
     gckVIRTUAL_COMMAND_BUFFER_PTR virtualBufferTail;
     gctPOINTER                    virtualBufferLock;
 #endif
+
+#if gcdDVFS
+    gckDVFS                     dvfs;
+#endif
+};
+
+struct _FrequencyHistory
+{
+    gctUINT32                   frequency;
+    gctUINT32                   count;
+};
+
+/* gckDVFS object. */
+struct _gckDVFS
+{
+    gckOS                       os;
+    gckHARDWARE                 hardware;
+    gctPOINTER                  timer;
+    gctUINT32                   pollingTime;
+    gctBOOL                     stop;
+    gctUINT32                   totalConfig;
+    gctUINT32                   loads[8];
+    gctUINT8                    currentScale;
+    struct _FrequencyHistory    frequencyHistory[16];
 };
 
 /* gckCOMMAND object. */
@@ -798,6 +888,13 @@ gckKERNEL_GetGPUAddress(
     IN gctPOINTER Logical,
     OUT gctUINT32 * Address
     );
+
+gceSTATUS
+gckKERNEL_QueryGPUAddress(
+    IN gckKERNEL Kernel,
+    IN gctUINT32 GpuAddress,
+    OUT gckVIRTUAL_COMMAND_BUFFER_PTR * Buffer
+    );
 #endif
 
 gceSTATUS
@@ -860,6 +957,23 @@ gckCONTEXT_Update(
     IN gcsSTATE_DELTA_PTR StateDelta
     );
 
+#if gcdLINK_QUEUE_SIZE
+void
+gckLINKQUEUE_Enqueue(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 start,
+    IN gctUINT32 end
+    );
+
+void
+gckLINKQUEUE_GetData(
+    IN gckLINKQUEUE LinkQueue,
+    IN gctUINT32 Index,
+    OUT gckLINKDATA * Data
+    );
+#endif
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
index f350f45..9ee9ea1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include "gc_hal_kernel_context.h"
 
@@ -30,9 +28,6 @@
 
 #define _GC_OBJ_ZONE            gcvZONE_COMMAND
 
-#if gcdENABLE_FSCALE_VAL_ADJUST
-extern int thermal_hot;
-#endif
 /******************************************************************************\
 ********************************* Support Code *********************************
 \******************************************************************************/
@@ -253,7 +248,7 @@ _ProcessHints(
         if (Command->hintArrayAllocated &&
             (Command->hintArraySize < CommandBuffer->hintArraySize))
         {
-            gcmkONERROR(gcmkOS_SAFE_FREE(Command->os, Command->hintArray));
+            gcmkONERROR(gcmkOS_SAFE_FREE(Command->os, gcmUINT64_TO_PTR(Command->hintArray)));
             Command->hintArraySize = gcvFALSE;
         }
 
@@ -267,18 +262,18 @@ _ProcessHints(
                 &pointer
                 ));
 
-            Command->hintArray          = pointer;
+            Command->hintArray          = gcmPTR_TO_UINT64(pointer);
             Command->hintArrayAllocated = gcvTRUE;
             Command->hintArraySize      = CommandBuffer->hintArraySize;
         }
 
-        hintArray = Command->hintArray;
+        hintArray = gcmUINT64_TO_PTR(Command->hintArray);
         copySize   = hintCount * gcmSIZEOF(gctUINT32);
 
         gcmkONERROR(gckOS_CopyFromUserData(
             Command->os,
             hintArray,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             copySize
             ));
     }
@@ -288,7 +283,7 @@ _ProcessHints(
 
         gcmkONERROR(gckOS_MapUserPointer(
             Command->os,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             CommandBuffer->hintArraySize,
             &pointer
             ));
@@ -314,7 +309,7 @@ OnError:
     {
         gcmkVERIFY_OK(gckOS_UnmapUserPointer(
             Command->os,
-            CommandBuffer->hintArray,
+            gcmUINT64_TO_PTR(CommandBuffer->hintArray),
             CommandBuffer->hintArraySize,
             hintArray
             ));
@@ -351,6 +346,86 @@ OnError:
     return status;
 }
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+static void
+_DumpBuffer(
+    IN gctPOINTER Buffer,
+    IN gctUINT32 GpuAddress,
+    IN gctSIZE_T Size
+    )
+{
+    gctINT i, line, left;
+    gctUINT32_PTR data = Buffer;
+
+    line = Size / 32;
+    left = Size % 32;
+
+
+    for (i = 0; i < line; i++)
+    {
+        gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X %08X %08X ",
+                  GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]);
+        data += 8;
+        GpuAddress += 8 * 4;
+    }
+
+    switch(left)
+    {
+        case 28:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5], data[6]);
+            break;
+        case 24:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4], data[5]);
+            break;
+        case 20:
+            gcmkPRINT("%X : %08X %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3], data[4]);
+            break;
+        case 16:
+            gcmkPRINT("%X : %08X %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2], data[3]);
+            break;
+        case 12:
+            gcmkPRINT("%X : %08X %08X %08X ",
+                      GpuAddress, data[0], data[1], data[2]);
+            break;
+        case 8:
+            gcmkPRINT("%X : %08X %08X ",
+                      GpuAddress, data[0], data[1]);
+            break;
+        case 4:
+            gcmkPRINT("%X : %08X ",
+                      GpuAddress, data[0]);
+            break;
+        default:
+            break;
+    }
+}
+
+static void
+_DumpKernelCommandBuffer(
+    IN gckCOMMAND Command
+)
+{
+    gctINT i;
+    gctUINT32 physical;
+    gctPOINTER entry;
+
+    for (i = 0; i < gcdCOMMAND_QUEUES; i++)
+    {
+        entry = Command->queues[i].logical;
+
+        gckOS_GetPhysicalAddress(Command->os, entry, &physical);
+
+        gcmkPRINT("Kernel command buffer %d\n", i);
+
+        _DumpBuffer(entry, physical, Command->pageSize);
+    }
+}
+#endif
+
 /******************************************************************************\
 ****************************** gckCOMMAND API Code ******************************
 \******************************************************************************/
@@ -600,7 +675,7 @@ gckCOMMAND_Destroy(
     /* Free state array. */
     if (Command->hintArrayAllocated)
     {
-        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Command->os, Command->hintArray));
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Command->os, gcmUINT64_TO_PTR(Command->hintArray)));
         Command->hintArrayAllocated = gcvFALSE;
     }
 #endif
@@ -1083,24 +1158,6 @@ gckCOMMAND_Commit(
     /* Extract the gckHARDWARE and gckEVENT objects. */
     hardware = Command->kernel->hardware;
 
-#if gcdENABLE_FSCALE_VAL_ADJUST
-    if(hardware->core == gcvCORE_MAJOR){
-        static gctUINT orgFscale,minFscale,maxFscale;
-        static gctBOOL bAlreadyTooHot = gcvFALSE;
-        if((thermal_hot > 0) && (!bAlreadyTooHot)) {
-            gckHARDWARE_GetFscaleValue(hardware,&orgFscale,&minFscale, &maxFscale);
-            gckHARDWARE_SetFscaleValue(hardware, minFscale);
-            bAlreadyTooHot = gcvTRUE;
-            gckOS_Print("System is too hot. GPU3D will work at %d/64 clock.\n", minFscale);
-        } else if((!(thermal_hot > 0)) && bAlreadyTooHot) {
-            gckHARDWARE_SetFscaleValue(hardware, orgFscale);
-            gckOS_Print("Hot alarm is canceled. GPU3D clock will return to %d/64\n", orgFscale);
-            bAlreadyTooHot = gcvFALSE;
-        }
-
-    }
-#endif
-
     /* Check wehther we need to copy the structures or not. */
     gcmkONERROR(gckOS_QueryNeedCopy(Command->os, ProcessID, &needCopy));
 
@@ -1160,7 +1217,7 @@ gckCOMMAND_Commit(
 
     /* Compute the command buffer entry and the size. */
     commandBufferLogical
-        = (gctUINT8_PTR) commandBufferObject->logical
+        = (gctUINT8_PTR) gcmUINT64_TO_PTR(commandBufferObject->logical)
         +                commandBufferObject->startOffset;
 
     gcmkONERROR(gckOS_GetPhysicalAddress(
@@ -1833,7 +1890,7 @@ gckCOMMAND_Commit(
 
     /* Determine the location of the LINK command in the command buffer. */
     commandBufferLink
-        = (gctUINT8_PTR) commandBufferObject->logical
+        = (gctUINT8_PTR) gcmUINT64_TO_PTR(commandBufferObject->logical)
         +                commandBufferObject->offset;
 
     /* Generate a LINK from the end of the command buffer being scheduled
@@ -1975,7 +2032,7 @@ gckCOMMAND_Commit(
             ));
 
         /* Next record in the queue. */
-        nextEventRecord = eventRecord->next;
+        nextEventRecord = gcmUINT64_TO_PTR(eventRecord->next);
 
         if (!needCopy)
         {
@@ -1990,14 +2047,14 @@ gckCOMMAND_Commit(
         EventQueue = nextEventRecord;
     }
 
-#if gcdPOWER_MANAGEMENT
-    if (Command->kernel->eventObj->queueHead == gcvNULL)
+    if (Command->kernel->eventObj->queueHead == gcvNULL
+     && Command->kernel->hardware->powerManagement == gcvTRUE
+    )
     {
         /* Commit done event by which work thread knows all jobs done. */
         gcmkVERIFY_OK(
             gckEVENT_CommitDone(Command->kernel->eventObj, gcvKERNEL_PIXEL));
     }
-#endif
 
     /* Submit events. */
     status = gckEVENT_Submit(Command->kernel->eventObj, gcvTRUE, gcvFALSE);
@@ -2667,3 +2724,262 @@ OnError:
     gcmkFOOTER();
     return status;
 }
+
+#if gcdVIRTUAL_COMMAND_BUFFER
+/*******************************************************************************
+**
+**  gckCOMMAND_DumpExecutingBuffer
+**
+**  Dump the command buffer which GPU is executing.
+**
+**  INPUT:
+**
+**      gckCOMMAND Command
+**          Pointer to a gckCOMMAND object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckCOMMAND_DumpExecutingBuffer(
+    IN gckCOMMAND Command
+    )
+{
+    gceSTATUS status;
+    gckVIRTUAL_COMMAND_BUFFER_PTR buffer;
+    gctUINT32 gpuAddress;
+    gctSIZE_T pageCount;
+    gctPOINTER entry;
+    gckOS os = Command->os;
+    gckKERNEL kernel = Command->kernel;
+#if gcdLINK_QUEUE_SIZE
+    gctINT pid;
+    gctINT i, rear;
+    gctUINT32 start, end;
+    gctUINT32 dumpFront, dumpRear;
+    gckLINKQUEUE queue = &kernel->hardware->linkQueue;
+    gckLINKQUEUE queueMirror;
+    gctUINT32 bytes;
+    gckLINKDATA linkData;
+#endif
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("**** COMMAND BUF DUMP ****\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkVERIFY_OK(gckOS_ReadRegisterEx(os, kernel->core, 0x664, &gpuAddress));
+
+    gcmkPRINT("DMA Address 0x%08X", gpuAddress);
+
+#if gcdLINK_QUEUE_SIZE
+    /* Duplicate queue because it will be changed.*/
+    gcmkONERROR(gckOS_AllocateMemory(os,
+                                     sizeof(struct _gckLINKQUEUE),
+                                     (gctPOINTER *)&queueMirror));
+
+    gcmkONERROR(gckOS_MemCopy(queueMirror,
+                              queue,
+                              sizeof(struct _gckLINKQUEUE)));
+
+    /* If kernel command buffer link to a context buffer, then link to a user command
+    ** buffer, the second link will be in queue first, so we must fix this.
+    **     In Queue:    C1 U1 U2 C2 U3 U4 U5 C3
+    **         Real: C1 X1 U1 C2 U2 U3 U4 C3 U5
+    ** Command buffer X1 which is after C1 is out of queue, so C1 is meaningless.
+    */
+    for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+
+        status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
+
+        if (gcmIS_ERROR(status))
+        {
+            /* Can't find it in virtual command buffer list, ignore it. */
+            continue;
+        }
+
+        if (buffer->kernelLogical)
+        {
+            /* It is a context buffer. */
+            if (i == 0)
+            {
+                /* The real command buffer is out, so clear this slot. */
+                linkData->start = 0;
+                linkData->end = 0;
+                linkData->pid = 0;
+            }
+            else
+            {
+                /* switch context buffer and command buffer. */
+                struct _gckLINKDATA tmp = *linkData;
+                gckLINKDATA linkDataPrevious;
+
+                gckLINKQUEUE_GetData(queueMirror, i - 1, &linkDataPrevious);
+                *linkData = *linkDataPrevious;
+                *linkDataPrevious = tmp;
+           }
+        }
+    }
+
+    /* Clear search result. */
+    dumpFront = dumpRear = gcvINFINITE;
+
+    gcmkPRINT("Link Stack:");
+
+    /* Search stuck address in link queue from rear. */
+    rear = gcdLINK_QUEUE_SIZE - 1;
+    for (i = 0; i < gcdLINK_QUEUE_SIZE; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
+
+        start = linkData->start;
+        end = linkData->end;
+        pid = linkData->pid;
+
+        if (gpuAddress >= start && gpuAddress < end)
+        {
+            /* Find latest matched command buffer. */
+            gcmkPRINT("  %d, [%08X - %08X]", pid, start, end);
+
+            /* Initiliaze dump information. */
+            dumpFront = dumpRear = rear;
+        }
+
+        /* Advance to previous one. */
+        rear--;
+
+        if (dumpFront != gcvINFINITE)
+        {
+            break;
+        }
+    }
+
+    if (dumpFront == gcvINFINITE)
+    {
+        /* Can't find matched record in link queue, dump kernel command buffer. */
+        _DumpKernelCommandBuffer(Command);
+
+        /* Free local copy. */
+        gcmkOS_SAFE_FREE(os, queueMirror);
+        return gcvSTATUS_OK;
+    }
+
+    /* Search the last context buffer linked. */
+    while (rear >= 0)
+    {
+        gckLINKQUEUE_GetData(queueMirror, rear, &linkData);
+
+        gcmkPRINT("  %d, [%08X - %08X]",
+                  linkData->pid,
+                  linkData->start,
+                  linkData->end);
+
+        status = gckKERNEL_QueryGPUAddress(kernel, linkData->start, &buffer);
+
+        if (gcmIS_SUCCESS(status) && buffer->kernelLogical)
+        {
+            /* Find a context buffer. */
+            dumpFront = rear;
+            break;
+        }
+
+        rear--;
+    }
+
+    /* Dump from last context buffer to last command buffer where hang happens. */
+    for (i = dumpFront; i <= dumpRear; i++)
+    {
+        gckLINKQUEUE_GetData(queueMirror, i, &linkData);
+
+        /* Get gpu address of this command buffer. */
+        gpuAddress = linkData->start;
+        bytes = linkData->end - gpuAddress;
+
+        /* Get the whole buffer. */
+        status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+
+        if (gcmIS_ERROR(status))
+        {
+            gcmkPRINT("Buffer [%08X - %08X] is lost",
+                      linkData->start,
+                      linkData->end);
+            continue;
+        }
+
+        /* Get kernel logical for dump. */
+        if (buffer->kernelLogical)
+        {
+            /* Get kernel logical directly if it is a context buffer. */
+            entry = buffer->kernelLogical;
+            gcmkPRINT("Context Buffer:");
+        }
+        else
+        {
+            /* Make it accessiable by kernel if it is a user command buffer. */
+            gcmkVERIFY_OK(
+                gckOS_CreateKernelVirtualMapping(buffer->physical,
+                                                 &pageCount,
+                                                 &entry));
+            gcmkPRINT("User Command Buffer:");
+        }
+
+        /* Dump from the entry. */
+        _DumpBuffer(entry + (gpuAddress - buffer->gpuAddress), gpuAddress, bytes);
+
+        /* Release kernel logical address if neccessary. */
+        if (!buffer->kernelLogical)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyKernelVirtualMapping(entry));
+        }
+    }
+
+    /* Free local copy. */
+    gcmkOS_SAFE_FREE(os, queueMirror);
+    return gcvSTATUS_OK;
+OnError:
+    return status;
+#else
+    /* Without link queue information, we don't know the entry of last command
+    ** buffer, just dump the page where GPU stuck. */
+    status = gckKERNEL_QueryGPUAddress(kernel, gpuAddress, &buffer);
+
+    if (gcmIS_SUCCESS(status))
+    {
+        gcmkVERIFY_OK(
+            gckOS_CreateKernelVirtualMapping(buffer->physical, &pageCount, &entry));
+
+        if (entry)
+        {
+            gctUINT32 offset = gpuAddress - buffer->gpuAddress;
+            gctPOINTER entryDump = entry;
+
+            /* Dump one pages. */
+            gctUINT32 bytes = 4096;
+
+            /* Align to page. */
+            offset &= 0xfffff000;
+
+            /* Kernel address of page where stall point stay. */
+            entryDump += offset;
+
+            /* Align to page. */
+            gpuAddress &= 0xfffff000;
+
+            gcmkPRINT("User Command Buffer:\n");
+            _DumpBuffer(entryDump, gpuAddress, bytes);
+        }
+
+        gcmkVERIFY_OK(
+            gckOS_DestroyKernelVirtualMapping(entry));
+    }
+    else
+    {
+        _DumpKernelCommandBuffer(Command);
+    }
+
+    return gcvSTATUS_OK;
+#endif
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
index b3e28ec..76c1c10 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
@@ -630,7 +628,7 @@ _RemoveRecordFromProcesDB(
                 Command->kernel->kernel,
                 pid,
                 gcvDB_VIDEO_MEMORY,
-                freeVideoMemory->node));
+                gcmUINT64_TO_PTR(freeVideoMemory->node)));
 
             /* Advance to next task. */
             size -= sizeof(gcsTASK_FREE_VIDEO_MEMORY);
@@ -645,7 +643,7 @@ _RemoveRecordFromProcesDB(
                 Command->kernel->kernel,
                 pid,
                 gcvDB_VIDEO_MEMORY_LOCKED,
-                unlockVideoMemory->node));
+                gcmUINT64_TO_PTR(unlockVideoMemory->node)));
 
             /* Advance to next task. */
             size -= sizeof(gcsTASK_UNLOCK_VIDEO_MEMORY);
@@ -963,7 +961,7 @@ _ConvertUserCommandBufferPointer(
         /* Translate the logical address to the kernel space. */
         gcmkERR_BREAK(_HardwareToKernel(
             Command->os,
-            mappedUserCommandBuffer->node,
+            gcmUINT64_TO_PTR(mappedUserCommandBuffer->node),
             headerAddress,
             (gctPOINTER *) KernelCommandBuffer
             ));
@@ -1137,7 +1135,7 @@ _AllocateCommandBuffer(
 
         /* Initialize the structure. */
         commandBuffer->completion    = gcvVACANT_BUFFER;
-        commandBuffer->node          = node;
+        commandBuffer->node          = gcmPTR_TO_UINT64(node);
         commandBuffer->address       = address + alignedHeaderSize;
         commandBuffer->bufferOffset  = alignedHeaderSize;
         commandBuffer->size          = requestedSize;
@@ -1192,7 +1190,7 @@ _FreeCommandBuffer(
     gceSTATUS status;
 
     /* Free the buffer. */
-    status = _FreeLinear(Kernel, CommandBuffer->node);
+    status = _FreeLinear(Kernel, gcmUINT64_TO_PTR(CommandBuffer->node));
 
     /* Return status. */
     return status;
@@ -1236,7 +1234,6 @@ _EventHandler_BusError(
     return gcvSTATUS_OK;
 }
 
-#if gcdPOWER_MANAGEMENT
 /******************************************************************************\
 ****************************** Power Stall Handler *******************************
 \******************************************************************************/
@@ -1252,7 +1249,6 @@ _EventHandler_PowerStall(
         Kernel->command->powerStallSignal,
         gcvTRUE);
 }
-#endif
 
 /******************************************************************************\
 ******************************** Task Routines *********************************
@@ -1649,7 +1645,7 @@ _TaskUnlockVideoMemory(
         /* Unlock video memory. */
         gcmkERR_BREAK(gckVIDMEM_Unlock(
             Command->kernel->kernel,
-            task->node,
+            gcmUINT64_TO_PTR(task->node),
             gcvSURF_TYPE_UNKNOWN,
             gcvNULL));
 
@@ -1680,7 +1676,7 @@ _TaskFreeVideoMemory(
             = (gcsTASK_FREE_VIDEO_MEMORY_PTR) TaskHeader->task;
 
         /* Free video memory. */
-        gcmkERR_BREAK(gckVIDMEM_Free(task->node));
+        gcmkERR_BREAK(gckVIDMEM_Free(gcmUINT64_TO_PTR(task->node)));
 
         /* Update the reference counter. */
         TaskHeader->container->referenceCount -= 1;
@@ -1967,15 +1963,12 @@ gcmDECLARE_INTERRUPT_HANDLER(COMMAND, 0)
                             );
                     }
                 }
-#if gcdPOWER_MANAGEMENT
                 else
                 {
-
                     status = gckVGHARDWARE_SetPowerManagementState(
                                 Kernel->command->hardware, gcvPOWER_IDLE_BROADCAST
                                 );
                 }
-#endif
 
                 /* Break out of the loop. */
                 break;
@@ -2850,7 +2843,7 @@ gckVGCOMMAND_Construct(
             _EventHandler_BusError
             ));
 
-#if gcdPOWER_MANAGEMENT
+
         command->powerStallInt = 30;
         /* Enable the interrupt. */
         gcmkERR_BREAK(gckVGINTERRUPT_Enable(
@@ -2858,7 +2851,6 @@ gckVGCOMMAND_Construct(
             &command->powerStallInt,
             _EventHandler_PowerStall
             ));
-#endif
 
         /***********************************************************************
         ** Task management initialization.
@@ -3421,7 +3413,6 @@ gckVGCOMMAND_Commit(
             gcvINFINITE
             ));
 
-#if gcdPOWER_MANAGEMENT
         status = gckVGHARDWARE_SetPowerManagementState(
             Command->hardware, gcvPOWER_ON_AUTO);
 
@@ -3449,7 +3440,7 @@ gckVGCOMMAND_Commit(
 
             break;
         }
-#endif
+
         gcmkERR_BREAK(_FlushMMU(Command));
 
         do
@@ -3678,10 +3669,9 @@ gckVGCOMMAND_Commit(
         }
         while (gcvFALSE);
 
-#if gcdPOWER_MANAGEMENT
         gcmkVERIFY_OK(gckOS_ReleaseSemaphore(
             Command->os, Command->powerSemaphore));
-#endif
+
         /* Release the mutex. */
         gcmkCHECK_STATUS(gckOS_ReleaseMutex(
             Command->os,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
index 9ab599b..673d4f7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_DATABASE
@@ -28,6 +26,9 @@
 /*******************************************************************************
 ***** Private fuctions ********************************************************/
 
+#define _GetSlot(database, x) \
+    (gctUINT32)(((gcmPTR_TO_UINT64(x) >> 7) % gcmCOUNTOF(database->list)))
+
 /*******************************************************************************
 **  gckKERNEL_NewDatabase
 **
@@ -58,6 +59,7 @@ gckKERNEL_NewDatabase(
     gcsDATABASE_PTR database;
     gctBOOL acquired = gcvFALSE;
     gctSIZE_T slot;
+    gcsDATABASE_PTR existingDatabase;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -65,6 +67,21 @@ gckKERNEL_NewDatabase(
     gcmkONERROR(gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
+    /* Compute the hash for the database. */
+    slot = ProcessID % gcmCOUNTOF(Kernel->db->db);
+
+    /* Walk the hash list. */
+    for (existingDatabase = Kernel->db->db[slot];
+         existingDatabase != gcvNULL;
+         existingDatabase = existingDatabase->next)
+    {
+        if (existingDatabase->processID == ProcessID)
+        {
+            /* One process can't be added twice. */
+            gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+        }
+    }
+
     if (Kernel->db->freeDatabase != gcvNULL)
     {
         /* Allocate a database from the free list. */
@@ -83,9 +100,6 @@ gckKERNEL_NewDatabase(
         database = pointer;
     }
 
-    /* Compute the hash for the database. */
-    slot = ProcessID % gcmCOUNTOF(Kernel->db->db);
-
     /* Insert the database into the hash. */
     database->next   = Kernel->db->db[slot];
     Kernel->db->db[slot] = database;
@@ -352,6 +366,7 @@ static gceSTATUS
 gckKERNEL_NewRecord(
     IN gckKERNEL Kernel,
     IN gcsDATABASE_PTR Database,
+    IN gctUINT32 Slot,
     OUT gcsDATABASE_RECORD_PTR * Record
     )
 {
@@ -385,8 +400,8 @@ gckKERNEL_NewRecord(
     }
 
     /* Insert the record in the database. */
-    record->next   = Database->list;
-    Database->list = record;
+    record->next         = Database->list[Slot];
+    Database->list[Slot] = record;
 
     /* Release the database mutex. */
     gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
@@ -451,6 +466,7 @@ gckKERNEL_DeleteRecord(
     gceSTATUS status;
     gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record, previous;
+    gctUINT32 slot = _GetSlot(Database, Data);
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x Type=%d Data=0x%x",
                    Kernel, Database, Type, Data);
@@ -460,8 +476,9 @@ gckKERNEL_DeleteRecord(
         gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
     acquired = gcvTRUE;
 
+
     /* Scan the database for this record. */
-    for (record = Database->list, previous = gcvNULL;
+    for (record = Database->list[slot], previous = gcvNULL;
          record != gcvNULL;
          record = record->next
     )
@@ -492,7 +509,7 @@ gckKERNEL_DeleteRecord(
     /* Remove record from database. */
     if (previous == gcvNULL)
     {
-        Database->list = record->next;
+        Database->list[slot] = record->next;
     }
     else
     {
@@ -559,6 +576,7 @@ gckKERNEL_FindRecord(
     gceSTATUS status;
     gctBOOL acquired = gcvFALSE;
     gcsDATABASE_RECORD_PTR record;
+    gctUINT32 slot = _GetSlot(Database, Data);
 
     gcmkHEADER_ARG("Kernel=0x%x Database=0x%x Type=%d Data=0x%x",
                    Kernel, Database, Type, Data);
@@ -569,7 +587,7 @@ gckKERNEL_FindRecord(
     acquired = gcvTRUE;
 
     /* Scan the database for this record. */
-    for (record = Database->list;
+    for (record = Database->list[slot];
          record != gcvNULL;
          record = record->next
     )
@@ -644,6 +662,7 @@ gckKERNEL_CreateProcessDB(
 {
     gceSTATUS status;
     gcsDATABASE_PTR database = gcvNULL;
+    gctUINT32 i;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -670,7 +689,11 @@ gckKERNEL_CreateProcessDB(
     database->mapUserMemory.bytes      = 0;
     database->mapUserMemory.maxBytes   = 0;
     database->mapUserMemory.totalBytes = 0;
-    database->list                  = gcvNULL;
+
+    for (i = 0; i < gcmCOUNTOF(database->list); i++)
+    {
+        database->list[i]              = gcvNULL;
+    }
 
 #if gcdSECURE_USER
     {
@@ -850,7 +873,7 @@ gckKERNEL_AddProcessDB(
     gcmkONERROR(gckKERNEL_FindDatabase(Kernel, ProcessID, gcvFALSE, &database));
 
     /* Create a new record in the database. */
-    gcmkONERROR(gckKERNEL_NewRecord(Kernel, database, &record));
+    gcmkONERROR(gckKERNEL_NewRecord(Kernel, database, _GetSlot(database, Pointer), &record));
 
     /* Initialize the record. */
     record->kernel   = Kernel;
@@ -1085,6 +1108,10 @@ gckKERNEL_DestroyProcessDB(
     gcsDATABASE_PTR database;
     gcsDATABASE_RECORD_PTR record, next;
     gctBOOL asynchronous;
+    gctPHYS_ADDR physical;
+    gcuVIDMEM_NODE_PTR node;
+    gckKERNEL kernel = Kernel;
+    gctUINT32 i;
 
     gcmkHEADER_ARG("Kernel=0x%x ProcessID=%d", Kernel, ProcessID);
 
@@ -1125,8 +1152,11 @@ gckKERNEL_DestroyProcessDB(
                        ProcessID);
     }
 
+    for(i = 0; i < gcmCOUNTOF(database->list); i++)
+    {
+
     /* Walk all records. */
-    for (record = database->list; record != gcvNULL; record = next)
+    for (record = database->list[i]; record != gcvNULL; record = next)
     {
         /* Next next record. */
         next = record->next;
@@ -1136,7 +1166,7 @@ gckKERNEL_DestroyProcessDB(
         {
         case gcvDB_VIDEO_MEMORY:
             /* Free the video memory. */
-            status = gckVIDMEM_Free(record->data);
+            status = gckVIDMEM_Free(gcmUINT64_TO_PTR(record->data));
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY 0x%x (status=%d)",
@@ -1144,17 +1174,19 @@ gckKERNEL_DestroyProcessDB(
             break;
 
         case gcvDB_NON_PAGED:
+            physical = gcmNAME_TO_PTR(record->physical);
             /* Unmap user logical memory first. */
             status = gckOS_UnmapUserLogical(Kernel->os,
-                                            record->physical,
+                                            physical,
                                             record->bytes,
                                             record->data);
 
             /* Free the non paged memory. */
             status = gckOS_FreeNonPagedMemory(Kernel->os,
                                               record->bytes,
-                                              record->physical,
+                                              physical,
                                               record->data);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: NON_PAGED 0x%x, bytes=%lu (status=%d)",
@@ -1166,9 +1198,10 @@ gckKERNEL_DestroyProcessDB(
             /* Free the command buffer. */
             status = gckEVENT_DestroyVirtualCommandBuffer(record->kernel->eventObj,
                                                           record->bytes,
-                                                          record->physical,
+                                                          gcmNAME_TO_PTR(record->physical),
                                                           record->data,
                                                           gcvKERNEL_PIXEL);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: COMMAND_BUFFER 0x%x, bytes=%lu (status=%d)",
@@ -1177,18 +1210,20 @@ gckKERNEL_DestroyProcessDB(
 #endif
 
         case gcvDB_CONTIGUOUS:
+            physical = gcmNAME_TO_PTR(record->physical);
             /* Unmap user logical memory first. */
             status = gckOS_UnmapUserLogical(Kernel->os,
-                                            record->physical,
+                                            physical,
                                             record->bytes,
                                             record->data);
 
             /* Free the contiguous memory. */
             status = gckEVENT_FreeContiguousMemory(Kernel->eventObj,
                                                    record->bytes,
-                                                   record->physical,
+                                                   physical,
                                                    record->data,
                                                    gcvKERNEL_PIXEL);
+            gcmRELEASE_NAME(record->physical);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: CONTIGUOUS 0x%x bytes=%lu (status=%d)",
@@ -1210,9 +1245,10 @@ gckKERNEL_DestroyProcessDB(
             break;
 
         case gcvDB_VIDEO_MEMORY_LOCKED:
+            node = gcmUINT64_TO_PTR(record->data);
             /* Unlock what we still locked */
             status = gckVIDMEM_Unlock(record->kernel,
-                                      record->data,
+                                      node,
                                       gcvSURF_TYPE_UNKNOWN,
                                       &asynchronous);
 
@@ -1220,19 +1256,20 @@ gckKERNEL_DestroyProcessDB(
             {
                 /* TODO: we maybe need to schedule a event here */
                 status = gckVIDMEM_Unlock(record->kernel,
-                                          record->data,
+                                          node,
                                           gcvSURF_TYPE_UNKNOWN,
                                           gcvNULL);
             }
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: VIDEO_MEMORY_LOCKED 0x%x (status=%d)",
-                           record->data, status);
+                           node, status);
             break;
 
         case gcvDB_CONTEXT:
             /* TODO: Free the context */
-            status = gckCOMMAND_Detach(Kernel->command, record->data);
+            status = gckCOMMAND_Detach(Kernel->command, gcmNAME_TO_PTR(record->data));
+            gcmRELEASE_NAME(record->data);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: CONTEXT 0x%x (status=%d)",
@@ -1257,17 +1294,18 @@ gckKERNEL_DestroyProcessDB(
                                            Kernel->core,
                                            record->physical,
                                            record->bytes,
-                                           record->data,
+                                           gcmNAME_TO_PTR(record->data),
                                            0);
+            gcmRELEASE_NAME(record->data);
 
             gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DATABASE,
                            "DB: MAP USER MEMORY %d (status=%d)",
                            gcmPTR2INT(record->data), status);
             break;
 
-                    case gcvDB_SHARED_INFO:
-                        status = gckOS_FreeMemory(Kernel->os, record->physical);
-                        break;
+        case gcvDB_SHARED_INFO:
+            status = gckOS_FreeMemory(Kernel->os, record->physical);
+            break;
 
         default:
             gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DATABASE,
@@ -1284,6 +1322,8 @@ gckKERNEL_DestroyProcessDB(
                                            gcvNULL));
     }
 
+    }
+
     /* Delete the database. */
     gcmkONERROR(gckKERNEL_DeleteDatabase(Kernel, database));
 
@@ -1350,21 +1390,21 @@ gckKERNEL_QueryProcessDB(
     switch (Type)
     {
     case gcvDB_VIDEO_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->vidMem,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_NON_PAGED:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->nonPaged,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_CONTIGUOUS:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->contiguous,
-                                  gcmSIZEOF(database->vidMem)));
+                                  gcmSIZEOF(database->vidMem));
         break;
 
     case gcvDB_IDLE:
@@ -1373,15 +1413,15 @@ gckKERNEL_QueryProcessDB(
         break;
 
     case gcvDB_MAP_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->mapMemory,
-                                  gcmSIZEOF(database->mapMemory)));
+                                  gcmSIZEOF(database->mapMemory));
         break;
 
     case gcvDB_MAP_USER_MEMORY:
-        gcmkONERROR(gckOS_MemCopy(&Info->counters,
+        gckOS_MemCopy(&Info->counters,
                                   &database->mapUserMemory,
-                                  gcmSIZEOF(database->mapUserMemory)));
+                                  gcmSIZEOF(database->mapUserMemory));
         break;
 
     default:
@@ -1449,3 +1489,48 @@ OnError:
     return status;
 }
 #endif
+
+gceSTATUS
+gckKERNEL_DumpProcessDB(
+    IN gckKERNEL Kernel
+    )
+{
+    gcsDATABASE_PTR database;
+    gctINT i, pid;
+    gctUINT8 name[24];
+
+    gcmkHEADER_ARG("Kernel=0x%x", Kernel);
+
+    /* Acquire the database mutex. */
+    gcmkVERIFY_OK(
+        gckOS_AcquireMutex(Kernel->os, Kernel->db->dbMutex, gcvINFINITE));
+
+    gcmkPRINT("**************************\n");
+    gcmkPRINT("***  PROCESS DB DUMP   ***\n");
+    gcmkPRINT("**************************\n");
+
+    gcmkPRINT_N(8, "%-8s%s\n", "PID", "NAME");
+    /* Walk the databases. */
+    for (i = 0; i < gcmCOUNTOF(Kernel->db->db); ++i)
+    {
+        for (database = Kernel->db->db[i];
+             database != gcvNULL;
+             database = database->next)
+        {
+            pid = database->processID;
+
+            gcmkVERIFY_OK(gckOS_ZeroMemory(name, gcmSIZEOF(name)));
+
+            gcmkVERIFY_OK(gckOS_GetProcessNameByPid(pid, gcmSIZEOF(name), name));
+
+            gcmkPRINT_N(8, "%-8d%s\n", pid, name);
+        }
+    }
+
+    /* Release the database mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Kernel->os, Kernel->db->dbMutex));
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
index 00decd9..a689bc3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include <gc_hal_kernel_debug.h>
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
index 75647c0..217f7f1 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 #include "gc_hal_kernel_buffer.h"
 
@@ -290,7 +288,7 @@ __RemoveRecordFromProcessDB(
         {
             /* TODO: Find a better place to bind signal to hardware.*/
             gcmkVERIFY_OK(gckOS_SignalSetHardware(Event->os,
-                        Record->info.u.Signal.signal,
+                        gcmUINT64_TO_PTR(Record->info.u.Signal.signal),
                         Event->kernel->hardware));
         }
 
@@ -308,7 +306,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_NON_PAGED,
-                Record->info.u.FreeNonPagedMemory.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeNonPagedMemory.logical)));
             break;
 
         case gcvHAL_FREE_CONTIGUOUS_MEMORY:
@@ -316,7 +314,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_CONTIGUOUS,
-                Record->info.u.FreeContiguousMemory.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeContiguousMemory.logical)));
             break;
 
         case gcvHAL_FREE_VIDEO_MEMORY:
@@ -324,7 +322,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_VIDEO_MEMORY,
-                Record->info.u.FreeVideoMemory.node));
+                gcmUINT64_TO_PTR(Record->info.u.FreeVideoMemory.node)));
             break;
 
         case gcvHAL_UNLOCK_VIDEO_MEMORY:
@@ -332,7 +330,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_VIDEO_MEMORY_LOCKED,
-                Record->info.u.UnlockVideoMemory.node));
+                gcmUINT64_TO_PTR(Record->info.u.UnlockVideoMemory.node)));
             break;
 
         case gcvHAL_UNMAP_USER_MEMORY:
@@ -340,7 +338,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_MAP_USER_MEMORY,
-                Record->info.u.UnmapUserMemory.info));
+                gcmINT2PTR(Record->info.u.UnmapUserMemory.info)));
             break;
 
         case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
@@ -348,7 +346,7 @@ __RemoveRecordFromProcessDB(
                 Event->kernel,
                 Record->processID,
                 gcvDB_COMMAND_BUFFER,
-                Record->info.u.FreeVirtualCommandBuffer.logical));
+                gcmUINT64_TO_PTR(Record->info.u.FreeVirtualCommandBuffer.logical)));
             break;
 
         default:
@@ -551,7 +549,7 @@ gckEVENT_Destroy(
     if (Event->submitTimer != gcvNULL)
     {
         gcmkVERIFY_OK(gckOS_StopTimer(Event->os, Event->submitTimer));
-        gcmkVERIFY_OK(gckOS_DestoryTimer(Event->os, Event->submitTimer));
+        gcmkVERIFY_OK(gckOS_DestroyTimer(Event->os, Event->submitTimer));
     }
 
     /* Delete the queue mutex. */
@@ -908,6 +906,7 @@ gckEVENT_AddList(
     gctBOOL acquired = gcvFALSE;
     gcsEVENT_PTR record = gcvNULL;
     gcsEVENT_QUEUE_PTR queue;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Interface=0x%x",
                    Event, Interface);
@@ -951,7 +950,7 @@ gckEVENT_AddList(
     record->fromKernel = FromKernel;
 
     /* Copy the event interface into the record. */
-    gcmkONERROR(gckOS_MemCopy(&record->info, Interface, gcmSIZEOF(record->info)));
+    gckOS_MemCopy(&record->info, Interface, gcmSIZEOF(record->info));
 
     /* Get process ID. */
     gcmkONERROR(gckOS_GetProcessID(&record->processID));
@@ -960,6 +959,8 @@ gckEVENT_AddList(
     record->kernel = Event->kernel;
 #endif
 
+    gcmkONERROR(__RemoveRecordFromProcessDB(Event, record));
+
     /* Acquire the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Event->os, Event->eventListMutex, gcvINFINITE));
     acquired = gcvTRUE;
@@ -1013,16 +1014,16 @@ gckEVENT_AddList(
     case gcvHAL_FREE_NON_PAGED_MEMORY:
         gcmkONERROR(gckOS_UnmapUserLogical(
                         Event->os,
-                        Interface->u.FreeNonPagedMemory.physical,
-                        Interface->u.FreeNonPagedMemory.bytes,
-                        Interface->u.FreeNonPagedMemory.logical));
+                        gcmNAME_TO_PTR(Interface->u.FreeNonPagedMemory.physical),
+                        (gctSIZE_T) Interface->u.FreeNonPagedMemory.bytes,
+                        gcmUINT64_TO_PTR(Interface->u.FreeNonPagedMemory.logical)));
         break;
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
         gcmkONERROR(gckOS_UnmapUserLogical(
                         Event->os,
-                        Interface->u.FreeContiguousMemory.physical,
-                        Interface->u.FreeContiguousMemory.bytes,
-                        Interface->u.FreeContiguousMemory.logical));
+                        gcmNAME_TO_PTR(Interface->u.FreeContiguousMemory.physical),
+                        (gctSIZE_T) Interface->u.FreeContiguousMemory.bytes,
+                        gcmUINT64_TO_PTR(Interface->u.FreeContiguousMemory.logical)));
         break;
     default:
         break;
@@ -1098,7 +1099,7 @@ gckEVENT_Unlock(
 
     /* Mark the event as an unlock. */
     iface.command                           = gcvHAL_UNLOCK_VIDEO_MEMORY;
-    iface.u.UnlockVideoMemory.node          = Node;
+    iface.u.UnlockVideoMemory.node          = gcmPTR_TO_UINT64(Node);
     iface.u.UnlockVideoMemory.type          = Type;
     iface.u.UnlockVideoMemory.asynchroneous = 0;
 
@@ -1155,7 +1156,7 @@ gckEVENT_FreeVideoMemory(
 
     /* Create an event. */
     iface.command = gcvHAL_FREE_VIDEO_MEMORY;
-    iface.u.FreeVideoMemory.node = VideoMemory;
+    iface.u.FreeVideoMemory.node = gcmPTR_TO_UINT64(VideoMemory);
 
     /* Append it to the queue. */
     gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
@@ -1204,6 +1205,7 @@ gckEVENT_FreeNonPagedMemory(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1218,8 +1220,8 @@ gckEVENT_FreeNonPagedMemory(
     /* Create an event. */
     iface.command = gcvHAL_FREE_NON_PAGED_MEMORY;
     iface.u.FreeNonPagedMemory.bytes    = Bytes;
-    iface.u.FreeNonPagedMemory.physical = Physical;
-    iface.u.FreeNonPagedMemory.logical  = Logical;
+    iface.u.FreeNonPagedMemory.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeNonPagedMemory.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
     gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
@@ -1245,6 +1247,7 @@ gckEVENT_DestroyVirtualCommandBuffer(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1259,8 +1262,8 @@ gckEVENT_DestroyVirtualCommandBuffer(
     /* Create an event. */
     iface.command = gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER;
     iface.u.FreeVirtualCommandBuffer.bytes    = Bytes;
-    iface.u.FreeVirtualCommandBuffer.physical = Physical;
-    iface.u.FreeVirtualCommandBuffer.logical  = Logical;
+    iface.u.FreeVirtualCommandBuffer.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeVirtualCommandBuffer.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
     gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
@@ -1309,6 +1312,7 @@ gckEVENT_FreeContiguousMemory(
 {
     gceSTATUS status;
     gcsHAL_INTERFACE iface;
+    gckKERNEL kernel = Event->kernel;
 
     gcmkHEADER_ARG("Event=0x%x Bytes=%lu Physical=0x%x Logical=0x%x "
                    "FromWhere=%d",
@@ -1323,8 +1327,8 @@ gckEVENT_FreeContiguousMemory(
     /* Create an event. */
     iface.command = gcvHAL_FREE_CONTIGUOUS_MEMORY;
     iface.u.FreeContiguousMemory.bytes    = Bytes;
-    iface.u.FreeContiguousMemory.physical = Physical;
-    iface.u.FreeContiguousMemory.logical  = Logical;
+    iface.u.FreeContiguousMemory.physical = gcmPTR_TO_NAME(Physical);
+    iface.u.FreeContiguousMemory.logical  = gcmPTR_TO_UINT64(Logical);
 
     /* Append it to the queue. */
     gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
@@ -1379,13 +1383,13 @@ gckEVENT_Signal(
 
     /* Mark the event as a signal. */
     iface.command            = gcvHAL_SIGNAL;
-    iface.u.Signal.signal    = Signal;
+    iface.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
 #ifdef __QNXNTO__
     iface.u.Signal.coid      = 0;
     iface.u.Signal.rcvid     = 0;
 #endif
-    iface.u.Signal.auxSignal = gcvNULL;
-    iface.u.Signal.process   = gcvNULL;
+    iface.u.Signal.auxSignal = 0;
+    iface.u.Signal.process   = 0;
 
     /* Append it to the queue. */
     gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE, gcvTRUE));
@@ -1537,9 +1541,6 @@ gckEVENT_Submit(
             gcmkONERROR(gckOS_ReleaseMutex(Event->os, Event->eventListMutex));
             acquired = gcvFALSE;
 
-            gcmkONERROR(__RemoveRecordFromProcessDB(Event,
-                Event->queues[id].head));
-
 #if gcdNULL_DRIVER
             /* Notify immediately on infinite hardware. */
             gcmkONERROR(gckEVENT_Interrupt(Event, 1 << id));
@@ -1690,7 +1691,7 @@ gckEVENT_Commit(
             gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL, gcvTRUE, gcvFALSE));
 
         /* Next record in the queue. */
-        next = record->next;
+        next = gcmUINT64_TO_PTR(record->next);
 
         if (!needCopy)
         {
@@ -1783,12 +1784,12 @@ gckEVENT_Compose(
     tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
     tempRecord->info.u.Signal.signal    = Info->signal;
-    tempRecord->info.u.Signal.auxSignal = gcvNULL;
+    tempRecord->info.u.Signal.auxSignal = 0;
     tempRecord->next = gcvNULL;
     tempRecord->processID = processID;
 
     /* Allocate another record for user signal #1. */
-    if (Info->userSignal1 != gcvNULL)
+    if (gcmUINT64_TO_PTR(Info->userSignal1) != gcvNULL)
     {
         /* Allocate a record. */
         gcmkONERROR(gckEVENT_AllocateRecord(Event, gcvTRUE, &tempRecord));
@@ -1803,13 +1804,13 @@ gckEVENT_Compose(
         tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
         tempRecord->info.u.Signal.signal    = Info->userSignal1;
-        tempRecord->info.u.Signal.auxSignal = gcvNULL;
+        tempRecord->info.u.Signal.auxSignal = 0;
         tempRecord->next = gcvNULL;
         tempRecord->processID = processID;
     }
 
     /* Allocate another record for user signal #2. */
-    if (Info->userSignal2 != gcvNULL)
+    if (gcmUINT64_TO_PTR(Info->userSignal2) != gcvNULL)
     {
         /* Allocate a record. */
         gcmkONERROR(gckEVENT_AllocateRecord(Event, gcvTRUE, &tempRecord));
@@ -1824,7 +1825,7 @@ gckEVENT_Compose(
         tempRecord->info.u.Signal.rcvid     = Info->rcvid;
 #endif
         tempRecord->info.u.Signal.signal    = Info->userSignal2;
-        tempRecord->info.u.Signal.auxSignal = gcvNULL;
+        tempRecord->info.u.Signal.auxSignal = 0;
         tempRecord->next = gcvNULL;
         tempRecord->processID = processID;
     }
@@ -1835,7 +1836,7 @@ gckEVENT_Compose(
     /* Start composition. */
     gcmkONERROR(gckHARDWARE_Compose(
         Event->kernel->hardware, processID,
-        Info->physical, Info->logical, Info->offset, Info->size, id
+        gcmUINT64_TO_PTR(Info->physical), gcmUINT64_TO_PTR(Info->logical), Info->offset, Info->size, id
         ));
 
     /* Success. */
@@ -1918,10 +1919,11 @@ gckEVENT_Notify(
     gcsEVENT_QUEUE * queue;
     gctUINT mask = 0;
     gctBOOL acquired = gcvFALSE;
-#ifdef __QNXNTO__
     gcuVIDMEM_NODE_PTR node;
-#endif
+    gctPOINTER info;
+    gctSIGNAL signal;
     gctUINT pending;
+    gckKERNEL kernel = Event->kernel;
 #if !gcdSMP
     gctBOOL suspended = gcvFALSE;
 #endif
@@ -2182,14 +2184,14 @@ gckEVENT_Notify(
             case gcvHAL_FREE_NON_PAGED_MEMORY:
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_FREE_NON_PAGED_MEMORY: 0x%x",
-                               record->info.u.FreeNonPagedMemory.physical);
+                               gcmNAME_TO_PTR(record->info.u.FreeNonPagedMemory.physical));
 
                 /* Free non-paged memory. */
                 status = gckOS_FreeNonPagedMemory(
                             Event->os,
-                            record->info.u.FreeNonPagedMemory.bytes,
-                            record->info.u.FreeNonPagedMemory.physical,
-                            record->info.u.FreeNonPagedMemory.logical);
+                            (gctSIZE_T) record->info.u.FreeNonPagedMemory.bytes,
+                            gcmNAME_TO_PTR(record->info.u.FreeNonPagedMemory.physical),
+                            gcmUINT64_TO_PTR(record->info.u.FreeNonPagedMemory.logical));
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -2197,24 +2199,25 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        record->event.u.FreeNonPagedMemory.logical,
-                        record->event.u.FreeNonPagedMemory.bytes));
+                        gcmUINT64_TO_PTR(record->record.u.FreeNonPagedMemory.logical),
+                        (gctSIZE_T) record->record.u.FreeNonPagedMemory.bytes));
 #endif
                 }
+                gcmRELEASE_NAME(record->info.u.FreeNonPagedMemory.physical);
                 break;
 
             case gcvHAL_FREE_CONTIGUOUS_MEMORY:
                 gcmkTRACE_ZONE(
                     gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                     "gcvHAL_FREE_CONTIGUOUS_MEMORY: 0x%x",
-                    record->info.u.FreeContiguousMemory.physical);
+                    gcmNAME_TO_PTR(record->info.u.FreeContiguousMemory.physical));
 
                 /* Unmap the user memory. */
                 status = gckOS_FreeContiguous(
                             Event->os,
-                            record->info.u.FreeContiguousMemory.physical,
-                            record->info.u.FreeContiguousMemory.logical,
-                            record->info.u.FreeContiguousMemory.bytes);
+                            gcmNAME_TO_PTR(record->info.u.FreeContiguousMemory.physical),
+                            gcmUINT64_TO_PTR(record->info.u.FreeContiguousMemory.logical),
+                            (gctSIZE_T) record->info.u.FreeContiguousMemory.bytes);
 
                 if (gcmIS_SUCCESS(status))
                 {
@@ -2222,19 +2225,19 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        event->event.u.FreeContiguousMemory.logical,
-                        event->event.u.FreeContiguousMemory.bytes));
+                        gcmUINT64_TO_PTR(record->record.u.FreeContiguousMemory.logical),
+                        (gctSIZE_T) record->record.u.FreeContiguousMemory.bytes));
 #endif
                 }
+                gcmRELEASE_NAME(record->info.u.FreeContiguousMemory.physical);
                 break;
 
             case gcvHAL_FREE_VIDEO_MEMORY:
+                node = gcmUINT64_TO_PTR(record->info.u.FreeVideoMemory.node);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_FREE_VIDEO_MEMORY: 0x%x",
-                               record->info.u.FreeVideoMemory.node);
-
+                               node);
 #ifdef __QNXNTO__
-                node = record->info.u.FreeVideoMemory.node;
 #if gcdUSE_VIDMEM_PER_PID
                 /* Check if the VidMem object still exists. */
                 if (gckKERNEL_GetVideoMemoryPoolPid(record->kernel,
@@ -2263,7 +2266,7 @@ gckEVENT_Notify(
 
                 /* Free video memory. */
                 status =
-                    gckVIDMEM_Free(record->info.u.FreeVideoMemory.node);
+                    gckVIDMEM_Free(node);
 
                 break;
 
@@ -2298,13 +2301,14 @@ gckEVENT_Notify(
                 break;
 
             case gcvHAL_UNLOCK_VIDEO_MEMORY:
+                node = gcmUINT64_TO_PTR(record->info.u.UnlockVideoMemory.node);
+
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_UNLOCK_VIDEO_MEMORY: 0x%x",
-                               record->info.u.UnlockVideoMemory.node);
+                               node);
 
                 /* Save node information before it disappears. */
 #if gcdSECURE_USER
-                node = event->event.u.UnlockVideoMemory.node;
                 if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
                 {
                     logical = gcvNULL;
@@ -2320,7 +2324,7 @@ gckEVENT_Notify(
                 /* Unlock. */
                 status = gckVIDMEM_Unlock(
                     Event->kernel,
-                    record->info.u.UnlockVideoMemory.node,
+                    node,
                     record->info.u.UnlockVideoMemory.type,
                     gcvNULL);
 
@@ -2337,9 +2341,10 @@ gckEVENT_Notify(
                 break;
 
             case gcvHAL_SIGNAL:
+                signal = gcmUINT64_TO_PTR(record->info.u.Signal.signal);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_SIGNAL: 0x%x",
-                               record->info.u.Signal.signal);
+                               signal);
 
 #ifdef __QNXNTO__
                 if ((record->info.u.Signal.coid == 0)
@@ -2349,7 +2354,7 @@ gckEVENT_Notify(
                     /* Kernel signal. */
                     gcmkERR_BREAK(
                         gckOS_Signal(Event->os,
-                                     record->info.u.Signal.signal,
+                                     signal,
                                      gcvTRUE));
                 }
                 else
@@ -2357,18 +2362,18 @@ gckEVENT_Notify(
                     /* User signal. */
                     gcmkERR_BREAK(
                         gckOS_UserSignal(Event->os,
-                                         record->info.u.Signal.signal,
+                                         signal,
                                          record->info.u.Signal.rcvid,
                                          record->info.u.Signal.coid));
                 }
 #else
                 /* Set signal. */
-                if (record->info.u.Signal.process == gcvNULL)
+                if (gcmUINT64_TO_PTR(record->info.u.Signal.process) == gcvNULL)
                 {
                     /* Kernel signal. */
                     gcmkERR_BREAK(
                         gckOS_Signal(Event->os,
-                                     record->info.u.Signal.signal,
+                                     signal,
                                      gcvTRUE));
                 }
                 else
@@ -2376,26 +2381,27 @@ gckEVENT_Notify(
                     /* User signal. */
                     gcmkERR_BREAK(
                         gckOS_UserSignal(Event->os,
-                                         record->info.u.Signal.signal,
-                                         record->info.u.Signal.process));
+                                         signal,
+                                         gcmUINT64_TO_PTR(record->info.u.Signal.process)));
                 }
 
-                gcmkASSERT(record->info.u.Signal.auxSignal == gcvNULL);
+                gcmkASSERT(record->info.u.Signal.auxSignal == 0);
 #endif
                 break;
 
             case gcvHAL_UNMAP_USER_MEMORY:
+                info = gcmNAME_TO_PTR(record->info.u.UnmapUserMemory.info);
                 gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
                                "gcvHAL_UNMAP_USER_MEMORY: 0x%x",
-                               record->info.u.UnmapUserMemory.info);
+                               info);
 
                 /* Unmap the user memory. */
                 status = gckOS_UnmapUserMemory(
                     Event->os,
                     Event->kernel->core,
-                    record->info.u.UnmapUserMemory.memory,
-                    record->info.u.UnmapUserMemory.size,
-                    record->info.u.UnmapUserMemory.info,
+                    gcmUINT64_TO_PTR(record->info.u.UnmapUserMemory.memory),
+                    (gctSIZE_T) record->info.u.UnmapUserMemory.size,
+                    info,
                     record->info.u.UnmapUserMemory.address);
 
 #if gcdSECURE_USER
@@ -2404,10 +2410,11 @@ gckEVENT_Notify(
                     gcmkVERIFY_OK(gckKERNEL_FlushTranslationCache(
                         Event->kernel,
                         cache,
-                        event->event.u.UnmapUserMemory.memory,
-                        event->event.u.UnmapUserMemory.size));
+                        gcmUINT64_TO_PTR(record->info.u.UnmapUserMemory.memory),
+                        (gctSIZE_T) record->info.u.UnmapUserMemory.size));
                 }
 #endif
+                gcmRELEASE_NAME(record->info.u.UnmapUserMemory.info);
                 break;
 
             case gcvHAL_TIMESTAMP:
@@ -2448,10 +2455,11 @@ gckEVENT_Notify(
              case gcvHAL_FREE_VIRTUAL_COMMAND_BUFFER:
                  gcmkVERIFY_OK(
                      gckKERNEL_DestroyVirtualCommandBuffer(Event->kernel,
-                         record->info.u.FreeVirtualCommandBuffer.bytes,
-                         record->info.u.FreeVirtualCommandBuffer.physical,
-                         record->info.u.FreeVirtualCommandBuffer.logical
+                         (gctSIZE_T) record->info.u.FreeVirtualCommandBuffer.bytes,
+                         gcmNAME_TO_PTR(record->info.u.FreeVirtualCommandBuffer.physical),
+                         gcmUINT64_TO_PTR(record->info.u.FreeVirtualCommandBuffer.logical)
                          ));
+                 gcmRELEASE_NAME(record->info.u.FreeVirtualCommandBuffer.physical);
                  break;
 #endif
 
@@ -2701,13 +2709,13 @@ gckEVENT_Stop(
     record->next = gcvNULL;
     record->processID               = ProcessID;
     record->info.command            = gcvHAL_SIGNAL;
-    record->info.u.Signal.signal    = Signal;
+    record->info.u.Signal.signal    = gcmPTR_TO_UINT64(Signal);
 #ifdef __QNXNTO__
     record->info.u.Signal.coid      = 0;
     record->info.u.Signal.rcvid     = 0;
 #endif
-    record->info.u.Signal.auxSignal = gcvNULL;
-    record->info.u.Signal.process   = gcvNULL;
+    record->info.u.Signal.auxSignal = 0;
+    record->info.u.Signal.process   = 0;
 
     /* Append the record. */
     Event->queues[id].head      = record;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
index c68e0c1..a5affb9 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /**
 **  @file
 **  gckHEAP object for kernel HAL layer.  The heap implemented here is an arena-
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
index e2f84f6..8ac187b 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
index 72e2b4f..c7f67c7 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_MMU
@@ -37,6 +35,8 @@ gceMMU_TYPE;
 
 #define gcdMMU_TABLE_DUMP       0
 
+#define gcdUSE_MMU_EXCEPTION    0
+
 /*
     gcdMMU_CLEAR_VALUE
 
@@ -97,6 +97,51 @@ static gcsMirrorPageTable_PTR mirrorPageTable = gcvNULL;
 static gctPOINTER mirrorPageTableMutex = gcvNULL;
 #endif
 
+typedef struct _gcsDynamicSpaceNode * gcsDynamicSpaceNode_PTR;
+typedef struct _gcsDynamicSpaceNode
+{
+    gctUINT32       start;
+    gctINT32        entries;
+}
+gcsDynamicSpaceNode;
+
+static void
+_WritePageEntry(
+    IN gctUINT32_PTR PageEntry,
+    IN gctUINT32     EntryValue
+    )
+{
+    static gctUINT16 data = 0xff00;
+
+    if (*(gctUINT8 *)&data == 0xff)
+    {
+        *PageEntry = gcmSWAB32(EntryValue);
+    }
+    else
+    {
+        *PageEntry = EntryValue;
+    }
+}
+
+static gctUINT32
+_ReadPageEntry(
+    IN gctUINT32_PTR PageEntry
+    )
+{
+    static gctUINT16 data = 0xff00;
+    gctUINT32 entryValue;
+
+    if (*(gctUINT8 *)&data == 0xff)
+    {
+        entryValue = *PageEntry;
+        return gcmSWAB32(entryValue);
+    }
+    else
+    {
+        return *PageEntry;
+    }
+}
+
 static gceSTATUS
 _FillPageTable(
     IN gctUINT32_PTR PageTable,
@@ -108,7 +153,7 @@ _FillPageTable(
 
     for (i = 0; i < PageCount; i++)
     {
-        PageTable[i] = EntryValue;
+        _WritePageEntry(PageTable + i, EntryValue);
     }
 
     return gcvSTATUS_OK;
@@ -132,16 +177,16 @@ _Link(
         gctUINT32_PTR pageTable = Mmu->pageTableLogical;
 
         /* Dispatch on node type. */
-        switch (gcmENTRY_TYPE(pageTable[Index]))
+        switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[Index])))
         {
         case gcvMMU_SINGLE:
             /* Set single index. */
-            pageTable[Index] = (Next << 8) | gcvMMU_SINGLE;
+            _WritePageEntry(&pageTable[Index], (Next << 8) | gcvMMU_SINGLE);
             break;
 
         case gcvMMU_FREE:
             /* Set index. */
-            pageTable[Index + 1] = Next;
+            _WritePageEntry(&pageTable[Index + 1], Next);
             break;
 
         default:
@@ -167,13 +212,13 @@ _AddFree(
     if (Count == 1)
     {
         /* Initialize a single page node. */
-        pageTable[Node] = (~((1U<<8)-1)) | gcvMMU_SINGLE;
+        _WritePageEntry(pageTable + Node, (~((1U<<8)-1)) | gcvMMU_SINGLE);
     }
     else
     {
         /* Initialize the node. */
-        pageTable[Node + 0] = (Count << 8) | gcvMMU_FREE;
-        pageTable[Node + 1] = ~0U;
+        _WritePageEntry(pageTable + Node + 0, (Count << 8) | gcvMMU_FREE);
+        _WritePageEntry(pageTable + Node + 1, ~0U);
     }
 
     /* Append the node. */
@@ -196,7 +241,7 @@ _Collect(
     for (i = 0; i < Mmu->pageTableEntries; ++i)
     {
         /* Dispatch based on type of page. */
-        switch (gcmENTRY_TYPE(pageTable[i]))
+        switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[i])))
         {
         case gcvMMU_USED:
             /* Used page, so close any open node. */
@@ -229,10 +274,10 @@ _Collect(
             }
 
             /* Advance the count. */
-            count += pageTable[i] >> 8;
+            count += _ReadPageEntry(&pageTable[i]) >> 8;
 
             /* Advance the index into the page table. */
-            i     += (pageTable[i] >> 8) - 1;
+            i     += (_ReadPageEntry(&pageTable[i]) >> 8) - 1;
             break;
 
         default:
@@ -341,19 +386,20 @@ _FillFlatMapping(
                 gcmkONERROR(gcvSTATUS_NOT_ALIGNED);
             }
 
-            *(Mmu->mtlbLogical + mStart)
-                      = stlb->physBase
-                        /* 64KB page size */
-                        | (1 << 2)
-                        /* Ignore exception */
-                        | (0 << 1)
-                        /* Present */
-                        | (1 << 0);
+            _WritePageEntry(Mmu->mtlbLogical + mStart,
+                            stlb->physBase
+                            /* 64KB page size */
+                            | (1 << 2)
+                            /* Ignore exception */
+                            | (0 << 1)
+                            /* Present */
+                            | (1 << 0)
+                            );
 #if gcdMMU_TABLE_DUMP
             gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
                 __FUNCTION__, __LINE__,
                 mStart,
-                *(Mmu->mtlbLogical + mStart));
+                _ReadPageEntry(Mmu->mtlbLogical + mStart));
 #endif
 
             stlb->mtlbIndex = mStart;
@@ -368,12 +414,12 @@ _FillFlatMapping(
             while (sStart <= last)
             {
                 gcmkASSERT(!(start & gcdMMU_PAGE_64K_MASK));
-                *(stlb->logical + sStart) = _SetPage(start);
+                _WritePageEntry(stlb->logical + sStart, _SetPage(start));
 #if gcdMMU_TABLE_DUMP
                 gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
                     __FUNCTION__, __LINE__,
                     sStart,
-                    *(stlb->logical + sStart));
+                    _ReadPageEntry(stlb->logical + sStart));
 #endif
                 /* next page. */
                 start += gcdMMU_PAGE_64K_SIZE;
@@ -428,7 +474,7 @@ OnError:
         if (pre->mtlbEntryNum != 0)
         {
             gcmkASSERT(pre->mtlbEntryNum == 1);
-            *(Mmu->mtlbLogical + pre->mtlbIndex) = 0;
+            _WritePageEntry(Mmu->mtlbLogical + pre->mtlbIndex, 0);
         }
 
         gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, pre));
@@ -444,30 +490,117 @@ OnError:
 }
 
 static gceSTATUS
+_FindDynamicSpace(
+    IN gckMMU Mmu,
+    OUT gcsDynamicSpaceNode_PTR *Array,
+    OUT gctINT * Size
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+    gctPOINTER pointer = gcvNULL;
+    gcsDynamicSpaceNode_PTR array = gcvNULL;
+    gctINT size = 0;
+    gctINT i = 0, nodeStart = -1, nodeEntries = 0;
+
+    /* Allocate memory for the array. */
+    gcmkONERROR(gckOS_Allocate(Mmu->os,
+                               gcmSIZEOF(*array) * (gcdMMU_MTLB_ENTRY_NUM / 2),
+                               &pointer));
+
+    array = (gcsDynamicSpaceNode_PTR)pointer;
+
+    /* Loop all the entries. */
+    while (i < gcdMMU_MTLB_ENTRY_NUM)
+    {
+        if (!Mmu->mtlbLogical[i])
+        {
+            if (nodeStart < 0)
+            {
+                /* This is the first entry of the dynamic space. */
+                nodeStart   = i;
+                nodeEntries = 1;
+            }
+            else
+            {
+                /* Other entries of the dynamic space. */
+                nodeEntries++;
+            }
+        }
+        else if (nodeStart >= 0)
+        {
+            /* Save the previous node. */
+            array[size].start   = nodeStart;
+            array[size].entries = nodeEntries;
+            size++;
+
+            /* Reset the start. */
+            nodeStart   = -1;
+            nodeEntries = 0;
+        }
+
+        i++;
+    }
+
+    /* Save the previous node. */
+    if (nodeStart >= 0)
+    {
+        array[size].start   = nodeStart;
+        array[size].entries = nodeEntries;
+        size++;
+    }
+
+#if gcdMMU_TABLE_DUMP
+    for (i = 0; i < size; i++)
+    {
+        gckOS_Print("%s(%d): [%d]: start=%d, entries=%d.\n",
+                __FUNCTION__, __LINE__,
+                i,
+                array[i].start,
+                array[i].entries);
+    }
+#endif
+
+    *Array = array;
+    *Size  = size;
+
+    return gcvSTATUS_OK;
+
+OnError:
+    if (pointer != gcvNULL)
+    {
+        gckOS_Free(Mmu->os, pointer);
+    }
+
+    return status;
+}
+
+static gceSTATUS
 _SetupDynamicSpace(
     IN gckMMU Mmu
     )
 {
     gceSTATUS status;
-    gctINT i;
+    gcsDynamicSpaceNode_PTR nodeArray = gcvNULL;
+    gctINT i, nodeArraySize = 0;
     gctUINT32 physical;
-    gctINT numEntries;
+    gctINT numEntries = 0;
     gctUINT32_PTR pageTable;
     gctBOOL acquired = gcvFALSE;
 
-    /* find the start of dynamic address space. */
-    for (i = 0; i < gcdMMU_MTLB_ENTRY_NUM; i++)
+    /* Find all the dynamic address space. */
+    gcmkONERROR(_FindDynamicSpace(Mmu, &nodeArray, &nodeArraySize));
+
+    /* TODO: We only use the largest one for now. */
+    for (i = 0; i < nodeArraySize; i++)
     {
-        if (!Mmu->mtlbLogical[i])
+        if (nodeArray[i].entries > numEntries)
         {
-            break;
+            Mmu->dynamicMappingStart = nodeArray[i].start;
+            numEntries               = nodeArray[i].entries;
         }
     }
 
-    Mmu->dynamicMappingStart = i;
-
-    /* Number of entries in Master TLB for dynamic mapping. */
-    numEntries = gcdMMU_MTLB_ENTRY_NUM - i;
+    gckOS_Free(Mmu->os, (gctPOINTER)nodeArray);
 
     Mmu->pageTableSize = numEntries * 4096;
 
@@ -480,14 +613,21 @@ _SetupDynamicSpace(
                 &Mmu->pageTablePhysical,
                 (gctPOINTER)&Mmu->pageTableLogical));
 
+#if gcdUSE_MMU_EXCEPTION
+    gcmkONERROR(_FillPageTable(Mmu->pageTableLogical,
+                               Mmu->pageTableEntries,
+                               /* Enable exception */
+                               1 << 1));
+#else
     /* Invalidate all entries. */
     gcmkONERROR(gckOS_ZeroMemory(Mmu->pageTableLogical,
                 Mmu->pageTableSize));
+#endif
 
     /* Initilization. */
     pageTable      = Mmu->pageTableLogical;
-    pageTable[0]   = (Mmu->pageTableEntries << 8) | gcvMMU_FREE;
-    pageTable[1]   = ~0U;
+    _WritePageEntry(pageTable,     (Mmu->pageTableEntries << 8) | gcvMMU_FREE);
+    _WritePageEntry(pageTable + 1, ~0U);
     Mmu->heapList  = 0;
     Mmu->freeNodes = gcvFALSE;
 
@@ -500,20 +640,24 @@ _SetupDynamicSpace(
     acquired = gcvTRUE;
 
     /* Map to Master TLB. */
-    for (; i < gcdMMU_MTLB_ENTRY_NUM; i++)
+    for (i = (gctINT)Mmu->dynamicMappingStart;
+         i < (gctINT)Mmu->dynamicMappingStart + numEntries;
+         i++)
     {
-        Mmu->mtlbLogical[i] = physical
-                            /* 4KB page size */
-                            | (0 << 2)
-                            /* Ignore exception */
-                            | (0 << 1)
-                            /* Present */
-                            | (1 << 0);
+        _WritePageEntry(Mmu->mtlbLogical + i,
+                        physical
+                        /* 4KB page size */
+                        | (0 << 2)
+                        /* Ignore exception */
+                        | (0 << 1)
+                        /* Present */
+                        | (1 << 0)
+                        );
 #if gcdMMU_TABLE_DUMP
         gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
                 __FUNCTION__, __LINE__,
                 i,
-                *(Mmu->mtlbLogical + i));
+                _ReadPageEntry(Mmu->mtlbLogical + i));
 #endif
         physical += gcdMMU_STLB_4K_SIZE;
     }
@@ -638,18 +782,11 @@ _Construct(
         pageTable      = mmu->pageTableLogical;
 
 #if gcdMMU_CLEAR_VALUE
-        {
-            gctUINT32 i;
-
-            for (i = 0; i < mmu->pageTableEntries; ++i)
-            {
-                pageTable[i] = gcdMMU_CLEAR_VALUE;
-            }
-        }
+        _FillPageTable(pageTable, mmu->pageTableEntries, gcdMMU_CLEAR_VALUE);
 #endif
 
-        pageTable[0]   = (mmu->pageTableEntries << 8) | gcvMMU_FREE;
-        pageTable[1]   = ~0U;
+        _WritePageEntry(pageTable,     (mmu->pageTableEntries << 8) | gcvMMU_FREE);
+        _WritePageEntry(pageTable + 1, ~0U);
         mmu->heapList  = 0;
         mmu->freeNodes = gcvFALSE;
 
@@ -790,7 +927,7 @@ _Destroy(
         if (pre->mtlbEntryNum != 0)
         {
             gcmkASSERT(pre->mtlbEntryNum == 1);
-            *(Mmu->mtlbLogical + pre->mtlbIndex) = 0;
+            _WritePageEntry(Mmu->mtlbLogical + pre->mtlbIndex, 0);
 #if gcdMMU_TABLE_DUMP
             gckOS_Print("%s(%d): clean MTLB[%d]\n",
                 __FUNCTION__, __LINE__,
@@ -1037,7 +1174,7 @@ _AllocatePages(
         for (index = Mmu->heapList; !gotIt && (index < Mmu->pageTableEntries);)
         {
             /* Check the node type. */
-            switch (gcmENTRY_TYPE(pageTable[index]))
+            switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[index])))
             {
             case gcvMMU_SINGLE:
                 /* Single odes are valid if we only need 1 page. */
@@ -1049,13 +1186,13 @@ _AllocatePages(
                 {
                     /* Move to next node. */
                     previous = index;
-                    index    = pageTable[index] >> 8;
+                    index    = _ReadPageEntry(&pageTable[index]) >> 8;
                 }
                 break;
 
             case gcvMMU_FREE:
                 /* Test if the node has enough space. */
-                if (PageCount <= (pageTable[index] >> 8))
+                if (PageCount <= (_ReadPageEntry(&pageTable[index]) >> 8))
                 {
                     gotIt = gcvTRUE;
                 }
@@ -1063,7 +1200,7 @@ _AllocatePages(
                 {
                     /* Move to next node. */
                     previous = index;
-                    index    = pageTable[index + 1];
+                    index    = _ReadPageEntry(&pageTable[index + 1]);
                 }
                 break;
 
@@ -1092,36 +1229,36 @@ _AllocatePages(
         }
     }
 
-    switch (gcmENTRY_TYPE(pageTable[index]))
+    switch (gcmENTRY_TYPE(_ReadPageEntry(&pageTable[index])))
     {
     case gcvMMU_SINGLE:
         /* Unlink single node from free list. */
         gcmkONERROR(
-            _Link(Mmu, previous, pageTable[index] >> 8));
+            _Link(Mmu, previous, _ReadPageEntry(&pageTable[index]) >> 8));
         break;
 
     case gcvMMU_FREE:
         /* Check how many pages will be left. */
-        left = (pageTable[index] >> 8) - PageCount;
+        left = (_ReadPageEntry(&pageTable[index]) >> 8) - PageCount;
         switch (left)
         {
         case 0:
             /* The entire node is consumed, just unlink it. */
             gcmkONERROR(
-                _Link(Mmu, previous, pageTable[index + 1]));
+                _Link(Mmu, previous, _ReadPageEntry(&pageTable[index + 1])));
             break;
 
         case 1:
             /* One page will remain.  Convert the node to a single node and
             ** advance the index. */
-            pageTable[index] = (pageTable[index + 1] << 8) | gcvMMU_SINGLE;
+            _WritePageEntry(&pageTable[index], (_ReadPageEntry(&pageTable[index + 1]) << 8) | gcvMMU_SINGLE);
             index ++;
             break;
 
         default:
             /* Enough pages remain for a new node.  However, we will just adjust
             ** the size of the current node and advance the index. */
-            pageTable[index] = (left << 8) | gcvMMU_FREE;
+            _WritePageEntry(&pageTable[index], (left << 8) | gcvMMU_FREE);
             index += left;
             break;
         }
@@ -1225,25 +1362,37 @@ _FreePages(
 #if gcdMMU_CLEAR_VALUE
     if (Mmu->hardware->mmuVersion == 0)
     {
-        gctUINT32 i;
-
-        for (i = 0; i < PageCount; ++i)
-        {
-            pageTable[i] = gcdMMU_CLEAR_VALUE;
-        }
+        _FillPageTable(pageTable, PageCount, gcdMMU_CLEAR_VALUE);
     }
 #endif
 
     if (PageCount == 1)
     {
         /* Single page node. */
-        pageTable[0] = (~((1U<<8)-1)) | gcvMMU_SINGLE;
+        _WritePageEntry(pageTable,
+                        (~((1U<<8)-1)) | gcvMMU_SINGLE
+#if gcdUSE_MMU_EXCEPTION
+                        /* Enable exception */
+                        | 1 << 1
+#endif
+                        );
     }
     else
     {
         /* Mark the node as free. */
-        pageTable[0] = (PageCount << 8) | gcvMMU_FREE;
-        pageTable[1] = ~0U;
+        _WritePageEntry(pageTable,
+                        (PageCount << 8) | gcvMMU_FREE
+#if gcdUSE_MMU_EXCEPTION
+                        /* Enable exception */
+                        | 1 << 1
+#endif
+                       );
+        _WritePageEntry(pageTable + 1, ~0U);
+
+#if gcdUSE_MMU_EXCEPTION
+        /* Enable exception */
+        gcmkVERIFY_OK(_FillPageTable(pageTable + 2, PageCount - 2, 1 << 1));
+#endif
     }
 
     /* We have free nodes. */
@@ -1280,8 +1429,11 @@ gckMMU_AllocatePages(
     gctUINT32 address;
     gctINT i;
     gckMMU mmu;
+    gctBOOL acquired = gcvFALSE;
+    gctBOOL allocated = gcvFALSE;
 
     gckOS_AcquireMutex(Mmu->os, mirrorPageTableMutex, gcvINFINITE);
+    acquired = gcvTRUE;
 
     /* Allocate page table for current MMU. */
     for (i = 0; i < mirrorPageTable->reference; i++)
@@ -1289,6 +1441,7 @@ gckMMU_AllocatePages(
         if (Mmu == mirrorPageTable->mmus[i])
         {
             gcmkONERROR(_AllocatePages(Mmu, PageCount, PageTable, Address));
+            allocated = gcvTRUE;
         }
     }
 
@@ -1305,9 +1458,24 @@ gckMMU_AllocatePages(
     }
 
     gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+    acquired = gcvFALSE;
 
     return gcvSTATUS_OK;
 OnError:
+
+    if (allocated)
+    {
+        /* Page tables for multiple GPU always keep the same. So it is impossible
+         * the fist one allocates successfully but others fail.
+         */
+        gcmkASSERT(0);
+    }
+
+    if (acquired)
+    {
+        gckOS_ReleaseMutex(Mmu->os, mirrorPageTableMutex);
+    }
+
     return status;
 #else
     return _AllocatePages(Mmu, PageCount, PageTable, Address);
@@ -1468,12 +1636,8 @@ gckMMU_SetPage(
         data = _SetPage(PageAddress);
     }
 
-    if (Mmu->hardware->bigEndian)
-    {
-        data = gcmSWAB32(data);
-    }
+    _WritePageEntry(PageEntry, data);
 
-    *PageEntry = data;
 #if gcdMIRROR_PAGETABLE
     for (i = 0; i < mirrorPageTable->reference; i++)
     {
@@ -1483,13 +1647,13 @@ gckMMU_SetPage(
         {
             pageEntry = mmu->pageTableLogical + offset / 4;
 
-            if (Mmu->hardware->mmuVersion == 0)
+            if (mmu->hardware->mmuVersion == 0)
             {
-                *pageEntry = PageAddress;
+                _WritePageEntry(pageEntry, PageAddress);
             }
             else
             {
-                *pageEntry = _SetPage(PageAddress);
+                _WritePageEntry(pageEntry, _SetPage(PageAddress));
             }
         }
 
@@ -1667,6 +1831,39 @@ gckMMU_Flush(
     return gcvSTATUS_OK;
 }
 
+gceSTATUS
+gckMMU_DumpPageTableEntry(
+    IN gckMMU Mmu,
+    IN gctUINT32 Address
+    )
+{
+    gctUINT32_PTR pageTable;
+    gctUINT32 index;
+    gctUINT32 mtlb, stlb;
+
+    gcmkHEADER_ARG("Mmu=0x%08X Address=0x%08X", Mmu, Address);
+    gcmkVERIFY_OBJECT(Mmu, gcvOBJ_MMU);
+
+    gcmkASSERT(Mmu->hardware->mmuVersion > 0);
+
+    mtlb   = (Address & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT;
+    stlb   = (Address & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+
+    if (Address >= 0x80000000)
+    {
+        pageTable = Mmu->pageTableLogical;
+
+        index = (mtlb - Mmu->dynamicMappingStart)
+              * gcdMMU_STLB_4K_ENTRY_NUM
+              + stlb;
+
+        gcmkPRINT("    Page table entry = 0x%08X", _ReadPageEntry(pageTable + index));
+    }
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
 /******************************************************************************
 ****************************** T E S T   C O D E ******************************
 ******************************************************************************/
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
index 46d1761..0c20290 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
new file mode 100644
index 0000000..df7579d
--- /dev/null
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.c
@@ -0,0 +1,347 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#include "gc_hal_kernel_precomp.h"
+
+#define _GC_OBJ_ZONE    gcvZONE_POWER
+
+/******************************************************************************\
+************************ Dynamic Voltage Frequency Setting *********************
+\******************************************************************************/
+#if gcdDVFS
+static gctUINT32
+_GetLoadHistory(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Select,
+    IN gctUINT32 Index
+)
+{
+    return Dvfs->loads[Index];
+}
+
+static void
+_IncreaseScale(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Load,
+    OUT gctUINT8 *Scale
+    )
+{
+    if (Dvfs->currentScale < 32)
+    {
+        *Scale = Dvfs->currentScale + 8;
+    }
+    else
+    {
+        *Scale = Dvfs->currentScale + 8;
+        *Scale = gcmMIN(64, *Scale);
+    }
+}
+
+static void
+_RecordFrequencyHistory(
+    gckDVFS Dvfs,
+    gctUINT32 Frequency
+    )
+{
+    gctUINT32 i = 0;
+
+    struct _FrequencyHistory *history = Dvfs->frequencyHistory;
+
+    for (i = 0; i < 16; i++)
+    {
+        if (history->frequency == Frequency)
+        {
+            break;
+        }
+
+        if (history->frequency == 0)
+        {
+            history->frequency = Frequency;
+            break;
+        }
+
+        history++;
+    }
+
+    if (i < 16)
+    {
+        history->count++;
+    }
+}
+
+static gctUINT32
+_GetFrequencyHistory(
+    gckDVFS Dvfs,
+    gctUINT32 Frequency
+    )
+{
+    gctUINT32 i = 0;
+
+    struct _FrequencyHistory * history = Dvfs->frequencyHistory;
+
+    for (i = 0; i < 16; i++)
+    {
+        if (history->frequency == Frequency)
+        {
+            break;
+        }
+
+        history++;
+    }
+
+    if (i < 16)
+    {
+        return history->count;
+    }
+
+    return 0;
+}
+
+static void
+_Policy(
+    IN gckDVFS Dvfs,
+    IN gctUINT32 Load,
+    OUT gctUINT8 *Scale
+    )
+{
+    gctUINT8 load[4], nextLoad;
+    gctUINT8 scale;
+
+    /* Last 4 history. */
+    load[0] = (Load & 0xFF);
+    load[1] = (Load & 0xFF00) >> 8;
+    load[2] = (Load & 0xFF0000) >> 16;
+    load[3] = (Load & 0xFF000000) >> 24;
+
+    /* Determine target scale. */
+    if (load[0] > 54)
+    {
+        _IncreaseScale(Dvfs, Load, &scale);
+    }
+    else
+    {
+        nextLoad = (load[0] + load[1] + load[2] + load[3])/4;
+
+        scale = Dvfs->currentScale * (nextLoad) / 54;
+
+        scale = gcmMAX(1, scale);
+        scale = gcmMIN(64, scale);
+    }
+
+    Dvfs->totalConfig++;
+
+    Dvfs->loads[(load[0]-1)/8]++;
+
+    *Scale = scale;
+
+
+    if (Dvfs->totalConfig % 100 == 0)
+    {
+        gcmkPRINT("=======================================================");
+        gcmkPRINT("GPU Load:       %-8d %-8d %-8d %-8d %-8d %-8d %-8d %-8d",
+                                   8, 16, 24, 32, 40, 48, 56, 64);
+        gcmkPRINT("                %-8d %-8d %-8d %-8d %-8d %-8d %-8d %-8d",
+                  _GetLoadHistory(Dvfs,2, 0),
+                  _GetLoadHistory(Dvfs,2, 1),
+                  _GetLoadHistory(Dvfs,2, 2),
+                  _GetLoadHistory(Dvfs,2, 3),
+                  _GetLoadHistory(Dvfs,2, 4),
+                  _GetLoadHistory(Dvfs,2, 5),
+                  _GetLoadHistory(Dvfs,2, 6),
+                  _GetLoadHistory(Dvfs,2, 7)
+                  );
+
+        gcmkPRINT("Frequency(MHz)  %-8d %-8d %-8d %-8d %-8d",
+                  58, 120, 240, 360, 480);
+        gcmkPRINT("                %-8d %-8d %-8d %-8d %-8d",
+                  _GetFrequencyHistory(Dvfs, 58),
+                  _GetFrequencyHistory(Dvfs,120),
+                  _GetFrequencyHistory(Dvfs,240),
+                  _GetFrequencyHistory(Dvfs,360),
+                  _GetFrequencyHistory(Dvfs,480)
+                  );
+    }
+}
+
+static void
+_TimerFunction(
+    gctPOINTER Data
+    )
+{
+    gceSTATUS status;
+    gckDVFS dvfs = (gckDVFS) Data;
+    gckHARDWARE hardware = dvfs->hardware;
+    gctUINT32 value;
+    gctUINT32 frequency;
+    gctUINT8 scale;
+    gctUINT32 t1, t2, consumed;
+
+    gckOS_GetTicks(&t1);
+
+    gcmkONERROR(gckHARDWARE_QueryLoad(hardware, &value));
+
+    /* determine target sacle. */
+    _Policy(dvfs, value, &scale);
+
+    /* Set frequency and voltage. */
+    gcmkONERROR(gckOS_SetGPUFrequency(hardware->os, hardware->core, scale));
+
+    /* Query real frequency. */
+    gcmkONERROR(
+        gckOS_QueryGPUFrequency(hardware->os,
+                                hardware->core,
+                                &frequency,
+                                &dvfs->currentScale));
+
+    _RecordFrequencyHistory(dvfs, frequency);
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_POWER,
+                   "Current frequency = %d",
+                   frequency);
+
+    /* Set period. */
+    gcmkONERROR(gckHARDWARE_SetDVFSPeroid(hardware, frequency));
+
+OnError:
+    /* Determine next querying time. */
+    gckOS_GetTicks(&t2);
+
+    consumed = gcmMIN(((long)t2 - (long)t1), 5);
+
+    if (dvfs->stop == gcvFALSE)
+    {
+        gcmkVERIFY_OK(gckOS_StartTimer(hardware->os,
+                                       dvfs->timer,
+                                       dvfs->pollingTime - consumed));
+    }
+
+    return;
+}
+
+gceSTATUS
+gckDVFS_Construct(
+    IN gckHARDWARE Hardware,
+    OUT gckDVFS * Dvfs
+    )
+{
+    gceSTATUS status;
+    gctPOINTER pointer;
+    gckDVFS dvfs = gcvNULL;
+    gckOS os = Hardware->os;
+
+    gcmkHEADER_ARG("Hardware=0x%X", Hardware);
+
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    /* Allocate a gckDVFS manager. */
+    gcmkONERROR(gckOS_Allocate(os, gcmSIZEOF(struct _gckDVFS), &pointer));
+
+    gckOS_ZeroMemory(pointer, gcmSIZEOF(struct _gckDVFS));
+
+    dvfs = pointer;
+
+    /* Initialization. */
+    dvfs->hardware = Hardware;
+    dvfs->pollingTime = gcdDVFS_POLLING_TIME;
+    dvfs->os = Hardware->os;
+    dvfs->currentScale = 64;
+
+    /* Create a polling timer. */
+    gcmkONERROR(gckOS_CreateTimer(os, _TimerFunction, pointer, &dvfs->timer));
+
+    /* Initialize frequency and voltage adjustment helper. */
+    gcmkONERROR(gckOS_PrepareGPUFrequency(os, Hardware->core));
+
+    /* Return result. */
+    *Dvfs = dvfs;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Roll back. */
+    if (dvfs)
+    {
+        if (dvfs->timer)
+        {
+            gcmkVERIFY_OK(gckOS_DestroyTimer(os, dvfs->timer));
+        }
+
+        gcmkOS_SAFE_FREE(os, dvfs);
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckDVFS_Destroy(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    /* Deinitialize helper fuunction. */
+    gcmkVERIFY_OK(gckOS_FinishGPUFrequency(Dvfs->os, Dvfs->hardware->core));
+
+    /* DestroyTimer. */
+    gcmkVERIFY_OK(gckOS_DestroyTimer(Dvfs->os, Dvfs->timer));
+
+    gcmkOS_SAFE_FREE(Dvfs->os, Dvfs);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDVFS_Start(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    gckHARDWARE_InitDVFS(Dvfs->hardware);
+
+    Dvfs->stop = gcvFALSE;
+
+    gckOS_StartTimer(Dvfs->os, Dvfs->timer, Dvfs->pollingTime);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckDVFS_Stop(
+    IN gckDVFS Dvfs
+    )
+{
+    gcmkHEADER_ARG("Dvfs=0x%X", Dvfs);
+    gcmkVERIFY_ARGUMENT(Dvfs != gcvNULL);
+
+    Dvfs->stop = gcvTRUE;
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+#endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
index 004e6bd..1e764c2 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_precomp.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_precomp_h_
 #define __gc_hal_kernel_precomp_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
index ee63e9b..7d0032e3 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,12 +19,12 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #if gcdENABLE_VG
 
+#define ENABLE_VG_TRY_VIRTUAL_MEMORY 0
+
 #define _GC_OBJ_ZONE            gcvZONE_VG
 
 /******************************************************************************\
@@ -333,11 +333,18 @@ gckKERNEL_AllocateLinearMemory(
         else if (pool == gcvPOOL_SYSTEM)
         {
             /* Advance to virtual memory. */
+#if ENABLE_VG_TRY_VIRTUAL_MEMORY
             pool = gcvPOOL_VIRTUAL;
+#else
+            /*VG non-contiguous memory support is not ready yet, disable it temporary*/
+            status = gcvSTATUS_OUT_OF_MEMORY;
+            break;
+#endif
         }
         else
         {
             /* Out of pools. */
+            status = gcvSTATUS_OUT_OF_MEMORY;
             break;
         }
     }
@@ -388,6 +395,11 @@ gceSTATUS gckVGKERNEL_Dispatch(
     gcsHAL_INTERFACE * kernelInterface = Interface;
     gcuVIDMEM_NODE_PTR node;
     gctUINT32 processID;
+    gckKERNEL kernel = Kernel;
+    gctPOINTER info = gcvNULL;
+    gctPHYS_ADDR physical = gcvNULL;
+    gctPOINTER logical = gcvNULL;
+    gctSIZE_T bytes = 0;
 
     gcmkHEADER_ARG("Kernel=0x%x Interface=0x%x ", Kernel, Interface);
 
@@ -427,61 +439,78 @@ gceSTATUS gckVGKERNEL_Dispatch(
             ));
         break;
     case gcvHAL_ALLOCATE_NON_PAGED_MEMORY:
+        bytes = (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes;
         /* Allocate non-paged memory. */
         gcmkERR_BREAK(gckOS_AllocateContiguous(
             Kernel->os,
             gcvTRUE,
-            &kernelInterface->u.AllocateNonPagedMemory.bytes,
-            &kernelInterface->u.AllocateNonPagedMemory.physical,
-            &kernelInterface->u.AllocateNonPagedMemory.logical
+            &bytes,
+            &physical,
+            &logical
             ));
+
+        kernelInterface->u.AllocateNonPagedMemory.bytes    = bytes;
+        kernelInterface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        kernelInterface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
         break;
 
     case gcvHAL_FREE_NON_PAGED_MEMORY:
+        physical = gcmNAME_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.physical);
+
         /* Unmap user logical out of physical memory first. */
         gcmkERR_BREAK(gckOS_UnmapUserLogical(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            physical,
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
 
         /* Free non-paged memory. */
         gcmkERR_BREAK(gckOS_FreeNonPagedMemory(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            physical,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
+
+        gcmRELEASE_NAME(kernelInterface->u.AllocateNonPagedMemory.physical);
         break;
 
     case gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY:
+        bytes = (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes;
         /* Allocate contiguous memory. */
         gcmkERR_BREAK(gckOS_AllocateContiguous(
             Kernel->os,
             gcvTRUE,
-            &kernelInterface->u.AllocateNonPagedMemory.bytes,
-            &kernelInterface->u.AllocateNonPagedMemory.physical,
-            &kernelInterface->u.AllocateNonPagedMemory.logical
+            &bytes,
+            &physical,
+            &logical
             ));
+
+        kernelInterface->u.AllocateNonPagedMemory.bytes    = bytes;
+        kernelInterface->u.AllocateNonPagedMemory.logical  = gcmPTR_TO_UINT64(logical);
+        kernelInterface->u.AllocateNonPagedMemory.physical = gcmPTR_TO_NAME(physical);
         break;
 
     case gcvHAL_FREE_CONTIGUOUS_MEMORY:
+        physical = gcmNAME_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.physical);
         /* Unmap user logical out of physical memory first. */
         gcmkERR_BREAK(gckOS_UnmapUserLogical(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes,
-            kernelInterface->u.AllocateNonPagedMemory.logical
+            physical,
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical)
             ));
 
         /* Free contiguous memory. */
         gcmkERR_BREAK(gckOS_FreeContiguous(
             Kernel->os,
-            kernelInterface->u.AllocateNonPagedMemory.physical,
-            kernelInterface->u.AllocateNonPagedMemory.logical,
-            kernelInterface->u.AllocateNonPagedMemory.bytes
+            physical,
+            gcmUINT64_TO_PTR(kernelInterface->u.AllocateNonPagedMemory.logical),
+            (gctSIZE_T) kernelInterface->u.AllocateNonPagedMemory.bytes
             ));
+
+        gcmRELEASE_NAME(kernelInterface->u.AllocateNonPagedMemory.physical);
         break;
 
     case gcvHAL_ALLOCATE_VIDEO_MEMORY:
@@ -523,8 +552,10 @@ gceSTATUS gckVGKERNEL_Dispatch(
                 bytes,
                 64,
                 kernelInterface->u.AllocateVideoMemory.type,
-                &kernelInterface->u.AllocateVideoMemory.node
+                &node
                 ));
+
+            kernelInterface->u.AllocateVideoMemory.node = gcmPTR_TO_UINT64(node);
         }
         break;
 
@@ -536,22 +567,23 @@ gceSTATUS gckVGKERNEL_Dispatch(
             kernelInterface->u.AllocateLinearVideoMemory.bytes,
             kernelInterface->u.AllocateLinearVideoMemory.alignment,
             kernelInterface->u.AllocateLinearVideoMemory.type,
-            &kernelInterface->u.AllocateLinearVideoMemory.node
+            &node
             ));
 
         gcmkERR_BREAK(gckKERNEL_AddProcessDB(Kernel,
            processID, gcvDB_VIDEO_MEMORY,
-           Interface->u.AllocateLinearVideoMemory.node,
+           node,
            gcvNULL,
            kernelInterface->u.AllocateLinearVideoMemory.bytes
            ));
 
+        kernelInterface->u.AllocateLinearVideoMemory.node = gcmPTR_TO_UINT64(node);
         break;
 
     case gcvHAL_FREE_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.FreeVideoMemory.node);
 #ifdef __QNXNTO__
         /* Unmap the video memory */
-        node = Interface->u.FreeVideoMemory.node;
 
         if ((node->VidMem.memory->object.type == gcvOBJ_VIDMEM) &&
             (node->VidMem.logical != gcvNULL))
@@ -566,13 +598,13 @@ gceSTATUS gckVGKERNEL_Dispatch(
 
         /* Free video memory. */
         gcmkERR_BREAK(gckVIDMEM_Free(
-            Interface->u.FreeVideoMemory.node
+            node
             ));
 
         gcmkERR_BREAK(gckKERNEL_RemoveProcessDB(
             Kernel,
             processID, gcvDB_VIDEO_MEMORY,
-            Interface->u.FreeVideoMemory.node
+            node
             ));
 
         break;
@@ -581,19 +613,20 @@ gceSTATUS gckVGKERNEL_Dispatch(
         /* Map memory. */
         gcmkERR_BREAK(gckKERNEL_MapMemory(
             Kernel,
-            kernelInterface->u.MapMemory.physical,
-            kernelInterface->u.MapMemory.bytes,
-            &kernelInterface->u.MapMemory.logical
+            gcmINT2PTR(kernelInterface->u.MapMemory.physical),
+            (gctSIZE_T) kernelInterface->u.MapMemory.bytes,
+            &logical
             ));
+        kernelInterface->u.MapMemory.logical = gcmPTR_TO_UINT64(logical);
         break;
 
     case gcvHAL_UNMAP_MEMORY:
         /* Unmap memory. */
         gcmkERR_BREAK(gckKERNEL_UnmapMemory(
             Kernel,
-            kernelInterface->u.MapMemory.physical,
-            kernelInterface->u.MapMemory.bytes,
-            kernelInterface->u.MapMemory.logical
+            gcmINT2PTR(kernelInterface->u.MapMemory.physical),
+            (gctSIZE_T) kernelInterface->u.MapMemory.bytes,
+            gcmUINT64_TO_PTR(kernelInterface->u.MapMemory.logical)
             ));
         break;
 
@@ -602,12 +635,14 @@ gceSTATUS gckVGKERNEL_Dispatch(
         gcmkERR_BREAK(gckOS_MapUserMemory(
             Kernel->os,
             gcvCORE_VG,
-            kernelInterface->u.MapUserMemory.memory,
+            gcmUINT64_TO_PTR(kernelInterface->u.MapUserMemory.memory),
             kernelInterface->u.MapUserMemory.physical,
-            kernelInterface->u.MapUserMemory.size,
-            &kernelInterface->u.MapUserMemory.info,
+            (gctSIZE_T) kernelInterface->u.MapUserMemory.size,
+            &info,
             &kernelInterface->u.MapUserMemory.address
             ));
+
+        kernelInterface->u.MapUserMemory.info = gcmPTR_TO_NAME(info);
         break;
 
     case gcvHAL_UNMAP_USER_MEMORY:
@@ -615,21 +650,22 @@ gceSTATUS gckVGKERNEL_Dispatch(
         gcmkERR_BREAK(gckOS_UnmapUserMemory(
             Kernel->os,
             gcvCORE_VG,
-            kernelInterface->u.UnmapUserMemory.memory,
-            kernelInterface->u.UnmapUserMemory.size,
-            kernelInterface->u.UnmapUserMemory.info,
+            gcmUINT64_TO_PTR(kernelInterface->u.UnmapUserMemory.memory),
+            (gctSIZE_T) kernelInterface->u.UnmapUserMemory.size,
+            gcmNAME_TO_PTR(kernelInterface->u.UnmapUserMemory.info),
             kernelInterface->u.UnmapUserMemory.address
             ));
         break;
     case gcvHAL_LOCK_VIDEO_MEMORY:
+        node = gcmUINT64_TO_PTR(Interface->u.LockVideoMemory.node);
+
         /* Lock video memory. */
         gcmkERR_BREAK(
             gckVIDMEM_Lock(Kernel,
-                           Interface->u.LockVideoMemory.node,
+                           node,
 						   gcvFALSE,
                            &Interface->u.LockVideoMemory.address));
 
-        node = Interface->u.LockVideoMemory.node;
         if (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         {
             /* Map video memory address into user space. */
@@ -645,19 +681,20 @@ gceSTATUS gckVGKERNEL_Dispatch(
                                          &node->VidMem.logical));
         }
 
-        Interface->u.LockVideoMemory.memory = node->VidMem.logical;
+        Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->VidMem.logical);
 #else
             gcmkERR_BREAK(
                 gckKERNEL_MapVideoMemoryEx(Kernel,
                                          gcvCORE_VG,
                                          FromUser,
                                          Interface->u.LockVideoMemory.address,
-                                         &Interface->u.LockVideoMemory.memory));
+                                         &logical));
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(logical);
 #endif
         }
         else
         {
-            Interface->u.LockVideoMemory.memory = node->Virtual.logical;
+            Interface->u.LockVideoMemory.memory = gcmPTR_TO_UINT64(node->Virtual.logical);
 
             /* Success. */
             status = gcvSTATUS_OK;
@@ -666,19 +703,19 @@ gceSTATUS gckVGKERNEL_Dispatch(
 #if gcdSECURE_USER
         /* Return logical address as physical address. */
         Interface->u.LockVideoMemory.address =
-            gcmPTR2INT(Interface->u.LockVideoMemory.memory);
+            (gctUINT32)(Interface->u.LockVideoMemory.memory);
 #endif
         gcmkERR_BREAK(
             gckKERNEL_AddProcessDB(Kernel,
                                    processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                                   Interface->u.LockVideoMemory.node,
+                                   node,
                                    gcvNULL,
                                    0));
         break;
 
     case gcvHAL_UNLOCK_VIDEO_MEMORY:
         /* Unlock video memory. */
-        node = Interface->u.UnlockVideoMemory.node;
+        node = gcmUINT64_TO_PTR(Interface->u.UnlockVideoMemory.node);
 
 #if gcdSECURE_USER
         /* Save node information before it disappears. */
@@ -718,7 +755,7 @@ gceSTATUS gckVGKERNEL_Dispatch(
             gcmkERR_BREAK(
                     gckKERNEL_RemoveProcessDB(Kernel,
                         processID, gcvDB_VIDEO_MEMORY_LOCKED,
-                        Interface->u.UnlockVideoMemory.node));
+                        node));
         }
 
         break;
@@ -780,10 +817,10 @@ gceSTATUS gckVGKERNEL_Dispatch(
         /* Commit a command and context buffer. */
         gcmkERR_BREAK(gckVGCOMMAND_Commit(
             Kernel->vg->command,
-            kernelInterface->u.VGCommit.context,
-            kernelInterface->u.VGCommit.queue,
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.context),
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.queue),
             kernelInterface->u.VGCommit.entryCount,
-            kernelInterface->u.VGCommit.taskTable
+            gcmUINT64_TO_PTR(kernelInterface->u.VGCommit.taskTable)
             ));
         break;
     case gcvHAL_VERSION:
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
index b86b0c9..b6c6d7e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_kernel_vg_h_
 #define __gc_hal_kernel_vg_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
index dc39b39..8b8bbdc 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_precomp.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_VIDMEM
@@ -1029,7 +1027,8 @@ gckVIDMEM_AllocateLinear(
     )
     {
         /* The left memory is for small memory.*/
-        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        status = gcvSTATUS_OUT_OF_MEMORY;
+        goto OnError;
     }
 #endif
 
@@ -2145,6 +2144,9 @@ gckVIDMEM_Unlock(
 
             if (!Node->Virtual.contiguous
             &&  (Node->Virtual.lockeds[Kernel->core] == 1)
+#if gcdENABLE_VG
+            && (Kernel->vg == gcvNULL)
+#endif
             )
             {
                 if (Type == gcvSURF_BITMAP)
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
index 5b90e2f..4406d7e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_h_
 #define __gc_hal_h_
 
@@ -49,7 +47,7 @@ extern "C" {
 
 #define gcmALIGN_BASE(n, align) \
 ( \
-    (n) & ~((align) - 1) \
+    ((n) & ~((align) - 1)) \
 )
 
 /******************************************************************************\
@@ -67,6 +65,59 @@ extern "C" {
 )
 
 /******************************************************************************\
+********************************* Cast Macro **********************************
+\******************************************************************************/
+#define gcmNAME_TO_PTR(na) \
+        gckKERNEL_QueryPointerFromName(kernel, gcmALL_TO_UINT32(na))
+
+#define gcmPTR_TO_NAME(ptr) \
+        gckKERNEL_AllocateNameFromPointer(kernel, ptr)
+
+#define gcmRELEASE_NAME(na) \
+        gckKERNEL_DeleteName(kernel, gcmALL_TO_UINT32(na))
+
+#ifdef __LP64__
+
+#define gcmALL_TO_UINT32(t) \
+( \
+    (gctUINT32) (gctUINTPTR_T) (t)\
+)
+
+#define gcmPTR_TO_UINT64(p) \
+( \
+    (gctUINT64) (p)\
+)
+
+#define gcmUINT64_TO_PTR(u) \
+( \
+    (gctPOINTER) (u)\
+)
+
+#else /* 32 bit */
+
+#define gcmALL_TO_UINT32(t) \
+( \
+    (gctUINT32) (t)\
+)
+
+#define gcmPTR_TO_UINT64(p) \
+( \
+    (gctUINT64) (gctUINTPTR_T) (p)\
+)
+
+#define gcmUINT64_TO_PTR(u) \
+( \
+    (gctPOINTER) (gctUINTPTR_T) (u)\
+)
+
+#endif
+
+#define gcmUINT64_TO_TYPE(u, t) \
+( \
+    (t) (gctUINTPTR_T) (u)\
+)
+
+/******************************************************************************\
 ******************************** Useful Macro *********************************
 \******************************************************************************/
 
@@ -579,11 +630,19 @@ gckOS_AtomClearMask(
 #endif
 
 gceSTATUS
-gckOS_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
+gckOS_DumpCallStack(
+    IN gckOS Os
+    );
+
+gceSTATUS
+gckOS_GetProcessNameByPid(
+    IN gctINT Pid,
+    IN gctSIZE_T Length,
+    OUT gctUINT8_PTR String
     );
 
+
+
 /*******************************************************************************
 **
 **  gckOS_AtomConstruct
@@ -1267,6 +1326,33 @@ gckOS_ResetGPU(
     IN gceCORE Core
     );
 
+gceSTATUS
+gckOS_PrepareGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_FinishGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_QueryGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gctUINT32 * Frequency,
+    OUT gctUINT8 * Scale
+    );
+
+gceSTATUS
+gckOS_SetGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT8 Scale
+    );
+
 /*******************************************************************************
 ** Semaphores.
 */
@@ -1331,7 +1417,7 @@ gckOS_CreateTimer(
 
 /* Destory a timer. */
 gceSTATUS
-gckOS_DestoryTimer(
+gckOS_DestroyTimer(
     IN gckOS Os,
     IN gctPOINTER Timer
     );
@@ -1406,6 +1492,7 @@ gckHEAP_ProfileEnd(
 typedef struct _gckVIDMEM *         gckVIDMEM;
 typedef struct _gckKERNEL *         gckKERNEL;
 typedef struct _gckDB *             gckDB;
+typedef struct _gckDVFS *           gckDVFS;
 
 /* Construct a new gckVIDMEM object. */
 gceSTATUS
@@ -1696,6 +1783,27 @@ gckKERNEL_CloseUserData(
     OUT gctPOINTER * KernelPointer
     );
 
+gceSTATUS
+gckDVFS_Construct(
+    IN gckHARDWARE Hardware,
+    OUT gckDVFS * Frequency
+    );
+
+gceSTATUS
+gckDVFS_Destroy(
+    IN gckDVFS Dvfs
+    );
+
+gceSTATUS
+gckDVFS_Start(
+    IN gckDVFS Dvfs
+    );
+
+gceSTATUS
+gckDVFS_Stop(
+    IN gckDVFS Dvfs
+    );
+
 /******************************************************************************\
 ******************************* gckHARDWARE Object *****************************
 \******************************************************************************/
@@ -1964,6 +2072,12 @@ gckHARDWARE_QueryPowerManagementState(
     OUT gceCHIPPOWERSTATE* State
     );
 
+gceSTATUS
+gckHARDWARE_SetPowerManagement(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    );
+
 #if gcdENABLE_FSCALE_VAL_ADJUST
 gceSTATUS
 gckHARDWARE_SetFscaleValue(
@@ -2045,6 +2159,28 @@ gckHARDWARE_DumpMMUException(
     IN gckHARDWARE Hardware
     );
 
+gceSTATUS
+gckHARDWARE_DumpGPUState(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_InitDVFS(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_QueryLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 * Load
+    );
+
+gceSTATUS
+gckHARDWARE_SetDVFSPeroid(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 Frequency
+    );
+
 #if !gcdENABLE_VG
 /******************************************************************************\
 ***************************** gckINTERRUPT Object ******************************
@@ -2316,6 +2452,13 @@ gckCOMMAND_Detach(
     IN gckCONTEXT Context
     );
 
+#if gcdVIRTUAL_COMMAND_BUFFER
+gceSTATUS
+gckCOMMAND_DumpExecutingBuffer(
+    IN gckCOMMAND Command
+    );
+#endif
+
 /******************************************************************************\
 ********************************* gckMMU Object ********************************
 \******************************************************************************/
@@ -2395,11 +2538,18 @@ gckMMU_Flush(
     IN gckMMU Mmu
     );
 
+gceSTATUS
+gckMMU_DumpPageTableEntry(
+    IN gckMMU Mmu,
+    IN gctUINT32 Address
+    );
+
 
 #if VIVANTE_PROFILER
 gceSTATUS
 gckHARDWARE_QueryProfileRegisters(
     IN gckHARDWARE Hardware,
+    IN gctBOOL   Clear,
     OUT gcsPROFILER_COUNTERS * Counters
     );
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
index 7cfd2e1..44689b0 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_base.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_base_h_
 #define __gc_hal_base_h_
 
@@ -58,6 +56,8 @@ typedef struct _gcoDUMP *               gcoDUMP;
 typedef struct _gcoHARDWARE *           gcoHARDWARE;
 typedef union  _gcuVIDMEM_NODE *        gcuVIDMEM_NODE_PTR;
 
+typedef struct gcsATOM *                gcsATOM_PTR;
+
 #if gcdENABLE_VG
 typedef struct _gcoVG *                 gcoVG;
 typedef struct _gcsCOMPLETION_SIGNAL *	gcsCOMPLETION_SIGNAL_PTR;
@@ -66,10 +66,14 @@ typedef struct _gcsCONTEXT_MAP *		gcsCONTEXT_MAP_PTR;
 typedef void *                          gcoVG;
 #endif
 
+#if gcdSYNC
+typedef struct _gcoFENCE *              gcoFENCE;
+typedef struct _gcsSYNC_CONTEXT  *      gcsSYNC_CONTEXT_PTR;
+#endif
+
 /******************************************************************************\
 ******************************* Process local storage *************************
 \******************************************************************************/
-
 typedef struct _gcsPLS * gcsPLS_PTR;
 typedef struct _gcsPLS
 {
@@ -97,6 +101,16 @@ typedef struct _gcsPLS
     gctPOINTER                  eglSurfaceInfo;
     gceSURF_FORMAT              eglConfigFormat;
 
+    /* PorcessID of the constrcutor process */
+    gctUINT32                   processID;
+
+    /* Reference count for destructor. */
+    gcsATOM_PTR                 reference;
+    gctBOOL                     bKFS;
+#if gcdUSE_NPOT_PATCH
+    gctBOOL                     bNeedSupportNP2Texture;
+#endif
+
 }
 gcsPLS;
 
@@ -109,7 +123,7 @@ extern gcsPLS gcPLS;
 typedef struct _gcsTLS * gcsTLS_PTR;
 
 typedef void (* gctTLS_DESTRUCTOR) (
-    gcsTLS_PTR TLS
+    gcsTLS_PTR
     );
 
 typedef struct _gcsTLS
@@ -129,6 +143,9 @@ typedef struct _gcsTLS
 #ifndef VIVANTE_NO_3D
 	gco3D						engine3D;
 #endif
+#if gcdSYNC
+    gctBOOL                     fenceEnable;
+#endif
 	gco2D						engine2D;
     gctBOOL                     copied;
 }
@@ -360,6 +377,11 @@ gcoHAL_GetFscaleValue(
     OUT gctUINT * MaxFscaleValue
     );
 
+gceSTATUS
+gcoHAL_SetBltNP2Texture(
+    gctBOOL enable
+    );
+
 #ifndef VIVANTE_NO_3D
 /* Get pointer to gco3D object. */
 gceSTATUS
@@ -636,8 +658,6 @@ gcoHAL_QueryChipFeature(
     IN gceFEATURE   Feature);
 
 #endif
-
-
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
 \******************************************************************************/
@@ -1006,29 +1026,6 @@ gcoOS_GetPos(
     OUT gctUINT32 * Position
     );
 
-/* Perform a memory copy. */
-gceSTATUS
-gcoOS_MemCopy(
-    IN gctPOINTER Destination,
-    IN gctCONST_POINTER Source,
-    IN gctSIZE_T Bytes
-    );
-
-/* Perform a memory fill. */
-gceSTATUS
-gcoOS_MemFill(
-    IN gctPOINTER Destination,
-    IN gctUINT8 Filler,
-    IN gctSIZE_T Bytes
-    );
-
-/* Zero memory. */
-gceSTATUS
-gcoOS_ZeroMemory(
-    IN gctPOINTER Memory,
-    IN gctSIZE_T Bytes
-    );
-
 /* Same as strstr. */
 gceSTATUS
 gcoOS_StrStr(
@@ -1046,12 +1043,6 @@ gcoOS_StrFindReverse(
     );
 
 gceSTATUS
-gcoOS_StrLen(
-    IN gctCONST_STRING String,
-    OUT gctSIZE_T * Length
-    );
-
-gceSTATUS
 gcoOS_StrDup(
     IN gcoOS Os,
     IN gctCONST_STRING String,
@@ -1097,13 +1088,15 @@ gcoOS_StrToFloat(
     );
 
 /* Convert hex string to integer. */
-gceSTATUS gcoOS_HexStrToInt(
+gceSTATUS
+gcoOS_HexStrToInt(
 	IN gctCONST_STRING String,
 	OUT gctINT * Int
 	);
 
 /* Convert hex string to float. */
-gceSTATUS gcoOS_HexStrToFloat(
+gceSTATUS
+gcoOS_HexStrToFloat(
 	IN gctCONST_STRING String,
 	OUT gctFLOAT * Float
 	);
@@ -1182,6 +1175,11 @@ gcoOS_SetProfileSetting(
         );
 #endif
 
+gctBOOL
+gcoOS_IsNeededSupportNP2Texture(
+    IN gctCHAR* ProcName
+    );
+
 /* Query the video memory. */
 gceSTATUS
 gcoOS_QueryVideoMemory(
@@ -1207,11 +1205,14 @@ gcoOS_DetectProcessByName(
     IN gctCONST_STRING Name
     );
 
+gceSTATUS
+gcoOS_DetectProcessByEncryptedName(
+    IN gctCONST_STRING Name
+    );
+
 /*----------------------------------------------------------------------------*/
 /*----- Atoms ----------------------------------------------------------------*/
 
-typedef struct gcsATOM * gcsATOM_PTR;
-
 /* Construct an atom. */
 gceSTATUS
 gcoOS_AtomConstruct(
@@ -1421,7 +1422,7 @@ gcoOS_ReadRegister(
 gceSTATUS
 gcoOS_CacheClean(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1429,7 +1430,7 @@ gcoOS_CacheClean(
 gceSTATUS
 gcoOS_CacheFlush(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1437,7 +1438,7 @@ gcoOS_CacheFlush(
 gceSTATUS
 gcoOS_CacheInvalidate(
     IN gcoOS Os,
-    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT64 Node,
     IN gctPOINTER Logical,
     IN gctSIZE_T Bytes
     );
@@ -1767,25 +1768,11 @@ gcoSURF_MapUserSurface(
 gceSTATUS
 gcoSURF_QueryVidMemNode(
     IN gcoSURF Surface,
-    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT64 * Node,
     OUT gcePOOL * Pool,
     OUT gctUINT_PTR Bytes
     );
 
-/*  Set usage attribute of a surface. */
-gceSTATUS
-gcoSURF_SetUsage(
-    IN gcoSURF Surface,
-    IN gceSURF_USAGE Usage
-    );
-
-/*  Return usage attribute of a surface. */
-gceSTATUS
-gcoSURF_QueryUsage(
-    IN gcoSURF Surface,
-    OUT gceSURF_USAGE *Usage
-    );
-
 /* Set the color type of the surface. */
 gceSTATUS
 gcoSURF_SetColorType(
@@ -1972,6 +1959,14 @@ gcoSURF_SetWindow(
     IN gctUINT Height
     );
 
+/* Set width/height alignment of the surface directly and calculate stride/size. This is only for dri backend now. Please be careful before use. */
+gceSTATUS
+gcoSURF_SetAlignment(
+    IN gcoSURF Surface,
+    IN gctUINT Width,
+    IN gctUINT Height
+    );
+
 /* Increase reference count of the surface. */
 gceSTATUS
 gcoSURF_ReferenceSurface(
@@ -2006,6 +2001,12 @@ gcoSURF_SetOffset(
     );
 
 gceSTATUS
+gcoSURF_GetOffset(
+    IN gcoSURF Surface,
+    OUT gctUINT *Offset
+    );
+
+gceSTATUS
 gcoSURF_NODE_Cache(
     IN gcsSURF_NODE_PTR Node,
     IN gctPOINTER Logical,
@@ -2431,6 +2432,7 @@ gcoOS_DebugTrace(
 #define gcvZONE_DEVICE          (1 << 10)
 #define gcvZONE_DATABASE        (1 << 11)
 #define gcvZONE_INTERRUPT       (1 << 12)
+#define gcvZONE_POWER           (1 << 13)
 
 /* User zones. */
 #define gcvZONE_HAL             (1 << 3)
@@ -3645,6 +3647,7 @@ gckOS_DebugStatus2Name(
 #   define gcmDEBUG_VERIFY_ARGUMENT(arg)
 #   define gcmkDEBUG_VERIFY_ARGUMENT(arg)
 #endif
+
 /*******************************************************************************
 **
 **  gcmVERIFY_ARGUMENT_RETURN
@@ -3702,6 +3705,7 @@ gcGetUserDebugOption(
     void
     );
 
+#if gcdHAS_ELLIPSES
 #define gcmUSER_DEBUG_MSG(level, ...) \
     do \
     { \
@@ -3713,6 +3717,11 @@ gcGetUserDebugOption(
 
 #define gcmUSER_DEBUG_ERROR_MSG(...)   gcmUSER_DEBUG_MSG(gcvDEBUG_MSG_ERROR, "Error: " __VA_ARGS__)
 #define gcmUSER_DEBUG_WARNING_MSG(...) gcmUSER_DEBUG_MSG(gcvDEBUG_MSG_WARNING, "Warring: " __VA_ARGS__)
+#else
+#define gcmUSER_DEBUG_MSG
+#define gcmUSER_DEBUG_ERROR_MSG
+#define gcmUSER_DEBUG_WARNING_MSG
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
index a089280..8693c37 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_compiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /*
 **	Include file the defines the front- and back-end compilers, as well as the
 **	objects they use.
@@ -38,9 +36,16 @@ extern "C" {
 #endif
 
 #ifndef GC_ENABLE_LOADTIME_OPT
-#define GC_ENABLE_LOADTIME_OPT      1
+#define GC_ENABLE_LOADTIME_OPT           1
 #endif
 
+#define TEMP_OPT_CONSTANT_TEXLD_COORD    1
+
+#define TEMP_SHADER_PATCH                1
+
+#define ADD_PRE_ROTATION_TO_VS           0
+
+#define TEMP_INLINE_ALL_EXPANSION            1
 /******************************* IR VERSION ******************/
 #define gcdSL_IR_VERSION gcmCC('\0','\0','\0','\1')
 
@@ -48,6 +53,126 @@ extern "C" {
 |******************************* SHADER LANGUAGE ******************************|
 \******************************************************************************/
 
+    /* allocator/deallocator function pointer */
+typedef gceSTATUS (*gctAllocatorFunc)(
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+typedef gceSTATUS (*gctDeallocatorFunc)(
+    IN gctPOINTER Memory
+    );
+
+typedef gctBOOL (*compareFunc) (
+     IN void *    data,
+     IN void *    key
+     );
+
+typedef struct _gcsListNode gcsListNode;
+struct _gcsListNode
+{
+    gcsListNode *       next;
+    void *              data;
+};
+
+typedef struct _gcsAllocator
+{
+    gctAllocatorFunc    allocate;
+    gctDeallocatorFunc  deallocate;
+} gcsAllocator;
+
+/* simple map structure */
+typedef struct _SimpleMap SimpleMap;
+struct _SimpleMap
+{
+    gctUINT32     key;
+    gctUINT32     val;
+    SimpleMap    *next;
+    gcsAllocator *allocator;
+
+};
+
+/* SimpleMap Operations */
+/* return -1 if not found, otherwise return the mapped value */
+gctUINT32
+gcSimpleMap_Find(
+     IN SimpleMap *Map,
+     IN gctUINT32    Key
+     );
+
+gceSTATUS
+gcSimpleMap_Destory(
+     IN SimpleMap *    Map,
+     IN gcsAllocator * Allocator
+     );
+
+/* Add a pair <Key, Val> to the Map head, the user should be aware that the
+ * map pointer is always changed when adding a new node :
+ *
+ *   gcSimpleMap_AddNode(&theMap, key, val, allocator);
+ *
+ */
+gceSTATUS
+gcSimpleMap_AddNode(
+     IN SimpleMap **   Map,
+     IN gctUINT32      Key,
+     IN gctUINT32      Val,
+     IN gcsAllocator * Allocator
+     );
+
+/* gcsList data structure and related operations */
+typedef struct _gcsList
+{
+    gcsListNode  *head;
+    gcsListNode  *tail;
+    gctINT        count;
+    gcsAllocator *allocator;
+} gcsList;
+
+/* List operations */
+void
+gcList_Init(
+    IN gcsList *list,
+    IN gcsAllocator *allocator
+    );
+
+gceSTATUS
+gcList_CreateNode(
+    IN void *             Data,
+    IN gctAllocatorFunc   Allocator,
+    OUT gcsListNode **    ListNode
+    );
+
+gceSTATUS
+gcList_Clean(
+    IN gcsList *          List,
+    IN gctBOOL            FreeData
+    );
+
+gcsListNode *
+gcList_FindNode(
+    IN gcsList *      List,
+    IN void *         Key,
+    IN compareFunc    compare
+    );
+
+gceSTATUS
+gcList_AddNode(
+    IN gcsList *          List,
+    IN void *             Data
+    );
+
+gceSTATUS
+gcList_RemoveNode(
+    IN gcsList *          List,
+    IN gcsListNode *      Node
+    );
+
+/*  link list structure for code list */
+typedef gcsList gcsCodeList;
+typedef gcsCodeList * gctCodeList;
+typedef gcsListNode gcsCodeListNode;
+
 /* Possible shader language opcodes. */
 typedef enum _gcSL_OPCODE
 {
@@ -146,6 +271,7 @@ typedef enum _gcSL_OPCODE
 	gcSL_ADDSAT,						/* 0x5C */  /* Integer only. */
 	gcSL_SUBSAT,						/* 0x5D */  /* Integer only. */
 	gcSL_MULSAT,						/* 0x5E */  /* Integer only. */
+	gcSL_MAXOPCODE
 }
 gcSL_OPCODE;
 
@@ -387,13 +513,20 @@ struct _gcsHINT
     gctUINT32   colorKillInstruction[3];
 #endif
 
+#if TEMP_SHADER_PATCH
+	gctUINT32	pachedShaderIdentifier;
+#endif
 };
 
+#if TEMP_SHADER_PATCH
+#define INVALID_SHADER_IDENTIFIER 0xFFFFFFFF
+#endif
+
 /* gcSHADER_TYPE enumeration. */
 typedef enum _gcSHADER_TYPE
 {
-	gcSHADER_FLOAT_X1,				/* 0x00 */
-	gcSHADER_FLOAT_X2,				/* 0x01 */
+    gcSHADER_FLOAT_X1   = 0,        /* 0x00 */
+    gcSHADER_FLOAT_X2,				/* 0x01 */
 	gcSHADER_FLOAT_X3,				/* 0x02 */
 	gcSHADER_FLOAT_X4,				/* 0x03 */
 	gcSHADER_FLOAT_2X2,				/* 0x04 */
@@ -431,10 +564,50 @@ typedef enum _gcSHADER_TYPE
 	gcSHADER_USAMPLER_3D,			/* 0x24 */
 	gcSHADER_USAMPLER_CUBIC,		/* 0x25 */
 	gcSHADER_SAMPLER_EXTERNAL_OES,		/* 0x26 */
-    gcSHADER_TYPE_COUNT
-}
+
+	gcSHADER_UINT_X1,			/* 0x27 */
+	gcSHADER_UINT_X2,			/* 0x28 */
+	gcSHADER_UINT_X3,			/* 0x29 */
+	gcSHADER_UINT_X4,			/* 0x2A */
+
+    gcSHADER_UNKONWN_TYPE,      /* do not add type after this */
+    gcSHADER_TYPE_COUNT         /* must to change gcvShaderTypeInfo at the
+                                 * same time if you add any new type! */}
 gcSHADER_TYPE;
 
+typedef enum _gcSHADER_TYPE_KIND
+{
+    gceTK_UNKOWN,
+    gceTK_FLOAT,
+    gceTK_INT,
+    gceTK_UINT,
+    gceTK_BOOL,
+    gceTK_FIXED,
+    gceTK_SAMPLER,
+    gceTK_IMAGE,
+    gceTK_OTHER
+} gcSHADER_TYPE_KIND;
+
+typedef struct _gcSHADER_TYPEINFO
+{
+    gcSHADER_TYPE      type;              /* e.g. gcSHADER_FLOAT_2X4 */
+    gctINT             components;        /* e.g. 4 components       */
+    gctINT             rows;              /* e.g. 2 rows             */
+    gcSHADER_TYPE      componentType;     /* e.g. gcSHADER_FLOAT_X4  */
+    gcSHADER_TYPE_KIND kind;              /* e.g. gceTK_FLOAT */
+    gctCONST_STRING    name;              /* e.g. "FLOAT_2X4" */
+} gcSHADER_TYPEINFO;
+
+extern gcSHADER_TYPEINFO gcvShaderTypeInfo[];
+
+#define gcmType_Comonents(Type)    (gcvShaderTypeInfo[Type].components)
+#define gcmType_Rows(Type)         (gcvShaderTypeInfo[Type].rows)
+#define gcmType_ComonentType(Type) (gcvShaderTypeInfo[Type].componentType)
+#define gcmType_Kind(Type)         (gcvShaderTypeInfo[Type].kind)
+#define gcmType_Name(Type)         (gcvShaderTypeInfo[Type].name)
+
+#define gcmType_isMatrix(type) (gcmType_Rows(type) > 1)
+
 typedef enum _gcSHADER_VAR_CATEGORY
 {
     gcSHADER_VAR_CATEGORY_NORMAL  =  0, /* primitive type and its array */
@@ -451,7 +624,6 @@ typedef enum _gceTYPE_QUALIFIER
 typedef gctUINT16  gctTYPE_QUALIFIER;
 
 #if GC_ENABLE_LOADTIME_OPT
-
 typedef struct _gcSHADER_TYPE_INFO
 {
     gcSHADER_TYPE    type;        /* eg. gcSHADER_FLOAT_2X3 is the type */
@@ -462,6 +634,8 @@ typedef struct _gcSHADER_TYPE_INFO
     gctINT           size;        /* the size in byte */
 } gcSHADER_TYPE_INFO;
 
+extern gcSHADER_TYPE_INFO shader_type_info[];
+
 enum gceLTCDumpOption {
     gceLTC_DUMP_UNIFORM      = 0x0001,
     gceLTC_DUMP_EVALUATION   = 0x0002,
@@ -471,11 +645,8 @@ enum gceLTCDumpOption {
 
 gctBOOL gcDumpOption(gctINT Opt);
 
-extern gcSHADER_TYPE_INFO shader_type_info[];
-
 #endif /* GC_ENABLE_LOADTIME_OPT */
 
-
 #define IS_MATRIX_TYPE(type) \
     (((type >= gcSHADER_FLOAT_2X2) && (type <= gcSHADER_FLOAT_4X4)) || \
      ((type >= gcSHADER_FLOAT_2X3) && (type <= gcSHADER_FLOAT_4X3)))
@@ -516,6 +687,13 @@ typedef enum _gceSHADER_FLAGS
     gcvSHADER_USE_ALPHA_KILL            = 0x100,
 #endif
 
+#if ADD_PRE_ROTATION_TO_VS
+    gcvSHADER_VS_PRE_ROTATION           = 0x200,
+#endif
+
+#if TEMP_INLINE_ALL_EXPANSION
+    gcvSHADER_INLINE_ALL_EXPANSION      = 0x200,
+#endif
 }
 gceSHADER_FLAGS;
 
@@ -525,6 +703,285 @@ gcSHADER_CheckClipW(
     IN gctCONST_STRING FragmentSource,
     OUT gctBOOL * clipW);
 
+/*******************************************************************************
+**							gcOptimizer Data Structures
+*******************************************************************************/
+typedef enum _gceSHADER_OPTIMIZATION
+{
+    /*  No optimization. */
+	gcvOPTIMIZATION_NONE,
+
+    /*  Flow graph construction. */
+	gcvOPTIMIZATION_CONSTRUCTION                = 1 << 0,
+
+    /*  Dead code elimination. */
+	gcvOPTIMIZATION_DEAD_CODE                   = 1 << 1,
+
+    /*  Redundant move instruction elimination. */
+	gcvOPTIMIZATION_REDUNDANT_MOVE              = 1 << 2,
+
+    /*  Inline expansion. */
+	gcvOPTIMIZATION_INLINE_EXPANSION            = 1 << 3,
+
+    /*  Constant propagation. */
+	gcvOPTIMIZATION_CONSTANT_PROPAGATION        = 1 << 4,
+
+    /*  Redundant bounds/checking elimination. */
+	gcvOPTIMIZATION_REDUNDANT_CHECKING          = 1 << 5,
+
+    /*  Loop invariant movement. */
+	gcvOPTIMIZATION_LOOP_INVARIANT              = 1 << 6,
+
+    /*  Induction variable removal. */
+	gcvOPTIMIZATION_INDUCTION_VARIABLE          = 1 << 7,
+
+    /*  Common subexpression elimination. */
+	gcvOPTIMIZATION_COMMON_SUBEXPRESSION        = 1 << 8,
+
+    /*  Control flow/banch optimization. */
+	gcvOPTIMIZATION_CONTROL_FLOW                = 1 << 9,
+
+    /*  Vector component operation merge. */
+	gcvOPTIMIZATION_VECTOR_INSTRUCTION_MERGE    = 1 << 10,
+
+    /*  Algebra simplificaton. */
+	gcvOPTIMIZATION_ALGEBRAIC_SIMPLIFICATION    = 1 << 11,
+
+    /*  Pattern matching and replacing. */
+	gcvOPTIMIZATION_PATTERN_MATCHING            = 1 << 12,
+
+    /*  Interprocedural constant propagation. */
+	gcvOPTIMIZATION_IP_CONSTANT_PROPAGATION     = 1 << 13,
+
+    /*  Interprecedural register optimization. */
+	gcvOPTIMIZATION_IP_REGISTRATION             = 1 << 14,
+
+    /*  Optimization option number. */
+	gcvOPTIMIZATION_OPTION_NUMBER               = 1 << 15,
+
+	/*  Loadtime constant. */
+    gcvOPTIMIZATION_LOADTIME_CONSTANT           = 1 << 16,
+
+    /*  MAD instruction optimization. */
+	gcvOPTIMIZATION_MAD_INSTRUCTION             = 1 << 17,
+
+    /*  Special optimization for LOAD SW workaround. */
+	gcvOPTIMIZATION_LOAD_SW_WORKAROUND          = 1 << 18,
+
+    /* move code into conditional block if possile */
+	gcvOPTIMIZATION_CONDITIONALIZE              = 1 << 19,
+
+    /* expriemental: power optimization mode
+        1. add extra dummy texld to tune performance
+        2. insert NOP after high power instrucitons
+        3. split high power vec3/vec4 instruciton to vec2/vec1 operation
+        4. ...
+     */
+	gcvOPTIMIZATION_POWER_OPTIMIZATION           = 1 << 20,
+
+    /* optimize varying packing */
+    gcvOPTIMIZATION_VARYINGPACKING              = 1 << 22,
+
+#if TEMP_INLINE_ALL_EXPANSION
+	gcvOPTIMIZATION_INLINE_ALL_EXPANSION        = 1 << 23,
+#endif
+
+    /*  Full optimization. */
+    /*  Note that gcvOPTIMIZATION_LOAD_SW_WORKAROUND is off. */
+	gcvOPTIMIZATION_FULL                        = 0x7FFFFFFF &
+                                                  ~gcvOPTIMIZATION_LOAD_SW_WORKAROUND &
+                                                  ~gcvOPTIMIZATION_INLINE_ALL_EXPANSION &
+                                                  ~gcvOPTIMIZATION_POWER_OPTIMIZATION,
+
+	/* Optimization Unit Test flag. */
+    gcvOPTIMIZATION_UNIT_TEST                   = 1 << 31
+}
+gceSHADER_OPTIMIZATION;
+
+typedef enum _gceOPTIMIZATION_VaryingPaking
+{
+    gcvOPTIMIZATION_VARYINGPACKING_NONE = 0,
+    gcvOPTIMIZATION_VARYINGPACKING_NOSPLIT,
+    gcvOPTIMIZATION_VARYINGPACKING_SPLIT
+} gceOPTIMIZATION_VaryingPaking;
+
+typedef struct _gcOPTIMIZER_OPTION
+{
+    gceSHADER_OPTIMIZATION     optFlags;
+
+    /* debug & dump options:
+
+         VC_OPTION=-DUMP:SRC:OPT|:OPTV|:CG|:CGV:|ALL|ALLV
+
+         SRC:  dump shader source code
+         OPT:  dump incoming and final IR
+         OPTV: dump result IR in each optimization phase
+         CG:   dump generated machine code
+         CGV:  dump BE tree and optimization detail
+
+         ALL = SRC|OPT|CG
+         ALLV = SRC|OPT|OPTV|CG|CGV
+     */
+    gctBOOL     dumpShaderSource;      /* dump shader source code */
+    gctBOOL     dumpOptimizer;         /* dump incoming and final IR */
+    gctBOOL     dumpOptimizerVerbose;  /* dump result IR in each optimization phase */
+    gctBOOL     dumpBEGenertedCode;    /* dump generated machine code */
+    gctBOOL     dumpBEVerbose;         /* dump BE tree and optimization detail */
+
+    /* Code generation */
+
+    /* Varying Packing:
+
+          VC_OPTION=-PACKVARYING:[0-2]|:T[-]m[,n]|:LshaderIdx,min,max
+
+          0: turn off varying packing
+          1: pack varyings, donot split any varying
+          2: pack varyings, may split to make fully packed output
+
+          Tm:    only packing shader pair which vertex shader id is m
+          Tm,n:  only packing shader pair which vertex shader id
+                   is in range of [m, n]
+          T-m:   do not packing shader pair which vertex shader id is m
+          T-m,n: do not packing shader pair which vertex shader id
+                   is in range of [m, n]
+
+          LshaderIdx,min,max : set  load balance (min, max) for shaderIdx
+                               if shaderIdx is -1, all shaders are impacted
+                               newMin = origMin * (min/100.);
+                               newMax = origMax * (max/100.);
+     */
+    gceOPTIMIZATION_VaryingPaking    packVarying;
+    gctINT                           _triageStart;
+    gctINT                           _triageEnd;
+    gctINT                           _loadBalanceShaderIdx;
+    gctINT                           _loadBalanceMin;
+    gctINT                           _loadBalanceMax;
+
+    /* Do not generate immdeiate
+
+          VC_OPTION=-NOIMM
+
+       Force generate immediate even the machine model don't support it,
+       for testing purpose only
+
+          VC_OPTION=-FORCEIMM
+     */
+    gctBOOL     noImmediate;
+    gctBOOL     forceImmediate;
+
+    /* Power reduction mode options */
+    gctBOOL   needPowerOptimization;
+
+    /* Patch TEXLD instruction by adding dummy texld
+       (can be used to tune GPU power usage):
+         for every TEXLD we seen, add n dummy TEXLD
+
+        it can be enabled by environment variable:
+
+          VC_OPTION=-PATCH_TEXLD:M:N
+
+        (for each M texld, add N dummy texld)
+     */
+    gctINT      patchEveryTEXLDs;
+    gctINT      patchDummyTEXLDs;
+
+    /* Insert NOP after high power consumption instructions
+
+         VC_OPTION="-INSERTNOP:MUL:MULLO:DP3:DP4:SEENTEXLD"
+     */
+    gctBOOL     insertNOP;
+    gctBOOL     insertNOPAfterMUL;
+    gctBOOL     insertNOPAfterMULLO;
+    gctBOOL     insertNOPAfterDP3;
+    gctBOOL     insertNOPAfterDP4;
+    gctBOOL     insertNOPOnlyWhenTexldSeen;
+
+    /* split MAD to MUL and ADD:
+
+         VC_OPTION=-SPLITMAD
+     */
+    gctBOOL     splitMAD;
+
+    /* Convert vect3/vec4 operations to multiple vec2/vec1 operations
+
+         VC_OPTION=-SPLITVEC:MUL:MULLO:DP3:DP4
+     */
+    gctBOOL     splitVec;
+    gctBOOL     splitVec4MUL;
+    gctBOOL     splitVec4MULLO;
+    gctBOOL     splitVec4DP3;
+    gctBOOL     splitVec4DP4;
+
+    /* turn/off features:
+
+          VC_OPTION=-F:n,[0|1]
+          Note: n must be decimal number
+     */
+    gctUINT     featureBits;
+
+    /* inline level (default 2 at O1):
+
+          VC_OPTION=-INLINELEVEL:[0-3]
+             0:  no inline
+             1:  only inline the function only called once or small function
+             2:  inline functions be called less than 5 times or medium size function
+             3:  inline everything possible
+     */
+    gctUINT     inlineLevel;
+} gcOPTIMIZER_OPTION;
+
+extern gcOPTIMIZER_OPTION theOptimizerOption;
+#define gcmGetOptimizerOption() gcGetOptimizerOption()
+
+#define gcmOPT_DUMP_SHADER_SRC()         \
+             (gcmGetOptimizerOption()->dumpShaderSource != 0)
+#define gcmOPT_DUMP_OPTIMIZER()          \
+             (gcmGetOptimizerOption()->dumpOptimizer != 0 || \
+              gcmOPT_DUMP_OPTIMIZER_VERBOSE() )
+#define gcmOPT_DUMP_OPTIMIZER_VERBOSE()  \
+             (gcmGetOptimizerOption()->dumpOptimizerVerbose != 0)
+#define gcmOPT_DUMP_CODEGEN()            \
+             (gcmGetOptimizerOption()->dumpBEGenertedCode != 0 || \
+              gcmOPT_DUMP_CODEGEN_VERBOSE() )
+#define gcmOPT_DUMP_CODEGEN_VERBOSE()    \
+             (gcmGetOptimizerOption()->dumpBEVerbose != 0)
+
+#define gcmOPT_SET_DUMP_SHADER_SRC(v)   \
+             gcmGetOptimizerOption()->dumpShaderSource = (v)
+
+#define gcmOPT_PATCH_TEXLD()  (gcmGetOptimizerOption()->patchDummyTEXLDs != 0)
+#define gcmOPT_INSERT_NOP()   (gcmGetOptimizerOption()->insertNOP == gcvTRUE)
+#define gcmOPT_SPLITMAD()     (gcmGetOptimizerOption()->splitMAD == gcvTRUE)
+#define gcmOPT_SPLITVEC()     (gcmGetOptimizerOption()->splitVec == gcvTRUE)
+
+#define gcmOPT_NOIMMEDIATE()  (gcmGetOptimizerOption()->noImmediate == gcvTRUE)
+#define gcmOPT_FORCEIMMEDIATE()  (gcmGetOptimizerOption()->forceImmediate == gcvTRUE)
+
+#define gcmOPT_PACKVARYING()     (gcmGetOptimizerOption()->packVarying)
+#define gcmOPT_PACKVARYING_triageStart()   (gcmGetOptimizerOption()->_triageStart)
+#define gcmOPT_PACKVARYING_triageEnd()     (gcmGetOptimizerOption()->_triageEnd)
+
+#define gcmOPT_INLINELEVEL()     (gcmGetOptimizerOption()->inlineLevel)
+
+/* Setters */
+#define gcmOPT_SetPatchTexld(m,n) (gcmGetOptimizerOption()->patchEveryTEXLDs = (m),\
+                                   gcmGetOptimizerOption()->patchDummyTEXLDs = (n))
+#define gcmOPT_SetSplitVecMUL() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4MUL = gcvTRUE)
+#define gcmOPT_SetSplitVecMULLO() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                  gcmGetOptimizerOption()->splitVec4MULLO = gcvTRUE)
+#define gcmOPT_SetSplitVecDP3() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4DP3 = gcvTRUE)
+#define gcmOPT_SetSplitVecDP4() (gcmGetOptimizerOption()->splitVec = gcvTRUE, \
+                                 gcmGetOptimizerOption()->splitVec4DP4 = gcvTRUE)
+
+#define gcmOPT_SetPackVarying(v)     (gcmGetOptimizerOption()->packVarying = v)
+
+#define FB_LIVERANGE_FIX1     0x0001
+
+
+#define PredefinedDummySamplerId       8
+
 /* Function argument qualifier */
 typedef enum _gceINPUT_OUTPUT
 {
@@ -576,6 +1033,50 @@ typedef enum _gceVARIABLE_UPDATE_FLAGS
     gcvVARIABLE_UPDATE_TYPE_QUALIFIER,
 }gceVARIABLE_UPDATE_FLAGS;
 
+typedef struct _gcMACHINE_INST
+{
+    gctUINT        state0;
+    gctUINT        state1;
+    gctUINT        state2;
+    gctUINT        state3;
+}gcMACHINE_INST, *gcMACHINE_INST_PTR;
+
+typedef struct _gcMACHINECODE
+{
+    gcMACHINE_INST_PTR   pCode;          /* machine code  */
+    gctUINT              instCount;      /* 128-bit count */
+    gctUINT              maxConstRegNo;
+    gctUINT              maxTempRegNo;
+    gctUINT              endPCOfMainRoutine;
+}gcMACHINECODE, *gcMACHINECODE_PTR;
+
+typedef enum NP2_ADDRESS_MODE
+{
+    NP2_ADDRESS_MODE_CLAMP  = 0,
+    NP2_ADDRESS_MODE_REPEAT = 1,
+    NP2_ADDRESS_MODE_MIRROR = 2
+}NP2_ADDRESS_MODE;
+
+typedef struct _gcNPOT_PATCH_PARAM
+{
+    gctINT               samplerSlot;
+    NP2_ADDRESS_MODE     addressMode[3];
+    gctINT               texDimension;    /* 2 or 3 */
+}gcNPOT_PATCH_PARAM, *gcNPOT_PATCH_PARAM_PTR;
+
+void
+gcGetOptionFromEnv(
+    IN OUT gcOPTIMIZER_OPTION * Option
+    );
+
+void
+gcSetOptimizerOption(
+    IN gceSHADER_FLAGS Flags
+    );
+
+gcOPTIMIZER_OPTION *
+gcGetOptimizerOption();
+
 /*******************************************************************************
 **  gcSHADER_SetCompilerVersion
 **
@@ -636,6 +1137,9 @@ gcSHADER_GetType(
     IN gcSHADER Shader,
     OUT gctINT *Type
     );
+
+gctUINT
+gcSHADER_NextId();
 /*******************************************************************************
 **                             gcSHADER_Construct
 ********************************************************************************
@@ -3356,7 +3860,9 @@ gcLinkShaders(
 	IN gceSHADER_FLAGS Flags,
 	OUT gctSIZE_T * StateBufferSize,
 	OUT gctPOINTER * StateBuffer,
-	OUT gcsHINT_PTR * Hints
+	OUT gcsHINT_PTR * Hints,
+    OUT gcMACHINECODE_PTR *ppVsMachineCode,
+    OUT gcMACHINECODE_PTR *ppFsMachineCode
 	);
 
 /*******************************************************************************
@@ -3388,6 +3894,24 @@ gcLoadShaders(
 	IN gcsHINT_PTR Hints
 	);
 
+gceSTATUS
+gcRecompileShaders(
+    IN gcoHAL Hal,
+    IN gcMACHINECODE_PTR pVsMachineCode,
+    IN gcMACHINECODE_PTR pPsMachineCode,
+    /*Recompile variables*/
+    IN OUT gctPOINTER *ppRecompileStateBuffer,
+    IN OUT gctSIZE_T *pRecompileStateBufferSize,
+    IN OUT gcsHINT_PTR *ppRecompileHints,
+    /* natvie state*/
+    IN gctPOINTER pNativeStateBuffer,
+    IN gctSIZE_T nativeStateBufferSize,
+    IN gcsHINT_PTR pNativeHints,
+    /* npt info */
+    IN gctUINT32 Samplers,
+    IN gctUINT32 *SamplerWrapS,
+    IN gctUINT32 *SamplerWrapT
+    );
 /*******************************************************************************
 **                                gcSaveProgram
 ********************************************************************************
@@ -3589,6 +4113,31 @@ gcInvokeThreadWalker(
     IN gcsTHREAD_WALKER_INFO_PTR Info
     );
 
+void
+gcTYPE_GetTypeInfo(
+    IN gcSHADER_TYPE      Type,
+    OUT gctINT *          Components,
+    OUT gctINT *          Rows,
+    OUT gctCONST_STRING * Name
+    );
+
+gctBOOL
+gcOPT_doVaryingPackingForShader(
+	IN gcSHADER Shader
+    );
+
+gceSTATUS
+gcSHADER_PatchNPOTForMachineCode(
+    IN     gcSHADER_KIND          shaderType,
+    IN     gcMACHINECODE_PTR      pMachineCode,
+    IN     gcNPOT_PATCH_PARAM_PTR pPatchParam,
+    IN     gctUINT                countOfPatchParam,
+    IN     gctUINT                hwSupportedInstCount,
+    OUT    gctPOINTER*            ppCmdBuffer,
+    OUT    gctUINT32*             pByteSizeOfCmdBuffer,
+    IN OUT gcsHINT_PTR            pHints /* User needs copy original hints to this one, then passed this one in */
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
index 30b6b18..b056c52 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_driver_h_
 #define __gc_hal_driver_h_
 
@@ -95,6 +93,9 @@ typedef enum _gceHAL_COMMAND_CODES
 
     gcvHAL_READ_ALL_PROFILE_REGISTERS,
     gcvHAL_PROFILE_REGISTERS_2D,
+#if VIVANTE_PROFILER_PERDRAW
+    gcvHAL_READ_PROFILER_REGISTER_SETTING,
+#endif
 
     /* Power management. */
     gcvHAL_SET_POWER_MANAGEMENT_STATE,
@@ -161,7 +162,10 @@ typedef enum _gceHAL_COMMAND_CODES
 
     /* FSCALE_VAL. */
     gcvHAL_SET_FSCALE_VALUE,
-    gcvHAL_GET_FSCALE_VALUE
+    gcvHAL_GET_FSCALE_VALUE,
+
+    /* Reset time stamp. */
+    gcvHAL_QUERY_RESET_TIME_STAMP,
 }
 gceHAL_COMMAND_CODES;
 
@@ -206,6 +210,9 @@ typedef struct _gcsHAL_QUERY_CHIP_IDENTITY
     /* Supported minor feature 3 fields. */
     gctUINT32                   chipMinorFeatures3;
 
+    /* Supported minor feature 4 fields. */
+    gctUINT32                   chipMinorFeatures4;
+
     /* Number of streams supported. */
     gctUINT32                   streamCount;
 
@@ -249,19 +256,19 @@ typedef struct _gcsHAL_COMPOSE * gcsHAL_COMPOSE_PTR;
 typedef struct _gcsHAL_COMPOSE
 {
     /* Composition state buffer. */
-    gctPHYS_ADDR                physical;
-    gctPOINTER                  logical;
-    gctSIZE_T                   offset;
-    gctSIZE_T                   size;
+    gctUINT64                   physical;
+    gctUINT64                   logical;
+    gctUINT                     offset;
+    gctUINT                     size;
 
     /* Composition end signal. */
-    gctHANDLE                   process;
-    gctSIGNAL                   signal;
+    gctUINT64                   process;
+    gctUINT64                   signal;
 
     /* User signals. */
-    gctHANDLE                   userProcess;
-    gctSIGNAL                   userSignal1;
-    gctSIGNAL                   userSignal2;
+    gctUINT64                   userProcess;
+    gctUINT64                   userSignal1;
+    gctUINT64                   userSignal2;
 
 #if defined(__QNXNTO__)
     /* Client pulse side-channel connection ID. */
@@ -273,6 +280,7 @@ typedef struct _gcsHAL_COMPOSE
 }
 gcsHAL_COMPOSE;
 
+
 typedef struct _gcsHAL_INTERFACE
 {
     /* Command code. */
@@ -285,7 +293,7 @@ typedef struct _gcsHAL_INTERFACE
     gceSTATUS                   status;
 
     /* Handle to this interface channel. */
-    gctHANDLE                   handle;
+    gctUINT64                   handle;
 
     /* Pid of the client. */
     gctUINT32                   pid;
@@ -304,23 +312,23 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_QUERY_VIDEO_MEMORY */
         struct _gcsHAL_QUERY_VIDEO_MEMORY
         {
-            /* Physical memory address of internal memory. */
-            OUT gctPHYS_ADDR            internalPhysical;
+            /* Physical memory address of internal memory. Just a name. */
+            OUT gctUINT32               internalPhysical;
 
-            /* Size in bytes of internal memory.*/
-            OUT gctSIZE_T               internalSize;
+            /* Size in bytes of internal memory. */
+            OUT gctUINT64               internalSize;
 
-            /* Physical memory address of external memory. */
-            OUT gctPHYS_ADDR            externalPhysical;
+            /* Physical memory address of external memory. Just a name. */
+            OUT gctUINT32               externalPhysical;
 
             /* Size in bytes of external memory.*/
-            OUT gctSIZE_T               externalSize;
+            OUT gctUINT64               externalSize;
 
-            /* Physical memory address of contiguous memory. */
-            OUT gctPHYS_ADDR            contiguousPhysical;
+            /* Physical memory address of contiguous memory. Just a name. */
+            OUT gctUINT32               contiguousPhysical;
 
             /* Size in bytes of contiguous memory.*/
-            OUT gctSIZE_T               contiguousSize;
+            OUT gctUINT64               contiguousSize;
         }
         QueryVideoMemory;
 
@@ -330,28 +338,28 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_MAP_MEMORY */
         struct _gcsHAL_MAP_MEMORY
         {
-            /* Physical memory address to map. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical memory address to map. Just a name on Linux/Qnx. */
+            IN gctUINT32                physical;
 
             /* Number of bytes in physical memory to map. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
             /* Address of mapped memory. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64               logical;
         }
         MapMemory;
 
         /* gcvHAL_UNMAP_MEMORY */
         struct _gcsHAL_UNMAP_MEMORY
         {
-            /* Physical memory address to unmap. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical memory address to unmap. Just a name on Linux/Qnx. */
+            IN gctUINT32                physical;
 
             /* Number of bytes in physical memory to unmap. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
             /* Address of mapped memory to unmap. */
-            IN gctPOINTER               logical;
+            IN gctUINT64                logical;
         }
         UnmapMemory;
 
@@ -370,8 +378,8 @@ typedef struct _gcsHAL_INTERFACE
             /* Memory pool to allocate from. */
             IN OUT gcePOOL              pool;
 
-            /* Allocated video memory. */
-            OUT gcuVIDMEM_NODE_PTR      node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            OUT gctUINT64               node;
         }
         AllocateLinearVideoMemory;
 
@@ -396,24 +404,24 @@ typedef struct _gcsHAL_INTERFACE
             /* Memory pool to allocate from. */
             IN OUT gcePOOL              pool;
 
-            /* Allocated video memory. */
-            OUT gcuVIDMEM_NODE_PTR      node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            OUT gctUINT64               node;
         }
         AllocateVideoMemory;
 
         /* gcvHAL_FREE_VIDEO_MEMORY */
         struct _gcsHAL_FREE_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            IN gctUINT64        node;
 
 #ifdef __QNXNTO__
 /* TODO: This is part of the unlock - why is it here? */
             /* Mapped logical address to unmap in user space. */
-            OUT gctPOINTER              memory;
+            OUT gctUINT64       memory;
 
             /* Number of bytes to allocated. */
-            OUT gctSIZE_T               bytes;
+            OUT gctUINT64       bytes;
 #endif
         }
         FreeVideoMemory;
@@ -421,33 +429,33 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_LOCK_VIDEO_MEMORY */
         struct _gcsHAL_LOCK_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory gcuVIDMEM_NODE gcuVIDMEM_NODE. */
+            IN gctUINT64            node;
 
             /* Cache configuration. */
             /* Only gcvPOOL_CONTIGUOUS and gcvPOOL_VIRUTAL
             ** can be configured */
-            IN gctBOOL                  cacheable;
+            IN gctBOOL              cacheable;
 
             /* Hardware specific address. */
-            OUT gctUINT32               address;
+            OUT gctUINT32           address;
 
             /* Mapped logical address. */
-            OUT gctPOINTER              memory;
+            OUT gctUINT64           memory;
         }
         LockVideoMemory;
 
         /* gcvHAL_UNLOCK_VIDEO_MEMORY */
         struct _gcsHAL_UNLOCK_VIDEO_MEMORY
         {
-            /* Allocated video memory. */
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* Allocated video memory in gcuVIDMEM_NODE. */
+            IN gctUINT64            node;
 
             /* Type of surface. */
-            IN gceSURF_TYPE             type;
+            IN gceSURF_TYPE         type;
 
             /* Flag to unlock surface asynchroneously. */
-            IN OUT gctBOOL              asynchroneous;
+            IN OUT gctBOOL          asynchroneous;
         }
         UnlockVideoMemory;
 
@@ -455,13 +463,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_NON_PAGED_MEMORY
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64        bytes;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32           physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64           logical;
         }
         AllocateNonPagedMemory;
 
@@ -469,13 +477,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_NON_PAGED_MEMORY
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64            bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32            physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64            logical;
         }
         FreeNonPagedMemory;
 
@@ -483,13 +491,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_VIRTUAL_COMMAND_BUFFER
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64        bytes;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32           physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64           logical;
         }
         AllocateVirtualCommandBuffer;
 
@@ -497,38 +505,38 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_VIRTUAL_COMMAND_BUFFER
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64            bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32            physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64            logical;
         }
         FreeVirtualCommandBuffer;
 
         /* gcvHAL_EVENT_COMMIT. */
         struct _gcsHAL_EVENT_COMMIT
         {
-            /* Event queue. */
-            IN gcsQUEUE_PTR             queue;
+            /* Event queue in gcsQUEUE. */
+            IN gctUINT64             queue;
         }
         Event;
 
         /* gcvHAL_COMMIT */
         struct _gcsHAL_COMMIT
         {
-            /* Context buffer object. */
-            IN gckCONTEXT               context;
+            /* Context buffer object gckCONTEXT. */
+            IN gctUINT64            context;
 
-            /* Command buffer. */
-            IN gcoCMDBUF                commandBuffer;
+            /* Command buffer gcoCMDBUF. */
+            IN gctUINT64            commandBuffer;
 
-            /* State delta buffer. */
-            gcsSTATE_DELTA_PTR          delta;
+            /* State delta buffer in gcsSTATE_DELTA. */
+            gctUINT64               delta;
 
-            /* Event queue. */
-            IN gcsQUEUE_PTR             queue;
+            /* Event queue in gcsQUEUE. */
+            IN gctUINT64            queue;
         }
         Commit;
 
@@ -536,16 +544,16 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_MAP_USER_MEMORY
         {
             /* Base address of user memory to map. */
-            IN gctPOINTER               memory;
+            IN gctUINT64                memory;
 
             /* Physical address of user memory to map. */
             IN gctUINT32                physical;
 
             /* Size of user memory in bytes to map. */
-            IN gctSIZE_T                size;
+            IN gctUINT64                size;
 
-            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. */
-            OUT gctPOINTER              info;
+            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. Just a name. */
+            OUT gctUINT32               info;
 
             /* Physical address of mapped memory. */
             OUT gctUINT32               address;
@@ -556,13 +564,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_UNMAP_USER_MEMORY
         {
             /* Base address of user memory to unmap. */
-            IN gctPOINTER               memory;
+            IN gctUINT64                memory;
 
             /* Size of user memory in bytes to unmap. */
-            IN gctSIZE_T                size;
+            IN gctUINT64                size;
 
-            /* Info record returned by gcvHAL_MAP_USER_MEMORY. */
-            IN gctPOINTER               info;
+            /* Info record returned by gcvHAL_MAP_USER_MEMORY. Just a name. */
+            IN gctUINT32                info;
 
             /* Physical address of mapped memory as returned by
                gcvHAL_MAP_USER_MEMORY. */
@@ -594,14 +602,14 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_SIGNAL. */
         struct _gcsHAL_SIGNAL
         {
-            /* Signal handle to signal. */
-            IN gctSIGNAL                signal;
+            /* Signal handle to signal gctSIGNAL. */
+            IN gctUINT64                signal;
 
-            /* Reserved. */
-            IN gctSIGNAL                auxSignal;
+            /* Reserved gctSIGNAL. */
+            IN gctUINT64                auxSignal;
 
-            /* Process owning the signal. */
-            IN gctHANDLE                process;
+            /* Process owning the signal gctHANDLE. */
+            IN gctUINT64                process;
 
 #if defined(__QNXNTO__)
             /* Client pulse side-channel connection ID. Set by client in gcoOS_CreateSignal. */
@@ -630,16 +638,16 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_ALLOCATE_CONTIGUOUS_MEMORY
         {
             /* Number of bytes to allocate. */
-            IN OUT gctSIZE_T            bytes;
+            IN OUT gctUINT64            bytes;
 
             /* Hardware address of allocation. */
             OUT gctUINT32               address;
 
-            /* Physical address of allocation. */
-            OUT gctPHYS_ADDR            physical;
+            /* Physical address of allocation. Just a name. */
+            OUT gctUINT32               physical;
 
             /* Logical address of allocation. */
-            OUT gctPOINTER              logical;
+            OUT gctUINT64               logical;
         }
         AllocateContiguousMemory;
 
@@ -647,13 +655,13 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_FREE_CONTIGUOUS_MEMORY
         {
             /* Number of bytes allocated. */
-            IN gctSIZE_T                bytes;
+            IN gctUINT64                bytes;
 
-            /* Physical address of allocation. */
-            IN gctPHYS_ADDR             physical;
+            /* Physical address of allocation. Just a name. */
+            IN gctUINT32                physical;
 
             /* Logical address of allocation. */
-            IN gctPOINTER               logical;
+            IN gctUINT64                logical;
         }
         FreeContiguousMemory;
 
@@ -702,6 +710,16 @@ typedef struct _gcsHAL_INTERFACE
         }
         SetProfileSetting;
 
+#if VIVANTE_PROFILER_PERDRAW
+        /* gcvHAL_READ_PROFILER_REGISTER_SETTING */
+        struct _gcsHAL_READ_PROFILER_REGISTER_SETTING
+         {
+            /*Should Clear Register*/
+            IN gctBOOL               bclear;
+         }
+        SetProfilerRegisterClear;
+#endif
+
         /* gcvHAL_READ_ALL_PROFILE_REGISTERS */
         struct _gcsHAL_READ_ALL_PROFILE_REGISTERS
         {
@@ -713,8 +731,8 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_PROFILE_REGISTERS_2D */
         struct _gcsHAL_PROFILE_REGISTERS_2D
         {
-            /* Data read. */
-            OUT gcs2D_PROFILE_PTR       hwProfile2D;
+            /* Data read in gcs2D_PROFILE. */
+            OUT gctUINT64       hwProfile2D;
         }
         RegisterProfileData2D;
 #endif
@@ -753,7 +771,7 @@ typedef struct _gcsHAL_INTERFACE
             IN gctBOOL                  map;
 
             /* Physical address. */
-            IN OUT gctPHYS_ADDR         physical;
+            IN OUT gctUINT64            physical;
         }
         MapPhysical;
 
@@ -778,10 +796,12 @@ typedef struct _gcsHAL_INTERFACE
         struct _gcsHAL_CACHE
         {
             IN gceCACHEOPERATION        operation;
-            IN gctHANDLE                process;
-            IN gctPOINTER               logical;
-            IN gctSIZE_T                bytes;
-            IN gcuVIDMEM_NODE_PTR       node;
+            /* gctHANDLE */
+            IN gctUINT64                process;
+            IN gctUINT64                logical;
+            IN gctUINT64                bytes;
+            /* gcuVIDMEM_NODE_PTR */
+            IN gctUINT64                node;
         }
         Cache;
 
@@ -848,29 +868,30 @@ typedef struct _gcsHAL_INTERFACE
         /* gcvHAL_ATTACH */
         struct _gcsHAL_ATTACH
         {
-            /* Context buffer object. */
-            OUT gckCONTEXT              context;
+            /* Context buffer object gckCONTEXT. Just a name. */
+            OUT gctUINT32               context;
 
             /* Number of states in the buffer. */
-            OUT gctSIZE_T               stateCount;
+            OUT gctUINT64               stateCount;
         }
         Attach;
 
         /* gcvHAL_DETACH */
         struct _gcsHAL_DETACH
         {
-            /* Context buffer object. */
-            IN gckCONTEXT               context;
+            /* Context buffer object gckCONTEXT. Just a name. */
+            IN gctUINT32                context;
         }
         Detach;
 
         /* gcvHAL_COMPOSE. */
-        gcsHAL_COMPOSE                  Compose;
+        gcsHAL_COMPOSE            Compose;
 
         /* gcvHAL_GET_FRAME_INFO. */
         struct _gcsHAL_GET_FRAME_INFO
         {
-            OUT gcsHAL_FRAME_INFO *     frameInfo;
+            /* gcsHAL_FRAME_INFO* */
+            OUT gctUINT64     frameInfo;
         }
         GetFrameInfo;
 
@@ -885,17 +906,17 @@ typedef struct _gcsHAL_INTERFACE
 		/* gcvHAL_COMMIT */
 		struct _gcsHAL_VGCOMMIT
 		{
-			/* Context buffer. */
-			IN gcsVGCONTEXT_PTR			context;
+			/* Context buffer in gcsVGCONTEXT. */
+			IN gctUINT64			context;
 
-			/* Command queue. */
-			IN gcsVGCMDQUEUE_PTR			queue;
+			/* Command queue in gcsVGCMDQUEUE. */
+			IN gctUINT64			queue;
 
 			/* Number of entries in the queue. */
-			IN gctUINT					entryCount;
+			IN gctUINT			entryCount;
 
-			/* Task table. */
-			IN gcsTASK_MASTER_TABLE_PTR	taskTable;
+			/* Task table in gcsTASK_MASTER_TABLE. */
+			IN gctUINT64	                taskTable;
 		}
 		VGCommit;
 
@@ -911,25 +932,30 @@ typedef struct _gcsHAL_INTERFACE
 
         struct _gcsHAL_GET_SHARED_INFO
         {
+            /* Process id. */
             IN gctUINT32            pid;
+
+            /* Data id. */
             IN gctUINT32            dataId;
-            IN gcuVIDMEM_NODE_PTR   node;
-            OUT gctUINT8_PTR        data;
-            /* fix size */
-            OUT gctUINT8_PTR        nodeData;
-            gctSIZE_T               size;
-            IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
+
+            /* Data size. */
+            IN gctSIZE_T            bytes;
+
+            /* Pointer to save the shared data. */
+            OUT gctPOINTER          data;
         }
         GetSharedInfo;
 
         struct _gcsHAL_SET_SHARED_INFO
         {
+            /* Data id. */
             IN gctUINT32            dataId;
-            IN gcuVIDMEM_NODE_PTR   node;
-            IN gctUINT8_PTR         data;
-            IN gctUINT8_PTR         nodeData;
-            IN gctSIZE_T            size;
-            IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
+
+            /* Data to be shared. */
+            IN gctPOINTER           data;
+
+            /* Data size. */
+            IN gctSIZE_T            bytes;
         }
         SetSharedInfo;
 
@@ -946,6 +972,12 @@ typedef struct _gcsHAL_INTERFACE
             OUT gctUINT             maxValue;
         }
         GetFscaleValue;
+
+        struct _gcsHAL_QUERY_RESET_TIME_STAMP
+        {
+            OUT gctUINT64           timeStamp;
+        }
+        QueryResetTimeStamp;
     }
     u;
 }
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
index c447dcf..b54752f 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_driver_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_driver_vg_h_
 #define __gc_hal_driver_vg_h_
 
@@ -213,7 +210,7 @@ typedef struct _gcsTASK_UNLOCK_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gcuVIDMEM_NODE_PTR       node;
+    IN gctUINT64                node;
 }
 gcsTASK_UNLOCK_VIDEO_MEMORY;
 
@@ -224,7 +221,7 @@ typedef struct _gcsTASK_FREE_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gcuVIDMEM_NODE_PTR       node;
+    IN gctUINT64                node;
 }
 gcsTASK_FREE_VIDEO_MEMORY;
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
index 9b2db22..ffd45e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_dump.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_dump_h_
 #define __gc_hal_dump_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
index f7934ea..06eea79 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_eglplatform_h_
 #define __gc_hal_eglplatform_h_
 
@@ -47,7 +45,7 @@ typedef struct __BITFIELDINFO{
 
 #elif defined(LINUX) && defined(EGL_API_DFB) && !defined(__APPLE__)
 #include <directfb.h>
-typedef IDirectFB * HALNativeDisplayType;
+typedef struct _DFBDisplay * HALNativeDisplayType;
 typedef IDirectFBWindow *  HALNativeWindowType;
 typedef struct _DFBPixmap *  HALNativePixmapType;
 
@@ -229,7 +227,8 @@ gcoOS_GetDisplayInfoEx(
     );
 
 gceSTATUS
-gcoOS_GetNextDisplayInfoEx(
+gcoOS_GetNextDisplayInfoExByIndex(
+    IN gctINT Index,
     IN HALNativeDisplayType Display,
     IN HALNativeWindowType Window,
     IN gctUINT DisplayInfoSize,
@@ -264,16 +263,27 @@ gcoOS_SetDisplayVirtual(
     );
 
 gceSTATUS
+gcoOS_SetDisplayVirtualEx(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctPOINTER Context,
+    IN gcoSURF Surface,
+    IN gctUINT Offset,
+    IN gctINT X,
+    IN gctINT Y
+    );
+
+gceSTATUS
 gcoOS_SetSwapInterval(
-	IN HALNativeDisplayType Display,
-	IN gctINT Interval
+    IN HALNativeDisplayType Display,
+    IN gctINT Interval
 );
 
 gceSTATUS
 gcoOS_GetSwapInterval(
-	IN HALNativeDisplayType Display,
-	IN gctINT_PTR Min,
-	IN gctINT_PTR Max
+    IN HALNativeDisplayType Display,
+    IN gctINT_PTR Min,
+    IN gctINT_PTR Max
 );
 
 gceSTATUS
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
index 727758f..4f5c3ce 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_eglplatform_type.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_eglplatform_type_h_
 #define __gc_hal_eglplatform_type_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
index bbfdbc6..8481375 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_engine_h_
 #define __gc_hal_engine_h_
 
@@ -325,72 +323,59 @@ gcoSURF_Resolve(
     IN gcoSURF DestSurface
     );
 
-/* Export the render target. */
-gceSTATUS
-gcoSURF_ExportRenderTarget(
-    IN gcoSURF SrcSurface
-);
-
-/* Import the render target. */
-gceSTATUS
-gcoSURF_ImportRenderTarget(
-    IN gctUINT32 Pid,
-    IN gcoSURF SrcSurface
-);
-
-/* Save the Resolve info to kernel. */
+/* Resolve rectangular area of a surface. */
 gceSTATUS
-gcoSURF_PrepareRemoteResolveRect(
+gcoSURF_ResolveRect(
     IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface,
     IN gcsPOINT_PTR SrcOrigin,
     IN gcsPOINT_PTR DestOrigin,
     IN gcsPOINT_PTR RectSize
     );
 
-/* Resolve using the rectangle info previously saved in the vid mem node. */
+/* Set surface resolvability. */
 gceSTATUS
-gcoSURF_ResolveFromStoredRect(
-    IN gcoSURF SrcSurface,
-    IN gcoSURF DestSurface
+gcoSURF_SetResolvability(
+    IN gcoSURF Surface,
+    IN gctBOOL Resolvable
     );
 
-/* Using the info that Process Pid saved to do resolve. */
 gceSTATUS
-gcoSURF_RemoteResolveRect(
-    IN gcoSURF SrcSurface,
-    IN gcoSURF DestSurface,
-    IN gctBOOL *resolveDiscarded
+gcoSURF_IsRenderable(
+    IN gcoSURF Surface
     );
 
-/* Return the "resolve submitted indicator" signal. */
+#if gcdSYNC
 gceSTATUS
-gcoSURF_GetRTSignal(
-    IN gcoSURF RTSurface,
-    OUT gctSIGNAL * resolveSubmittedSignal
+gcoSURF_GetFence(
+    IN gcoSURF Surface
+    );
+gceSTATUS
+gcoSURF_WaitFence(
+    IN gcoSURF Surface
     );
 
-/* Resolve rectangular area of a surface. */
 gceSTATUS
-gcoSURF_ResolveRect(
-    IN gcoSURF SrcSurface,
-    IN gcoSURF DestSurface,
-    IN gcsPOINT_PTR SrcOrigin,
-    IN gcsPOINT_PTR DestOrigin,
-    IN gcsPOINT_PTR RectSize
+gcoSTREAM_GetFence(
+    IN gcoSTREAM stream
     );
 
-/* Set surface resolvability. */
 gceSTATUS
-gcoSURF_SetResolvability(
-    IN gcoSURF Surface,
-    IN gctBOOL Resolvable
+gcoSTREAM_WaitFence(
+    IN gcoSTREAM stream
     );
 
 gceSTATUS
-gcoSURF_IsRenderable(
-    IN gcoSURF Surface
+gcoINDEX_GetFence(
+    IN gcoINDEX index
     );
 
+gceSTATUS
+gcoINDEX_WaitFence(
+    IN gcoINDEX index
+    );
+#endif
+
 /******************************************************************************\
 ******************************** gcoINDEX Object *******************************
 \******************************************************************************/
@@ -469,6 +454,22 @@ gcoINDEX_UploadOffset(
     IN gctSIZE_T Bytes
     );
 
+/*Merge index2 to index1 from 0, index2 must subset of inex1*/
+gceSTATUS
+gcoINDEX_Merge(
+    IN gcoINDEX Index1,
+    IN gcoINDEX Index2
+    );
+
+/*check if index buffer is enough for this draw*/
+gctBOOL
+gcoINDEX_CheckRange(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE Type,
+    IN gctINT Count,
+    IN gctUINT32  Indices
+    );
+
 /* Query the index capabilities. */
 gceSTATUS
 gcoINDEX_QueryCaps(
@@ -1210,6 +1211,12 @@ gco3D_SetWClipEnable(
     );
 
 gceSTATUS
+gco3D_GetWClipEnable(
+    IN gco3D Engine,
+    OUT gctBOOL * Enable
+    );
+
+gceSTATUS
 gco3D_SetWPlaneLimitF(
 	IN gco3D Engine,
 	IN gctFLOAT Value
@@ -1379,6 +1386,16 @@ typedef enum _gceTEXTURE_FACE
 }
 gceTEXTURE_FACE;
 
+#if gcdFORCE_MIPMAP
+typedef enum
+{
+    gcvForceMipDisabled  = 0,
+    gcvForceMipEnable    = 1,
+    gcvForceMipGenerated = 2,
+    gcvForceMipNever     = 3,
+}gceFORCE_MIPMAP;
+#endif
+
 typedef struct _gcsTEXTURE
 {
     /* Addressing modes. */
@@ -1394,7 +1411,11 @@ typedef struct _gcsTEXTURE
     gceTEXTURE_FILTER           magFilter;
     gceTEXTURE_FILTER           mipFilter;
     gctUINT                     anisoFilter;
-
+    gctBOOL                     forceTopLevel;
+    gctBOOL                     autoMipmap;
+#if gcdFORCE_MIPMAP
+    gceFORCE_MIPMAP             forceMipmap;
+#endif
     /* Level of detail. */
     gctFIXED_POINT              lodBias;
     gctFIXED_POINT              lodMin;
@@ -1428,6 +1449,31 @@ gceSTATUS
 gcoTEXTURE_Destroy(
     IN gcoTEXTURE Texture
     );
+#if gcdFORCE_MIPMAP
+gceSTATUS
+gcoTEXTURE_DestroyForceMipmap(
+    IN gcoTEXTURE Texture
+    );
+
+gceSTATUS
+gcoTEXTURE_GetMipLevels(
+    IN gcoTEXTURE Texture,
+    OUT gctINT * levels
+    );
+#endif
+/* Replace a mipmap in gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_ReplaceMipMap(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Level,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctINT imageFormat,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Depth,
+    IN gctUINT Faces,
+    IN gcePOOL Pool
+    );
 
 /* Upload data to an gcoTEXTURE object. */
 gceSTATUS
@@ -1540,6 +1586,12 @@ gcoTEXTURE_AddMipMapFromSurface(
     );
 
 gceSTATUS
+gcoTEXTURE_SetMaxLevel(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Levels
+    );
+
+gceSTATUS
 gcoTEXTURE_SetEndianHint(
     IN gcoTEXTURE Texture,
     IN gceENDIAN_HINT EndianHint
@@ -1588,6 +1640,12 @@ gcoTEXTURE_IsRenderable(
     );
 
 gceSTATUS
+gcoTEXTURE_IsRenderableEx(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Level
+    );
+
+gceSTATUS
 gcoTEXTURE_IsComplete(
     IN gcoTEXTURE Texture,
     IN gctINT MaxLevel
@@ -1932,21 +1990,15 @@ gceSTATUS
 gcoHAL_GetSharedInfo(
     IN gctUINT32 Pid,
     IN gctUINT32 DataId,
-    OUT gctUINT8_PTR Data,
     IN gctSIZE_T Bytes,
-    IN gcuVIDMEM_NODE_PTR Node,
-    OUT gctUINT8_PTR NodeData,
-    IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
+    OUT gctPOINTER Data
     );
 
 gceSTATUS
 gcoHAL_SetSharedInfo(
     IN gctUINT32 DataId,
-    IN gctUINT8_PTR Data,
-    IN gctSIZE_T Bytes,
-    IN gcuVIDMEM_NODE_PTR Node,
-    IN gctUINT8_PTR NodeData,
-    IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
+    IN gctPOINTER Data,
+    IN gctSIZE_T Bytes
     );
 
 #ifdef __cplusplus
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
index 1526b0c..4bb6772 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_engine_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_engine_vg_h_
 #define __gc_hal_engine_vg_h_
 
@@ -527,14 +524,14 @@ gcoHAL_CombineAddress(
 gceSTATUS
 gcoHAL_ScheduleVideoMemory(
     IN gcoHAL Hal,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gctUINT64 Node
     );
 
 /* Free linear video memory allocated with gcoHAL_AllocateLinearVideoMemory. */
 gceSTATUS
 gcoHAL_FreeVideoMemory(
     IN gcoHAL Hal,
-    IN gcuVIDMEM_NODE_PTR Node
+    IN gctUINT64 Node
     );
 
 /* Query command buffer attributes. */
@@ -550,7 +547,7 @@ gcoHAL_AllocateLinearVideoMemory(
     IN gctUINT Size,
     IN gctUINT Alignment,
     IN gcePOOL Pool,
-    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT64 * Node,
     OUT gctUINT32 * Address,
     OUT gctPOINTER * Memory
     );
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
index 67ad54f..a1d9ae5 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_enum.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_enum_h_
 #define __gc_hal_enum_h_
 
@@ -148,6 +146,10 @@ typedef enum _gceFEATURE
     gcvFEATURE_FRUSTUM_CLIP_FIX,
     gcvFEATURE_TEXTURE_LINEAR,
     gcvFEATURE_TEXTURE_YUV_ASSEMBLER,
+    gcvFEATURE_DYNAMIC_FREQUENCY_SCALING,
+    gcvFEATURE_BUGFIX15,
+    gcvFEATURE_2D_MIRROR_EXTENSION,
+    gcvFEATURE_ELEMENT_INDEX_UINT,
 }
 gceFEATURE;
 
@@ -179,13 +181,6 @@ typedef enum _gceCACHEOPERATION
 }
 gceCACHEOPERATION;
 
-typedef enum _gceVIDMEM_NODE_SHARED_INFO_TYPE
-{
-    gcvVIDMEM_INFO_GENERIC,
-    gcvVIDMEM_INFO_DIRTY_RECTANGLE
-}
-gceVIDMEM_NODE_SHARED_INFO_TYPE;
-
 /* Surface types. */
 typedef enum _gceSURF_TYPE
 {
@@ -349,6 +344,16 @@ typedef enum _gceSURF_FORMAT
     gcvSURF_DXT5,
     gcvSURF_CXV8U8,
     gcvSURF_ETC1,
+    gcvSURF_R11_EAC,
+    gcvSURF_SIGNED_R11_EAC,
+    gcvSURF_RG11_EAC,
+    gcvSURF_SIGNED_RG11_EAC,
+    gcvSURF_RGB8_ETC2,
+    gcvSURF_SRGB8_ETC2,
+    gcvSURF_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
+    gcvSURF_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
+    gcvSURF_RGBA8_ETC2_EAC,
+    gcvSURF_SRGB8_ALPHA8_ETC2_EAC,
 
     /* YUV formats. */
     gcvSURF_YUY2                = 500,
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
index 24edc0b..0608e43 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_kernel_buffer.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_buffer_h_
 #define __gc_hal_kernel_buffer_h_
 
@@ -59,11 +57,6 @@ typedef struct _gcsSTATE_DELTA
     gctUINT                     num;
 #endif
 
-    /* For dumping. */
-#if gcdDUMP
-    gcoOS                       os;
-#endif
-
     /* Main state delta ID. Every time state delta structure gets reinitialized,
        main ID is incremented. If main state ID overflows, all map entry IDs get
        reinitialized to make sure there is no potential erroneous match after
@@ -79,22 +72,22 @@ typedef struct _gcsSTATE_DELTA
     /* Number of states currently stored in the record array. */
     gctUINT                     recordCount;
 
-    /* Record array; holds all modified states. */
-    gcsSTATE_DELTA_RECORD_PTR   recordArray;
+    /* Record array; holds all modified states in gcsSTATE_DELTA_RECORD. */
+    gctUINT64                   recordArray;
 
     /* Map entry ID is used for map entry validation. If map entry ID does not
        match the main state delta ID, the entry and the corresponding state are
        considered not in use. */
-    gctUINT_PTR                 mapEntryID;
+    gctUINT64                   mapEntryID;
     gctUINT                     mapEntryIDSize;
 
     /* If the map entry ID matches the main state delta ID, index points to
        the state record in the record array. */
-    gctUINT_PTR                 mapEntryIndex;
+    gctUINT64                   mapEntryIndex;
 
-    /* Previous and next state deltas. */
-    gcsSTATE_DELTA_PTR          prev;
-    gcsSTATE_DELTA_PTR          next;
+    /* Previous and next state deltas in gcsSTATE_DELTA. */
+    gctUINT64                   prev;
+    gctUINT64                   next;
 }
 gcsSTATE_DELTA;
 
@@ -114,38 +107,38 @@ struct _gcoCMDBUF
     gctBOOL                     usingFilterBlit;
     gctBOOL                     usingPalette;
 
-    /* Physical address of command buffer. */
-    gctPHYS_ADDR                physical;
+    /* Physical address of command buffer. Just a name. */
+    gctUINT32                   physical;
 
     /* Logical address of command buffer. */
-    gctPOINTER                  logical;
+    gctUINT64                   logical;
 
     /* Number of bytes in command buffer. */
-    gctSIZE_T                   bytes;
+    gctUINT                     bytes;
 
     /* Start offset into the command buffer. */
-    gctUINT32                   startOffset;
+    gctUINT                     startOffset;
 
     /* Current offset into the command buffer. */
-    gctUINT32                   offset;
+    gctUINT                     offset;
 
     /* Number of free bytes in command buffer. */
-    gctSIZE_T                   free;
+    gctUINT                     free;
 
     /* Location of the last reserved area. */
-    gctPOINTER                  lastReserve;
+    gctUINT64                   lastReserve;
     gctUINT                     lastOffset;
 
 #if gcdSECURE_USER
     /* Hint array for the current command buffer. */
     gctUINT                     hintArraySize;
-    gctUINT32_PTR               hintArray;
-    gctUINT32_PTR               hintArrayTail;
+    gctUINT64                   hintArray;
+    gctUINT64                   hintArrayTail;
 #endif
 
 #if gcmIS_DEBUG(gcdDEBUG_CODE)
     /* Last load state command location and hardware address. */
-    gctUINT32_PTR               lastLoadStatePtr;
+    gctUINT64                   lastLoadStatePtr;
     gctUINT32                   lastLoadStateAddress;
     gctUINT32                   lastLoadStateCount;
 #endif
@@ -153,8 +146,8 @@ struct _gcoCMDBUF
 
 typedef struct _gcsQUEUE
 {
-    /* Pointer to next gcsQUEUE structure. */
-    gcsQUEUE_PTR                next;
+    /* Pointer to next gcsQUEUE structure in gcsQUEUE. */
+    gctUINT64                   next;
 
     /* Event information. */
     gcsHAL_INTERFACE            iface;
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
index e64f7e7..9e32878 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_mem.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 /*
 **	Include file for the local memory management.
 */
@@ -176,7 +174,7 @@ Prefix##_CAllocate##TypeName( \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
 	gcmERR_RETURN(gcfMEM_FSMemPoolGetANode(MemPool, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -233,7 +231,7 @@ gceSTATUS \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
 	gcmERR_RETURN(gcfMEM_VSMemPoolGetANode(MemPool, Size, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size)); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -276,7 +274,7 @@ Prefix##_CAllocate##TypeName( \
 	gceSTATUS				status; \
     gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
 	gcmERR_RETURN(gcfMEM_AFSMemPoolGetANode(MemPool, Count, (gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -323,7 +321,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							gcmSIZEOF(Type), \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -370,7 +368,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							Size, \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size)); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
@@ -417,7 +415,7 @@ Prefix##_CAllocate##TypeName( \
 	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
 							Count * gcmSIZEOF(Type), \
 							(gctPOINTER *) Pointer)); \
-	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+	gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type)); \
     gcmFOOTER(); \
 	return gcvSTATUS_OK; \
 } \
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
index 8b00ccd..9e2a8db 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_options.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_options_h_
 #define __gc_hal_options_h_
 
@@ -43,15 +41,6 @@
 #endif
 
 /*
-    NO_USER_DIRECT_ACCESS_FROM_KERNEL
-
-        This define enables the Linux kernel behavior accessing user memory.
-*/
-#ifndef NO_USER_DIRECT_ACCESS_FROM_KERNEL
-#   define NO_USER_DIRECT_ACCESS_FROM_KERNEL    0
-#endif
-
-/*
     VIVANTE_PROFILER
 
         This define enables the profiler.
@@ -60,6 +49,10 @@
 #   define VIVANTE_PROFILER                     0
 #endif
 
+#ifndef VIVANTE_PROFILER_PERDRAW
+#   define  VIVANTE_PROFILER_PERDRAW    0
+#endif
+
 /*
     gcdUSE_VG
 
@@ -121,6 +114,30 @@
 #define COMMAND_PROCESSOR_VERSION               1
 
 /*
+    gcdDUMP_KEY
+
+        Set this to a string that appears in 'cat /proc/<pid>/cmdline'. E.g. 'camera'.
+        HAL will create dumps for the processes matching this key.
+*/
+#ifndef gcdDUMP_KEY
+#   define gcdDUMP_KEY                          "process"
+#endif
+
+/*
+    gcdDUMP_PATH
+
+        The dump file location. Some processes cannot write to the sdcard.
+        Try apps' data dir, e.g. /data/data/com.android.launcher
+*/
+#ifndef gcdDUMP_PATH
+#if defined(ANDROID)
+#   define gcdDUMP_PATH                         "/mnt/sdcard/"
+#else
+#   define gcdDUMP_PATH                         "./"
+#endif
+#endif
+
+/*
     gcdDUMP
 
         When set to 1, a dump of all states and memory uploads, as well as other
@@ -170,14 +187,6 @@
 #endif
 
 /*
-    gcdENABLE_FSCALE_VAL_ADJUST
-        When non-zero, FSCALE_VAL when gcvPOWER_ON can be adjusted externally.
- */
-#ifndef gcdENABLE_FSCALE_VAL_ADJUST
-#   define gcdENABLE_FSCALE_VAL_ADJUST          1
-#endif
-
-/*
     gcdDUMP_IN_KERNEL
 
         When set to 1, all dumps will happen in the kernel.  This is handy if
@@ -357,6 +366,17 @@
 #endif
 
 /*
+    gcdUSER_HEAP_ALLOCATOR
+
+        Set to 1 to enable user mode heap allocator for fast memory allocation
+        and destroying. Otherwise, memory allocation/destroying in user mode
+        will be directly managed by system. Only for linux for now.
+*/
+#ifndef gcdUSER_HEAP_ALLOCATOR
+#   define gcdUSER_HEAP_ALLOCATOR               1
+#endif
+
+/*
     gcdHEAP_SIZE
 
         Set the allocation size for the internal heaps.  Each time a heap is
@@ -371,15 +391,6 @@
 #endif
 
 /*
-    gcdPOWER_MANAGEMENT
-
-        This define enables the power management code.
-*/
-#ifndef gcdPOWER_MANAGEMENT
-#   define gcdPOWER_MANAGEMENT                  1
-#endif
-
-/*
     gcdPOWER_SUSNPEND_WHEN_IDLE
 
         Set to 1 to make GPU enter gcvPOWER_SUSPEND when idle detected,
@@ -408,10 +419,10 @@
         If the value is 0, no timeout will be checked for.
 */
 #ifndef gcdGPU_TIMEOUT
-#   if gcdFPGA_BUILD
+#if gcdFPGA_BUILD
 #       define gcdGPU_TIMEOUT                   0
 #   else
-#       define gcdGPU_TIMEOUT                   (2000 * 5)
+#       define gcdGPU_TIMEOUT                   20000
 #   endif
 #endif
 
@@ -706,31 +717,13 @@
 
         Support swap with a specific rectangle.
 
-        Set the rectangle with eglSetSwapRectangleANDROID api.
+        Set the rectangle with eglSetSwapRectangleVIV api.
 */
 #ifndef gcdSUPPORT_SWAP_RECTANGLE
 #   define gcdSUPPORT_SWAP_RECTANGLE            0
 #endif
 
 /*
-    gcdDEFER_RESOLVES
-
-        Support deferred resolves for 3D apps.
-*/
-#ifndef gcdDEFER_RESOLVES
-#   define gcdDEFER_RESOLVES                    0
-#endif
-
-/*
-    gcdCOPYBLT_OPTIMIZATION
-
-        Combine dirty areas resulting from Android's copyBlt.
-*/
-#ifndef gcdCOPYBLT_OPTIMIZATION
-#   define gcdCOPYBLT_OPTIMIZATION              0
-#endif
-
-/*
     gcdGPU_LINEAR_BUFFER_ENABLED
 
         Use linear buffer for GPU apps so HWC can do 2D composition.
@@ -768,6 +761,10 @@
 #   define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    0
 #endif
 
+#ifndef gcdENABLE_PE_DITHER_FIX
+#   define gcdENABLE_PE_DITHER_FIX              1
+#endif
+
 #ifndef gcdSHARED_PAGETABLE
 #   define gcdSHARED_PAGETABLE                  1
 #endif
@@ -796,7 +793,22 @@
         limited by gcdCONTIGUOUS_SIZE_LIMIT.
  */
 #ifndef gcdCONTIGUOUS_SIZE_LIMIT
-#   define gcdCONTIGUOUS_SIZE_LIMIT             4096
+#   define gcdCONTIGUOUS_SIZE_LIMIT             0
+#endif
+
+#ifndef gcdDISALBE_EARLY_EARLY_Z
+#   define gcdDISALBE_EARLY_EARLY_Z             1
+#endif
+
+/*
+    gcdLINK_QUEUE_SIZE
+
+        When non-zero, driver maintains a queue to record information of
+        latest lined context buffer and command buffer. Data in this queue
+        is be used to debug.
+*/
+#ifndef gcdLINK_QUEUE_SIZE
+#   define gcdLINK_QUEUE_SIZE                  0
 #endif
 
 /*  gcdALPHA_KILL_IN_SHADER
@@ -821,4 +833,37 @@
 #   define gcdUSE_WCLIP_PATCH                   1
 #endif
 
+#ifndef gcdHZ_L2_DISALBE
+#   define gcdHZ_L2_DISALBE                     1
+#endif
+
+#ifndef gcdBUGFIX15_DISABLE
+#   define gcdBUGFIX15_DISABLE                  1
+#endif
+
+#ifndef gcdDISABLE_HZ_FAST_CLEAR
+#   define gcdDISABLE_HZ_FAST_CLEAR             1
+#endif
+
+#ifndef gcdUSE_NPOT_PATCH
+#define gcdUSE_NPOT_PATCH                       1
+#endif
+
+
+#ifndef gcdSYNC
+#   define gcdSYNC                              1
+#endif
+
+/*
+    gcdDVFS
+
+        When non-zero, software will make use of dynamic voltage and
+        frequency feature.
+ */
+#ifndef gcdDVFS
+#   define gcdDVFS                               0
+#   define gcdDVFS_ANAYLSE_WINDOW                4
+#   define gcdDVFS_POLLING_TIME                  (gcdDVFS_ANAYLSE_WINDOW * 4)
+#endif
+
 #endif /* __gc_hal_options_h_ */
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
index 62ebb0d..3e450ba 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_profiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -578,6 +578,8 @@ extern "C" {
 #define VPG_ES11_TIME   0x170000
 #define VPG_ES20_TIME   0x180000
 #define VPG_FRAME       0x190000
+#define VPG_ES11_DRAW 0x200000
+#define VPG_ES20_DRAW 0x210000
 #define VPG_END         0xff0000
 
 /* Info. */
@@ -1093,6 +1095,12 @@ extern "C" {
 #define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
 #define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
 
+
+#define VPG_ES20_DRAW_NO  (VPG_ES20_DRAW + 1)
+#define VPG_ES11_DRAW_NO  (VPG_ES11_DRAW + 1)
+
+#define VPG_FRAME_USEVBO (VPG_FRAME + 1)
+
 #endif
 
 
@@ -1292,6 +1300,13 @@ gcoPROFILER_EndFrame(
     IN gcoHAL Hal
     );
 
+/* Call to signal end of draw. */
+gceSTATUS
+gcoPROFILER_EndDraw(
+    IN gcoHAL Hal,
+    IN gctBOOL FirstDraw
+    );
+
 /* Increase profile counter Enum by Value. */
 gceSTATUS
 gcoPROFILER_Count(
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
index d9b2993..bc4171e 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_raster.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_raster_h_
 #define __gc_hal_raster_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
index ed6718d..6c10fbf 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_rename.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_rename_h_
 #define __gc_hal_rename_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
index 1e85458..82336e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_statistics.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,7 +19,6 @@
 *****************************************************************************/
 
 
-
 #ifndef __gc_hal_statistics_h_
 #define __gc_hal_statistics_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
index f3d6fad..5c0877d 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_types.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_types_h_
 #define __gc_hal_types_h_
 
@@ -588,13 +586,13 @@ gceSTATUS;
 #if gcmIS_DEBUG(gcdDEBUG_CODE)
 
 #   define gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count) \
-        CommandBuffer->lastLoadStatePtr     = Memory; \
+        CommandBuffer->lastLoadStatePtr     = gcmPTR_TO_UINT64(Memory); \
         CommandBuffer->lastLoadStateAddress = Address; \
         CommandBuffer->lastLoadStateCount   = Count
 
 #   define gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address) \
         gcmASSERT( \
-            (gctUINT) (Memory  - CommandBuffer->lastLoadStatePtr - 1) \
+            (gctUINT) (Memory  - gcmUINT64_TO_TYPE(CommandBuffer->lastLoadStatePtr, gctUINT32_PTR) - 1) \
             == \
             (gctUINT) (Address - CommandBuffer->lastLoadStateAddress) \
             ); \
@@ -623,10 +621,10 @@ gceSTATUS;
 #   define gcmBEGINSECUREUSER() \
         __secure_user_offset__ = reserve->lastOffset; \
         \
-        __secure_user_hintArray__ = reserve->hintArrayTail
+        __secure_user_hintArray__ = gcmUINT64_TO_PTR(reserve->hintArrayTail)
 
 #   define gcmENDSECUREUSER() \
-        reserve->hintArrayTail = __secure_user_hintArray__
+        reserve->hintArrayTail = gcmPTR_TO_UINT64(__secure_user_hintArray__)
 
 #   define gcmSKIPSECUREUSER() \
         __secure_user_offset__ += gcmSIZEOF(gctUINT32)
@@ -682,7 +680,7 @@ gceSTATUS;
         Hardware->buffer, ReserveSize, gcvTRUE, &CommandBuffer \
         )); \
     \
-    Memory = (gctUINT32_PTR) CommandBuffer->lastReserve; \
+    Memory =  gcmUINT64_TO_PTR(CommandBuffer->lastReserve); \
     \
     StateDelta = Hardware->delta; \
     \
@@ -694,7 +692,7 @@ gceSTATUS;
     gcmENDSECUREUSER(); \
     \
     gcmASSERT( \
-        ((gctUINT8_PTR) CommandBuffer->lastReserve) + ReserveSize \
+        gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT8_PTR) + ReserveSize \
         == \
          (gctUINT8_PTR) Memory \
         ); \
@@ -704,7 +702,8 @@ gceSTATUS;
 
 #define gcmBEGINSTATEBATCH(CommandBuffer, Memory, FixedPoint, Address, Count) \
 { \
-    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    gcmASSERT(((Memory - gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT32_PTR)) & 1) == 0); \
+    gcmASSERT((gctUINT32)Count <= 1024); \
     \
     gcmVERIFYLOADSTATEDONE(CommandBuffer); \
     \
@@ -723,7 +722,7 @@ gceSTATUS;
 { \
     gcmVERIFYLOADSTATEDONE(CommandBuffer); \
     \
-    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    gcmASSERT(((Memory - gcmUINT64_TO_TYPE(CommandBuffer->lastReserve, gctUINT32_PTR)) & 1) == 0); \
 }
 
 /*----------------------------------------------------------------------------*/
@@ -902,13 +901,13 @@ gceSTATUS;
 typedef struct _gcsDATABASE_COUNTERS
 {
     /* Number of currently allocated bytes. */
-    gctSIZE_T                   bytes;
+    gctUINT64                   bytes;
 
     /* Maximum number of bytes allocated (memory footprint). */
-    gctSIZE_T                   maxBytes;
+    gctUINT64                   maxBytes;
 
     /* Total number of bytes allocated. */
-    gctSIZE_T                   totalBytes;
+    gctUINT64                   totalBytes;
 }
 gcsDATABASE_COUNTERS;
 
@@ -977,6 +976,25 @@ typedef struct _gcsHAL_FRAME_INFO
 }
 gcsHAL_FRAME_INFO;
 
+#if gcdLINK_QUEUE_SIZE
+typedef struct _gckLINKDATA * gckLINKDATA;
+struct _gckLINKDATA
+{
+    gctUINT32                   start;
+    gctUINT32                   end;
+    gctINT                      pid;
+};
+
+typedef struct _gckLINKQUEUE * gckLINKQUEUE;
+struct _gckLINKQUEUE
+{
+    struct _gckLINKDATA         data[gcdLINK_QUEUE_SIZE];
+    gctUINT32                   rear;
+    gctUINT32                   front;
+    gctUINT32                   count;
+};
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
index f98742e..03cb4d6 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_version.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_version_h_
 #define __gc_hal_version_h_
 
@@ -30,7 +28,7 @@
 
 #define gcvVERSION_PATCH        9
 
-#define gcvVERSION_BUILD        1478
+#define gcvVERSION_BUILD     6622
 
 #define gcvVERSION_DATE      __DATE__
 
diff --git a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
index 8731137..2a910e8 100644
--- a/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
+++ b/drivers/mxc/gpu-viv/hal/kernel/inc/gc_hal_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,9 +19,6 @@
 *****************************************************************************/
 
 
-
-
-
 #ifndef __gc_hal_vg_h_
 #define __gc_hal_vg_h_
 
@@ -555,6 +552,12 @@ gckVGHARDWARE_QueryPowerManagementState(
     );
 
 gceSTATUS
+gckVGHARDWARE_SetPowerManagement(
+    IN gckVGHARDWARE Hardware,
+    IN gctBOOL PowerManagement
+    );
+
+gceSTATUS
 gckVGHARDWARE_SetPowerOffTimeout(
     IN gckVGHARDWARE  Hardware,
     IN gctUINT32    Timeout
@@ -588,7 +591,7 @@ typedef struct _gcsCMDBUFFER
     /* The user sets this to the node of the container buffer whitin which
        this particular command buffer resides. The kernel sets this to the
        node of the internally allocated buffer. */
-    gcuVIDMEM_NODE_PTR          node;
+    gctUINT64                   node;
 
     /* Command buffer hardware address. */
     gctUINT32                   address;
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
index a6754fe..339dff4 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debug.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_debug_h_
 #define __gc_hal_kernel_debug_h_
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
index 99d7d9a..6bdc5a6 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
index e0b6142..78d8199 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include <stdarg.h>
 
 #ifndef __gc_hal_kernel_debugfs_h_
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
index 27c1e6f..4d48bd5 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 #include <linux/pagemap.h>
 #include <linux/seq_file.h>
@@ -28,6 +26,7 @@
 #include <linux/mman.h>
 #include <linux/slab.h>
 #include <mach/hardware.h>
+#include <linux/pm_runtime.h>
 
 #define _GC_OBJ_ZONE    gcvZONE_DEVICE
 
@@ -304,6 +303,8 @@ gckGALDEVICE_Construct(
     IN gctUINT32 PhysSize,
     IN gctINT Signal,
     IN gctUINT LogFileSize,
+    IN struct device *pdev,
+    IN gctINT PowerManagement,
     OUT gckGALDEVICE *Device
     )
 {
@@ -318,6 +319,7 @@ gckGALDEVICE_Construct(
     gctINT32 i;
     gceHARDWARE_TYPE type;
     gckDB sharedDB = gcvNULL;
+    gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("IrqLine=%d RegisterMemBase=0x%08x RegisterMemSize=%u "
                    "IrqLine2D=%d RegisterMemBase2D=0x%08x RegisterMemSize2D=%u "
@@ -331,7 +333,7 @@ gckGALDEVICE_Construct(
                    PhysBaseAddr, PhysSize, Signal);
 
     /* Allocate device structure. */
-    device = kmalloc(sizeof(struct _gckGALDEVICE), GFP_KERNEL | __GFP_NOWARN);
+    device = kmalloc(sizeof(struct _gckGALDEVICE), GFP_KERNEL);
 
     if (!device)
     {
@@ -358,8 +360,15 @@ gckGALDEVICE_Construct(
 	 	gckDebugFileSystemSetCurrentNode(device->dbgnode);
 	}
     }
+#ifdef CONFIG_PM
+    /*Init runtime pm for gpu*/
+    pm_runtime_enable(pdev);
+    device->pmdev = pdev;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     /*get gpu regulator*/
-    device->gpu_regulator = regulator_get(NULL, "cpu_vddgpu");
+    device->gpu_regulator = regulator_get(pdev, "cpu_vddgpu");
     if (IS_ERR(device->gpu_regulator)) {
 	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
 		"%s(%d): Failed to get gpu regulator  %s/%s \n",
@@ -367,13 +376,14 @@ gckGALDEVICE_Construct(
 		PARENT_FILE, DEBUG_FILE);
 	gcmkONERROR(gcvSTATUS_NOT_FOUND);
     }
-
+#endif
     /*Initialize the clock structure*/
     if (IrqLine != -1) {
-        device->clk_3d_core = clk_get(NULL, "gpu3d_clk");
+        device->clk_3d_core = clk_get(pdev, "gpu3d_clk");
         if (!IS_ERR(device->clk_3d_core)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
             if (cpu_is_mx6q()) {
-	            device->clk_3d_shader = clk_get(NULL, "gpu3d_shader_clk");
+	            device->clk_3d_shader = clk_get(pdev, "gpu3d_shader_clk");
 	            if (IS_ERR(device->clk_3d_shader)) {
 	                IrqLine = -1;
 	                clk_put(device->clk_3d_core);
@@ -381,7 +391,18 @@ gckGALDEVICE_Construct(
 	                device->clk_3d_shader = NULL;
 	                gckOS_Print("galcore: clk_get gpu3d_shader_clk failed, disable 3d!\n");
 	            }
-            }
+	          }
+#else
+	            device->clk_3d_axi = clk_get(pdev, "gpu3d_axi_clk");
+	            device->clk_3d_shader = clk_get(pdev, "gpu3d_shader_clk");
+	            if (IS_ERR(device->clk_3d_shader)) {
+	                IrqLine = -1;
+	                clk_put(device->clk_3d_core);
+	                device->clk_3d_core = NULL;
+	                device->clk_3d_shader = NULL;
+	                gckOS_Print("galcore: clk_get gpu3d_shader_clk failed, disable 3d!\n");
+	            }
+#endif
         } else {
             IrqLine = -1;
             device->clk_3d_core = NULL;
@@ -389,7 +410,7 @@ gckGALDEVICE_Construct(
         }
     }
     if ((IrqLine2D != -1) || (IrqLineVG != -1)) {
-        device->clk_2d_core = clk_get(NULL, "gpu2d_clk");
+        device->clk_2d_core = clk_get(pdev, "gpu2d_clk");
         if (IS_ERR(device->clk_2d_core)) {
             IrqLine2D = -1;
             IrqLineVG = -1;
@@ -397,7 +418,7 @@ gckGALDEVICE_Construct(
             gckOS_Print("galcore: clk_get 2d core clock failed, disable 2d/vg!\n");
         } else {
 	    if (IrqLine2D != -1) {
-                device->clk_2d_axi = clk_get(NULL, "gpu2d_axi_clk");
+                device->clk_2d_axi = clk_get(pdev, "gpu2d_axi_clk");
                 if (IS_ERR(device->clk_2d_axi)) {
                     device->clk_2d_axi = NULL;
                     IrqLine2D = -1;
@@ -405,7 +426,7 @@ gckGALDEVICE_Construct(
                 }
             }
             if (IrqLineVG != -1) {
-                device->clk_vg_axi = clk_get(NULL, "openvg_axi_clk");
+                device->clk_vg_axi = clk_get(pdev, "openvg_axi_clk");
                 if (IS_ERR(device->clk_vg_axi)) {
                     IrqLineVG = -1;
 	                device->clk_vg_axi = NULL;
@@ -516,6 +537,9 @@ gckGALDEVICE_Construct(
             device->kernels[gcvCORE_MAJOR]->hardware, FastClear, Compression
             ));
 
+        gcmkONERROR(gckHARDWARE_SetPowerManagement(
+            device->kernels[gcvCORE_MAJOR]->hardware, PowerManagement
+            ));
 
 #if COMMAND_PROCESSOR_VERSION == 1
         /* Start the command queue. */
@@ -571,6 +595,10 @@ gckGALDEVICE_Construct(
             device
             ));
 
+        gcmkONERROR(gckHARDWARE_SetPowerManagement(
+            device->kernels[gcvCORE_2D]->hardware, PowerManagement
+            ));
+
 #if COMMAND_PROCESSOR_VERSION == 1
         /* Start the command queue. */
         gcmkONERROR(gckCOMMAND_Start(device->kernels[gcvCORE_2D]->command));
@@ -602,6 +630,11 @@ gckGALDEVICE_Construct(
             device->coreMapping[gcvHARDWARE_VG] = gcvCORE_VG;
         }
 
+
+        gcmkONERROR(gckVGHARDWARE_SetPowerManagement(
+            device->kernels[gcvCORE_VG]->vg->hardware,
+            PowerManagement
+            ));
 #endif
     }
     else
@@ -669,6 +702,16 @@ gckGALDEVICE_Construct(
     }
 
 
+    /* Grab the first availiable kernel */
+    for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+    {
+        if (device->irqLines[i] != -1)
+        {
+            kernel = device->kernels[i];
+            break;
+        }
+    }
+
     /* Set up the internal memory region. */
     if (device->internalSize > 0)
     {
@@ -695,6 +738,7 @@ gckGALDEVICE_Construct(
             }
 
             device->internalPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) physical;
+            device->internalPhysicalName = gcmPTR_TO_NAME(device->internalPhysical);
             physical += device->internalSize;
         }
     }
@@ -725,6 +769,7 @@ gckGALDEVICE_Construct(
             }
 
             device->externalPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) physical;
+            device->externalPhysicalName = gcmPTR_TO_NAME(device->externalPhysical);
             physical += device->externalSize;
         }
     }
@@ -749,6 +794,7 @@ gckGALDEVICE_Construct(
 
                 if (gcmIS_SUCCESS(status))
                 {
+                    device->contiguousPhysicalName = gcmPTR_TO_NAME(device->contiguousPhysical);
                     status = gckVIDMEM_Construct(
                         device->os,
                         physAddr | device->systemMemoryBaseAddress,
@@ -769,6 +815,7 @@ gckGALDEVICE_Construct(
                         device->contiguousPhysical
                         ));
 
+                    gcmRELEASE_NAME(device->contiguousPhysicalName);
                     device->contiguousBase     = gcvNULL;
                     device->contiguousPhysical = gcvNULL;
                 }
@@ -840,7 +887,8 @@ gckGALDEVICE_Construct(
                 }
 #endif
 
-                device->contiguousPhysical = (gctPHYS_ADDR)(gctUINTPTR_T) ContiguousBase;
+                device->contiguousPhysical = gcvNULL;
+                device->contiguousPhysicalName = 0;
                 device->contiguousSize     = ContiguousSize;
                 device->contiguousMapped   = gcvTRUE;
             }
@@ -885,11 +933,38 @@ gckGALDEVICE_Destroy(
 {
     gctINT i;
     gceSTATUS status = gcvSTATUS_OK;
+    gckKERNEL kernel = gcvNULL;
 
     gcmkHEADER_ARG("Device=0x%x", Device);
 
     if (Device != gcvNULL)
     {
+        /* Grab the first availiable kernel */
+        for (i = 0; i < gcdMAX_GPU_COUNT; i++)
+        {
+            if (Device->irqLines[i] != -1)
+            {
+                kernel = Device->kernels[i];
+                break;
+            }
+        }
+        if (Device->internalPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->internalPhysicalName);
+            Device->internalPhysicalName = 0;
+        }
+        if (Device->externalPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->externalPhysicalName);
+            Device->externalPhysicalName = 0;
+        }
+        if (Device->contiguousPhysicalName != 0)
+        {
+            gcmRELEASE_NAME(Device->contiguousPhysicalName);
+            Device->contiguousPhysicalName = 0;
+        }
+
+
         for (i = 0; i < gcdMAX_GPU_COUNT; i++)
         {
             if (Device->kernels[i] != gcvNULL)
@@ -1000,6 +1075,12 @@ gckGALDEVICE_Destroy(
         }
 
         /*Disable clock*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+        if (Device->clk_3d_axi) {
+           clk_put(Device->clk_3d_axi);
+           Device->clk_3d_axi = NULL;
+        }
+#endif
         if (Device->clk_3d_core) {
            clk_put(Device->clk_3d_core);
            Device->clk_3d_core = NULL;
@@ -1021,7 +1102,17 @@ gckGALDEVICE_Destroy(
            Device->clk_vg_axi = NULL;
         }
 
+#ifdef CONFIG_PM
+        if(Device->pmdev)
+            pm_runtime_disable(Device->pmdev);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        if (Device->gpu_regulator) {
+           regulator_put(Device->gpu_regulator);
+           Device->gpu_regulator = NULL;
+        }
+#endif
 
         /* Destroy the gckOS object. */
         if (Device->os != gcvNULL)
@@ -1550,6 +1641,11 @@ gckGALDEVICE_Start(
     {
         /* Setup the ISR routine. */
         gcmkONERROR(gckGALDEVICE_Setup_ISR_VG(Device));
+
+        /* Switch to SUSPEND power state. */
+        gcmkONERROR(gckVGHARDWARE_SetPowerManagementState(
+            Device->kernels[gcvCORE_VG]->vg->hardware, gcvPOWER_OFF_BROADCAST
+            ));
     }
 
     gcmkFOOTER_NO();
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
index c159898..dde4f03 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_device_h_
 #define __gc_hal_kernel_device_h_
 
@@ -37,15 +35,18 @@ typedef struct _gckGALDEVICE
     /* Attributes. */
     gctSIZE_T           internalSize;
     gctPHYS_ADDR        internalPhysical;
+    gctUINT32           internalPhysicalName;
     gctPOINTER          internalLogical;
     gckVIDMEM           internalVidMem;
     gctSIZE_T           externalSize;
     gctPHYS_ADDR        externalPhysical;
+    gctUINT32           externalPhysicalName;
     gctPOINTER          externalLogical;
     gckVIDMEM           externalVidMem;
     gckVIDMEM           contiguousVidMem;
     gctPOINTER          contiguousBase;
     gctPHYS_ADDR        contiguousPhysical;
+    gctUINT32           contiguousPhysicalName;
     gctSIZE_T           contiguousSize;
     gctBOOL             contiguousMapped;
     gctPOINTER          contiguousMappedUser;
@@ -85,13 +86,17 @@ typedef struct _gckGALDEVICE
     /* Clock management.*/
     struct clk         *clk_3d_core;
     struct clk         *clk_3d_shader;
+    struct clk		   *clk_3d_axi;
     struct clk         *clk_2d_core;
     struct clk         *clk_2d_axi;
     struct clk         *clk_vg_axi;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     /*Power management.*/
     struct regulator      *gpu_regulator;
-
+#endif
+	/*Run time pm*/
+	struct device		*pmdev;
 }
 * gckGALDEVICE;
 
@@ -164,6 +169,8 @@ gceSTATUS gckGALDEVICE_Construct(
     IN gctUINT32 PhysSize,
     IN gctINT Signal,
     IN gctUINT LogFileSize,
+    IN struct device *pdev,
+    IN gctINT PowerManagement,
     OUT gckGALDEVICE *Device
     );
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
index c7928dd..bacd531 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *    Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
 *
 *    This program is free software; you can redistribute it and/or modify
@@ -20,12 +20,9 @@
 *****************************************************************************/
 
 
-
-
 #include <linux/device.h>
 #include <linux/slab.h>
-#include <mach/viv_gpu.h>
-
+#include <linux/notifier.h>
 #include "gc_hal_kernel_linux.h"
 #include "gc_hal_driver.h"
 
@@ -41,12 +38,47 @@
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
 #    include <linux/resmem_account.h>
-#endif
+#    include <linux/kernel.h>
+#    include <linux/mm.h>
+#    include <linux/oom.h>
+#    include <linux/sched.h>
+#    include <linux/notifier.h>
+
+struct task_struct *lowmem_deathpending;
+
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data);
+
+static struct notifier_block task_nb = {
+	.notifier_call	= task_notify_func,
+};
 
+static int
+task_notify_func(struct notifier_block *self, unsigned long val, void *data)
+{
+	struct task_struct *task = data;
+
+	if (task == lowmem_deathpending)
+		lowmem_deathpending = NULL;
+
+	return NOTIFY_OK;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+#include <mach/viv_gpu.h>
+#else
+#include <linux/pm_runtime.h>
+#include <mach/busfreq.h>
+#endif
 /* Zone used for header/footer. */
 #define _GC_OBJ_ZONE    gcvZONE_DRIVER
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+extern int register_thermal_notifier(struct notifier_block *nb);
+extern int unregister_thermal_notifier(struct notifier_block *nb);
+#endif
+
 MODULE_DESCRIPTION("Vivante Graphics Driver");
 MODULE_LICENSE("GPL");
 
@@ -99,6 +131,9 @@ module_param(fastClear, int, 0644);
 static int compression = -1;
 module_param(compression, int, 0644);
 
+static int powerManagement = 1;
+module_param(powerManagement, int, 0644);
+
 static int signal = 48;
 module_param(signal, int, 0644);
 
@@ -114,6 +149,9 @@ module_param(logFileSize,uint, 0644);
 static int showArgs = 0;
 module_param(showArgs, int, 0644);
 
+int gpu3DMinClock = 0;
+module_param(gpu3DMinClock, int, 0644);
+
 #if ENABLE_GPU_CLOCK_BY_DRIVER
     unsigned long coreClock = 156000000;
     module_param(coreClock, ulong, 0644);
@@ -146,6 +184,9 @@ static struct file_operations driver_fops =
     .open       = drv_open,
     .release    = drv_release,
     .unlocked_ioctl = drv_ioctl,
+#ifdef HAVE_COMPAT_IOCTL
+    .compat_ioctl = drv_ioctl,
+#endif
     .mmap       = drv_mmap,
 };
 
@@ -196,7 +237,7 @@ int drv_open(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
-    data = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL | __GFP_NOWARN);
+    data = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL);
 
     if (data == gcvNULL)
     {
@@ -458,7 +499,7 @@ long drv_ioctl(
     }
 
     copyLen = copy_from_user(
-        &iface, drvArgs.InputBuffer, sizeof(gcsHAL_INTERFACE)
+        &iface, gcmUINT64_TO_PTR(drvArgs.InputBuffer), sizeof(gcsHAL_INTERFACE)
         );
 
     if (copyLen != 0)
@@ -536,25 +577,26 @@ long drv_ioctl(
 
     if (gcmIS_SUCCESS(status) && (iface.command == gcvHAL_LOCK_VIDEO_MEMORY))
     {
+        gcuVIDMEM_NODE_PTR node = gcmUINT64_TO_PTR(iface.u.LockVideoMemory.node);
         /* Special case for mapped memory. */
         if ((data->mappedMemory != gcvNULL)
-        &&  (iface.u.LockVideoMemory.node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+        &&  (node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
         )
         {
             /* Compute offset into mapped memory. */
             gctUINT32 offset
-                = (gctUINT8 *) iface.u.LockVideoMemory.memory
+                = (gctUINT8 *) gcmUINT64_TO_PTR(iface.u.LockVideoMemory.memory)
                 - (gctUINT8 *) device->contiguousBase;
 
             /* Compute offset into user-mapped region. */
             iface.u.LockVideoMemory.memory =
-                (gctUINT8 *) data->mappedMemory + offset;
+                gcmPTR_TO_UINT64((gctUINT8 *) data->mappedMemory + offset);
         }
     }
 
     /* Copy data back to the user. */
     copyLen = copy_to_user(
-        drvArgs.OutputBuffer, &iface, sizeof(gcsHAL_INTERFACE)
+        gcmUINT64_TO_PTR(drvArgs.OutputBuffer), &iface, sizeof(gcsHAL_INTERFACE)
         );
 
     if (copyLen != 0)
@@ -582,7 +624,7 @@ static int drv_mmap(
     struct vm_area_struct* vma
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
     gcsHAL_PRIVATE_DATA_PTR data;
     gckGALDEVICE device;
 
@@ -627,7 +669,7 @@ static int drv_mmap(
 
 #if !gcdPAGED_MEMORY_CACHEABLE
     vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-    vma->vm_flags    |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND;
+    vma->vm_flags    |= gcdVM_FLAGS;
 #endif
     vma->vm_pgoff     = 0;
 
@@ -650,7 +692,7 @@ static int drv_mmap(
         ret = io_remap_pfn_range(
             vma,
             vma->vm_start,
-            (gctUINTPTR_T) device->contiguousPhysical >> PAGE_SHIFT,
+            device->requestedContiguousBase >> PAGE_SHIFT,
             size,
             vma->vm_page_prot
             );
@@ -670,11 +712,12 @@ static int drv_mmap(
         }
 
         data->mappedMemory = (gctPOINTER) vma->vm_start;
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return 0;
     }
 
-    /* Success. */
-    gcmkFOOTER_NO();
-    return 0;
 
 OnError:
     gcmkFOOTER();
@@ -685,7 +728,7 @@ OnError:
 #if !USE_PLATFORM_DRIVER
 static int __init drv_init(void)
 #else
-static int drv_init(void)
+static int drv_init(struct device *pdev)
 #endif
 {
     int ret;
@@ -741,6 +784,9 @@ static int drv_init(void)
     }
 #endif
 
+    printk(KERN_INFO "Galcore version %d.%d.%d.%d\n",
+        gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH, gcvVERSION_BUILD);
+
     if (showArgs)
     {
         printk("galcore options:\n");
@@ -770,7 +816,8 @@ static int drv_init(void)
         printk("  signal            = %d\n",      signal);
         printk("  baseAddress       = 0x%08lX\n", baseAddress);
         printk("  physSize          = 0x%08lX\n", physSize);
-	printk(" logFileSize         = %d KB \n",     logFileSize);
+        printk("  logFileSize       = %d KB \n",  logFileSize);
+        printk("  powerManagement   = %d\n",      powerManagement);
 #if ENABLE_GPU_CLOCK_BY_DRIVER
         printk("  coreClock       = %lu\n",     coreClock);
 #endif
@@ -792,6 +839,8 @@ static int drv_init(void)
         contiguousBase, contiguousSize,
         bankSize, fastClear, compression, baseAddress, physSize, signal,
         logFileSize,
+        pdev,
+        powerManagement,
         &device
         ));
 
@@ -819,6 +868,7 @@ static int drv_init(void)
     }
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+    task_free_register(&task_nb);
     viv_gpu_resmem_handler.data = device->kernels[gcvCORE_MAJOR];
     register_reserved_memory_account(&viv_gpu_resmem_handler);
 #endif
@@ -904,6 +954,7 @@ static void drv_exit(void)
     gcmkHEADER();
 
 #ifdef CONFIG_ANDROID_RESERVED_MEMORY_ACCOUNT
+    task_free_unregister(&task_nb);
     unregister_reserved_memory_account(&viv_gpu_resmem_handler);
 #endif
 
@@ -949,12 +1000,44 @@ static void drv_exit(void)
 #   define DEVICE_NAME "galcore"
 #endif
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+static int thermal_hot_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+    static gctUINT orgFscale, minFscale, maxFscale;
+    static gctBOOL bAlreadyTooHot = gcvFALSE;
+    gckHARDWARE hardware = galDevice->kernels[gcvCORE_MAJOR]->hardware;
+
+    if (event && !bAlreadyTooHot) {
+        gckHARDWARE_GetFscaleValue(hardware,&orgFscale,&minFscale, &maxFscale);
+        gckHARDWARE_SetFscaleValue(hardware, minFscale);
+        bAlreadyTooHot = gcvTRUE;
+        gckOS_Print("System is too hot. GPU3D will work at %d/64 clock.\n", minFscale);
+    } else if (!event && bAlreadyTooHot) {
+        gckHARDWARE_SetFscaleValue(hardware, orgFscale);
+        gckOS_Print("Hot alarm is canceled. GPU3D clock will return to %d/64\n", orgFscale);
+        bAlreadyTooHot = gcvFALSE;
+    }
+    return NOTIFY_OK;
+}
+
+static struct notifier_block thermal_hot_pm_notifier = {
+    .notifier_call = thermal_hot_pm_notify,
+    };
+#endif
+
+
+
 static int __devinit gpu_probe(struct platform_device *pdev)
 {
     int ret = -ENODEV;
     struct resource* res;
-    struct viv_gpu_platform_data *pdata;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	struct device_node *dn =pdev->dev.of_node;
+	const u32 *prop;
+#else
+	struct viv_gpu_platform_data *pdata;
+#endif
     gcmkHEADER();
 
     res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phys_baseaddr");
@@ -994,35 +1077,53 @@ static int __devinit gpu_probe(struct platform_device *pdev)
         registerMemSizeVG = res->end - res->start + 1;
     }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	prop = of_get_property(dn, "contiguousbase", NULL);
+	if(prop)
+		contiguousBase = *prop;
+	of_property_read_u32(dn,"contiguoussize", (u32 *)&contiguousSize);
+#else
     pdata = pdev->dev.platform_data;
     if (pdata) {
         contiguousBase = pdata->reserved_mem_base;
         contiguousSize = pdata->reserved_mem_size;
      }
-
-    ret = drv_init();
+#endif
+    if (contiguousSize == 0)
+       gckOS_Print("Warning: No contiguous memory is reserverd for gpu.!\n ");
+    ret = drv_init(&pdev->dev);
 
     if (!ret)
     {
         platform_set_drvdata(pdev, galDevice);
 
+#if gcdENABLE_FSCALE_VAL_ADJUST
+        if(galDevice->kernels[gcvCORE_MAJOR])
+            register_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
         gcmkFOOTER_NO();
         return ret;
     }
-
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    unregister_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
     gcmkFOOTER_ARG(KERN_INFO "Failed to register gpu driver: %d\n", ret);
     return ret;
 }
 
-static int __devinit gpu_remove(struct platform_device *pdev)
+static int __devexit gpu_remove(struct platform_device *pdev)
 {
     gcmkHEADER();
+#if gcdENABLE_FSCALE_VAL_ADJUST
+    if(galDevice->kernels[gcvCORE_MAJOR])
+        unregister_thermal_notifier(&thermal_hot_pm_notifier);
+#endif
     drv_exit();
     gcmkFOOTER_NO();
     return 0;
 }
 
-static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state)
+static int gpu_suspend(struct platform_device *dev, pm_message_t state)
 {
     gceSTATUS status;
     gckGALDEVICE device;
@@ -1072,7 +1173,7 @@ static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state
     return 0;
 }
 
-static int __devinit gpu_resume(struct platform_device *dev)
+static int gpu_resume(struct platform_device *dev)
 {
     gceSTATUS status;
     gckGALDEVICE device;
@@ -1143,15 +1244,59 @@ static int __devinit gpu_resume(struct platform_device *dev)
     return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+static const struct of_device_id mxs_gpu_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-gpu", },
+	{/* sentinel */}
+};
+MODULE_DEVICE_TABLE(of, mxs_gpu_dt_ids);
+
+#ifdef CONFIG_PM
+static int gpu_runtime_suspend(struct device *dev)
+{
+	release_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static int gpu_runtime_resume(struct device *dev)
+{
+	request_bus_freq(BUS_FREQ_HIGH);
+	return 0;
+}
+
+static int gpu_system_suspend(struct device *dev)
+{
+	pm_message_t state={0};
+	return gpu_suspend(to_platform_device(dev), state);
+}
+
+static int gpu_system_resume(struct device *dev)
+{
+	return gpu_resume(to_platform_device(dev));
+}
+
+static const struct dev_pm_ops gpu_pm_ops = {
+	SET_RUNTIME_PM_OPS(gpu_runtime_suspend, gpu_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(gpu_system_suspend, gpu_system_resume)
+};
+#endif
+#endif
+
 static struct platform_driver gpu_driver = {
     .probe      = gpu_probe,
-    .remove     = gpu_remove,
+    .remove     = __devexit_p(gpu_remove),
 
     .suspend    = gpu_suspend,
     .resume     = gpu_resume,
 
     .driver     = {
         .name   = DEVICE_NAME,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+		.of_match_table = mxs_gpu_dt_ids,
+#if CONFIG_PM
+		.pm		= &gpu_pm_ops,
+#endif
+#endif
     }
 };
 
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
index cba2040..22c4071 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
@@ -65,15 +63,15 @@ gckKERNEL_QueryVideoMemory(
 
     /* Get internal memory size and physical address. */
     Interface->u.QueryVideoMemory.internalSize = device->internalSize;
-    Interface->u.QueryVideoMemory.internalPhysical = device->internalPhysical;
+    Interface->u.QueryVideoMemory.internalPhysical = device->internalPhysicalName;
 
     /* Get external memory size and physical address. */
     Interface->u.QueryVideoMemory.externalSize = device->externalSize;
-    Interface->u.QueryVideoMemory.externalPhysical = device->externalPhysical;
+    Interface->u.QueryVideoMemory.externalPhysical = device->externalPhysicalName;
 
     /* Get contiguous memory size and physical address. */
     Interface->u.QueryVideoMemory.contiguousSize = device->contiguousSize;
-    Interface->u.QueryVideoMemory.contiguousPhysical = device->contiguousPhysical;
+    Interface->u.QueryVideoMemory.contiguousPhysical = device->contiguousPhysicalName;
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -181,7 +179,10 @@ gckKERNEL_MapMemory(
     OUT gctPOINTER * Logical
     )
 {
-    return gckOS_MapMemory(Kernel->os, Physical, Bytes, Logical);
+    gckKERNEL kernel = Kernel;
+    gctPHYS_ADDR physical = gcmNAME_TO_PTR(Physical);
+
+    return gckOS_MapMemory(Kernel->os, physical, Bytes, Logical);
 }
 
 /*******************************************************************************
@@ -216,7 +217,10 @@ gckKERNEL_UnmapMemory(
     IN gctPOINTER Logical
     )
 {
-    return gckOS_UnmapMemory(Kernel->os, Physical, Bytes, Logical);
+    gckKERNEL kernel = Kernel;
+    gctPHYS_ADDR physical = gcmNAME_TO_PTR(Physical);
+
+    return gckOS_UnmapMemory(Kernel->os, physical, Bytes, Logical);
 }
 
 /*******************************************************************************
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
index a6ed03f..3c148f6 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_linux_h_
 #define __gc_hal_kernel_linux_h_
 
@@ -75,6 +73,12 @@
 
 #define GetPageCount(size, offset) 	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,7,0)
+#define gcdVM_FLAGS (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP)
+#else
+#define gcdVM_FLAGS (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED)
+#endif
+
 static inline gctINT
 GetOrder(
 	IN gctINT numPages
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
index a4cb717..992aeff 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 gctINT
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
index 7ebaab0..e7edc39 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #include "gc_hal_kernel_linux.h"
 
 #include <linux/pagemap.h>
@@ -38,7 +36,12 @@
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
 #include <linux/math64.h>
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#include <mach/common.h>
+#endif
 #include <linux/delay.h>
+#include <linux/pm_runtime.h>
+
 
 #define _GC_OBJ_ZONE    gcvZONE_OS
 
@@ -52,6 +55,7 @@ const char * _PLATFORM = "\n\0$PLATFORM$Linux$\n";
 #endif
 
 #define USER_SIGNAL_TABLE_LEN_INIT  64
+#define gcdSUPPRESS_OOM_MESSAGE 1
 
 #define MEMORY_LOCK(os) \
     gcmkVERIFY_OK(gckOS_AcquireMutex( \
@@ -82,6 +86,12 @@ const char * _PLATFORM = "\n\0$PLATFORM$Linux$\n";
 #define gcmkNONPAGED_MEMROY_PROT(x) pgprot_noncached(x)
 #endif
 
+#if gcdSUPPRESS_OOM_MESSAGE
+#define gcdNOWARN __GFP_NOWARN
+#else
+#define gcdNOWARN 0
+#endif
+
 #define gcdINFINITE_TIMEOUT     (60 * 1000)
 #define gcdDETECT_TIMEOUT       0
 #define gcdDETECT_DMA_ADDRESS   1
@@ -213,18 +223,6 @@ typedef struct _gcsPageInfo
 }
 gcsPageInfo;
 
-typedef struct _gcsiDEBUG_REGISTERS * gcsiDEBUG_REGISTERS_PTR;
-typedef struct _gcsiDEBUG_REGISTERS
-{
-    gctSTRING       module;
-    gctUINT         index;
-    gctUINT         shift;
-    gctUINT         data;
-    gctUINT         count;
-    gctUINT32       signature;
-}
-gcsiDEBUG_REGISTERS;
-
 typedef struct _gcsOSTIMER * gcsOSTIMER_PTR;
 typedef struct _gcsOSTIMER
 {
@@ -237,318 +235,6 @@ typedef struct _gcsOSTIMER
 ******************************* Private Functions ******************************
 \******************************************************************************/
 
-static gceSTATUS
-_VerifyDMA(
-    IN gckOS Os,
-    IN gceCORE Core,
-    gctUINT32_PTR Address1,
-    gctUINT32_PTR Address2,
-    gctUINT32_PTR State1,
-    gctUINT32_PTR State2
-    )
-{
-    gceSTATUS status;
-    gctUINT32 i;
-
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State1));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address1));
-
-    for (i = 0; i < 500; i += 1)
-    {
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x660, State2));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, Core, 0x664, Address2));
-
-        if (*Address1 != *Address2)
-        {
-            break;
-        }
-
-#if gcdDETECT_DMA_STATE
-        if (*State1 != *State2)
-        {
-            break;
-        }
-#endif
-    }
-
-OnError:
-    return status;
-}
-
-static gceSTATUS
-_DumpDebugRegisters(
-    IN gckOS Os,
-    IN gcsiDEBUG_REGISTERS_PTR Descriptor
-    )
-{
-    gceSTATUS status;
-    gctUINT32 select;
-    gctUINT32 data;
-    gctUINT i;
-
-    gcmkHEADER_ARG("Os=0x%X Descriptor=0x%X", Os, Descriptor);
-
-    gcmkPRINT_N(4, "  %s debug registers:\n", Descriptor->module);
-
-    for (i = 0; i < Descriptor->count; i += 1)
-    {
-        select = i << Descriptor->shift;
-
-        gcmkONERROR(gckOS_WriteRegister(Os, Descriptor->index, select));
-#if !gcdENABLE_RECOVERY
-        gcmkONERROR(gckOS_Delay(Os, 1000));
-#endif
-        gcmkONERROR(gckOS_ReadRegister(Os, Descriptor->data, &data));
-
-        gcmkPRINT_N(12, "    [0x%02X] 0x%08X\n", i, data);
-    }
-
-    select = 0xF << Descriptor->shift;
-
-    for (i = 0; i < 500; i += 1)
-    {
-        gcmkONERROR(gckOS_WriteRegister(Os, Descriptor->index, select));
-#if !gcdENABLE_RECOVERY
-        gcmkONERROR(gckOS_Delay(Os, 1000));
-#endif
-        gcmkONERROR(gckOS_ReadRegister(Os, Descriptor->data, &data));
-
-        if (data == Descriptor->signature)
-        {
-            break;
-        }
-    }
-
-    if (i == 500)
-    {
-        gcmkPRINT_N(4, "    failed to obtain the signature (read 0x%08X).\n", data);
-    }
-    else
-    {
-        gcmkPRINT_N(8, "    signature = 0x%08X (%d read attempt(s))\n", data, i + 1);
-    }
-
-OnError:
-    /* Return the error. */
-    gcmkFOOTER();
-    return status;
-}
-
-static gceSTATUS
-_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
-    )
-{
-    static gctCONST_STRING _cmdState[] =
-    {
-        "PAR_IDLE_ST", "PAR_DEC_ST", "PAR_ADR0_ST", "PAR_LOAD0_ST",
-        "PAR_ADR1_ST", "PAR_LOAD1_ST", "PAR_3DADR_ST", "PAR_3DCMD_ST",
-        "PAR_3DCNTL_ST", "PAR_3DIDXCNTL_ST", "PAR_INITREQDMA_ST",
-        "PAR_DRAWIDX_ST", "PAR_DRAW_ST", "PAR_2DRECT0_ST", "PAR_2DRECT1_ST",
-        "PAR_2DDATA0_ST", "PAR_2DDATA1_ST", "PAR_WAITFIFO_ST", "PAR_WAIT_ST",
-        "PAR_LINK_ST", "PAR_END_ST", "PAR_STALL_ST"
-    };
-
-    static gctCONST_STRING _cmdDmaState[] =
-    {
-        "CMD_IDLE_ST", "CMD_START_ST", "CMD_REQ_ST", "CMD_END_ST"
-    };
-
-    static gctCONST_STRING _cmdFetState[] =
-    {
-        "FET_IDLE_ST", "FET_RAMVALID_ST", "FET_VALID_ST"
-    };
-
-    static gctCONST_STRING _reqDmaState[] =
-    {
-        "REQ_IDLE_ST", "REQ_WAITIDX_ST", "REQ_CAL_ST"
-    };
-
-    static gctCONST_STRING _calState[] =
-    {
-        "CAL_IDLE_ST", "CAL_LDADR_ST", "CAL_IDXCALC_ST"
-    };
-
-    static gctCONST_STRING _veReqState[] =
-    {
-        "VER_IDLE_ST", "VER_CKCACHE_ST", "VER_MISS_ST"
-    };
-
-    static gcsiDEBUG_REGISTERS _dbgRegs[] =
-    {
-        { "RA", 0x474, 16, 0x448, 16, 0x12344321 },
-        { "TX", 0x474, 24, 0x44C, 16, 0x12211221 },
-        { "FE", 0x470,  0, 0x450, 16, 0xBABEF00D },
-        { "PE", 0x470, 16, 0x454, 16, 0xBABEF00D },
-        { "DE", 0x470,  8, 0x458, 16, 0xBABEF00D },
-        { "SH", 0x470, 24, 0x45C, 16, 0xDEADBEEF },
-        { "PA", 0x474,  0, 0x460, 16, 0x0000AAAA },
-        { "SE", 0x474,  8, 0x464, 16, 0x5E5E5E5E },
-        { "MC", 0x478,  0, 0x468, 16, 0x12345678 },
-        { "HI", 0x478,  8, 0x46C, 16, 0xAAAAAAAA }
-    };
-
-    static gctUINT32 _otherRegs[] =
-    {
-        0x040, 0x044, 0x04C, 0x050, 0x054, 0x058, 0x05C, 0x060,
-        0x43c, 0x440, 0x444, 0x414,
-    };
-
-    gceSTATUS status;
-    gctBOOL acquired = gcvFALSE;
-    gckGALDEVICE device;
-    gckKERNEL kernel;
-    gctUINT32 idle, axi;
-    gctUINT32 dmaAddress1, dmaAddress2;
-    gctUINT32 dmaState1, dmaState2;
-    gctUINT32 dmaLow, dmaHigh;
-    gctUINT32 cmdState, cmdDmaState, cmdFetState;
-    gctUINT32 dmaReqState, calState, veReqState;
-    gctUINT i;
-
-    gcmkHEADER_ARG("Os=0x%X, Core=%d", Os, Core);
-
-    gcmkONERROR(gckOS_AcquireMutex(Os, Os->debugLock, gcvINFINITE));
-    acquired = gcvTRUE;
-
-    /* Extract the pointer to the gckGALDEVICE class. */
-    device = (gckGALDEVICE) Os->device;
-
-    /* TODO: Kernel shortcut. */
-    kernel = device->kernels[Core];
-    gcmkPRINT_N(4, "GPU[%d]:\n",Core);
-
-    if (kernel == gcvNULL)
-    {
-        gcmkFOOTER();
-        return gcvSTATUS_OK;
-    }
-
-    /* Reset register values. */
-    idle        = axi         =
-    dmaState1   = dmaState2   =
-    dmaAddress1 = dmaAddress2 =
-    dmaLow      = dmaHigh     = 0;
-
-    /* Verify whether DMA is running. */
-    gcmkONERROR(_VerifyDMA(
-        Os, kernel->core, &dmaAddress1, &dmaAddress2, &dmaState1, &dmaState2
-        ));
-
-    cmdState    =  dmaState2        & 0x1F;
-    cmdDmaState = (dmaState2 >>  8) & 0x03;
-    cmdFetState = (dmaState2 >> 10) & 0x03;
-    dmaReqState = (dmaState2 >> 12) & 0x03;
-    calState    = (dmaState2 >> 14) & 0x03;
-    veReqState  = (dmaState2 >> 16) & 0x03;
-
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x004, &idle));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x00C, &axi));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x668, &dmaLow));
-    gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x66C, &dmaHigh));
-
-    gcmkPRINT_N(0, "**************************\n");
-    gcmkPRINT_N(0, "***   GPU STATE DUMP   ***\n");
-    gcmkPRINT_N(0, "**************************\n");
-
-    gcmkPRINT_N(4, "  axi      = 0x%08X\n", axi);
-
-    gcmkPRINT_N(4, "  idle     = 0x%08X\n", idle);
-    if ((idle & 0x00000001) == 0) gcmkPRINT_N(0, "    FE not idle\n");
-    if ((idle & 0x00000002) == 0) gcmkPRINT_N(0, "    DE not idle\n");
-    if ((idle & 0x00000004) == 0) gcmkPRINT_N(0, "    PE not idle\n");
-    if ((idle & 0x00000008) == 0) gcmkPRINT_N(0, "    SH not idle\n");
-    if ((idle & 0x00000010) == 0) gcmkPRINT_N(0, "    PA not idle\n");
-    if ((idle & 0x00000020) == 0) gcmkPRINT_N(0, "    SE not idle\n");
-    if ((idle & 0x00000040) == 0) gcmkPRINT_N(0, "    RA not idle\n");
-    if ((idle & 0x00000080) == 0) gcmkPRINT_N(0, "    TX not idle\n");
-    if ((idle & 0x00000100) == 0) gcmkPRINT_N(0, "    VG not idle\n");
-    if ((idle & 0x00000200) == 0) gcmkPRINT_N(0, "    IM not idle\n");
-    if ((idle & 0x00000400) == 0) gcmkPRINT_N(0, "    FP not idle\n");
-    if ((idle & 0x00000800) == 0) gcmkPRINT_N(0, "    TS not idle\n");
-    if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
-
-    if (
-        (dmaAddress1 == dmaAddress2)
-
-#if gcdDETECT_DMA_STATE
-     && (dmaState1 == dmaState2)
-#endif
-    )
-    {
-        gcmkPRINT_N(0, "  DMA appears to be stuck at this address:\n");
-        gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
-    }
-    else
-    {
-        if (dmaAddress1 == dmaAddress2)
-        {
-            gcmkPRINT_N(0, "  DMA address is constant, but state is changing:\n");
-            gcmkPRINT_N(4, "    0x%08X\n", dmaState1);
-            gcmkPRINT_N(4, "    0x%08X\n", dmaState2);
-        }
-        else
-        {
-            gcmkPRINT_N(0, "  DMA is running; known addresses are:\n");
-            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress1);
-            gcmkPRINT_N(4, "    0x%08X\n", dmaAddress2);
-        }
-    }
-
-    gcmkPRINT_N(4, "  dmaLow   = 0x%08X\n", dmaLow);
-    gcmkPRINT_N(4, "  dmaHigh  = 0x%08X\n", dmaHigh);
-    gcmkPRINT_N(4, "  dmaState = 0x%08X\n", dmaState2);
-    gcmkPRINT_N(8, "    command state       = %d (%s)\n", cmdState,    _cmdState   [cmdState]);
-    gcmkPRINT_N(8, "    command DMA state   = %d (%s)\n", cmdDmaState, _cmdDmaState[cmdDmaState]);
-    gcmkPRINT_N(8, "    command fetch state = %d (%s)\n", cmdFetState, _cmdFetState[cmdFetState]);
-    gcmkPRINT_N(8, "    DMA request state   = %d (%s)\n", dmaReqState, _reqDmaState[dmaReqState]);
-    gcmkPRINT_N(8, "    cal state           = %d (%s)\n", calState,    _calState   [calState]);
-    gcmkPRINT_N(8, "    VE request state    = %d (%s)\n", veReqState,  _veReqState [veReqState]);
-
-    for (i = 0; i < gcmCOUNTOF(_dbgRegs); i += 1)
-    {
-        gcmkONERROR(_DumpDebugRegisters(Os, &_dbgRegs[i]));
-    }
-
-    if (kernel->hardware->identity.chipFeatures & (1 << 4))
-    {
-        gctUINT32 read0, read1, write;
-
-        read0 = read1 = write = 0;
-
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x43C, &read0));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x440, &read1));
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, 0x444, &write));
-
-        gcmkPRINT_N(4, "  read0    = 0x%08X\n", read0);
-        gcmkPRINT_N(4, "  read1    = 0x%08X\n", read1);
-        gcmkPRINT_N(4, "  write    = 0x%08X\n", write);
-    }
-
-    gcmkPRINT_N(0, "  Other Registers:\n");
-    for (i = 0; i < gcmCOUNTOF(_otherRegs); i += 1)
-    {
-        gctUINT32 read;
-        gcmkONERROR(gckOS_ReadRegisterEx(Os, kernel->core, _otherRegs[i], &read));
-        gcmkPRINT_N(12, "    [0x%04X] 0x%08X\n", _otherRegs[i], read);
-    }
-
-    /* Dump call stack. */
-    dump_stack();
-
-OnError:
-    if (acquired)
-    {
-        /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->debugLock));
-    }
-
-    /* Return the error. */
-    gcmkFOOTER();
-    return status;
-}
-
 static gctINT
 _GetProcessID(
     void
@@ -582,7 +268,7 @@ _CreateMdl(
 
     gcmkHEADER_ARG("ProcessID=%d", ProcessID);
 
-    mdl = (PLINUX_MDL)kzalloc(sizeof(struct _LINUX_MDL), GFP_KERNEL | __GFP_NOWARN);
+    mdl = (PLINUX_MDL)kzalloc(sizeof(struct _LINUX_MDL), GFP_KERNEL | gcdNOWARN);
     if (mdl == gcvNULL)
     {
         gcmkFOOTER_NO();
@@ -643,7 +329,7 @@ _CreateMdlMap(
 
     gcmkHEADER_ARG("Mdl=0x%X ProcessID=%d", Mdl, ProcessID);
 
-    mdlMap = (PLINUX_MDL_MAP)kmalloc(sizeof(struct _LINUX_MDL_MAP), GFP_KERNEL | __GFP_NOWARN);
+    mdlMap = (PLINUX_MDL_MAP)kmalloc(sizeof(struct _LINUX_MDL_MAP), GFP_KERNEL | gcdNOWARN);
     if (mdlMap == gcvNULL)
     {
         gcmkFOOTER_NO();
@@ -802,7 +488,7 @@ _NonContiguousAlloc(
 
     size = NumPages * sizeof(struct page *);
 
-    pages = kmalloc(size, GFP_KERNEL | __GFP_NOWARN);
+    pages = kmalloc(size, GFP_KERNEL | gcdNOWARN);
 
     if (!pages)
     {
@@ -817,7 +503,7 @@ _NonContiguousAlloc(
 
     for (i = 0; i < NumPages; i++)
     {
-        p = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_NOWARN);
+        p = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN);
 
         if (!p)
         {
@@ -1083,7 +769,7 @@ _AllocateIntegerId(
     int result;
 
 again:
-    if (idr_pre_get(&Database->idr, GFP_KERNEL | __GFP_NOWARN) == 0)
+    if (idr_pre_get(&Database->idr, GFP_KERNEL | gcdNOWARN) == 0)
     {
         return gcvSTATUS_OUT_OF_MEMORY;
     }
@@ -1190,6 +876,60 @@ _UnmapUserLogical(
 #endif
 }
 
+gceSTATUS
+_QueryProcessPageTable(
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    )
+{
+    spinlock_t *lock;
+    gctUINTPTR_T logical = (gctUINTPTR_T)Logical;
+    pgd_t *pgd;
+    pud_t *pud;
+    pmd_t *pmd;
+    pte_t *pte;
+
+    if (!current->mm)
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pgd = pgd_offset(current->mm, logical);
+    if (pgd_none(*pgd) || pgd_bad(*pgd))
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pud = pud_offset(pgd, logical);
+    if (pud_none(*pud) || pud_bad(*pud))
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pmd = pmd_offset(pud, logical);
+    if (pmd_none(*pmd) || pmd_bad(*pmd))
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    pte = pte_offset_map_lock(current->mm, pmd, logical, &lock);
+    if (!pte)
+    {
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    if (!pte_present(*pte))
+    {
+        pte_unmap_unlock(pte, lock);
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    *Address = (pte_pfn(*pte) << PAGE_SHIFT) | (logical & ~PAGE_MASK);
+    pte_unmap_unlock(pte, lock);
+
+    return gcvSTATUS_OK;
+}
+
 /*******************************************************************************
 **
 **  gckOS_Construct
@@ -1221,7 +961,7 @@ gckOS_Construct(
     gcmkVERIFY_ARGUMENT(Os != gcvNULL);
 
     /* Allocate the gckOS object. */
-    os = (gckOS) kmalloc(gcmSIZEOF(struct _gckOS), GFP_KERNEL | __GFP_NOWARN);
+    os = (gckOS) kmalloc(gcmSIZEOF(struct _gckOS), GFP_KERNEL | gcdNOWARN);
 
     if (os == gcvNULL)
     {
@@ -1427,6 +1167,9 @@ _CreateKernelVirtualMapping(
                     numPages,
                     0,
                     PAGE_KERNEL);
+
+        /* Trigger a page fault. */
+        memset(addr, 0, numPages * PAGE_SIZE);
     }
 #else
     struct page ** pages;
@@ -1435,7 +1178,7 @@ _CreateKernelVirtualMapping(
 
     if (Mdl->contiguous)
     {
-        pages = kmalloc(sizeof(struct page *) * numPages, GFP_KERNEL | __GFP_NOWARN);
+        pages = kmalloc(sizeof(struct page *) * numPages, GFP_KERNEL | gcdNOWARN);
 
         if (!pages)
         {
@@ -1457,6 +1200,9 @@ _CreateKernelVirtualMapping(
     /* ioremap() can't work on system memory since 2.6.38. */
     addr = vmap(pages, numPages, 0, gcmkNONPAGED_MEMROY_PROT(PAGE_KERNEL));
 
+    /* Trigger a page fault. */
+    memset(addr, 0, numPages * PAGE_SIZE);
+
     if (free)
     {
         kfree(pages);
@@ -1646,7 +1392,7 @@ gckOS_AllocateMemory(
     }
     else
     {
-        memory = (gctPOINTER) kmalloc(Bytes, GFP_KERNEL | __GFP_NOWARN);
+        memory = (gctPOINTER) kmalloc(Bytes, GFP_KERNEL | gcdNOWARN);
     }
 
     if (memory == gcvNULL)
@@ -1770,6 +1516,14 @@ gckOS_MapMemory(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (char *)vm_mmap(gcvNULL,
+                    0L,
+                    mdl->numPages * PAGE_SIZE,
+                    PROT_READ | PROT_WRITE,
+                    MAP_SHARED,
+                    0);
+#else
         down_write(&current->mm->mmap_sem);
 
         mdlMap->vmaAddr = (char *)do_mmap_pgoff(gcvNULL,
@@ -1779,6 +1533,9 @@ gckOS_MapMemory(
                     MAP_SHARED,
                     0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         if (IS_ERR(mdlMap->vmaAddr))
         {
             gcmkTRACE(
@@ -1797,14 +1554,14 @@ gckOS_MapMemory(
 
             mdlMap->vmaAddr = gcvNULL;
 
-            up_write(&current->mm->mmap_sem);
-
             MEMORY_UNLOCK(Os);
 
             gcmkFOOTER_ARG("status=%d", gcvSTATUS_OUT_OF_MEMORY);
             return gcvSTATUS_OUT_OF_MEMORY;
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (!mdlMap->vma)
@@ -1850,7 +1607,7 @@ gckOS_MapMemory(
 #else
 #if !gcdPAGED_MEMORY_CACHEABLE
         mdlMap->vma->vm_page_prot = gcmkPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
-        mdlMap->vma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED;
+        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
 #   endif
         mdlMap->vma->vm_pgoff = 0;
 
@@ -2154,7 +1911,7 @@ gckOS_AllocateNonPagedMemory(
         addr = dma_alloc_coherent(gcvNULL,
                 mdl->numPages * PAGE_SIZE,
                 &mdl->dmaHandle,
-                GFP_KERNEL | __GFP_NOWARN);
+                GFP_KERNEL | gcdNOWARN);
     }
 #else
     size    = mdl->numPages * PAGE_SIZE;
@@ -2165,7 +1922,7 @@ gckOS_AllocateNonPagedMemory(
     if (page == gcvNULL)
 #endif
     {
-        page = alloc_pages(GFP_KERNEL | __GFP_NOWARN, order);
+        page = alloc_pages(GFP_KERNEL | gcdNOWARN, order);
     }
 
     if (page == gcvNULL)
@@ -2181,12 +1938,14 @@ gckOS_AllocateNonPagedMemory(
     mdl->kaddr      = vaddr;
     mdl->u.contiguousPages = page;
 
+#if !defined(CONFIG_PPC)
     /* Cache invalidate. */
     dma_sync_single_for_device(
                 gcvNULL,
                 page_to_phys(page),
                 bytes,
                 DMA_FROM_DEVICE);
+#endif
 
     while (size > 0)
     {
@@ -2226,6 +1985,14 @@ gckOS_AllocateNonPagedMemory(
         /* Only after mmap this will be valid. */
 
         /* We need to map this to user space. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (gctSTRING) vm_mmap(gcvNULL,
+                0L,
+                mdl->numPages * PAGE_SIZE,
+                PROT_READ | PROT_WRITE,
+                MAP_SHARED,
+                0);
+#else
         down_write(&current->mm->mmap_sem);
 
         mdlMap->vmaAddr = (gctSTRING) do_mmap_pgoff(gcvNULL,
@@ -2235,6 +2002,9 @@ gckOS_AllocateNonPagedMemory(
                 MAP_SHARED,
                 0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         if (IS_ERR(mdlMap->vmaAddr))
         {
             gcmkTRACE_ZONE(
@@ -2245,11 +2015,11 @@ gckOS_AllocateNonPagedMemory(
 
             mdlMap->vmaAddr = gcvNULL;
 
-            up_write(&current->mm->mmap_sem);
-
             gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (mdlMap->vma == gcvNULL)
@@ -2284,7 +2054,7 @@ gckOS_AllocateNonPagedMemory(
         }
 #else
         mdlMap->vma->vm_page_prot = gcmkNONPAGED_MEMROY_PROT(mdlMap->vma->vm_page_prot);
-        mdlMap->vma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED;
+        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
         mdlMap->vma->vm_pgoff = 0;
 
         if (remap_pfn_range(mdlMap->vma,
@@ -2664,12 +2434,18 @@ gckOS_GetPhysicalAddress(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
-    /* Get current process ID. */
-    processID = _GetProcessID();
+    /* Query page table of current process first. */
+    status = _QueryProcessPageTable(Logical, Address);
+
+    if (gcmIS_ERROR(status))
+    {
+        /* Get current process ID. */
+        processID = _GetProcessID();
 
-    /* Route through other function. */
-    gcmkONERROR(
-        gckOS_GetPhysicalAddressProcess(Os, Logical, processID, Address));
+        /* Route through other function. */
+        gcmkONERROR(
+            gckOS_GetPhysicalAddressProcess(Os, Logical, processID, Address));
+    }
 
     /* Success. */
     gcmkFOOTER_ARG("*Address=0x%08x", *Address);
@@ -4079,6 +3855,9 @@ gckOS_AllocatePagedMemoryEx(
     gctSIZE_T bytes;
     gctBOOL locked = gcvFALSE;
     gceSTATUS status;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+    gctPOINTER addr = gcvNULL;
+#endif
 
     gcmkHEADER_ARG("Os=0x%X Contiguous=%d Bytes=%lu", Os, Contiguous, Bytes);
 
@@ -4104,13 +3883,27 @@ gckOS_AllocatePagedMemoryEx(
     {
         /* Get contiguous pages, and suppress warning (stack dump) from kernel when
            we run out of memory. */
-        mdl->u.contiguousPages =
-            alloc_pages(GFP_KERNEL | __GFP_NOWARN, GetOrder(numPages));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        addr =
+            alloc_pages_exact(numPages * PAGE_SIZE, GFP_KERNEL | gcdNOWARN | __GFP_NORETRY);
+
+        mdl->u.contiguousPages = addr
+                               ? virt_to_page(addr)
+                               : gcvNULL;
 
+        mdl->exact = gcvTRUE;
+#else
+        mdl->u.contiguousPages =
+            alloc_pages(GFP_KERNEL | gcdNOWARN | __GFP_NORETRY, GetOrder(numPages));
+#endif
         if (mdl->u.contiguousPages == gcvNULL)
         {
             mdl->u.contiguousPages =
-                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | __GFP_NOWARN, GetOrder(numPages));
+                alloc_pages(GFP_KERNEL | __GFP_HIGHMEM | gcdNOWARN, GetOrder(numPages));
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+            mdl->exact = gcvFALSE;
+#endif
         }
     }
     else
@@ -4148,7 +3941,7 @@ gckOS_AllocatePagedMemoryEx(
         {
             gcmkVERIFY_OK(
                 gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)page_to_phys(page),
+                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(page),
                                  page_address(page),
                                  PAGE_SIZE));
         }
@@ -4255,7 +4048,16 @@ gckOS_FreePagedMemory(
 
     if (mdl->contiguous)
     {
-        __free_pages(mdl->u.contiguousPages, GetOrder(mdl->numPages));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        if (mdl->exact == gcvTRUE)
+        {
+            free_pages_exact(page_address(mdl->u.contiguousPages), mdl->numPages * PAGE_SIZE);
+        }
+        else
+#endif
+        {
+            __free_pages(mdl->u.contiguousPages, GetOrder(mdl->numPages));
+        }
     }
     else
     {
@@ -4370,6 +4172,14 @@ gckOS_LockPages(
 
     if (mdlMap->vmaAddr == gcvNULL)
     {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+        mdlMap->vmaAddr = (gctSTRING)vm_mmap(gcvNULL,
+                        0L,
+                        mdl->numPages * PAGE_SIZE,
+                        PROT_READ | PROT_WRITE,
+                        MAP_SHARED,
+                        0);
+#else
         down_write(&current->mm->mmap_sem);
 
         mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
@@ -4379,6 +4189,9 @@ gckOS_LockPages(
                         MAP_SHARED,
                         0);
 
+        up_write(&current->mm->mmap_sem);
+#endif
+
         gcmkTRACE_ZONE(
             gcvLEVEL_INFO, gcvZONE_OS,
             "%s(%d): vmaAddr->0x%X for phys_addr->0x%X",
@@ -4389,8 +4202,6 @@ gckOS_LockPages(
 
         if (IS_ERR(mdlMap->vmaAddr))
         {
-            up_write(&current->mm->mmap_sem);
-
             gcmkTRACE_ZONE(
                 gcvLEVEL_INFO, gcvZONE_OS,
                 "%s(%d): do_mmap_pgoff error",
@@ -4405,6 +4216,8 @@ gckOS_LockPages(
             return gcvSTATUS_OUT_OF_MEMORY;
         }
 
+        down_write(&current->mm->mmap_sem);
+
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
         if (mdlMap->vma == gcvNULL)
@@ -4425,7 +4238,7 @@ gckOS_LockPages(
             return gcvSTATUS_OUT_OF_RESOURCES;
         }
 
-        mdlMap->vma->vm_flags |= VM_RESERVED;
+        mdlMap->vma->vm_flags |= gcdVM_FLAGS;
 #if !gcdPAGED_MEMORY_CACHEABLE
         if (Cacheable == gcvFALSE)
         {
@@ -5068,20 +4881,18 @@ gckOS_MapUserPointer(
     OUT gctPOINTER * KernelPointer
     )
 {
-    gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu", Os, Pointer, Size);
-
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
-{
     gctPOINTER buf = gcvNULL;
     gctUINT32 len;
 
+    gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu", Os, Pointer, Size);
+
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
     gcmkVERIFY_ARGUMENT(Size > 0);
     gcmkVERIFY_ARGUMENT(KernelPointer != gcvNULL);
 
-    buf = kmalloc(Size, GFP_KERNEL | __GFP_NOWARN);
+    buf = kmalloc(Size, GFP_KERNEL | gcdNOWARN);
     if (buf == gcvNULL)
     {
         gcmkTRACE(
@@ -5113,10 +4924,6 @@ gckOS_MapUserPointer(
     }
 
     *KernelPointer = buf;
-}
-#else
-    *KernelPointer = Pointer;
-#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
     gcmkFOOTER_ARG("*KernelPointer=0x%X", *KernelPointer);
     return gcvSTATUS_OK;
@@ -5154,12 +4961,11 @@ gckOS_UnmapUserPointer(
     IN gctPOINTER KernelPointer
     )
 {
+    gctUINT32 len;
+
     gcmkHEADER_ARG("Os=0x%X Pointer=0x%X Size=%lu KernelPointer=0x%X",
                    Os, Pointer, Size, KernelPointer);
 
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
-{
-    gctUINT32 len;
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
@@ -5182,8 +4988,6 @@ gckOS_UnmapUserPointer(
         gcmkFOOTER_ARG("status=%d", gcvSTATUS_GENERIC_IO);
         return gcvSTATUS_GENERIC_IO;
     }
-}
-#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -5223,13 +5027,8 @@ gckOS_QueryNeedCopy(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(NeedCopy != gcvNULL);
 
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
     /* We need to copy data. */
     *NeedCopy = gcvTRUE;
-#else
-    /* No need to copy data. */
-    *NeedCopy = gcvFALSE;
-#endif
 
     /* Success. */
     gcmkFOOTER_ARG("*NeedCopy=%d", *NeedCopy);
@@ -5391,7 +5190,6 @@ gckOS_WriteMemory(
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
     /* Write memory. */
-#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
     if (access_ok(VERIFY_WRITE, Address, 4))
     {
         /* User address. */
@@ -5401,7 +5199,6 @@ gckOS_WriteMemory(
         }
     }
     else
-#endif
     {
         /* Kernel address. */
         *(gctUINT32 *)Address = Data;
@@ -5510,7 +5307,7 @@ OnError:
         MEMORY_MAP_LOCK(Os);
 
         /* Allocate the Info struct. */
-        info = (gcsPageInfo_PTR)kmalloc(sizeof(gcsPageInfo), GFP_KERNEL | __GFP_NOWARN);
+        info = (gcsPageInfo_PTR)kmalloc(sizeof(gcsPageInfo), GFP_KERNEL | gcdNOWARN);
 
         if (info == gcvNULL)
         {
@@ -5519,7 +5316,7 @@ OnError:
         }
 
         /* Allocate the array of page addresses. */
-        pages = (struct page **)kmalloc(pageCount * sizeof(struct page *), GFP_KERNEL | __GFP_NOWARN);
+        pages = (struct page **)kmalloc(pageCount * sizeof(struct page *), GFP_KERNEL | gcdNOWARN);
 
         if (pages == gcvNULL)
         {
@@ -5635,7 +5432,7 @@ OnError:
             {
                 /* Flush(clean) the data cache. */
                 gcmkONERROR(gckOS_CacheFlush(Os, _GetProcessID(), gcvNULL,
-                                 (gctPOINTER)page_to_phys(pages[i]),
+                                 (gctPOINTER)(gctUINTPTR_T)page_to_phys(pages[i]),
                                  (gctPOINTER)(memory & PAGE_MASK) + i*PAGE_SIZE,
                                  PAGE_SIZE));
             }
@@ -6322,6 +6119,10 @@ gckOS_CacheClean(
 
     dma_cache_wback((unsigned long) Logical, Bytes);
 
+#elif defined(CONFIG_PPC)
+
+    /* TODO */
+
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6399,6 +6200,8 @@ gckOS_CacheInvalidate(
 
 #elif defined(CONFIG_MIPS)
     dma_cache_inv((unsigned long) Logical, Bytes);
+#elif defined(CONFIG_PPC)
+    /* TODO */
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6471,6 +6274,8 @@ gckOS_CacheFlush(
 
 #elif defined(CONFIG_MIPS)
     dma_cache_wback_inv((unsigned long) Logical, Bytes);
+#elif defined(CONFIG_PPC)
+    /* TODO */
 #else
     dma_sync_single_for_device(
               gcvNULL,
@@ -6594,14 +6399,14 @@ gckOS_Broadcast(
     case gcvBROADCAST_GPU_STUCK:
         gcmkTRACE_N(gcvLEVEL_ERROR, 0, "gcvBROADCAST_GPU_STUCK\n");
 #if !gcdENABLE_RECOVERY
-        gcmkONERROR(_DumpGPUState(Os, Hardware->core));
+        gcmkONERROR(gckHARDWARE_DumpGPUState(Hardware));
 #endif
         gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
         break;
 
     case gcvBROADCAST_AXI_BUS_ERROR:
         gcmkTRACE_N(gcvLEVEL_ERROR, 0, "gcvBROADCAST_AXI_BUS_ERROR\n");
-        gcmkONERROR(_DumpGPUState(Os, Hardware->core));
+        gcmkONERROR(gckHARDWARE_DumpGPUState(Hardware));
         gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
         break;
     }
@@ -6730,7 +6535,7 @@ gckOS_CreateSemaphore(
     gcmkVERIFY_ARGUMENT(Semaphore != gcvNULL);
 
     /* Allocate the semaphore structure. */
-    sem = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | __GFP_NOWARN);
+    sem = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | gcdNOWARN);
     if (sem == gcvNULL)
     {
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
@@ -7016,6 +6821,9 @@ gckOS_SetGPUPower(
 {
     struct clk *clk_3dcore = Os->device->clk_3d_core;
     struct clk *clk_3dshader = Os->device->clk_3d_shader;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+    struct clk *clk_3d_axi = Os->device->clk_3d_axi;
+#endif
     struct clk *clk_2dcore = Os->device->clk_2d_core;
     struct clk *clk_2d_axi = Os->device->clk_2d_axi;
     struct clk *clk_vg_axi = Os->device->clk_vg_axi;
@@ -7042,10 +6850,21 @@ gckOS_SetGPUPower(
         }
 #endif
     }
-	if((Power == gcvTRUE) && (oldPowerState == gcvFALSE) &&
-		!IS_ERR(Os->device->gpu_regulator))
+	if((Power == gcvTRUE) && (oldPowerState == gcvFALSE))
+	{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        if(!IS_ERR(Os->device->gpu_regulator))
             regulator_enable(Os->device->gpu_regulator);
+#else
+        imx_gpc_power_up_pu(true);
+#endif
+
+#ifdef CONFIG_PM
+		pm_runtime_get_sync(Os->device->pmdev);
+#endif
+	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
     if (Clock == gcvTRUE) {
         if (oldClockState == gcvFALSE) {
             switch (Core) {
@@ -7087,9 +6906,77 @@ gckOS_SetGPUPower(
             }
         }
     }
-	if((Power == gcvFALSE) && (oldPowerState == gcvTRUE) &&
-		!IS_ERR(Os->device->gpu_regulator))
+#else
+    if (Clock == gcvTRUE) {
+        if (oldClockState == gcvFALSE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_prepare(clk_3dcore);
+                clk_enable(clk_3dcore);
+                clk_prepare(clk_3dshader);
+                clk_enable(clk_3dshader);
+                clk_prepare(clk_3d_axi);
+                clk_enable(clk_3d_axi);
+                break;
+            case gcvCORE_2D:
+                clk_prepare(clk_2dcore);
+                clk_enable(clk_2dcore);
+                clk_prepare(clk_2d_axi);
+                clk_enable(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_prepare(clk_2dcore);
+                clk_enable(clk_2dcore);
+                clk_prepare(clk_vg_axi);
+                clk_enable(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    } else {
+        if (oldClockState == gcvTRUE) {
+            switch (Core) {
+            case gcvCORE_MAJOR:
+                clk_disable(clk_3dshader);
+                clk_unprepare(clk_3dshader);
+                clk_disable(clk_3dcore);
+                clk_unprepare(clk_3dcore);
+                clk_disable(clk_3d_axi);
+                clk_unprepare(clk_3d_axi);
+                break;
+           case gcvCORE_2D:
+                clk_disable(clk_2dcore);
+                clk_unprepare(clk_2dcore);
+                clk_disable(clk_2d_axi);
+                clk_unprepare(clk_2d_axi);
+                break;
+            case gcvCORE_VG:
+                clk_disable(clk_2dcore);
+                clk_unprepare(clk_2dcore);
+                clk_disable(clk_vg_axi);
+                clk_unprepare(clk_vg_axi);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+#endif
+	if((Power == gcvFALSE) && (oldPowerState == gcvTRUE))
+	{
+#ifdef CONFIG_PM
+		pm_runtime_put_sync(Os->device->pmdev);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        if(!IS_ERR(Os->device->gpu_regulator))
             regulator_disable(Os->device->gpu_regulator);
+#else
+        imx_gpc_power_up_pu(false);
+#endif
+
+	}
     /* TODO: Put your code here. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
@@ -7119,10 +7006,10 @@ gckOS_ResetGPU(
     IN gceCORE Core
     )
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
 #define SRC_SCR_OFFSET 0
 #define BP_SRC_SCR_GPU3D_RST 1
 #define BP_SRC_SCR_GPU2D_RST 4
-
     void __iomem *src_base = IO_ADDRESS(SRC_BASE_ADDR);
     gctUINT32 bit_offset,val;
 
@@ -7146,6 +7033,137 @@ gckOS_ResetGPU(
     }
 
     gcmkFOOTER_NO();
+#else
+    imx_src_reset_gpu((int)Core);
+#endif
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_PrepareGPUFrequency
+**
+**  Prepare to set GPU frequency and voltage.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose frequency and voltage will be set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_PrepareGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_FinishGPUFrequency
+**
+**  Finish GPU frequency setting.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose frequency and voltage is set.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_FinishGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_QueryGPUFrequency
+**
+**  Query the current frequency of the GPU.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**      gctUINT32 * Frequency
+**          Pointer to a gctUINT32 to obtain current frequency, in MHz.
+**
+**      gctUINT8 * Scale
+**          Pointer to a gctUINT8 to obtain current scale(1 - 64).
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_QueryGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gctUINT32 * Frequency,
+    OUT gctUINT8 * Scale
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**  gckOS_SetGPUFrequency
+**
+**  Set frequency and voltage of the GPU.
+**
+**      1. DVFS manager gives the target scale of full frequency, BSP must find
+**         a real frequency according to this scale and board's configure.
+**
+**      2. BSP should find a suitable voltage for this frequency.
+**
+**      3. BSP must make sure setting take effect before this function returns.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gckCORE Core
+**          GPU whose power is set.
+**
+**      gctUINT8 Scale
+**          Target scale of full frequency, range is [1, 64]. 1 means 1/64 of
+**          full frequency and 64 means 64/64 of full frequency.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_SetGPUFrequency(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT8 Scale
+    )
+{
     return gcvSTATUS_OK;
 }
 
@@ -7271,7 +7289,7 @@ gckOS_CreateSignal(
     gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
     /* Create an event structure. */
-    signal = (gcsSIGNAL_PTR) kmalloc(sizeof(gcsSIGNAL), GFP_KERNEL | __GFP_NOWARN);
+    signal = (gcsSIGNAL_PTR) kmalloc(sizeof(gcsSIGNAL), GFP_KERNEL | gcdNOWARN);
 
     if (signal == gcvNULL)
     {
@@ -7897,8 +7915,14 @@ gckOS_CreateUserSignal(
     OUT gctINT * SignalID
     )
 {
+    gceSTATUS status;
+    gctSIZE_T signal;
+
     /* Create a new signal. */
-    return gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) SignalID);
+    status = gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) &signal);
+    *SignalID = (gctINT) signal;
+
+    return status;
 }
 
 /*******************************************************************************
@@ -8010,7 +8034,7 @@ gckOS_CreateSemaphoreVG(
     do
     {
         /* Allocate the semaphore structure. */
-    	newSemaphore = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | __GFP_NOWARN);
+    	newSemaphore = (struct semaphore *)kmalloc(gcmSIZEOF(struct semaphore), GFP_KERNEL | gcdNOWARN);
     	if (newSemaphore == gcvNULL)
     	{
         	gcmkERR_BREAK(gcvSTATUS_OUT_OF_MEMORY);
@@ -8256,41 +8280,6 @@ gckOS_VerifyThread(
 }
 #endif
 
-/*******************************************************************************
-**
-**  gckOS_DumpGPUState
-**
-**  Dump GPU state.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to the gckOS object.
-**
-**      gceCORE Core
-**          The core type of kernel.
-**
-**  OUTPUT:
-**
-**      Nothing.
-*/
-gceSTATUS
-gckOS_DumpGPUState(
-    IN gckOS Os,
-    IN gceCORE Core
-    )
-{
-    gcmkHEADER_ARG("Os=0x%X Core=%d", Os, Core);
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-
-    _DumpGPUState(Os, Core);
-
-    gcmkFOOTER_NO();
-    /* Success. */
-    return gcvSTATUS_OK;
-}
-
 /******************************************************************************\
 ******************************** Software Timer ********************************
 \******************************************************************************/
@@ -8365,7 +8354,7 @@ OnError:
 
 /*******************************************************************************
 **
-**  gckOS_DestoryTimer
+**  gckOS_DestroyTimer
 **
 **  Destory a software timer.
 **
@@ -8382,7 +8371,7 @@ OnError:
 **      Nothing.
 */
 gceSTATUS
-gckOS_DestoryTimer(
+gckOS_DestroyTimer(
     IN gckOS Os,
     IN gctPOINTER Timer
     )
@@ -8494,3 +8483,49 @@ gckOS_StopTimer(
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
+
+
+gceSTATUS
+gckOS_DumpCallStack(
+    IN gckOS Os
+    )
+{
+    gcmkHEADER_ARG("Os=0x%X", Os);
+
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    dump_stack();
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
+
+
+gceSTATUS
+gckOS_GetProcessNameByPid(
+    IN gctINT Pid,
+    IN gctSIZE_T Length,
+    OUT gctUINT8_PTR String
+    )
+{
+    struct task_struct *task;
+
+    /* Get the task_struct of the task with pid. */
+    rcu_read_lock();
+
+    task = FIND_TASK_BY_PID(Pid);
+
+    if (task == gcvNULL)
+    {
+        rcu_read_unlock();
+        return gcvSTATUS_NOT_FOUND;
+    }
+
+    /* Get name of process. */
+    strncpy(String, task->comm, Length);
+
+    rcu_read_unlock();
+
+    return gcvSTATUS_OK;
+}
+
diff --git a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
index 577fb38..006632c 100644
--- a/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*    Copyright (C) 2005 - 2013 by Vivante Corp.
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
@@ -19,8 +19,6 @@
 *****************************************************************************/
 
 
-
-
 #ifndef __gc_hal_kernel_os_h_
 #define __gc_hal_kernel_os_h_
 
@@ -56,6 +54,9 @@ typedef struct _LINUX_MDL
     gctINT                  numPages;
     gctINT                  pagedMem;
     gctBOOL                 contiguous;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+    gctBOOL                 exact;
+#endif
     dma_addr_t              dmaHandle;
     PLINUX_MDL_MAP          maps;
     struct _LINUX_MDL *     prev;
@@ -71,10 +72,10 @@ FindMdlMap(
 
 typedef struct _DRIVER_ARGS
 {
-    gctPOINTER              InputBuffer;
-    gctUINT32               InputBufferSize;
-    gctPOINTER              OutputBuffer;
-    gctUINT32               OutputBufferSize;
+    gctUINT64               InputBuffer;
+    gctUINT64               InputBufferSize;
+    gctUINT64               OutputBuffer;
+    gctUINT64               OutputBufferSize;
 }
 DRIVER_ARGS;
 
diff --git a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
index 011fc33..1764623 100644
--- a/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -381,11 +381,11 @@ static long hdmi_cec_ioctl(struct file *filp, u_int cmd,
 		val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
 		hdmi_writeb(val, HDMI_MC_CLKDIS);
 		hdmi_writeb(0x02, HDMI_CEC_CTRL);
+		val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
+		hdmi_writeb(val, HDMI_CEC_POLARITY);
 		val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ARB_LOST;
 		hdmi_writeb(val, HDMI_CEC_MASK);
 		hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
-		val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
-		hdmi_writeb(val, HDMI_CEC_POLARITY);
 		mutex_lock(&hdmi_cec_data.lock);
 		hdmi_cec_data.cec_state = true;
 		mutex_unlock(&hdmi_cec_data.lock);
diff --git a/drivers/mxc/ipu/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu/ipu_calc_stripes_sizes.c
index b6230e81..0700b94 100644
--- a/drivers/mxc/ipu/ipu_calc_stripes_sizes.c
+++ b/drivers/mxc/ipu/ipu_calc_stripes_sizes.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,7 +21,7 @@
 
 #include <linux/module.h>
 #include <linux/ipu.h>
-#include <asm/div64.h>
+#include <linux/math64.h>
 
 #define BPP_32 0
 #define BPP_16 3
@@ -30,21 +30,13 @@
 #define BPP_12 4
 #define BPP_18 2
 
-static u64 _do_div(u64 a, u32 b)
-{
-	u64 div;
-	div = a;
-	do_div(div, b);
-	return div;
-}
-
 static u32 truncate(u32 up, /* 0: down; else: up */
 					u64 a, /* must be non-negative */
 					u32 b)
 {
 	u32 d;
 	u64 div;
-	div = _do_div(a, b);
+	div = div_u64(a, b);
 	d = b * (div >> 32);
 	if (up && (a > (((u64)d) << 32)))
 		return d+b;
@@ -227,9 +219,9 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 	    || (output_frame_width < 4))
 		return 1;
 
-	irr_opt = _do_div((((u64)(input_frame_width - 1)) << 32),
+	irr_opt = div_u64((((u64)(input_frame_width - 1)) << 32),
 			  (output_frame_width - 1));
-	rr_opt = _do_div((((u64)(output_frame_width - 1)) << 32),
+	rr_opt = div_u64((((u64)(output_frame_width - 1)) << 32),
 			 (input_frame_width - 1));
 
 	if ((input_m == 0) || (output_m == 0) || (input_f == 0) || (output_f == 0)
@@ -262,7 +254,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			left->output_width = right->output_width = right->output_column =
 				output_frame_width >> 1;
 			left->input_column = right->input_column = 0;
-			div = _do_div(((((u64)irr_steps) << 32) *
+			div = div_u64(((((u64)irr_steps) << 32) *
 				       (right->input_width - 1)), (right->output_width - 1));
 			left->irr = right->irr = truncate(0, div, 1);
 		} else { /* with overlap */
@@ -272,7 +264,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* this is the maximal inw which allows the same resizing ratio */
 			/* in both stripes */
 			onw = truncate(1, (inw * rr_opt), output_f);
-			div = _do_div((((u64)(irr_steps * inw)) <<
+			div = div_u64((((u64)(irr_steps * inw)) <<
 				       32), onw);
 			left->irr = right->irr = truncate(0, div, 1);
 			left->output_width = right->output_width =
@@ -280,14 +272,14 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* These are valid assignments for output_width, */
 			/* assuming output_f is a multiple of output_m */
 			div = (((u64)(left->output_width-1) * (left->irr)) << 32);
-			div = (((u64)1) << 32) + _do_div(div, irr_steps);
+			div = (((u64)1) << 32) + div_u64(div, irr_steps);
 
 			left->input_width = right->input_width = truncate(1, div, input_m);
 
-			div = _do_div((((u64)((right->output_width - 1) * right->irr)) <<
+			div = div_u64((((u64)((right->output_width - 1) * right->irr)) <<
 				       32), irr_steps);
 			difwr = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
-			div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+			div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 			left->input_column = truncate(0, div, input_f);
 
 
@@ -312,13 +304,13 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		/* in both stripes */
 		onw = truncate(1, inw * rr_opt, output_f);
 		do {
-			div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+			div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 			left->irr = truncate(0, div, 1);
-			div = _do_div((((u64)(onw * left->irr)) << 32),
+			div = div_u64((((u64)(onw * left->irr)) << 32),
 				      irr_steps);
 			dinw = (((u64)inw) << 32) - div;
 
-			div = _do_div((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
+			div = div_u64((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
 				       32), irr_steps);
 
 			difwl = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
@@ -338,7 +330,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 
 		inw = inw_best;
 		onw = truncate(1, inw * rr_opt, output_f);
-		div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+		div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 		left->irr = truncate(0, div, 1);
 
 		left->output_width = onw;
@@ -349,18 +341,18 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		right->input_width = truncate(1, ((u64)(input_frame_width - inw)) <<
 					      32, input_m);
 
-		div = _do_div((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
+		div = div_u64((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
 			       32), (right->output_width - 1));
 		right->irr = truncate(0, div, 1);
 		temp = truncate(0, ((u64)left->irr) * ((((u64)1) << 32) + dirr), 1);
 		if (temp < right->irr)
 			right->irr = temp;
-		div = _do_div(((u64)((right->output_width - 1) * right->irr) <<
+		div = div_u64(((u64)((right->output_width - 1) * right->irr) <<
 			       32), irr_steps);
 		difwr = (u64)(input_frame_width - 1 - inw) - div;
 
 
-		div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+		div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 		left->input_column = truncate(0, div, input_f);
 
 		/* This splits the truncated input columns evenly */
diff --git a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
index 4cee1df..3a27195 100644
--- a/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
+++ b/drivers/mxc/ipu3/ipu_calc_stripes_sizes.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,7 +21,7 @@
 
 #include <linux/module.h>
 #include <mach/ipu-v3.h>
-#include <asm/div64.h>
+#include <linux/math64.h>
 
 #define BPP_32 0
 #define BPP_16 3
@@ -30,21 +30,13 @@
 #define BPP_12 4
 #define BPP_18 2
 
-static u64 _do_div(u64 a, u32 b)
-{
-	u64 div;
-	div = a;
-	do_div(div, b);
-	return div;
-}
-
 static u32 truncate(u32 up, /* 0: down; else: up */
 					u64 a, /* must be non-negative */
 					u32 b)
 {
 	u32 d;
 	u64 div;
-	div = _do_div(a, b);
+	div = div_u64(a, b);
 	d = b * (div >> 32);
 	if (up && (a > (((u64)d) << 32)))
 		return d+b;
@@ -229,9 +221,9 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 	if ((input_frame_width < 4) || (output_frame_width < 4))
 		return 1;
 
-	irr_opt = _do_div((((u64)(input_frame_width - 1)) << 32),
+	irr_opt = div_u64((((u64)(input_frame_width - 1)) << 32),
 			  (output_frame_width - 1));
-	rr_opt = _do_div((((u64)(output_frame_width - 1)) << 32),
+	rr_opt = div_u64((((u64)(output_frame_width - 1)) << 32),
 			 (input_frame_width - 1));
 
 	if ((input_m == 0) || (output_m == 0) || (input_f == 0) || (output_f == 0)
@@ -265,7 +257,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 				output_frame_width >> 1;
 			left->input_column = 0;
 			left->output_column = 0;
-			div = _do_div(((((u64)irr_steps) << 32) *
+			div = div_u64(((((u64)irr_steps) << 32) *
 				       (right->input_width - 1)), (right->output_width - 1));
 			left->irr = right->irr = truncate(0, div, 1);
 		} else { /* with overlap */
@@ -275,7 +267,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* this is the maximal inw which allows the same resizing ratio */
 			/* in both stripes */
 			onw = truncate(1, (inw * rr_opt), output_f);
-			div = _do_div((((u64)(irr_steps * inw)) <<
+			div = div_u64((((u64)(irr_steps * inw)) <<
 				       32), onw);
 			left->irr = right->irr = truncate(0, div, 1);
 			left->output_width = right->output_width =
@@ -283,14 +275,14 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 			/* These are valid assignments for output_width, */
 			/* assuming output_f is a multiple of output_m */
 			div = (((u64)(left->output_width-1) * (left->irr)) << 32);
-			div = (((u64)1) << 32) + _do_div(div, irr_steps);
+			div = (((u64)1) << 32) + div_u64(div, irr_steps);
 
 			left->input_width = right->input_width = truncate(1, div, input_m);
 
-			div = _do_div((((u64)((right->output_width - 1) * right->irr)) <<
+			div = div_u64((((u64)((right->output_width - 1) * right->irr)) <<
 				       32), irr_steps);
 			difwr = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
-			div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+			div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 			left->input_column = truncate(0, div, input_f);
 
 
@@ -315,13 +307,13 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		/* in both stripes */
 		onw = truncate(1, inw * rr_opt, output_f);
 		do {
-			div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+			div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 			left->irr = truncate(0, div, 1);
-			div = _do_div((((u64)(onw * left->irr)) << 32),
+			div = div_u64((((u64)(onw * left->irr)) << 32),
 				      irr_steps);
 			dinw = (((u64)inw) << 32) - div;
 
-			div = _do_div((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
+			div = div_u64((((u64)((output_frame_width - 1 - onw) * left->irr)) <<
 				       32), irr_steps);
 
 			difwl = (((u64)(input_frame_width - 1 - inw)) << 32) - div;
@@ -341,7 +333,7 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 
 		inw = inw_best;
 		onw = truncate(1, inw * rr_opt, output_f);
-		div = _do_div((((u64)(irr_steps * inw)) << 32), onw);
+		div = div_u64((((u64)(irr_steps * inw)) << 32), onw);
 		left->irr = truncate(0, div, 1);
 
 		left->output_width = onw;
@@ -352,18 +344,18 @@ int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 		right->input_width = truncate(1, ((u64)(input_frame_width - inw)) <<
 					      32, input_m);
 
-		div = _do_div((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
+		div = div_u64((((u64)(irr_steps * (input_frame_width - 1 - inw))) <<
 			       32), (right->output_width - 1));
 		right->irr = truncate(0, div, 1);
 		temp = truncate(0, ((u64)left->irr) * ((((u64)1) << 32) + dirr), 1);
 		if (temp < right->irr)
 			right->irr = temp;
-		div = _do_div(((u64)((right->output_width - 1) * right->irr) <<
+		div = div_u64(((u64)((right->output_width - 1) * right->irr) <<
 			       32), irr_steps);
 		difwr = (u64)(input_frame_width - 1 - inw) - div;
 
 
-		div = _do_div((difwr + (((u64)input_f) << 32)), 2);
+		div = div_u64((difwr + (((u64)input_f) << 32)), 2);
 		left->input_column = truncate(0, div, input_f);
 
 		/* This splits the truncated input columns evenly */
diff --git a/drivers/mxc/ipu3/ipu_capture.c b/drivers/mxc/ipu3/ipu_capture.c
index f463836..3e2acf2 100644
--- a/drivers/mxc/ipu3/ipu_capture.c
+++ b/drivers/mxc/ipu3/ipu_capture.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -98,6 +98,7 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_RGB_YUV444;
 		break;
 	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_GENERIC_16:
 		cfg_param.data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;
 		break;
 	case IPU_PIX_FMT_RGB565:
@@ -129,10 +130,6 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 
 	ipu_csi_write(ipu, csi, data, CSI_SENS_CONF);
 
-	/* Setup the mclk */
-	if (cfg_param.mclk > 0)
-		_ipu_csi_mclk_set(ipu, cfg_param.mclk, csi);
-
 	/* Setup sensor frame size */
 	ipu_csi_write(ipu, csi, (width - 1) | (height - 1) << 16, CSI_SENS_FRM_SIZE);
 
@@ -144,29 +141,30 @@ ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
 		if (width == 720 && height == 625) {
 			/* PAL case */
 			/*
-			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
-			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
+			 * Field0BlankEnd = 0x6, Field0BlankStart = 0x2,
+			 * Field0ActiveEnd = 0x4, Field0ActiveStart = 0
 			 */
-			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_1);
+			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_1);
 			/*
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 * Field1BlankEnd = 0x7, Field1BlankStart = 0x3,
+			 * Field1ActiveEnd = 0x5, Field1ActiveStart = 0x1
 			 */
-			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_2);
+			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_2);
+
 			ipu_csi_write(ipu, csi, 0xFF0000, CSI_CCIR_CODE_3);
 
 		} else if (width == 720 && height == 525) {
 			/* NTSC case */
 			/*
-			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
-			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
-			 */
-			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_1);
-			/*
 			 * Field0BlankEnd = 0x7, Field0BlankStart = 0x3,
 			 * Field0ActiveEnd = 0x5, Field0ActiveStart = 0x1
 			 */
-			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_2);
+			ipu_csi_write(ipu, csi, 0xD07DF, CSI_CCIR_CODE_1);
+			/*
+			 * Field1BlankEnd = 0x6, Field1BlankStart = 0x2,
+			 * Field1ActiveEnd = 0x4, Field1ActiveStart = 0
+			 */
+			ipu_csi_write(ipu, csi, 0x40596, CSI_CCIR_CODE_2);
 			ipu_csi_write(ipu, csi, 0xFF0000, CSI_CCIR_CODE_3);
 		} else {
 			dev_err(ipu->dev, "Unsupported CCIR656 interlaced "
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index 92703f3..c2b5717 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -44,7 +44,8 @@ static struct ipu_soc ipu_array[MXC_IPU_MAX_NUM];
 int g_ipu_hw_rev;
 
 /* Static functions */
-static irqreturn_t ipu_irq_handler(int irq, void *desc);
+static irqreturn_t ipu_sync_irq_handler(int irq, void *desc);
+static irqreturn_t ipu_err_irq_handler(int irq, void *desc);
 
 static inline uint32_t channel_2_dma(ipu_channel_t ch, ipu_buffer_t type)
 {
@@ -109,6 +110,17 @@ static inline int _ipu_is_primary_disp_chan(uint32_t dma_chan)
 		(dma_chan == 28) || (dma_chan == 41));
 }
 
+static inline int _ipu_is_sync_irq(uint32_t irq)
+{
+	/* sync interrupt register number */
+	int reg_num = irq / 32 + 1;
+
+	return ((reg_num == 1)  || (reg_num == 2)  || (reg_num == 3)  ||
+		(reg_num == 4)  || (reg_num == 7)  || (reg_num == 8)  ||
+		(reg_num == 11) || (reg_num == 12) || (reg_num == 13) ||
+		(reg_num == 14) || (reg_num == 15));
+}
+
 #define idma_is_valid(ch)	(ch != NO_DMA)
 #define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
 #define idma_is_set(ipu, reg, dma)	(ipu_idmac_read(ipu, reg(dma)) & idma_mask(dma))
@@ -162,8 +174,18 @@ static int __devinit ipu_clk_setup_enable(struct ipu_soc *ipu,
 	clk_debug_register(&ipu->pixel_clk[0]);
 	clk_debug_register(&ipu->pixel_clk[1]);
 
-	if (!plat_data->bypass_reset)
-		clk_enable(ipu->ipu_clk);
+	/*
+	 * Enable ipu hsp clock anyway, so that we
+	 * may keep the clock on until user space
+	 * triggers frame buffer set_par(), i.e., any
+	 * ipu interface which enables/disables ipu
+	 * hsp clock with pair(called in IPUv3 fb
+	 * driver or mxc v4l2 driver<probed after fb
+	 * driver>) cannot eventually disables the
+	 * clock to damage the channel setup by
+	 * bootloader.
+	 */
+	clk_enable(ipu->ipu_clk);
 
 	ipu->pixel_clk[0].parent = ipu->ipu_clk;
 	ipu->pixel_clk[1].parent = ipu->ipu_clk;
@@ -202,6 +224,12 @@ void _ipu_put(struct ipu_soc *ipu)
 	clk_disable(ipu->ipu_clk);
 }
 
+void ipu_disable_hsp_clk(struct ipu_soc *ipu)
+{
+	_ipu_put(ipu);
+}
+EXPORT_SYMBOL(ipu_disable_hsp_clk);
+
 /*!
  * This function is called by the driver framework to initialize the IPU
  * hardware.
@@ -242,19 +270,17 @@ static int __devinit ipu_probe(struct platform_device *pdev)
 		goto failed_get_res;
 	}
 
-	if (request_irq(ipu->irq_sync, ipu_irq_handler, 0, pdev->name, ipu) != 0) {
+	ret = request_irq(ipu->irq_sync, ipu_sync_irq_handler, 0,
+			  pdev->name, ipu);
+	if (ret) {
 		dev_err(ipu->dev, "request SYNC interrupt failed\n");
-		ret = -EBUSY;
 		goto failed_req_irq_sync;
 	}
-	/* Some platforms have 2 IPU interrupts */
-	if (ipu->irq_err >= 0) {
-		if (request_irq
-		    (ipu->irq_err, ipu_irq_handler, 0, pdev->name, ipu) != 0) {
-			dev_err(ipu->dev, "request ERR interrupt failed\n");
-			ret = -EBUSY;
-			goto failed_req_irq_err;
-		}
+	ret = request_irq(ipu->irq_err, ipu_err_irq_handler, 0,
+			  pdev->name, ipu);
+	if (ret) {
+		dev_err(ipu->dev, "request ERR interrupt failed\n");
+		goto failed_req_irq_err;
 	}
 
 	ipu_base = res->start;
@@ -368,8 +394,7 @@ failed_clk_setup:
 	iounmap(ipu->disp_base[1]);
 	iounmap(ipu->vdi_reg);
 failed_ioremap:
-	if (ipu->irq_sync)
-		free_irq(ipu->irq_err, ipu);
+	free_irq(ipu->irq_err, ipu);
 failed_req_irq_err:
 	free_irq(ipu->irq_sync, ipu);
 failed_req_irq_sync:
@@ -383,10 +408,8 @@ int __devexit ipu_remove(struct platform_device *pdev)
 
 	unregister_ipu_device(ipu, pdev->id);
 
-	if (ipu->irq_sync)
-		free_irq(ipu->irq_sync, ipu);
-	if (ipu->irq_err)
-		free_irq(ipu->irq_err, ipu);
+	free_irq(ipu->irq_sync, ipu);
+	free_irq(ipu->irq_err, ipu);
 
 	clk_put(ipu->ipu_clk);
 
@@ -1153,10 +1176,17 @@ int32_t ipu_init_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
 			rot_mode);
 	} else if (_ipu_is_smfc_chan(dma_chan)) {
 		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
-		if ((pixel_fmt == IPU_PIX_FMT_GENERIC) &&
-			((_ipu_ch_param_get_bpp(ipu, dma_chan) == 5) ||
-			(_ipu_ch_param_get_bpp(ipu, dma_chan) == 3)))
+		/*
+		 * This is different from IPUv3 spec, but it is confirmed
+		 * in IPUforum that SMFC burst size should be NPB[6:3]
+		 * when IDMAC works in 16-bit generic data mode.
+		 */
+		if (pixel_fmt == IPU_PIX_FMT_GENERIC)
+			/* 8 bits per pixel */
 			burst_size = burst_size >> 4;
+		else if (pixel_fmt == IPU_PIX_FMT_GENERIC_16)
+			/* 16 bits per pixel */
+			burst_size = burst_size >> 3;
 		else
 			burst_size = burst_size >> 2;
 		_ipu_smfc_set_burst_size(ipu, channel, burst_size-1);
@@ -2179,7 +2209,8 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 				}
 			}
 		}
-	} else if (wait_for_stop && !_ipu_is_smfc_chan(out_dma)) {
+	} else if (wait_for_stop && !_ipu_is_smfc_chan(out_dma) &&
+		   channel != CSI_PRP_VF_MEM && channel != CSI_PRP_ENC_MEM) {
 		while (idma_is_set(ipu, IDMAC_CHA_BUSY, in_dma) ||
 		       idma_is_set(ipu, IDMAC_CHA_BUSY, out_dma) ||
 			(ipu->sec_chan_en[IPU_CHAN_ID(channel)] &&
@@ -2187,7 +2218,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 			(ipu->thrd_chan_en[IPU_CHAN_ID(channel)] &&
 			idma_is_set(ipu, IDMAC_CHA_BUSY, thrd_dma))) {
 			uint32_t irq = 0xffffffff;
-			int timeout = 50;
+			int timeout = 50000;
 
 			if (idma_is_set(ipu, IDMAC_CHA_BUSY, out_dma))
 				irq = out_dma;
@@ -2213,7 +2244,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 			while (((ipu_cm_read(ipu, IPUIRQ_2_STATREG(irq))
 				& IPUIRQ_2_MASK(irq)) == 0) &&
 				(idma_is_set(ipu, IDMAC_CHA_BUSY, irq))) {
-				msleep(10);
+				udelay(10);
 				timeout -= 10;
 				if (timeout <= 0) {
 					ipu_dump_registers(ipu);
@@ -2221,6 +2252,7 @@ int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wai
 					break;
 				}
 			}
+			dev_dbg(ipu->dev, "wait_time:%d\n", 50000 - timeout);
 
 		}
 	}
@@ -2371,42 +2403,17 @@ int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi)
 }
 EXPORT_SYMBOL(ipu_disable_csi);
 
-static irqreturn_t ipu_irq_handler(int irq, void *desc)
+static irqreturn_t ipu_sync_irq_handler(int irq, void *desc)
 {
 	struct ipu_soc *ipu = desc;
 	int i;
-	uint32_t line;
-	uint32_t bit;
+	uint32_t line, bit, int_stat, int_ctrl;
 	irqreturn_t result = IRQ_NONE;
-	uint32_t int_stat;
-	uint32_t int_ctrl;
-	const int err_reg[] = { 5, 6, 9, 10, 0 };
 	const int int_reg[] = { 1, 2, 3, 4, 11, 12, 13, 14, 15, 0 };
 
 	spin_lock(&ipu->int_reg_spin_lock);
 
-	for (i = 0;; i++) {
-		if (err_reg[i] == 0)
-			break;
-
-		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(err_reg[i]));
-		int_stat &= ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i]));
-		if (int_stat) {
-			ipu_cm_write(ipu, int_stat, IPU_INT_STAT(err_reg[i]));
-			dev_warn(ipu->dev,
-				"IPU Warning - IPU_INT_STAT_%d = 0x%08X\n",
-				err_reg[i], int_stat);
-			/* Disable interrupts so we only get error once */
-			int_stat =
-			    ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i])) & ~int_stat;
-			ipu_cm_write(ipu, int_stat, IPU_INT_CTRL(err_reg[i]));
-		}
-	}
-
-	for (i = 0;; i++) {
-		if (int_reg[i] == 0)
-			break;
-
+	for (i = 0; int_reg[i] != 0; i++) {
 		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(int_reg[i]));
 		int_ctrl = ipu_cm_read(ipu, IPU_INT_CTRL(int_reg[i]));
 		int_stat &= int_ctrl;
@@ -2432,6 +2439,35 @@ static irqreturn_t ipu_irq_handler(int irq, void *desc)
 	return result;
 }
 
+static irqreturn_t ipu_err_irq_handler(int irq, void *desc)
+{
+	struct ipu_soc *ipu = desc;
+	int i;
+	uint32_t int_stat;
+	const int err_reg[] = { 5, 6, 9, 10, 0 };
+
+	spin_lock(&ipu->int_reg_spin_lock);
+
+	for (i = 0; err_reg[i] != 0; i++) {
+		int_stat = ipu_cm_read(ipu, IPU_INT_STAT(err_reg[i]));
+		int_stat &= ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i]));
+		if (int_stat) {
+			ipu_cm_write(ipu, int_stat, IPU_INT_STAT(err_reg[i]));
+			dev_warn(ipu->dev,
+				"IPU Warning - IPU_INT_STAT_%d = 0x%08X\n",
+				err_reg[i], int_stat);
+			/* Disable interrupts so we only get error once */
+			int_stat = ipu_cm_read(ipu, IPU_INT_CTRL(err_reg[i])) &
+					~int_stat;
+			ipu_cm_write(ipu, int_stat, IPU_INT_CTRL(err_reg[i]));
+		}
+	}
+
+	spin_unlock(&ipu->int_reg_spin_lock);
+
+	return IRQ_HANDLED;
+}
+
 /*!
  * This function enables the interrupt for the specified interrupt line.
  * The interrupt lines are defined in \b ipu_irq_line enum.
@@ -2439,23 +2475,40 @@ static irqreturn_t ipu_irq_handler(int irq, void *desc)
  * @param	ipu		ipu handler
  * @param       irq             Interrupt line to enable interrupt for.
  *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
  */
-void ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq)
+int ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq)
 {
 	uint32_t reg;
 	unsigned long lock_flags;
+	int ret = 0;
 
 	_ipu_get(ipu);
 
 	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
 
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (ipu->irq_list[irq].handler == NULL)) {
+		dev_err(ipu->dev, "handler hasn't been registered on sync "
+				  "irq %d\n", irq);
+		ret = -EACCES;
+		goto out;
+	}
+
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
 	reg |= IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
-
+out:
 	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
+
+	return ret;
 }
 EXPORT_SYMBOL(ipu_enable_irq);
 
@@ -2567,6 +2620,7 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 {
 	uint32_t reg;
 	unsigned long lock_flags;
+	int ret = 0;
 
 	BUG_ON(irq >= IPU_IRQ_COUNT);
 
@@ -2577,8 +2631,19 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 	if (ipu->irq_list[irq].handler != NULL) {
 		dev_err(ipu->dev,
 			"handler already installed on irq %d\n", irq);
-		spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (handler == NULL)) {
+		dev_err(ipu->dev, "handler is NULL for sync irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
 	}
 
 	ipu->irq_list[irq].handler = handler;
@@ -2592,12 +2657,12 @@ int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
 	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
 	reg |= IPUIRQ_2_MASK(irq);
 	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
-
+out:
 	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
 
 	_ipu_put(ipu);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(ipu_request_irq);
 
@@ -2772,6 +2837,7 @@ uint32_t bytes_per_pixel(uint32_t fmt)
 	case IPU_PIX_FMT_YUV444P:
 		return 1;
 		break;
+	case IPU_PIX_FMT_GENERIC_16:	/* generic data */
 	case IPU_PIX_FMT_RGB565:
 	case IPU_PIX_FMT_YUYV:
 	case IPU_PIX_FMT_UYVY:
@@ -2779,6 +2845,7 @@ uint32_t bytes_per_pixel(uint32_t fmt)
 		break;
 	case IPU_PIX_FMT_BGR24:
 	case IPU_PIX_FMT_RGB24:
+	case IPU_PIX_FMT_YUV444:
 		return 3;
 		break;
 	case IPU_PIX_FMT_GENERIC_32:	/*generic data */
diff --git a/drivers/mxc/ipu3/ipu_device.c b/drivers/mxc/ipu3/ipu_device.c
index be17251..ce34775 100644
--- a/drivers/mxc/ipu3/ipu_device.c
+++ b/drivers/mxc/ipu3/ipu_device.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -680,6 +680,11 @@ static void dump_check_warn(struct device *dev, int warn)
 
 static int set_crop(struct ipu_crop *crop, int width, int height, int fmt)
 {
+	if ((width == 0) || (height == 0)) {
+		pr_err("Invalid param: width=%d, height=%d\n", width, height);
+		return -EINVAL;
+	}
+
 	if ((IPU_PIX_FMT_TILED_NV12 == fmt) ||
 		(IPU_PIX_FMT_TILED_NV12F == fmt)) {
 		if (crop->w || crop->h) {
@@ -719,6 +724,12 @@ static int set_crop(struct ipu_crop *crop, int width, int height, int fmt)
 		crop->h -= crop->h%8;
 	}
 
+	if ((crop->w == 0) || (crop->h == 0)) {
+		pr_err("Invalid crop param: crop.w=%d, crop.h=%d\n",
+			crop->w, crop->h);
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -733,26 +744,28 @@ static void update_offset(unsigned int fmt,
 	case IPU_PIX_FMT_YUV420P:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
-			+ ((width/2 * pos_y/2) + pos_x/2);
-		*voff = *uoff + (width/2 * height/2);
+			+ (width/2) * (pos_y/2) + pos_x/2;
+		/* In case height is odd, round up to even */
+		*voff = *uoff + (width/2) * ((height+1)/2);
 		break;
 	case IPU_PIX_FMT_YVU420P:
 		*off = pos_y * width + pos_x;
 		*voff = (width * (height - pos_y) - pos_x)
-			+ ((width/2 * pos_y/2) + pos_x/2);
-		*uoff = *voff + (width/2 * height/2);
+			+ (width/2) * (pos_y/2) + pos_x/2;
+		/* In case height is odd, round up to even */
+		*uoff = *voff + (width/2) * ((height+1)/2);
 		break;
 	case IPU_PIX_FMT_YVU422P:
 		*off = pos_y * width + pos_x;
 		*voff = (width * (height - pos_y) - pos_x)
-			+ ((width * pos_y)/2 + pos_x/2);
-		*uoff = *voff + (width * height)/2;
+			+ (width/2) * pos_y + pos_x/2;
+		*uoff = *voff + (width/2) * height;
 		break;
 	case IPU_PIX_FMT_YUV422P:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
-			+ (width * pos_y)/2 + pos_x/2;
-		*voff = *uoff + (width * height)/2;
+			+ (width/2) * pos_y + pos_x/2;
+		*voff = *uoff + (width/2) * height;
 		break;
 	case IPU_PIX_FMT_YUV444P:
 		*off = pos_y * width + pos_x;
@@ -762,7 +775,7 @@ static void update_offset(unsigned int fmt,
 	case IPU_PIX_FMT_NV12:
 		*off = pos_y * width + pos_x;
 		*uoff = (width * (height - pos_y) - pos_x)
-			+ width * pos_y/2 + pos_x;
+			+ width * (pos_y/2) + pos_x;
 		break;
 	case IPU_PIX_FMT_TILED_NV12:
 		/*
@@ -799,6 +812,7 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 	struct stripe_param down_stripe;
 	u32 iw, ih, ow, oh;
 	u32 max_width;
+	int ret;
 
 	if (t->output.rotate >= IPU_ROTATE_90_RIGHT)
 		return IPU_CHECK_ERR_SPLIT_WITH_ROT;
@@ -809,12 +823,26 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 	ow = t->output.crop.w;
 	oh = t->output.crop.h;
 
+	memset(&left_stripe, 0, sizeof(left_stripe));
+	memset(&right_stripe, 0, sizeof(right_stripe));
+	memset(&up_stripe, 0, sizeof(up_stripe));
+	memset(&down_stripe, 0, sizeof(down_stripe));
+
 	if (t->set.split_mode & RL_SPLIT) {
+		/*
+		 * We do want equal strips: initialize stripes in case
+		 * calc_stripes returns before actually doing the calculation
+		 */
+		left_stripe.input_width = iw / 2;
+		left_stripe.output_width = ow / 2;
+		right_stripe.input_column = iw / 2;
+		right_stripe.output_column = ow / 2;
+
 		if (vdi_split)
 			max_width = soc_max_vdi_in_width();
 		else
 			max_width = soc_max_out_width();
-		ipu_calc_stripes_sizes(iw,
+		ret = ipu_calc_stripes_sizes(iw,
 				ow,
 				max_width,
 				(((unsigned long long)1) << 32), /* 32bit for fractional*/
@@ -823,6 +851,9 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 				t->output.format,
 				&left_stripe,
 				&right_stripe);
+		if (ret)
+			dev_dbg(t->dev, "Warn: no:0x%x,calc_stripes ret:%d\n",
+				 t->task_no, ret);
 		t->set.sp_setting.iw = left_stripe.input_width;
 		t->set.sp_setting.ow = left_stripe.output_width;
 		t->set.sp_setting.outh_resize_ratio = left_stripe.irr;
@@ -846,7 +877,15 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 		return IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER;
 
 	if (t->set.split_mode & UD_SPLIT) {
-		ipu_calc_stripes_sizes(ih,
+		/*
+		 * We do want equal strips: initialize stripes in case
+		 * calc_stripes returns before actually doing the calculation
+		 */
+		up_stripe.input_width = ih / 2;
+		up_stripe.output_width = oh / 2;
+		down_stripe.input_column = ih / 2;
+		down_stripe.output_column = oh / 2;
+		ret = ipu_calc_stripes_sizes(ih,
 				oh,
 				soc_max_out_height(),
 				(((unsigned long long)1) << 32), /* 32bit for fractional*/
@@ -855,6 +894,9 @@ static int update_split_setting(struct ipu_task_entry *t, bool vdi_split)
 				t->output.format,
 				&up_stripe,
 				&down_stripe);
+		if (ret)
+			dev_err(t->dev, "Warn: no:0x%x,calc_stripes ret:%d\n",
+				 t->task_no, ret);
 		t->set.sp_setting.ih = up_stripe.input_width;
 		t->set.sp_setting.oh = up_stripe.output_width;
 		t->set.sp_setting.outv_resize_ratio = up_stripe.irr;
@@ -1856,6 +1898,7 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	int out_uoff = 0, out_voff = 0, out_rot;
 	int out_w = 0, out_h = 0, out_stride;
 	int out_fmt;
+	u32 vdi_frame_idx = 0;
 
 	memset(&params, 0, sizeof(params));
 
@@ -1899,8 +1942,9 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		params.mem_prp_vf_mem.graphics_combine_en = 1;
 		if (t->overlay.alpha.mode == IPU_ALPHA_MODE_GLOBAL)
 			params.mem_prp_vf_mem.global_alpha_en = 1;
-		else
+		else if (t->overlay.alpha.loc_alp_paddr)
 			params.mem_prp_vf_mem.alpha_chan_en = 1;
+		/* otherwise, alpha bending per pixel is used. */
 		params.mem_prp_vf_mem.alpha = t->overlay.alpha.gvalue;
 		if (t->overlay.colorkey.enable) {
 			params.mem_prp_vf_mem.key_color_en = 1;
@@ -1908,6 +1952,19 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 		}
 	}
 
+	if (t->input.deinterlace.enable) {
+		if (t->input.deinterlace.field_fmt & IPU_DEINTERLACE_FIELD_MASK)
+			params.mem_prp_vf_mem.field_fmt =
+				IPU_DEINTERLACE_FIELD_BOTTOM;
+		else
+			params.mem_prp_vf_mem.field_fmt =
+				IPU_DEINTERLACE_FIELD_TOP;
+
+		if (t->input.deinterlace.field_fmt & IPU_DEINTERLACE_RATE_EN)
+			vdi_frame_idx = t->input.deinterlace.field_fmt &
+						IPU_DEINTERLACE_RATE_FRAME1;
+	}
+
 	if (t->set.mode & VDOA_MODE)
 		ipu->vdoa_en = 1;
 
@@ -1921,13 +1978,6 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	}
 
 	if (deinterlace_3_field(t)) {
-		if (IPU_DEINTERLACE_FIELD_TOP == t->input.deinterlace.field_fmt)
-			params.mem_prp_vf_mem.field_fmt = V4L2_FIELD_INTERLACED_TB;
-		else if (IPU_DEINTERLACE_FIELD_BOTTOM == t->input.deinterlace.field_fmt)
-			params.mem_prp_vf_mem.field_fmt = V4L2_FIELD_INTERLACED_BT;
-		else
-			dev_err(t->dev, "ERR[no-0x%x]invalid field fmt:0x%x!\n",
-				t->task_no, t->input.deinterlace.field_fmt);
 		ret = ipu_init_channel(ipu, t->set.vdi_ic_p_chan, &params);
 		if (ret < 0) {
 			t->state = STATE_INIT_CHAN_FAIL;
@@ -1949,13 +1999,57 @@ static int init_ic(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	} else {
 		if ((deinterlace_3_field(t)) &&
 			(IPU_PIX_FMT_TILED_NV12F != t->input.format)) {
-				inbuf_p = t->input.paddr + t->set.istride +
-						t->set.i_off;
-				inbuf = t->input.paddr_n + t->set.i_off;
-				inbuf_n = t->input.paddr_n + t->set.istride +
-						t->set.i_off;
-		} else
-			inbuf = t->input.paddr + t->set.i_off;
+			if (params.mem_prp_vf_mem.field_fmt ==
+				IPU_DEINTERLACE_FIELD_TOP) {
+				if (vdi_frame_idx) {
+					inbuf_p = t->input.paddr + t->set.istride +
+							t->set.i_off;
+					inbuf = t->input.paddr_n + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.istride +
+							t->set.i_off;
+					params.mem_prp_vf_mem.field_fmt =
+						IPU_DEINTERLACE_FIELD_BOTTOM;
+				} else {
+					inbuf_p = t->input.paddr + t->set.i_off;
+					inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.i_off;
+				}
+			} else {
+				if (vdi_frame_idx) {
+					inbuf_p = t->input.paddr + t->set.i_off;
+					inbuf = t->input.paddr_n + t->set.istride + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.i_off;
+					params.mem_prp_vf_mem.field_fmt =
+						IPU_DEINTERLACE_FIELD_TOP;
+				} else {
+					inbuf_p = t->input.paddr + t->set.istride +
+							t->set.i_off;
+					inbuf = t->input.paddr + t->set.i_off;
+					inbuf_n = t->input.paddr_n + t->set.istride +
+							t->set.i_off;
+				}
+			}
+		} else {
+			if (t->input.deinterlace.enable) {
+				if (params.mem_prp_vf_mem.field_fmt ==
+					IPU_DEINTERLACE_FIELD_TOP) {
+					if (vdi_frame_idx) {
+						inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+						params.mem_prp_vf_mem.field_fmt =
+							IPU_DEINTERLACE_FIELD_BOTTOM;
+					} else
+						inbuf = t->input.paddr + t->set.i_off;
+				} else {
+					if (vdi_frame_idx) {
+						inbuf = t->input.paddr + t->set.i_off;
+						params.mem_prp_vf_mem.field_fmt =
+							IPU_DEINTERLACE_FIELD_TOP;
+					} else
+						inbuf = t->input.paddr + t->set.istride + t->set.i_off;
+				}
+			} else
+				inbuf = t->input.paddr + t->set.i_off;
+		}
 
 		if (t->overlay_en)
 			ovbuf = t->overlay.paddr + t->set.ov_off;
@@ -2243,6 +2337,9 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	u32 task_no;
 	u32 i, offset_addr;
 	unsigned char  *base_off;
+	u32 pixwidth;
+	u32 crop_width;
+
 	struct ipu_task_entry *parent = t->parent;
 
 	if (!parent) {
@@ -2252,21 +2349,30 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	stripe_mode = t->task_no & 0xf;
 	task_no = t->task_no >> 4;
 
-	base_off = (char *) __va(t->output.paddr);
+	pixwidth = fmt_to_bpp(t->output.format)/8;
+	crop_width = t->output.crop.w * pixwidth;
+
+	if (pfn_valid(t->output.paddr >> PAGE_SHIFT))
+		base_off = page_address(pfn_to_page(t->output.paddr >> PAGE_SHIFT));
+	else
+		base_off = (char *)ioremap_nocache(t->output.paddr,
+				t->output.width * t->output.height *
+				pixwidth);
+
 	if (base_off == NULL) {
 		dev_err(t->dev, "ERR[0x%p]Falied get vitual address\n", t);
 		return;
 	}
 
 	vdi_save_lines = (t->output.crop.h - t->set.sp_setting.ud_split_line)/2;
-	vdi_size = vdi_save_lines * t->output.crop.w * 2;
+	vdi_size = vdi_save_lines * t->output.crop.w * pixwidth;
 
 	if (vdi_save_lines <= 0) {
 		dev_err(t->dev, "[0x%p] vdi_save_line error\n", (void *)t);
 		return;
 	}
 
-	/*check vditmpbuf buffer have alloced or buffer size is changed */
+	/* Check vditmpbuf buffer have alloced or buffer size is changed */
 	if ((vdi_save_lines != parent->old_save_lines) ||
 		(vdi_size != parent->old_size)) {
 		if (parent->vditmpbuf[0] != NULL)
@@ -2298,120 +2404,93 @@ static void vdi_split_process(struct ipu_soc *ipu, struct ipu_task_entry *t)
 	if ((stripe_mode == UP_STRIPE) ||
 			(stripe_mode == (UP_STRIPE | LEFT_STRIPE))) {
 		if (!parent->buf0filled) {
-			offset_addr = t->set.o_off +
-				t->set.sp_setting.ud_split_line*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_size);
-			outer_flush_range(t->output.paddr + offset_addr,
-				t->output.paddr + offset_addr + vdi_size);
+			offset_addr = t->set.o_off * pixwidth +
+				t->set.sp_setting.ud_split_line * t->set.ostride ;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[0] + i*t->output.crop.w*2,
+				memcpy(parent->vditmpbuf[0] + i * crop_width,
 					base_off + offset_addr +
-					i*t->set.ostride, t->output.crop.w*2);
+					i * t->set.ostride, crop_width);
 			parent->buf0filled = true;
 		} else {
-			offset_addr = t->set.o_off + (t->output.crop.h -
+			offset_addr = t->set.o_off * pixwidth + (t->output.crop.h -
 					vdi_save_lines) * t->set.ostride;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[0] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + i*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + i*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[0] + i * crop_width,
+						crop_width);
+
 			parent->buf0filled = false;
 		}
 	}
-	/*Down stripe or Down&Left stripe*/
+	/* Down stripe or Down&Left stripe */
 	else if ((stripe_mode == DOWN_STRIPE) ||
 			(stripe_mode == (DOWN_STRIPE | LEFT_STRIPE))) {
 		if (!parent->buf0filled) {
-			offset_addr = t->set.o_off + vdi_save_lines*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_size);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_size);
+			offset_addr = t->set.o_off * pixwidth +
+				vdi_save_lines * t->set.ostride;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[0] + i*t->output.crop.w*2,
-						base_off + offset_addr + i*t->set.ostride,
-						t->output.crop.w*2);
+				memcpy(parent->vditmpbuf[0] + i * crop_width,
+						base_off + offset_addr + i * t->set.ostride,
+						crop_width);
 			parent->buf0filled = true;
+
 		} else {
-			offset_addr = t->set.o_off;
+			offset_addr = t->set.o_off * pixwidth;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[0] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + i*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + i*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[0] + i * crop_width,
+						crop_width);
+
 			parent->buf0filled = false;
 		}
 	}
-	/*Up&Right stripe*/
+	/* Up&Right stripe */
 	else if (stripe_mode == (UP_STRIPE | RIGHT_STRIPE)) {
 		if (!parent->buf1filled) {
-			offset_addr = t->set.o_off +
-				t->set.sp_setting.ud_split_line*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_size);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_size);
+			offset_addr = t->set.o_off * pixwidth +
+				t->set.sp_setting.ud_split_line * t->set.ostride;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						base_off + offset_addr + i*t->set.ostride,
-						t->output.crop.w*2);
+				memcpy(parent->vditmpbuf[1] + i * crop_width,
+						base_off + offset_addr + i * t->set.ostride,
+						crop_width);
 			parent->buf1filled = true;
 		} else {
-			offset_addr = t->set.o_off +
-				(t->output.crop.h - vdi_save_lines)*t->set.ostride;
+			offset_addr = t->set.o_off * pixwidth +
+				(t->output.crop.h - vdi_save_lines) * t->set.ostride;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + i*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + i*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[1] + i * crop_width,
+						crop_width);
+
 			parent->buf1filled = false;
 		}
 	}
-	/*Down stripe or Down&Right stript*/
+	/* Down stripe or Down&Right stript */
 	else if (stripe_mode == (DOWN_STRIPE | RIGHT_STRIPE)) {
 		if (!parent->buf1filled) {
-			offset_addr = t->set.o_off + vdi_save_lines*t->set.ostride;
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_save_lines*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_save_lines*t->set.ostride);
+			offset_addr = t->set.o_off * pixwidth +
+				vdi_save_lines * t->set.ostride;
 
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						base_off + offset_addr + i*t->set.ostride,
-						t->output.crop.w*2);
+				memcpy(parent->vditmpbuf[1] + i * crop_width,
+						base_off + offset_addr + i * t->set.ostride,
+						crop_width);
 			parent->buf1filled = true;
 		} else {
-			offset_addr = t->set.o_off;
+			offset_addr = t->set.o_off * pixwidth;
 			for (i = 0; i < vdi_save_lines; i++)
-				memcpy(base_off + offset_addr + i*t->set.ostride,
-						parent->vditmpbuf[1] + i*t->output.crop.w*2,
-						t->output.crop.w*2);
-
-			dmac_flush_range(base_off + offset_addr,
-					base_off + offset_addr + vdi_save_lines*t->set.ostride);
-			outer_flush_range(t->output.paddr + offset_addr,
-					t->output.paddr + offset_addr + vdi_save_lines*t->set.ostride);
+				memcpy(base_off + offset_addr + i * t->set.ostride,
+						parent->vditmpbuf[1] + i * crop_width,
+						crop_width);
+
 			parent->buf1filled = false;
 		}
 	}
+	if (!pfn_valid(t->output.paddr >> PAGE_SHIFT))
+		iounmap(base_off);
 }
 
 static void do_task_release(struct ipu_task_entry *t, int fail)
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index 35b7819..87fa001 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -61,7 +61,7 @@ static unsigned long _ipu_pixel_clk_get_rate(struct clk *clk)
 {
 	struct ipu_soc *ipu = pixelclk2ipu(clk);
 	u32 div;
-	u64 final_rate = clk_get_rate(clk->parent) * 16;
+	u64 final_rate = (unsigned long long)clk_get_rate(clk->parent) * 16;
 
 	_ipu_get(ipu);
 	div = ipu_di_read(ipu, clk->id, DI_BS_CLKGEN0);
@@ -1297,6 +1297,10 @@ int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp, uint32_t pixel_clk,
 	msleep(5);
 	/* Get integer portion of divider */
 	div = clk_get_rate(clk_get_parent(&ipu->pixel_clk[disp])) / rounded_pixel_clk;
+	if (!div) {
+		dev_err(ipu->dev, "invalid pixel clk div = 0\n");
+		return -EINVAL;
+	}
 
 	mutex_lock(&ipu->mutex_lock);
 
diff --git a/drivers/mxc/ipu3/ipu_ic.c b/drivers/mxc/ipu3/ipu_ic.c
index b0b79ad..0f528d0 100644
--- a/drivers/mxc/ipu3/ipu_ic.c
+++ b/drivers/mxc/ipu3/ipu_ic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -69,6 +69,7 @@ void _ipu_vdi_set_motion(struct ipu_soc *ipu, ipu_motion_sel motion_sel)
 		reg |= VDI_C_MOT_SEL_LOW;
 
 	ipu_vdi_write(ipu, reg, VDI_C);
+	dev_dbg(ipu->dev, "VDI_C = \t0x%08X\n", reg);
 }
 
 void ic_dump_register(struct ipu_soc *ipu)
@@ -215,10 +216,10 @@ void _ipu_vdi_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_param
 	}
 	ipu_vdi_write(ipu, reg, VDI_C);
 
-	if (params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_TB)
-		_ipu_vdi_set_top_field_man(ipu, false);
-	else if (params->mem_prp_vf_mem.field_fmt == V4L2_FIELD_INTERLACED_BT)
+	if (params->mem_prp_vf_mem.field_fmt == IPU_DEINTERLACE_FIELD_TOP)
 		_ipu_vdi_set_top_field_man(ipu, true);
+	else if (params->mem_prp_vf_mem.field_fmt == IPU_DEINTERLACE_FIELD_BOTTOM)
+		_ipu_vdi_set_top_field_man(ipu, false);
 
 	_ipu_vdi_set_motion(ipu, params->mem_prp_vf_mem.motion_sel);
 
diff --git a/drivers/mxc/ipu3/ipu_param_mem.h b/drivers/mxc/ipu3/ipu_param_mem.h
index 1387c49..6d0a470 100644
--- a/drivers/mxc/ipu3/ipu_param_mem.h
+++ b/drivers/mxc/ipu3/ipu_param_mem.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -285,6 +285,13 @@ static inline void _ipu_ch_param_init(struct ipu_soc *ipu, int ch,
 		ipu_ch_param_set_field(&params, 1, 78, 7, 63);	/* burst size */
 
 		break;
+	case IPU_PIX_FMT_GENERIC_16:
+		/* Represents 16-bit generic data */
+		ipu_ch_param_set_field(&params, 0, 107, 3, 3);	/* bits/pixel */
+		ipu_ch_param_set_field(&params, 1, 85, 4, 6);	/* pix format */
+		ipu_ch_param_set_field(&params, 1, 78, 7, 31);	/* burst size */
+
+		break;
 	case IPU_PIX_FMT_GENERIC_32:
 		/*Represents 32-bit Generic data */
 		break;
@@ -695,6 +702,7 @@ static inline void _ipu_ch_offset_update(struct ipu_soc *ipu,
 
 	switch (pixel_fmt) {
 	case IPU_PIX_FMT_GENERIC:
+	case IPU_PIX_FMT_GENERIC_16:
 	case IPU_PIX_FMT_GENERIC_32:
 	case IPU_PIX_FMT_RGB565:
 	case IPU_PIX_FMT_BGR24:
diff --git a/drivers/mxc/mlb/mxc_mlb150.c b/drivers/mxc/mlb/mxc_mlb150.c
index e3ecbe2..fa75d09 100755
--- a/drivers/mxc/mlb/mxc_mlb150.c
+++ b/drivers/mxc/mlb/mxc_mlb150.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,161 +37,173 @@
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/sched.h>
+#include <linux/circ_buf.h>
 
 #define DRIVER_NAME "mxc_mlb150"
 
 /*!
  * MLB module memory map registers define
  */
-#define MLB150_REG_MLBC0		0x0
-#define MLB150_MLBC0_MLBEN		(0x1)
-#define MLB150_MLBC0_MLBCLK_MASK	(0x7 << 2)
-#define MLB150_MLBC0_MLBCLK_SHIFT	(2)
-#define MLB150_MLBC0_MLBPEN		(0x1 << 5)
-#define MLB150_MLBC0_MLBLK		(0x1 << 7)
-#define MLB150_MLBC0_ASYRETRY		(0x1 << 12)
-#define MLB150_MLBC0_CTLRETRY		(0x1 << 12)
-#define MLB150_MLBC0_FCNT_MASK		(0x7 << 15)
-#define MLB150_MLBC0_FCNT_SHIFT		(15)
-
-#define MLB150_REG_MLBPC0		0x8
-#define MLB150_MLBPC0_MCLKHYS		(0x1 << 11)
-
-#define MLB150_REG_MS0			0xC
-#define MLB150_REG_MS1			0x14
-
-#define MLB150_REG_MSS			0x20
-#define MLB150_MSS_RSTSYSCMD		(0x1)
-#define MLB150_MSS_LKSYSCMD		(0x1 << 1)
-#define MLB150_MSS_ULKSYSCMD		(0x1 << 2)
-#define MLB150_MSS_CSSYSCMD		(0x1 << 3)
-#define MLB150_MSS_SWSYSCMD		(0x1 << 4)
-#define MLB150_MSS_SERVREQ		(0x1 << 5)
-
-#define MLB150_REG_MSD			0x24
-
-#define MLB150_REG_MIEN			0x2C
-#define MLB150_MIEN_ISOC_PE		(0x1)
-#define MLB150_MIEN_ISOC_BUFO		(0x1 << 1)
-#define MLB150_MIEN_SYNC_PE		(0x1 << 16)
-#define MLB150_MIEN_ARX_DONE		(0x1 << 17)
-#define MLB150_MIEN_ARX_PE		(0x1 << 18)
-#define MLB150_MIEN_ARX_BREAK		(0x1 << 19)
-#define MLB150_MIEN_ATX_DONE		(0x1 << 20)
-#define MLB150_MIEN_ATX_PE		(0x1 << 21)
-#define MLB150_MIEN_ATX_BREAK		(0x1 << 22)
-#define MLB150_MIEN_CRX_DONE		(0x1 << 24)
-#define MLB150_MIEN_CRX_PE		(0x1 << 25)
-#define MLB150_MIEN_CRX_BREAK		(0x1 << 26)
-#define MLB150_MIEN_CTX_DONE		(0x1 << 27)
-#define MLB150_MIEN_CTX_PE		(0x1 << 28)
-#define MLB150_MIEN_CTX_BREAK		(0x1 << 29)
-
-#define MLB150_REG_MLBPC2		0x34
-#define MLB150_REG_MLBPC1		0x38
-#define MLB150_MLBPC1_VAL		(0x00000888)
-
-#define MLB150_REG_MLBC1		0x3C
-#define MLB150_MLBC1_LOCK		(0x1 << 6)
-#define MLB150_MLBC1_CLKM		(0x1 << 7)
-#define MLB150_MLBC1_NDA_MASK		(0xFF << 8)
-#define MLB150_MLBC1_NDA_SHIFT		(8)
-
-#define MLB150_REG_HCTL			0x80
-#define MLB150_HCTL_RST0		(0x1)
-#define MLB150_HCTL_RST1		(0x1 << 1)
-#define MLB150_HCTL_EN			(0x1 << 15)
-
-#define MLB150_REG_HCMR0		0x88
-#define MLB150_REG_HCMR1		0x8C
-#define MLB150_REG_HCER0		0x90
-#define MLB150_REG_HCER1		0x94
-#define MLB150_REG_HCBR0		0x98
-#define MLB150_REG_HCBR1		0x9C
-
-#define MLB150_REG_MDAT0		0xC0
-#define MLB150_REG_MDAT1		0xC4
-#define MLB150_REG_MDAT2		0xC8
-#define MLB150_REG_MDAT3		0xCC
-
-#define MLB150_REG_MDWE0		0xD0
-#define MLB150_REG_MDWE1		0xD4
-#define MLB150_REG_MDWE2		0xD8
-#define MLB150_REG_MDWE3		0xDC
-
-#define MLB150_REG_MCTL			0xE0
-#define MLB150_MCTL_XCMP		(0x1)
-
-#define MLB150_REG_MADR			0xE4
-#define MLB150_MADR_WNR			(0x1 << 31)
-#define MLB150_MADR_TB			(0x1 << 30)
-#define MLB150_MADR_ADDR_MASK		(0x7f << 8)
-#define MLB150_MADR_ADDR_SHIFT		(0)
-
-#define MLB150_REG_ACTL			0x3C0
-#define MLB150_ACTL_MPB			(0x1 << 4)
-#define MLB150_ACTL_DMAMODE		(0x1 << 2)
-#define MLB150_ACTL_SMX			(0x1 << 1)
-#define MLB150_ACTL_SCE			(0x1)
-
-#define MLB150_REG_ACSR0		0x3D0
-#define MLB150_REG_ACSR1		0x3D4
-#define MLB150_REG_ACMR0		0x3D8
-#define MLB150_REG_ACMR1		0x3DC
-
-#define MLB150_REG_CAT_MDATn(ch) (MLB150_REG_MDAT0 + ((ch % 8) >> 1) * 4)
-#define MLB150_REG_CAT_MDWEn(ch) (MLB150_REG_MDWE0 + ((ch % 8) >> 1) * 4)
-
-#define MLB150_LOGIC_CH_NUM		(64)
-#define MLB150_BUF_CDT_OFFSET		(0x0)
-#define MLB150_BUF_ADT_OFFSET		(0x40)
-#define MLB150_BUF_CAT_MLB_OFFSET	(0x80)
-#define MLB150_BUF_CAT_HBI_OFFSET	(0x88)
-#define MLB150_BUF_CTR_END_OFFSET	(0x8F)
-
-#define MLB150_CAT_MODE_RX		(0x1 << 0)
-#define MLB150_CAT_MODE_TX		(0x1 << 1)
-#define MLB150_CAT_MODE_INBOUND_DMA	(0x1 << 8)
-#define MLB150_CAT_MODE_OUTBOUND_DMA	(0x1 << 9)
-
-#define MLB150_CH_SYNC_BUF_DEP		(128 * 4 * 4)
-#define MLB150_CH_CTRL_BUF_DEP		(64)
-#define MLB150_CH_ASYNC_BUF_DEP		(2048)
-#define MLB150_CH_ISOC_BLK_SIZE		(196)
-#define MLB150_CH_ISOC_BLK_NUM		(3)
-#define MLB150_CH_ISOC_BUF_DEP		(MLB150_CH_ISOC_BLK_SIZE * MLB150_CH_ISOC_BLK_NUM)
-
-#define MLB150_CH_SYNC_DBR_BUF_OFFSET	(0x0)
-#define MLB150_CH_CTRL_DBR_BUF_OFFSET	(MLB150_CH_SYNC_DBR_BUF_OFFSET + 2 * MLB150_CH_SYNC_BUF_DEP)
-#define MLB150_CH_ASYNC_DBR_BUF_OFFSET	(MLB150_CH_CTRL_DBR_BUF_OFFSET + 2 * MLB150_CH_CTRL_BUF_DEP)
-#define MLB150_CH_ISOC_DBR_BUF_OFFSET	(MLB150_CH_ASYNC_DBR_BUF_OFFSET + 2 * MLB150_CH_ASYNC_BUF_DEP)
-
-static u32 mlb150_ch_packet_buf_size[4] = {
-	MLB150_CH_SYNC_BUF_DEP,
-	MLB150_CH_CTRL_BUF_DEP,
-	MLB150_CH_ASYNC_BUF_DEP,
-	MLB150_CH_ISOC_BUF_DEP
-};
-
-#define MLB150_DBR_BUF_START 0x00000
-
-#define MLB150_CDT_LEN			(16)
-#define MLB150_ADT_LEN			(16)
-#define MLB150_CAT_LEN			(2)
-
-#define MLB150_CDT_SZ		(MLB150_CDT_LEN * MLB150_LOGIC_CH_NUM)
-#define MLB150_ADT_SZ		(MLB150_ADT_LEN * MLB150_LOGIC_CH_NUM)
-#define MLB150_CAT_SZ		(MLB150_CAT_LEN * MLB150_LOGIC_CH_NUM * 2)
-
-#define MLB150_CDT_BASE(base)		(base + MLB150_BUF_CDT_OFFSET)
-#define MLB150_ADT_BASE(base)		(base + MLB150_BUF_ADT_OFFSET)
-#define MLB150_CAT_MLB_BASE(base)	(base + MLB150_BUF_CAT_MLB_OFFSET)
-#define MLB150_CAT_HBI_BASE(base)	(base + MLB150_BUF_CAT_HBI_OFFSET)
-
-#define MLB150_CDTn_ADDR(base, n)	(base + MLB150_BUF_CDT_OFFSET + n * MLB150_CDT_LEN)
-#define MLB150_ADTn_ADDR(base, n)	(base + MLB150_BUF_ADT_OFFSET + n * MLB150_ADT_LEN)
-#define MLB150_CATn_MLB_ADDR(base, n)	(base + MLB150_BUF_CAT_MLB_OFFSET + n * MLB150_CAT_LEN)
-#define MLB150_CATn_HBI_ADDR(base, n)	(base + MLB150_BUF_CAT_HBI_OFFSET + n * MLB150_CAT_LEN)
+#define REG_MLBC0		0x0
+#define MLBC0_MLBEN		(0x1)
+#define MLBC0_MLBCLK_MASK	(0x7 << 2)
+#define MLBC0_MLBCLK_SHIFT	(2)
+#define MLBC0_MLBPEN		(0x1 << 5)
+#define MLBC0_MLBLK		(0x1 << 7)
+#define MLBC0_ASYRETRY		(0x1 << 12)
+#define MLBC0_CTLRETRY		(0x1 << 12)
+#define MLBC0_FCNT_MASK		(0x7 << 15)
+#define MLBC0_FCNT_SHIFT	(15)
+
+#define REG_MLBPC0		0x8
+#define MLBPC0_MCLKHYS		(0x1 << 11)
+
+#define REG_MS0			0xC
+#define REG_MS1			0x14
+
+#define REG_MSS			0x20
+#define MSS_RSTSYSCMD		(0x1)
+#define MSS_LKSYSCMD		(0x1 << 1)
+#define MSS_ULKSYSCMD		(0x1 << 2)
+#define MSS_CSSYSCMD		(0x1 << 3)
+#define MSS_SWSYSCMD		(0x1 << 4)
+#define MSS_SERVREQ		(0x1 << 5)
+
+#define REG_MSD			0x24
+
+#define REG_MIEN		0x2C
+#define MIEN_ISOC_PE		(0x1)
+#define MIEN_ISOC_BUFO		(0x1 << 1)
+#define MIEN_SYNC_PE		(0x1 << 16)
+#define MIEN_ARX_DONE		(0x1 << 17)
+#define MIEN_ARX_PE		(0x1 << 18)
+#define MIEN_ARX_BREAK		(0x1 << 19)
+#define MIEN_ATX_DONE		(0x1 << 20)
+#define MIEN_ATX_PE		(0x1 << 21)
+#define MIEN_ATX_BREAK		(0x1 << 22)
+#define MIEN_CRX_DONE		(0x1 << 24)
+#define MIEN_CRX_PE		(0x1 << 25)
+#define MIEN_CRX_BREAK		(0x1 << 26)
+#define MIEN_CTX_DONE		(0x1 << 27)
+#define MIEN_CTX_PE		(0x1 << 28)
+#define MIEN_CTX_BREAK		(0x1 << 29)
+
+#define REG_MLBPC2		0x34
+#define REG_MLBPC1		0x38
+#define MLBPC1_VAL		(0x00000888)
+
+#define REG_MLBC1		0x3C
+#define MLBC1_LOCK		(0x1 << 6)
+#define MLBC1_CLKM		(0x1 << 7)
+#define MLBC1_NDA_MASK		(0xFF << 8)
+#define MLBC1_NDA_SHIFT		(8)
+
+#define REG_HCTL		0x80
+#define HCTL_RST0		(0x1)
+#define HCTL_RST1		(0x1 << 1)
+#define HCTL_EN			(0x1 << 15)
+
+#define REG_HCMR0		0x88
+#define REG_HCMR1		0x8C
+#define REG_HCER0		0x90
+#define REG_HCER1		0x94
+#define REG_HCBR0		0x98
+#define REG_HCBR1		0x9C
+
+#define REG_MDAT0		0xC0
+#define REG_MDAT1		0xC4
+#define REG_MDAT2		0xC8
+#define REG_MDAT3		0xCC
+
+#define REG_MDWE0		0xD0
+#define REG_MDWE1		0xD4
+#define REG_MDWE2		0xD8
+#define REG_MDWE3		0xDC
+
+#define REG_MCTL		0xE0
+#define MCTL_XCMP		(0x1)
+
+#define REG_MADR		0xE4
+#define MADR_WNR		(0x1 << 31)
+#define MADR_TB			(0x1 << 30)
+#define MADR_ADDR_MASK		(0x7f << 8)
+#define MADR_ADDR_SHIFT		(0)
+
+#define REG_ACTL		0x3C0
+#define ACTL_MPB		(0x1 << 4)
+#define ACTL_DMAMODE		(0x1 << 2)
+#define ACTL_SMX		(0x1 << 1)
+#define ACTL_SCE		(0x1)
+
+#define REG_ACSR0		0x3D0
+#define REG_ACSR1		0x3D4
+#define REG_ACMR0		0x3D8
+#define REG_ACMR1		0x3DC
+
+#define REG_CAT_MDATn(ch) (REG_MDAT0 + ((ch % 8) >> 1) * 4)
+#define REG_CAT_MDWEn(ch) (REG_MDWE0 + ((ch % 8) >> 1) * 4)
+
+#define INT_AHB0_CH_START	(0)
+#define INT_AHB1_CH_START	(32)
+
+#define LOGIC_CH_NUM		(64)
+#define BUF_CDT_OFFSET		(0x0)
+#define BUF_ADT_OFFSET		(0x40)
+#define BUF_CAT_MLB_OFFSET	(0x80)
+#define BUF_CAT_HBI_OFFSET	(0x88)
+#define BUF_CTR_END_OFFSET	(0x8F)
+
+#define CAT_MODE_RX		(0x1 << 0)
+#define CAT_MODE_TX		(0x1 << 1)
+#define CAT_MODE_INBOUND_DMA	(0x1 << 8)
+#define CAT_MODE_OUTBOUND_DMA	(0x1 << 9)
+
+#define CH_SYNC_DEFAULT_QUAD	(1)
+#define CH_SYNC_MAX_QUAD	(15)
+#define CH_SYNC_CDT_BUF_DEP	(CH_SYNC_DEFAULT_QUAD * 4 * 4)
+#define CH_SYNC_ADT_BUF_MULTI	(4)
+#define CH_SYNC_ADT_BUF_DEP	(CH_SYNC_CDT_BUF_DEP * CH_SYNC_ADT_BUF_MULTI)
+#define CH_SYNC_BUF_SZ		(CH_SYNC_MAX_QUAD * 4 * 4 * CH_SYNC_ADT_BUF_MULTI)
+#define CH_CTRL_CDT_BUF_DEP	(64)
+#define CH_CTRL_ADT_BUF_DEP	(CH_CTRL_CDT_BUF_DEP)
+#define CH_CTRL_BUF_SZ		(CH_CTRL_ADT_BUF_DEP)
+#define CH_ASYNC_MDP_PACKET_LEN	(1024)
+#define CH_ASYNC_MEP_PACKET_LEN	(1536)
+#define CH_ASYNC_CDT_BUF_DEP	(CH_ASYNC_MEP_PACKET_LEN)
+#define CH_ASYNC_ADT_BUF_DEP	(CH_ASYNC_CDT_BUF_DEP)
+#define CH_ASYNC_BUF_SZ		(CH_ASYNC_ADT_BUF_DEP)
+#define CH_ISOC_BLK_SIZE_188	(188)
+#define CH_ISOC_BLK_SIZE_196	(196)
+#define CH_ISOC_BLK_SIZE	(CH_ISOC_BLK_SIZE_188)
+#define CH_ISOC_BLK_NUM		(5)
+#define CH_ISOC_CDT_BUF_DEP	(CH_ISOC_BLK_SIZE * CH_ISOC_BLK_NUM)
+#define CH_ISOC_ADT_BUF_DEP	(CH_ISOC_CDT_BUF_DEP)
+#define CH_ISOC_BUF_SZ		(1024)
+
+#define CH_SYNC_DBR_BUF_OFFSET	(0x0)
+#define CH_CTRL_DBR_BUF_OFFSET	(CH_SYNC_DBR_BUF_OFFSET + 2 * (CH_SYNC_MAX_QUAD * 4 * 4))
+#define CH_ASYNC_DBR_BUF_OFFSET	(CH_CTRL_DBR_BUF_OFFSET + 2 * CH_CTRL_CDT_BUF_DEP)
+#define CH_ISOC_DBR_BUF_OFFSET	(CH_ASYNC_DBR_BUF_OFFSET + 2 * CH_ASYNC_CDT_BUF_DEP)
+
+#define DBR_BUF_START 0x00000
+
+#define CDT_LEN			(16)
+#define ADT_LEN			(16)
+#define CAT_LEN			(2)
+
+#define CDT_SZ			(CDT_LEN * LOGIC_CH_NUM)
+#define ADT_SZ			(ADT_LEN * LOGIC_CH_NUM)
+#define CAT_SZ			(CAT_LEN * LOGIC_CH_NUM * 2)
+
+#define CDT_BASE(base)		(base + BUF_CDT_OFFSET)
+#define ADT_BASE(base)		(base + BUF_ADT_OFFSET)
+#define CAT_MLB_BASE(base)	(base + BUF_CAT_MLB_OFFSET)
+#define CAT_HBI_BASE(base)	(base + BUF_CAT_HBI_OFFSET)
+
+#define CDTn_ADDR(base, n)	(base + BUF_CDT_OFFSET + n * CDT_LEN)
+#define ADTn_ADDR(base, n)	(base + BUF_ADT_OFFSET + n * ADT_LEN)
+#define CATn_MLB_ADDR(base, n)	(base + BUF_CAT_MLB_OFFSET + n * CAT_LEN)
+#define CATn_HBI_ADDR(base, n)	(base + BUF_CAT_HBI_OFFSET + n * CAT_LEN)
 
 #define CAT_CL_SHIFT		(0x0)
 #define CAT_CT_SHIFT		(8)
@@ -246,11 +258,6 @@ static u32 mlb150_ch_packet_buf_size[4] = {
 #define ADT_MEP1		(0x1 << 11)
 #define ADT_MEP2		(0x1 << 27)
 
-#define MLB_CONTROL_TX_CHANN	(0 << 4)
-#define MLB_CONTROL_RX_CHANN	(1 << 4)
-#define MLB_ASYNC_TX_CHANN	(2 << 4)
-#define MLB_ASYNC_RX_CHANN	(3 << 4)
-
 #define MLB_MINOR_DEVICES	4
 #define MLB_CONTROL_DEV_NAME	"ctrl"
 #define MLB_ASYNC_DEV_NAME	"async"
@@ -259,16 +266,8 @@ static u32 mlb150_ch_packet_buf_size[4] = {
 
 #define TX_CHANNEL		0
 #define RX_CHANNEL		1
-#define PING_BUF_MAX_SIZE	(2 * 1024)
-#define PONG_BUF_MAX_SIZE	(2 * 1024)
-/* max package data size */
-#define ASYNC_PACKET_SIZE	1024
-#define CTRL_PACKET_SIZE	64
-#define TRANS_RING_NODES	10
 
-#define MLB_IRAM_SIZE		(MLB_MINOR_DEVICES * (PING_BUF_MAX_SIZE + PONG_BUF_MAX_SIZE))
-#define _get_txchan(dev)	mlb_devinfo[dev].channels[TX_CHANNEL]
-#define _get_rxchan(dev)	mlb_devinfo[dev].channels[RX_CHANNEL]
+#define TRANS_RING_NODES	(1 << 3)
 
 enum MLB_CTYPE {
 	MLB_CTYPE_SYNC,
@@ -277,71 +276,34 @@ enum MLB_CTYPE {
 	MLB_CTYPE_ISOC,
 };
 
-enum MLB150_CLK_SPEED {
-	MLB150_CLK_256FS,
-	MLB150_CLK_512FS,
-	MLB150_CLK_1024FS,
-	MLB150_CLK_2048FS,
-	MLB150_CLK_3072FS,
-	MLB150_CLK_4096FS,
-	MLB150_CLK_6144FS,
-	MLB150_CLK_8192FS,
+enum CLK_SPEED {
+	CLK_256FS,
+	CLK_512FS,
+	CLK_1024FS,
+	CLK_2048FS,
+	CLK_3072FS,
+	CLK_4096FS,
+	CLK_6144FS,
+	CLK_8192FS,
 };
 
-/*!
- * Ring buffer
- */
-#define MLB_RING_BUF_INIT(r)	{	\
-	r->wpos = 0;	\
-	r->rpos = 0;	\
-}
-
-#define MLB_RING_BUF_IS_FULL(r) (((r->wpos + 1) % TRANS_RING_NODES) == r->rpos)
-#define MLB_RING_BUF_IS_EMPTY(r) (r->rpos == r->wpos)
-#define MLB_RING_BUF_ENQUE(r, buf) {	\
-	memcpy(r->node[r->wpos].data, buf, r->node.size);	\
-	r->wpos = (r->wpos + 1) % TRANS_RING_NODES;	\
-}
-#define MLB_RING_BUF_DEQUE(r, buf) {	\
-	memcpy(buf, r->node[r->rpos].data, r->node.size);	\
-	r->rpos = (r->rpos + 1) % TRANS_RING_NODES;	\
-}
-
 struct mlb_ringbuf {
-	u32 wpos;
-	u32 rpos;
-	u32 size;
-	/* Last buffer is for package drop */
-	u8  *virt_bufs[TRANS_RING_NODES + 1];
-	u32 phy_addrs[TRANS_RING_NODES + 1];
+	s8 *virt_bufs[TRANS_RING_NODES];
+	u32 phy_addrs[TRANS_RING_NODES];
+	s32 head;
+	s32 tail;
+	s32 unit_size;
+	s32 total_size;
+	rwlock_t rb_lock ____cacheline_aligned; /* ring index lock */
 };
 
 struct mlb_channel_info {
-
-	/* channel address */
-	s32 address;
+	/* Input MLB channel address */
+	u32 address;
+	/* Internal AHB channel label */
+	u32 cl;
 	/* DBR buf head */
 	u32 dbr_buf_head;
-	/* ping buffer head */
-	u32 ping_buf_head;
-	/* pong buffer head */
-	u32 pong_buf_head;
-	/* ping buffer physical head */
-	u32 ping_phy_head;
-	/* pong buffer physical head */
-	u32 pong_phy_head;
-	/* channel buffer size */
-	u32 buf_size;
-	/* channel buffer current ptr */
-	u32 buf_ptr;
-	/* channel buffer phy addr */
-	u32 buf_phy_addr;
-	/* packet start indicator */
-	u32 ps_ind;
-	/* packet remain size */
-	u32 pkt_remain_size;
-	/* buffer spin lock */
-	rwlock_t buf_lock;
 };
 
 struct mlb_dev_info {
@@ -351,11 +313,14 @@ struct mlb_dev_info {
 	/* channel type */
 	const unsigned int channel_type;
 	/* ch fps */
-	enum MLB150_CLK_SPEED fps;
+	enum CLK_SPEED fps;
 	/* channel info for tx/rx */
 	struct mlb_channel_info channels[2];
-	/* rx ring buffer */
-	struct mlb_ringbuf rx_bufs;
+	/* ring buffer */
+	u8 *rbuf_base_virt;
+	u32 rbuf_base_phy;
+	struct mlb_ringbuf rx_rbuf;
+	struct mlb_ringbuf tx_rbuf;
 	/* exception event */
 	unsigned long ex_event;
 	/* tx busy indicator */
@@ -365,37 +330,109 @@ struct mlb_dev_info {
 	/* device open count */
 	atomic_t opencnt;
 	/* wait queue head for channel */
-	wait_queue_head_t rd_wq;
-	wait_queue_head_t wt_wq;
+	wait_queue_head_t rx_wq;
+	wait_queue_head_t tx_wq;
+	/* TX OK */
+	s32 tx_ok;
 	/* spinlock for event access */
 	spinlock_t event_lock;
+	/* Block size for isoc mode
+	 * This variable can be configured in ioctl */
+	u32 isoc_blksz;
+	/* Quads number for sync mode
+	 * This variable can be confifured in ioctl */
+	u32 sync_quad;
+	/* Buffer depth in cdt */
+	u32 cdt_buf_dep;
+	/* Buffer depth in adt */
+	u32 adt_buf_dep;
+	/* Buffer size to hold data */
+	u32 buf_size;
+};
+
+struct mlb_data {
+	struct mlb_dev_info *devinfo;
+	struct clk *clk_mlb3p;
+	struct clk *clk_mlb6p;
+	struct cdev cdev;
+	struct class *class;	/* device class */
+	dev_t firstdev;
+#ifdef CONFIG_REGULATOR
+	struct regulator *nvcc;
+#endif
+	u32 membase;	/* mlb module base address */
+	u32 irq_ahb0;
+	u32 irq_ahb1;
+	u32 irq_mlb;
 };
 
+/* For optimization, we use fixed channel label for
+ * input channels of each mode */
+/* SYNC: CL = 0 for RX, CL = 64 for TX
+ * CTRL: CL = 1 for RX, CL = 65 for TX
+ * ASYNC: CL = 2 for RX, CL = 66 for TX
+ * ISOC: CL = 3 for RX, CL = 67 for TX
+ * */
+#define SYNC_RX_CL_AHB0		0
+#define CTRL_RX_CL_AHB0		1
+#define ASYNC_RX_CL_AHB0	2
+#define ISOC_RX_CL_AHB0		3
+#define SYNC_TX_CL_AHB0		4
+#define CTRL_TX_CL_AHB0		5
+#define ASYNC_TX_CL_AHB0	6
+#define ISOC_TX_CL_AHB0		7
+
+#define SYNC_RX_CL_AHB1		32
+#define CTRL_RX_CL_AHB1		33
+#define ASYNC_RX_CL_AHB1	34
+#define ISOC_RX_CL_AHB1		35
+#define SYNC_TX_CL_AHB1		36
+#define CTRL_TX_CL_AHB1		37
+#define ASYNC_TX_CL_AHB1	38
+#define ISOC_TX_CL_AHB1		39
+
+#define SYNC_RX_CL	SYNC_RX_CL_AHB0
+#define CTRL_RX_CL	CTRL_RX_CL_AHB0
+#define ASYNC_RX_CL	ASYNC_RX_CL_AHB0
+#define ISOC_RX_CL	ISOC_RX_CL_AHB0
+
+#define SYNC_TX_CL	SYNC_TX_CL_AHB0
+#define CTRL_TX_CL	CTRL_TX_CL_AHB0
+#define ASYNC_TX_CL	ASYNC_TX_CL_AHB0
+#define ISOC_TX_CL	ISOC_TX_CL_AHB0
+
 static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	{
 	.dev_name = MLB_SYNC_DEV_NAME,
 	.channel_type = MLB_CTYPE_SYNC,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_SYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_SYNC_DBR_BUF_OFFSET,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[0].channels[0].
-					buf_lock),
+			.cl = SYNC_TX_CL,
+			.dbr_buf_head = CH_SYNC_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_SYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_SYNC_DBR_BUF_OFFSET
-					+ MLB150_CH_SYNC_BUF_DEP,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[0].channels[1].
-					buf_lock),
+			.cl = SYNC_RX_CL,
+			.dbr_buf_head = CH_SYNC_DBR_BUF_OFFSET
+					+ CH_SYNC_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_SYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[0].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_SYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[0].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_SYNC_CDT_BUF_DEP,
+	.adt_buf_dep = CH_SYNC_ADT_BUF_DEP,
+	.buf_size = CH_SYNC_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[0].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[0].event_lock),
 	},
 	{
@@ -403,25 +440,32 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	.channel_type = MLB_CTYPE_CTRL,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_CTRL_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_CTRL_DBR_BUF_OFFSET,
-			.buf_lock =
-			__RW_LOCK_UNLOCKED(mlb_devinfo[1].channels[0].
-					buf_lock),
+			.cl = CTRL_TX_CL,
+			.dbr_buf_head = CH_CTRL_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_CTRL_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_CTRL_DBR_BUF_OFFSET
-					+ MLB150_CH_CTRL_BUF_DEP,
-			.buf_lock =
-			__RW_LOCK_UNLOCKED(mlb_devinfo[1].channels[1].
-					buf_lock),
+			.cl = CTRL_RX_CL,
+			.dbr_buf_head = CH_CTRL_DBR_BUF_OFFSET
+					+ CH_CTRL_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_CTRL_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[1].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_CTRL_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[1].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_CTRL_CDT_BUF_DEP,
+	.adt_buf_dep = CH_CTRL_ADT_BUF_DEP,
+	.buf_size = CH_CTRL_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[1].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[1].event_lock),
 	},
 	{
@@ -429,25 +473,32 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	.channel_type = MLB_CTYPE_ASYNC,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_ASYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ASYNC_DBR_BUF_OFFSET,
-			.buf_lock =
-			__RW_LOCK_UNLOCKED(mlb_devinfo[2].channels[0].
-					buf_lock),
+			.cl = ASYNC_TX_CL,
+			.dbr_buf_head = CH_ASYNC_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_ASYNC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ASYNC_DBR_BUF_OFFSET
-					+ MLB150_CH_ASYNC_BUF_DEP,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[2].channels[1].
-					buf_lock),
+			.cl = ASYNC_RX_CL,
+			.dbr_buf_head = CH_ASYNC_DBR_BUF_OFFSET
+					+ CH_ASYNC_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_ASYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[2].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_ASYNC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[2].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_ASYNC_CDT_BUF_DEP,
+	.adt_buf_dep = CH_ASYNC_ADT_BUF_DEP,
+	.buf_size = CH_ASYNC_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[2].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[2].event_lock),
 	},
 	{
@@ -455,171 +506,98 @@ static struct mlb_dev_info mlb_devinfo[MLB_MINOR_DEVICES] = {
 	.channel_type = MLB_CTYPE_ISOC,
 	.channels = {
 		[0] = {
-			.buf_size = MLB150_CH_ISOC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ISOC_DBR_BUF_OFFSET,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[3].channels[0].
-					buf_lock),
+			.cl = ISOC_TX_CL,
+			.dbr_buf_head = CH_ISOC_DBR_BUF_OFFSET,
 		},
 		[1] = {
-			.buf_size = MLB150_CH_ISOC_BUF_DEP,
-			.dbr_buf_head = MLB150_CH_ISOC_DBR_BUF_OFFSET
-					+ MLB150_CH_ISOC_BUF_DEP,
-			.buf_lock =
-				__RW_LOCK_UNLOCKED(mlb_devinfo[3].channels[1].
-					buf_lock),
+			.cl = ISOC_RX_CL,
+			.dbr_buf_head = CH_ISOC_DBR_BUF_OFFSET
+					+ CH_ISOC_BUF_SZ,
 		},
 	},
+	.rx_rbuf = {
+		.unit_size = CH_ISOC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[3].rx_rbuf.rb_lock),
+	},
+	.tx_rbuf = {
+		.unit_size = CH_ISOC_BUF_SZ,
+		.rb_lock =
+			__RW_LOCK_UNLOCKED(mlb_devinfo[3].tx_rbuf.rb_lock),
+	},
+	.cdt_buf_dep = CH_ISOC_CDT_BUF_DEP,
+	.adt_buf_dep = CH_ISOC_ADT_BUF_DEP,
+	.buf_size = CH_ISOC_BUF_SZ,
 	.on = ATOMIC_INIT(0),
 	.opencnt = ATOMIC_INIT(0),
-	.rd_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].rd_wq),
-	.wt_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].wt_wq),
+	.rx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].rx_wq),
+	.tx_wq = __WAIT_QUEUE_HEAD_INITIALIZER(mlb_devinfo[3].tx_wq),
 	.event_lock = __SPIN_LOCK_UNLOCKED(mlb_devinfo[3].event_lock),
+	.isoc_blksz = CH_ISOC_BLK_SIZE_188,
 	},
 };
 
-static struct regulator *reg_nvcc;	/* NVCC_MLB regulator */
-static struct clk *mlb_clk;
-static struct clk *mlb_pll_clk;
-static dev_t dev;
-static struct class *mlb_class;	/* device class */
-static struct device *class_dev;
-static u32 mlb_base;	/* mlb module base address */
-static u32 ahb0_irq, ahb1_irq, mlb_irq;
+static u32 mlb_base;
 
 DEFINE_SPINLOCK(ctr_lock);
 
 #ifdef DEBUG
-
 #define DUMP_REG(reg) pr_debug(#reg": 0x%08x\n", __raw_readl(mlb_base + reg))
 
 static void mlb150_dev_dump_reg(void)
 {
 	pr_debug("mxc_mlb150: Dump registers:\n");
-	DUMP_REG(MLB150_REG_MLBC0);
-	DUMP_REG(MLB150_REG_MLBPC0);
-	DUMP_REG(MLB150_REG_MS0);
-	DUMP_REG(MLB150_REG_MS1);
-	DUMP_REG(MLB150_REG_MSS);
-	DUMP_REG(MLB150_REG_MSD);
-	DUMP_REG(MLB150_REG_MIEN);
-	DUMP_REG(MLB150_REG_MLBPC2);
-	DUMP_REG(MLB150_REG_MLBPC1);
-	DUMP_REG(MLB150_REG_MLBC1);
-	DUMP_REG(MLB150_REG_HCTL);
-	DUMP_REG(MLB150_REG_HCMR0);
-	DUMP_REG(MLB150_REG_HCMR1);
-	DUMP_REG(MLB150_REG_HCER0);
-	DUMP_REG(MLB150_REG_HCER1);
-	DUMP_REG(MLB150_REG_HCBR0);
-	DUMP_REG(MLB150_REG_HCBR1);
-	DUMP_REG(MLB150_REG_MDAT0);
-	DUMP_REG(MLB150_REG_MDAT1);
-	DUMP_REG(MLB150_REG_MDAT2);
-	DUMP_REG(MLB150_REG_MDAT3);
-	DUMP_REG(MLB150_REG_MDWE0);
-	DUMP_REG(MLB150_REG_MDWE1);
-	DUMP_REG(MLB150_REG_MDWE2);
-	DUMP_REG(MLB150_REG_MDWE3);
-	DUMP_REG(MLB150_REG_MCTL);
-	DUMP_REG(MLB150_REG_MADR);
-	DUMP_REG(MLB150_REG_ACTL);
-	DUMP_REG(MLB150_REG_ACSR0);
-	DUMP_REG(MLB150_REG_ACSR1);
-	DUMP_REG(MLB150_REG_ACMR0);
-	DUMP_REG(MLB150_REG_ACMR1);
+	DUMP_REG(REG_MLBC0);
+	DUMP_REG(REG_MLBPC0);
+	DUMP_REG(REG_MS0);
+	DUMP_REG(REG_MS1);
+	DUMP_REG(REG_MSS);
+	DUMP_REG(REG_MSD);
+	DUMP_REG(REG_MIEN);
+	DUMP_REG(REG_MLBPC2);
+	DUMP_REG(REG_MLBPC1);
+	DUMP_REG(REG_MLBC1);
+	DUMP_REG(REG_HCTL);
+	DUMP_REG(REG_HCMR0);
+	DUMP_REG(REG_HCMR1);
+	DUMP_REG(REG_HCER0);
+	DUMP_REG(REG_HCER1);
+	DUMP_REG(REG_HCBR0);
+	DUMP_REG(REG_HCBR1);
+	DUMP_REG(REG_MDAT0);
+	DUMP_REG(REG_MDAT1);
+	DUMP_REG(REG_MDAT2);
+	DUMP_REG(REG_MDAT3);
+	DUMP_REG(REG_MDWE0);
+	DUMP_REG(REG_MDWE1);
+	DUMP_REG(REG_MDWE2);
+	DUMP_REG(REG_MDWE3);
+	DUMP_REG(REG_MCTL);
+	DUMP_REG(REG_MADR);
+	DUMP_REG(REG_ACTL);
+	DUMP_REG(REG_ACSR0);
+	DUMP_REG(REG_ACSR1);
+	DUMP_REG(REG_ACMR0);
+	DUMP_REG(REG_ACMR1);
 }
 
 static void mlb150_dev_dump_hex(const u8 *buf, u32 len)
 {
-	u32 i, remain, round_len;
-
-	pr_debug("buf: 0x%08x, len: %d\n", (u32)buf, len);
-	remain = len & 0x7;
-	round_len = len - remain;
-	for (i = 0; i < round_len; i += 8) {
-		pr_debug("%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			*(buf + i),
-			*(buf + i + 1),
-			*(buf + i + 2),
-			*(buf + i + 3),
-			*(buf + i + 4),
-			*(buf + i + 5),
-			*(buf + i + 6),
-			*(buf + i + 7));
-	}
-
-	if (remain) {
-		i = round_len;
-		switch (remain) {
-		case 1:
-			pr_debug("%02x\n",
-				*(buf + i));
-			break;
-		case 2:
-			pr_debug("%02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1));
-			break;
-		case 3:
-			pr_debug("%02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2));
-			break;
-		case 4:
-			pr_debug("%02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3));
-			break;
-		case 5:
-			pr_debug("%02x %02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3),
-				*(buf + i + 4));
-			break;
-		case 6:
-			pr_debug("%02x %02x %02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3),
-				*(buf + i + 4),
-				*(buf + i + 5));
-			break;
-		case 7:
-			pr_debug("%02x %02x %02x %02x %02x %02x %02x\n",
-				*(buf + i),
-				*(buf + i + 1),
-				*(buf + i + 2),
-				*(buf + i + 3),
-				*(buf + i + 4),
-				*(buf + i + 5),
-				*(buf + i + 6));
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (i % 8 != 0)
-		pr_debug("\n");
+	print_hex_dump(KERN_DEBUG, "CTR DUMP:",
+			DUMP_PREFIX_OFFSET, 8, 1, buf, len, 0);
 }
 #endif
 
 static inline void mlb150_dev_enable_ctr_write(u32 mdat0_bits_en,
 		u32 mdat1_bits_en, u32 mdat2_bits_en, u32 mdat3_bits_en)
 {
-	__raw_writel(mdat0_bits_en, mlb_base + MLB150_REG_MDWE0);
-	__raw_writel(mdat1_bits_en, mlb_base + MLB150_REG_MDWE1);
-	__raw_writel(mdat2_bits_en, mlb_base + MLB150_REG_MDWE2);
-	__raw_writel(mdat3_bits_en, mlb_base + MLB150_REG_MDWE3);
+	__raw_writel(mdat0_bits_en, mlb_base + REG_MDWE0);
+	__raw_writel(mdat1_bits_en, mlb_base + REG_MDWE1);
+	__raw_writel(mdat2_bits_en, mlb_base + REG_MDWE2);
+	__raw_writel(mdat3_bits_en, mlb_base + REG_MDWE3);
 }
 
+#ifdef DEBUG
 static inline u8 mlb150_dev_dbr_read(u32 dbr_addr)
 {
 	s32 timeout = 1000;
@@ -627,20 +605,22 @@ static inline u8 mlb150_dev_dbr_read(u32 dbr_addr)
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(MLB150_MADR_TB | dbr_addr,
-		mlb_base + MLB150_REG_MADR);
+	__raw_writel(MADR_TB | dbr_addr,
+		mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(0 == timeout))
+	if (0 == timeout) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		return -ETIME;
+	}
 
-	dbr_val = __raw_readl(mlb_base + MLB150_REG_MDAT0) & 0x000000ff;
+	dbr_val = __raw_readl(mlb_base + REG_MDAT0) & 0x000000ff;
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
 	return dbr_val;
@@ -653,49 +633,76 @@ static inline s32 mlb150_dev_dbr_write(u32 dbr_addr, u8 dbr_val)
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(mdat0, mlb_base + MLB150_REG_MDAT0);
+	__raw_writel(mdat0, mlb_base + REG_MDAT0);
 
-	__raw_writel(MLB150_MADR_WNR | MLB150_MADR_TB | dbr_addr,
-			mlb_base + MLB150_REG_MADR);
+	__raw_writel(MADR_WNR | MADR_TB | dbr_addr,
+			mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(timeout <= 0))
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		return -ETIME;
+	}
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
 	return 0;
 }
 
+static inline s32 mlb150_dev_dbr_dump(u32 addr, u32 size)
+{
+	u8 *dump_buf = NULL;
+	u8 *buf_ptr = NULL;
+	s32 i;
+
+	dump_buf = kzalloc(size, GFP_KERNEL);
+	if (!dump_buf) {
+		pr_err("can't allocate enough memory\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0, buf_ptr = dump_buf;
+			i < size; ++i, ++buf_ptr)
+		*buf_ptr = mlb150_dev_dbr_read(addr + i);
+
+	mlb150_dev_dump_hex(dump_buf, size);
+
+	kfree(dump_buf);
+
+	return 0;
+}
+#endif
+
 static s32 mlb150_dev_ctr_read(u32 ctr_offset, u32 *ctr_val)
 {
 	s32 timeout = 1000;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(ctr_offset, mlb_base + MLB150_REG_MADR);
+	__raw_writel(ctr_offset, mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(timeout <= 0)) {
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		pr_debug("mxc_mlb150: Read CTR timeout\n");
 		return -ETIME;
 	}
 
-	ctr_val[0] = __raw_readl(mlb_base + MLB150_REG_MDAT0);
-	ctr_val[1] = __raw_readl(mlb_base + MLB150_REG_MDAT1);
-	ctr_val[2] = __raw_readl(mlb_base + MLB150_REG_MDAT2);
-	ctr_val[3] = __raw_readl(mlb_base + MLB150_REG_MDAT3);
+	ctr_val[0] = __raw_readl(mlb_base + REG_MDAT0);
+	ctr_val[1] = __raw_readl(mlb_base + REG_MDAT1);
+	ctr_val[2] = __raw_readl(mlb_base + REG_MDAT2);
+	ctr_val[3] = __raw_readl(mlb_base + REG_MDAT3);
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
@@ -709,25 +716,26 @@ static s32 mlb150_dev_ctr_write(u32 ctr_offset, const u32 *ctr_val)
 
 	spin_lock_irqsave(&ctr_lock, flags);
 
-	__raw_writel(ctr_val[0], mlb_base + MLB150_REG_MDAT0);
-	__raw_writel(ctr_val[1], mlb_base + MLB150_REG_MDAT1);
-	__raw_writel(ctr_val[2], mlb_base + MLB150_REG_MDAT2);
-	__raw_writel(ctr_val[3], mlb_base + MLB150_REG_MDAT3);
+	__raw_writel(ctr_val[0], mlb_base + REG_MDAT0);
+	__raw_writel(ctr_val[1], mlb_base + REG_MDAT1);
+	__raw_writel(ctr_val[2], mlb_base + REG_MDAT2);
+	__raw_writel(ctr_val[3], mlb_base + REG_MDAT3);
 
-	__raw_writel(MLB150_MADR_WNR | ctr_offset,
-			mlb_base + MLB150_REG_MADR);
+	__raw_writel(MADR_WNR | ctr_offset,
+			mlb_base + REG_MADR);
 
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
 			timeout--)
 		;
 
-	if (unlikely(timeout <= 0)) {
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
 		pr_debug("mxc_mlb150: Write CTR timeout\n");
 		return -ETIME;
 	}
 
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
+	__raw_writel(0, mlb_base + REG_MCTL);
 
 	spin_unlock_irqrestore(&ctr_lock, flags);
 
@@ -743,6 +751,13 @@ static s32 mlb150_dev_ctr_write(u32 ctr_offset, const u32 *ctr_val)
 				return 0;
 			else {
 				pr_debug("mxc_mlb150: ctr write failed\n");
+				pr_debug("offset: 0x%x\n", ctr_offset);
+				pr_debug("Write: 0x%x 0x%x 0x%x 0x%x\n",
+						ctr_val[3], ctr_val[2],
+						ctr_val[1], ctr_val[0]);
+				pr_debug("Read: 0x%x 0x%x 0x%x 0x%x\n",
+						ctr_rd[3], ctr_rd[2],
+						ctr_rd[1], ctr_rd[0]);
 				return -EBADE;
 			}
 		} else {
@@ -755,69 +770,88 @@ static s32 mlb150_dev_ctr_write(u32 ctr_offset, const u32 *ctr_val)
 	return 0;
 }
 
-static s32 mlb150_dev_get_adt_sts(u32 ch)
+#ifdef DEBUG
+static s32 mlb150_dev_cat_read(u32 ctr_offset, u32 ch, u16 *cat_val)
 {
-	s32 timeout = 1000;
-	unsigned long flags;
-	u32 reg;
-
-	spin_lock_irqsave(&ctr_lock, flags);
-	__raw_writel(MLB150_BUF_ADT_OFFSET + ch,
-			mlb_base + MLB150_REG_MADR);
-
-	while ((!(__raw_readl(mlb_base + MLB150_REG_MCTL)
-			& MLB150_MCTL_XCMP)) &&
-			timeout--)
-		;
+	u16 ctr_val[8] = { 0 };
 
-	if (unlikely(timeout <= 0)) {
-		pr_debug("mxc_mlb150: Read CTR timeout\n");
+	if (mlb150_dev_ctr_read(ctr_offset, (u32 *)ctr_val))
 		return -ETIME;
-	}
-
-	reg = __raw_readl(mlb_base + MLB150_REG_MDAT1);
-
-	__raw_writel(0, mlb_base + MLB150_REG_MCTL);
-	spin_unlock_irqrestore(&ctr_lock, flags);
 
-#ifdef DEBUG_ADT
-	pr_debug("mxc_mlb150: Get ch %d adt sts: 0x%08x\n", ch, reg);
-#endif
+	/*
+	 * Use u16 array to get u32 array value,
+	 * need to convert
+	 * */
+	cat_val = ctr_val[ch % 8];
 
-	return reg;
+	 return 0;
 }
+#endif
 
 static s32 mlb150_dev_cat_write(u32 ctr_offset, u32 ch, const u16 cat_val)
 {
 	u16 ctr_val[8] = { 0 };
 
-	if (unlikely(mlb150_dev_ctr_read(ctr_offset, (u32 *)ctr_val)))
+	if (mlb150_dev_ctr_read(ctr_offset, (u32 *)ctr_val))
 		return -ETIME;
 
 	ctr_val[ch % 8] = cat_val;
-	if (unlikely(mlb150_dev_ctr_write(ctr_offset, (u32 *)ctr_val)))
+	if (mlb150_dev_ctr_write(ctr_offset, (u32 *)ctr_val))
 		return -ETIME;
 
 	return 0;
 }
 
 #define mlb150_dev_cat_mlb_read(ch, cat_val)	\
-	mlb150_dev_cat_read(MLB150_BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_read(BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
 #define mlb150_dev_cat_mlb_write(ch, cat_val)	\
-	mlb150_dev_cat_write(MLB150_BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_write(BUF_CAT_MLB_OFFSET + (ch >> 3), ch, cat_val)
 #define mlb150_dev_cat_hbi_read(ch, cat_val)	\
-	mlb150_dev_cat_read(MLB150_BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_read(BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
 #define mlb150_dev_cat_hbi_write(ch, cat_val)	\
-	mlb150_dev_cat_write(MLB150_BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
+	mlb150_dev_cat_write(BUF_CAT_HBI_OFFSET + (ch >> 3), ch, cat_val)
 
 #define mlb150_dev_cdt_read(ch, cdt_val)	\
-	mlb150_dev_ctr_read(MLB150_BUF_CDT_OFFSET + ch, cdt_val)
+	mlb150_dev_ctr_read(BUF_CDT_OFFSET + ch, cdt_val)
 #define mlb150_dev_cdt_write(ch, cdt_val)	\
-	mlb150_dev_ctr_write(MLB150_BUF_CDT_OFFSET + ch, cdt_val)
+	mlb150_dev_ctr_write(BUF_CDT_OFFSET + ch, cdt_val)
 #define mlb150_dev_adt_read(ch, adt_val)	\
-	mlb150_dev_ctr_read(MLB150_BUF_ADT_OFFSET + ch, adt_val)
+	mlb150_dev_ctr_read(BUF_ADT_OFFSET + ch, adt_val)
 #define mlb150_dev_adt_write(ch, adt_val)	\
-	mlb150_dev_ctr_write(MLB150_BUF_ADT_OFFSET + ch, adt_val)
+	mlb150_dev_ctr_write(BUF_ADT_OFFSET + ch, adt_val)
+
+static s32 mlb150_dev_get_adt_sts(u32 ch)
+{
+	s32 timeout = 1000;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&ctr_lock, flags);
+	__raw_writel(BUF_ADT_OFFSET + ch,
+			mlb_base + REG_MADR);
+
+	while ((!(__raw_readl(mlb_base + REG_MCTL)
+			& MCTL_XCMP)) &&
+			timeout--)
+		;
+
+	if (timeout <= 0) {
+		spin_unlock_irqrestore(&ctr_lock, flags);
+		pr_debug("mxc_mlb150: Read CTR timeout\n");
+		return -ETIME;
+	}
+
+	reg = __raw_readl(mlb_base + REG_MDAT1);
+
+	__raw_writel(0, mlb_base + REG_MCTL);
+	spin_unlock_irqrestore(&ctr_lock, flags);
+
+#ifdef DEBUG_ADT
+	pr_debug("mxc_mlb150: Get ch %d adt sts: 0x%08x\n", ch, reg);
+#endif
+
+	return reg;
+}
 
 #ifdef DEBUG
 static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
@@ -826,8 +860,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	u32 ctr_val[4] = { 0 };
 
 	pr_debug("mxc_mlb150: CDT Table");
-	for (i = MLB150_BUF_CDT_OFFSET + ch_start;
-			i < MLB150_BUF_CDT_OFFSET + ch_end;
+	for (i = BUF_CDT_OFFSET + ch_start;
+			i < BUF_CDT_OFFSET + ch_end;
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -835,8 +869,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	}
 
 	pr_debug("mxc_mlb150: ADT Table");
-	for (i = MLB150_BUF_ADT_OFFSET + ch_start;
-			i < MLB150_BUF_ADT_OFFSET + ch_end;
+	for (i = BUF_ADT_OFFSET + ch_start;
+			i < BUF_ADT_OFFSET + ch_end;
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -844,8 +878,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	}
 
 	pr_debug("mxc_mlb150: CAT MLB Table");
-	for (i = MLB150_BUF_CAT_MLB_OFFSET + (ch_start >> 3);
-			i < MLB150_BUF_CAT_MLB_OFFSET + (ch_end >> 3) + 1;
+	for (i = BUF_CAT_MLB_OFFSET + (ch_start >> 3);
+			i <= BUF_CAT_MLB_OFFSET + ((ch_end + 8) >> 3);
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -853,8 +887,8 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
 	}
 
 	pr_debug("mxc_mlb150: CAT HBI Table");
-	for (i = MLB150_BUF_CAT_HBI_OFFSET + (ch_start >> 3);
-			i < MLB150_BUF_CAT_HBI_OFFSET + (ch_end >> 3) + 1;
+	for (i = BUF_CAT_HBI_OFFSET + (ch_start >> 3);
+			i <= BUF_CAT_HBI_OFFSET + ((ch_end + 8) >> 3);
 			++i) {
 		mlb150_dev_ctr_read(i, ctr_val);
 		pr_debug("CTR 0x%02x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
@@ -868,12 +902,25 @@ static void mlb150_dev_dump_ctr_tbl(u32 ch_start, u32 ch_end)
  */
 static inline s32 mlb150_dev_enable_dma_irq(u32 enable)
 {
+	u32 ch_rx_mask = (1 << SYNC_RX_CL_AHB0) | (1 << CTRL_RX_CL_AHB0)
+			| (1 << ASYNC_RX_CL_AHB0) | (1 << ISOC_RX_CL_AHB0)
+			| (1 << SYNC_TX_CL_AHB0) | (1 << CTRL_TX_CL_AHB0)
+			| (1 << ASYNC_TX_CL_AHB0) | (1 << ISOC_TX_CL_AHB0);
+	u32 ch_tx_mask = (1 << (SYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (SYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_TX_CL_AHB1 - INT_AHB1_CH_START));
+
 	if (enable) {
-		__raw_writel(0xffffffff, mlb_base + MLB150_REG_ACMR0);
-		__raw_writel(0xffffffff, mlb_base + MLB150_REG_ACMR1);
+		__raw_writel(ch_rx_mask, mlb_base + REG_ACMR0);
+		__raw_writel(ch_tx_mask, mlb_base + REG_ACMR1);
 	} else {
-		__raw_writel(0x0, mlb_base + MLB150_REG_ACMR0);
-		__raw_writel(0x0, mlb_base + MLB150_REG_ACMR1);
+		__raw_writel(0x0, mlb_base + REG_ACMR0);
+		__raw_writel(0x0, mlb_base + REG_ACMR1);
 	}
 
 	return 0;
@@ -892,10 +939,10 @@ static s32 mlb150_dev_init_ir_amba_ahb(void)
 	 * ACTL.SCE = 0, hardware clears on read
 	 * ACTL.SCE = 1, software writes a '1' to clear */
 	/* We only support DMA MODE 1 */
-	reg = __raw_readl(mlb_base + MLB150_REG_ACTL);
-	reg |= MLB150_ACTL_DMAMODE;
-#ifdef MLB150_MULTIPLE_PACKAGE_MODE
-	reg |= MLB150_REG_ACTL_MPB;
+	reg = __raw_readl(mlb_base + REG_ACTL);
+	reg |= ACTL_DMAMODE;
+#ifdef MULTIPLE_PACKAGE_MODE
+	reg |= REG_ACTL_MPB;
 #endif
 
 	/* Step 3. Select 1 or 2 interrupt signals:
@@ -903,11 +950,9 @@ static s32 mlb150_dev_init_ir_amba_ahb(void)
 	 *	and another interrupt for channels 32 - 63 on ahb_init[1]
 	 * ACTL.SMX = 1: singel interrupt all channels on ahb_init[0]
 	 * */
-	/*
-	reg |= MLB150_ACTL_SMX;
-	*/
+	reg &= ~ACTL_SMX;
 
-	__raw_writel(reg, mlb_base + MLB150_REG_ACTL);
+	__raw_writel(reg, mlb_base + REG_ACTL);
 
 	return 0;
 }
@@ -916,155 +961,111 @@ static inline s32 mlb150_dev_enable_ir_mlb(u32 enable)
 {
 	/* Step 1, Select the MSn to be cleared by software,
 	 * writing a '0' to the appropriate bits */
-	__raw_writel(0, mlb_base + MLB150_REG_MS0);
-	__raw_writel(0, mlb_base + MLB150_REG_MS1);
+	__raw_writel(0, mlb_base + REG_MS0);
+	__raw_writel(0, mlb_base + REG_MS1);
 
 	/* Step 1, Program MIEN to enable protocol error
 	 * interrupts for all active MLB channels */
 	if (enable)
-		__raw_writel(MLB150_MIEN_CTX_PE |
-			MLB150_MIEN_CRX_PE | MLB150_MIEN_ATX_PE |
-			MLB150_MIEN_ARX_PE | MLB150_MIEN_SYNC_PE |
-			MLB150_MIEN_ISOC_PE,
-			mlb_base + MLB150_REG_MIEN);
+		__raw_writel(MIEN_CTX_PE |
+			MIEN_CRX_PE | MIEN_ATX_PE |
+			MIEN_ARX_PE | MIEN_SYNC_PE |
+			MIEN_ISOC_PE,
+			mlb_base + REG_MIEN);
 	else
-		__raw_writel(0, mlb_base + MLB150_REG_MIEN);
+		__raw_writel(0, mlb_base + REG_MIEN);
 
 	return 0;
 }
 
-static inline int mlb150_enable_pll(void)
+static inline int mlb150_enable_pll(struct mlb_data *drvdata)
 {
 	u32 c0_val;
 
-	__raw_writel(MLB150_MLBPC1_VAL,
-			mlb_base + MLB150_REG_MLBPC1);
+	__raw_writel(MLBPC1_VAL,
+			drvdata->membase + REG_MLBPC1);
 
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-	if (c0_val & MLB150_MLBC0_MLBPEN) {
-		c0_val &= ~MLB150_MLBC0_MLBPEN;
+	c0_val = __raw_readl(drvdata->membase + REG_MLBC0);
+	if (c0_val & MLBC0_MLBPEN) {
+		c0_val &= ~MLBC0_MLBPEN;
 		__raw_writel(c0_val,
-				mlb_base + MLB150_REG_MLBC0);
+				drvdata->membase + REG_MLBC0);
 	}
 
-	clk_enable(mlb_pll_clk);
+	clk_enable(drvdata->clk_mlb6p);
 
-	c0_val |= (MLB150_MLBC0_MLBPEN);
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
+	c0_val |= (MLBC0_MLBPEN);
+	__raw_writel(c0_val, drvdata->membase + REG_MLBC0);
 
 	return 0;
 }
 
-static inline int mlb150_disable_pll(void)
+static inline int mlb150_disable_pll(struct mlb_data *drvdata)
 {
 	u32 c0_val;
 
-	clk_disable(mlb_pll_clk);
+	clk_disable(drvdata->clk_mlb6p);
 
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
+	c0_val = __raw_readl(drvdata->membase + REG_MLBC0);
 
-	__raw_writel(0x0, mlb_base + MLB150_REG_MLBPC1);
+	__raw_writel(0x0, drvdata->membase + REG_MLBPC1);
 
-	c0_val &= ~MLB150_MLBC0_MLBPEN;
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
+	c0_val &= ~MLBC0_MLBPEN;
+	__raw_writel(c0_val, drvdata->membase + REG_MLBC0);
 
 	return 0;
 }
 
-static void mlb150_dev_init(void)
-{
-	u32 c0_val, hctl_val;
-
-	/* Disable EN bits */
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-	c0_val &= ~MLB150_MLBC0_MLBEN;
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
-
-	hctl_val = __raw_readl(mlb_base + MLB150_REG_HCTL);
-	hctl_val &= ~MLB150_HCTL_EN;
-	__raw_writel(hctl_val, mlb_base + MLB150_REG_HCTL);
-
-	/* Step 1, Configure the MediaLB interface */
-	/* Select pin mode and clock, 3-pin and 256fs */
-	c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-	c0_val &= ~(MLB150_MLBC0_MLBPEN | MLB150_MLBC0_MLBCLK_MASK);
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
-
-	c0_val |= MLB150_MLBC0_MLBEN;
-	__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
-
-	/* Step 2, Configure the HBI interface */
-	__raw_writel(0xffffffff, mlb_base + MLB150_REG_HCMR0);
-	__raw_writel(0xffffffff, mlb_base + MLB150_REG_HCMR1);
-	__raw_writel(MLB150_HCTL_EN, mlb_base + MLB150_REG_HCTL);
-
-	mlb150_dev_init_ir_amba_ahb();
-
-	mlb150_dev_enable_ir_mlb(1);
-}
-
 static s32 mlb150_dev_reset_cdt(void)
 {
 	int i = 0;
 	u32 ctr_val[4] = { 0 };
 
-	for (i = 0; i < (MLB150_LOGIC_CH_NUM); ++i)
-		mlb150_dev_ctr_write(MLB150_BUF_CDT_OFFSET + i, ctr_val);
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+
+	for (i = 0; i < (LOGIC_CH_NUM); ++i)
+		mlb150_dev_ctr_write(BUF_CDT_OFFSET + i, ctr_val);
 
 	return 0;
 }
 
-static s32 mlb150_dev_init_ch_cdt(u32 ch, enum MLB_CTYPE ctype, u32 ch_func)
+static s32 mlb150_dev_init_ch_cdt(struct mlb_dev_info *pdevinfo, u32 ch,
+		enum MLB_CTYPE ctype, u32 ch_func)
 {
 	u32 cdt_val[4] = { 0 };
 
 	/* a. Set the 14-bit base address (BA) */
 	pr_debug("mxc_mlb150: ctype: %d, ch: %d, dbr_buf_head: 0x%08x",
-		ctype, ch, mlb_devinfo[ctype].channels[ch_func].dbr_buf_head);
-	cdt_val[3] = (mlb_devinfo[ctype].channels[ch_func].dbr_buf_head)
+		ctype, ch, pdevinfo->channels[ch_func].dbr_buf_head);
+	cdt_val[3] = (pdevinfo->channels[ch_func].dbr_buf_head)
 			<< CDT_BA_SHIFT;
 
 	/* b. Set the 12-bit or 13-bit buffer depth (BD)
 	 * BD = buffer depth in bytes - 1 */
-	switch (ctype) {
-	case MLB_CTYPE_SYNC:
-		/* For synchronous channels: (BD + 1) = 4 * m * bpf */
-		cdt_val[3] |= (MLB150_CH_SYNC_BUF_DEP - 1) << CDT_BD_SHIFT;
-		break;
-	case MLB_CTYPE_CTRL:
-		/* For control channels: (BD + 1) >= max packet length (64) */
-		/* BD */
-		cdt_val[3] |= ((MLB150_CH_CTRL_BUF_DEP - 1) << CDT_BD_SHIFT);
-		break;
-	case MLB_CTYPE_ASYNC:
-		/* For asynchronous channels: (BD + 1) >= max packet length
-		 * 1024 for a MOST Data packet (MDP);
-		 * 1536 for a MOST Ethernet Packet (MEP) */
-		cdt_val[3] |= ((MLB150_CH_ASYNC_BUF_DEP - 1) << CDT_BD_SHIFT);
-		break;
-	case MLB_CTYPE_ISOC:
-		/* For isochronous channels: (BD + 1) mod (BS + 1) = 0 */
-		/* BS */
-		cdt_val[1] |= (MLB150_CH_ISOC_BLK_SIZE - 1);
-		/* BD */
-		cdt_val[3] |= (MLB150_CH_ISOC_BUF_DEP - 1)
-				<< CDT_BD_SHIFT;
-		break;
-	default:
-		break;
-	}
+	/* For synchronous channels: (BD + 1) = 4 * m * bpf */
+	/* For control channels: (BD + 1) >= max packet length (64) */
+	/* For asynchronous channels: (BD + 1) >= max packet length
+	 * 1024 for a MOST Data packet (MDP);
+	 * 1536 for a MOST Ethernet Packet (MEP) */
+	/* For isochronous channels: (BD + 1) mod (BS + 1) = 0 */
+	/* BS */
+	if (MLB_CTYPE_ISOC == ctype)
+		cdt_val[1] |= (pdevinfo->isoc_blksz - 1);
+	/* BD */
+	cdt_val[3] |= (pdevinfo->cdt_buf_dep - 1) << CDT_BD_SHIFT;
 
 	pr_debug("mxc_mlb150: Set CDT val of channel %d, type: %d: "
 		"0x%08x 0x%08x 0x%08x 0x%08x\n",
 		ch, ctype, cdt_val[3], cdt_val[2], cdt_val[1], cdt_val[0]);
 
-	if (unlikely(mlb150_dev_cdt_write(ch, cdt_val)))
+	if (mlb150_dev_cdt_write(ch, cdt_val))
 		return -ETIME;
 
 #ifdef DEBUG_CTR
 	{
 		u32 cdt_rd[4] = { 0 };
-		if (likely(!mlb150_dev_cdt_read(ch, cdt_rd))) {
+		if (!mlb150_dev_cdt_read(ch, cdt_rd)) {
 			pr_debug("mxc_mlb150: CDT val of channel %d: "
 				"0x%08x 0x%08x 0x%08x 0x%08x\n",
 				ch, cdt_rd[3], cdt_rd[2], cdt_rd[1], cdt_rd[0]);
@@ -1089,31 +1090,32 @@ static s32 mlb150_dev_init_ch_cdt(u32 ch, enum MLB_CTYPE ctype, u32 ch_func)
 	return 0;
 }
 
-static s32 mlb150_dev_init_ch_cat(u32 ch, u32 cat_mode, enum MLB_CTYPE ctype)
+static s32 mlb150_dev_init_ch_cat(u32 ch, u32 cl,
+		u32 cat_mode, enum MLB_CTYPE ctype)
 {
 	u16 cat_val = 0;
 #ifdef DEBUG_CTR
 	u16 cat_rd = 0;
 #endif
 
-	cat_val = CAT_CE | (ctype << CAT_CT_SHIFT) | ch;
+	cat_val = CAT_CE | (ctype << CAT_CT_SHIFT) | cl;
 
-	if (cat_mode & MLB150_CAT_MODE_OUTBOUND_DMA)
+	if (cat_mode & CAT_MODE_OUTBOUND_DMA)
 		cat_val |= CAT_RNW;
 
 	if (MLB_CTYPE_SYNC == ctype)
 		cat_val |= CAT_MT;
 
-	pr_debug("mxc_mlb150: set CAT val of channel %d, type: %d: 0x%04x\n",
+	switch (cat_mode) {
+	case CAT_MODE_RX | CAT_MODE_INBOUND_DMA:
+	case CAT_MODE_TX | CAT_MODE_OUTBOUND_DMA:
+		pr_debug("mxc_mlb150: set CAT val of channel %d, type: %d: 0x%04x\n",
 			ch, ctype, cat_val);
 
-	switch (cat_mode) {
-	case MLB150_CAT_MODE_RX | MLB150_CAT_MODE_INBOUND_DMA:
-	case MLB150_CAT_MODE_TX | MLB150_CAT_MODE_OUTBOUND_DMA:
-		if (unlikely(mlb150_dev_cat_mlb_write(ch, cat_val)))
+		if (mlb150_dev_cat_mlb_write(ch, cat_val))
 			return -ETIME;
 #ifdef DEBUG_CTR
-		if (likely(!mlb150_dev_cat_mlb_read(ch, &cat_rd)))
+		if (!mlb150_dev_cat_mlb_read(ch, &cat_rd))
 			pr_debug("mxc_mlb150: CAT val of mlb channel %d: 0x%04x",
 					ch, cat_rd);
 		else {
@@ -1123,17 +1125,20 @@ static s32 mlb150_dev_init_ch_cat(u32 ch, u32 cat_mode, enum MLB_CTYPE ctype)
 		}
 #endif
 		break;
-	case MLB150_CAT_MODE_TX | MLB150_CAT_MODE_INBOUND_DMA:
-	case MLB150_CAT_MODE_RX | MLB150_CAT_MODE_OUTBOUND_DMA:
-		if (unlikely(mlb150_dev_cat_hbi_write(ch, cat_val)))
+	case CAT_MODE_TX | CAT_MODE_INBOUND_DMA:
+	case CAT_MODE_RX | CAT_MODE_OUTBOUND_DMA:
+		pr_debug("mxc_mlb150: set CAT val of channel %d, type: %d: 0x%04x\n",
+			cl, ctype, cat_val);
+
+		if (mlb150_dev_cat_hbi_write(cl, cat_val))
 			return -ETIME;
 #ifdef DEBUG_CTR
-		if (likely(!mlb150_dev_cat_hbi_read(ch, &cat_rd)))
+		if (!mlb150_dev_cat_hbi_read(cl, &cat_rd))
 			pr_debug("mxc_mlb150: CAT val of hbi channel %d: 0x%04x",
-					ch, cat_rd);
+					cl, cat_rd);
 		else {
 			pr_debug("mxc_mlb150: Read CAT of hbi channel %d failed\n",
-					ch);
+					cl);
 				return -EBADE;
 		}
 #endif
@@ -1161,37 +1166,43 @@ static s32 mlb150_dev_reset_cat(void)
 	int i = 0;
 	u32 ctr_val[4] = { 0 };
 
-	for (i = 0; i < (MLB150_LOGIC_CH_NUM >> 3); ++i) {
-		mlb150_dev_ctr_write(MLB150_BUF_CAT_MLB_OFFSET + i, ctr_val);
-		mlb150_dev_ctr_write(MLB150_BUF_CAT_HBI_OFFSET + i, ctr_val);
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+
+	for (i = 0; i < (LOGIC_CH_NUM >> 3); ++i) {
+		mlb150_dev_ctr_write(BUF_CAT_MLB_OFFSET + i, ctr_val);
+		mlb150_dev_ctr_write(BUF_CAT_HBI_OFFSET + i, ctr_val);
 	}
 
 	return 0;
 }
 
-static s32 mlb150_dev_init_rfb(u32 rx_ch, u32 tx_ch, enum MLB_CTYPE ctype)
+static s32 mlb150_dev_init_rfb(struct mlb_dev_info *pdevinfo, u32 rx_ch,
+		u32 tx_ch, enum MLB_CTYPE ctype)
 {
+	u32 rx_cl = pdevinfo->channels[RX_CHANNEL].cl;
+	u32 tx_cl = pdevinfo->channels[TX_CHANNEL].cl;
 	/* Step 1, Initialize all bits of CAT to '0' */
 	mlb150_dev_reset_cat();
 	mlb150_dev_reset_cdt();
 
 	/* Step 2, Initialize logical channel */
 	/* Step 3, Program the CDT for channel N */
-	mlb150_dev_init_ch_cdt(rx_ch, ctype, RX_CHANNEL);
-	mlb150_dev_init_ch_cdt(tx_ch, ctype, TX_CHANNEL);
+	mlb150_dev_init_ch_cdt(pdevinfo, rx_cl, ctype, RX_CHANNEL);
+	mlb150_dev_init_ch_cdt(pdevinfo, tx_cl, ctype, TX_CHANNEL);
 
 	/* Step 4&5, Program the CAT for the inbound and outbound DMA */
-	mlb150_dev_init_ch_cat(rx_ch,
-			MLB150_CAT_MODE_RX | MLB150_CAT_MODE_INBOUND_DMA,
+	mlb150_dev_init_ch_cat(rx_ch, rx_cl,
+			CAT_MODE_RX | CAT_MODE_INBOUND_DMA,
 			ctype);
-	mlb150_dev_init_ch_cat(rx_ch,
-			MLB150_CAT_MODE_RX | MLB150_CAT_MODE_OUTBOUND_DMA,
+	mlb150_dev_init_ch_cat(rx_ch, rx_cl,
+			CAT_MODE_RX | CAT_MODE_OUTBOUND_DMA,
 			ctype);
-	mlb150_dev_init_ch_cat(tx_ch,
-			MLB150_CAT_MODE_TX | MLB150_CAT_MODE_INBOUND_DMA,
+	mlb150_dev_init_ch_cat(tx_ch, tx_cl,
+			CAT_MODE_TX | CAT_MODE_INBOUND_DMA,
 			ctype);
-	mlb150_dev_init_ch_cat(tx_ch,
-			MLB150_CAT_MODE_TX | MLB150_CAT_MODE_OUTBOUND_DMA,
+	mlb150_dev_init_ch_cat(tx_ch, tx_cl,
+			CAT_MODE_TX | CAT_MODE_OUTBOUND_DMA,
 			ctype);
 
 	return 0;
@@ -1202,14 +1213,82 @@ static s32 mlb150_dev_reset_adt(void)
 	int i = 0;
 	u32 ctr_val[4] = { 0 };
 
-	for (i = 0; i < (MLB150_LOGIC_CH_NUM); ++i)
-		mlb150_dev_ctr_write(MLB150_BUF_ADT_OFFSET + i, ctr_val);
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+
+	for (i = 0; i < (LOGIC_CH_NUM); ++i)
+		mlb150_dev_ctr_write(BUF_ADT_OFFSET + i, ctr_val);
+
+	return 0;
+}
+
+static s32 mlb150_dev_reset_whole_ctr(void)
+{
+	mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
+			0xffffffff, 0xffffffff);
+	mlb150_dev_reset_cdt();
+	mlb150_dev_reset_adt();
+	mlb150_dev_reset_cat();
+
+	return 0;
+}
+
+#define CLR_REG(reg)  __raw_writel(0x0, mlb_base + reg)
+
+static s32 mlb150_dev_reset_all_regs(void)
+{
+	CLR_REG(REG_MLBC0);
+	CLR_REG(REG_MLBPC0);
+	CLR_REG(REG_MS0);
+	CLR_REG(REG_MS1);
+	CLR_REG(REG_MSS);
+	CLR_REG(REG_MSD);
+	CLR_REG(REG_MIEN);
+	CLR_REG(REG_MLBPC2);
+	CLR_REG(REG_MLBPC1);
+	CLR_REG(REG_MLBC1);
+	CLR_REG(REG_HCTL);
+	CLR_REG(REG_HCMR0);
+	CLR_REG(REG_HCMR1);
+	CLR_REG(REG_HCER0);
+	CLR_REG(REG_HCER1);
+	CLR_REG(REG_HCBR0);
+	CLR_REG(REG_HCBR1);
+	CLR_REG(REG_MDAT0);
+	CLR_REG(REG_MDAT1);
+	CLR_REG(REG_MDAT2);
+	CLR_REG(REG_MDAT3);
+	CLR_REG(REG_MDWE0);
+	CLR_REG(REG_MDWE1);
+	CLR_REG(REG_MDWE2);
+	CLR_REG(REG_MDWE3);
+	CLR_REG(REG_MCTL);
+	CLR_REG(REG_MADR);
+	CLR_REG(REG_ACTL);
+	CLR_REG(REG_ACSR0);
+	CLR_REG(REG_ACSR1);
+	CLR_REG(REG_ACMR0);
+	CLR_REG(REG_ACMR1);
 
 	return 0;
 }
 
-static inline s32 mlb150_dev_set_ch_amba_ahb(u32 ch, enum MLB_CTYPE ctype,
-					u32 dne_sts, u32 buf_addr)
+static inline s32 mlb150_dev_pipo_start(struct mlb_ringbuf *rbuf,
+						u32 ahb_ch, u32 buf_addr)
+{
+	u32 ctr_val[4] = { 0 };
+
+	ctr_val[1] |= ADT_RDY1;
+	ctr_val[2] = buf_addr;
+
+	if (mlb150_dev_adt_write(ahb_ch, ctr_val))
+		return -ETIME;
+
+	return 0;
+}
+
+static inline s32 mlb150_dev_pipo_next(u32 ahb_ch, enum MLB_CTYPE ctype,
+				u32 dne_sts, u32 buf_addr)
 {
 	u32 ctr_val[4] = { 0 };
 
@@ -1229,54 +1308,38 @@ static inline s32 mlb150_dev_set_ch_amba_ahb(u32 ch, enum MLB_CTYPE ctype,
 		ctr_val[2] = buf_addr;
 	}
 
-#ifdef DEBUG_ADT
-	pr_debug("mxc_mlb150: Set ADT val of channel %d, ctype: %d: "
-		"0x%08x 0x%08x 0x%08x 0x%08x\n",
-		ch, ctype, ctr_val[3], ctr_val[2], ctr_val[1], ctr_val[0]);
-#endif
-
-	if (unlikely(mlb150_dev_adt_write(ch, ctr_val)))
+	if (mlb150_dev_adt_write(ahb_ch, ctr_val))
 		return -ETIME;
 
-#ifdef DEBUG_ADT_N
-	{
-		u32 ctr_rd[4] = { 0 };
-		if (likely(!mlb150_dev_adt_read(ch, ctr_rd))) {
-			pr_debug("mxc_mlb150: ADT val of channel %d: "
-				"0x%08x 0x%08x 0x%08x 0x%08x\n",
-				ch, ctr_rd[3], ctr_rd[2],
-				ctr_rd[1], ctr_rd[0]);
-			if (ctr_rd[3] == ctr_val[3] &&
-				ctr_rd[2] == ctr_val[2] &&
-				ctr_rd[1] == ctr_val[1] &&
-				ctr_rd[0] == ctr_val[0]) {
-				pr_debug("mxc_mlb150: set adt succeed!\n");
-				return 0;
-			} else {
-				pr_debug("mxc_mlb150: set adt failed!\n");
-				return -EBADE;
-			}
-		} else {
-			pr_debug("mxc_mlb150: Read ADT val of channel %d failed\n",
-					ch);
-			return -EBADE;
-		}
-	}
-#endif
+	return 0;
+}
+
+static inline s32 mlb150_dev_pipo_stop(struct mlb_ringbuf *rbuf, u32 ahb_ch)
+{
+	u32 ctr_val[4] = { 0 };
+	unsigned long flags;
+
+	write_lock_irqsave(&rbuf->rb_lock, flags);
+	rbuf->head = rbuf->tail = 0;
+	write_unlock_irqrestore(&rbuf->rb_lock, flags);
 
-      return 0;
+	if (mlb150_dev_adt_write(ahb_ch, ctr_val))
+		return -ETIME;
+
+	return 0;
 }
 
-static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
+static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_dev_info *pdevinfo,
+					struct mlb_channel_info *chinfo,
 					enum MLB_CTYPE ctype)
 {
 	u32 ctr_val[4] = { 0 };
 
 	/* a. Set the 32-bit base address (BA1) */
-	ctr_val[3] = chinfo->pong_phy_head;
-	ctr_val[2] = chinfo->ping_phy_head;
-	ctr_val[1] = (chinfo->buf_size - 1) << ADT_BD1_SHIFT;
-	ctr_val[1] |= (chinfo->buf_size - 1) << ADT_BD2_SHIFT;
+	ctr_val[3] = 0;
+	ctr_val[2] = 0;
+	ctr_val[1] = (pdevinfo->adt_buf_dep - 1) << ADT_BD1_SHIFT;
+	ctr_val[1] |= (pdevinfo->adt_buf_dep - 1) << ADT_BD2_SHIFT;
 	if (MLB_CTYPE_ASYNC == ctype ||
 		MLB_CTYPE_CTRL == ctype) {
 		ctr_val[1] |= ADT_PS1;
@@ -1287,19 +1350,19 @@ static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
 
 	pr_debug("mxc_mlb150: Set ADT val of channel %d, ctype: %d: "
 		"0x%08x 0x%08x 0x%08x 0x%08x\n",
-		chinfo->address, ctype, ctr_val[3], ctr_val[2],
+		chinfo->cl, ctype, ctr_val[3], ctr_val[2],
 		ctr_val[1], ctr_val[0]);
 
-	if (unlikely(mlb150_dev_adt_write(chinfo->address, ctr_val)))
+	if (mlb150_dev_adt_write(chinfo->cl, ctr_val))
 		return -ETIME;
 
 #ifdef DEBUG_CTR
 	{
 		u32 ctr_rd[4] = { 0 };
-		if (likely(!mlb150_dev_adt_read(chinfo->address, ctr_rd))) {
+		if (!mlb150_dev_adt_read(chinfo->cl, ctr_rd)) {
 			pr_debug("mxc_mlb150: ADT val of channel %d: "
 				"0x%08x 0x%08x 0x%08x 0x%08x\n",
-				chinfo->address, ctr_rd[3], ctr_rd[2],
+				chinfo->cl, ctr_rd[3], ctr_rd[2],
 				ctr_rd[1], ctr_rd[0]);
 			if (ctr_rd[3] == ctr_val[3] &&
 				ctr_rd[2] == ctr_val[2] &&
@@ -1313,7 +1376,7 @@ static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
 			}
 		} else {
 			pr_debug("mxc_mlb150: Read ADT val of channel %d failed\n",
-					chinfo->address);
+					chinfo->cl);
 			return -EBADE;
 		}
 	}
@@ -1322,263 +1385,364 @@ static s32 mlb150_dev_init_ch_amba_ahb(struct mlb_channel_info *chinfo,
 	return 0;
 }
 
-static s32 mlb150_dev_init_amba_ahb(struct mlb_channel_info *rx_chinfo,
-		struct mlb_channel_info *tx_chinfo, enum MLB_CTYPE ctype)
+static s32 mlb150_dev_init_amba_ahb(struct mlb_dev_info *pdevinfo,
+					enum MLB_CTYPE ctype)
 {
+	struct mlb_channel_info *tx_chinfo = &pdevinfo->channels[TX_CHANNEL];
+	struct mlb_channel_info *rx_chinfo = &pdevinfo->channels[RX_CHANNEL];
+
 	/* Step 1, Initialize all bits of the ADT to '0' */
 	mlb150_dev_reset_adt();
 
 	/* Step 2, Select a logic channel */
 	/* Step 3, Program the AMBA AHB block ping page for channel N */
 	/* Step 4, Program the AMBA AHB block pong page for channel N */
-	mlb150_dev_init_ch_amba_ahb(rx_chinfo, ctype);
-	mlb150_dev_init_ch_amba_ahb(tx_chinfo, ctype);
+	mlb150_dev_init_ch_amba_ahb(pdevinfo, rx_chinfo, ctype);
+	mlb150_dev_init_ch_amba_ahb(pdevinfo, tx_chinfo, ctype);
 
 	return 0;
 }
 
-static s32 mlb150_dev_unmute_syn_ch(u32 rx_ch, u32 tx_ch)
+static void mlb150_dev_exit(void)
+{
+	u32 c0_val, hctl_val;
+
+	/* Disable EN bits */
+	c0_val = __raw_readl(mlb_base + REG_MLBC0);
+	c0_val &= ~(MLBC0_MLBEN | MLBC0_MLBPEN);
+	__raw_writel(c0_val, mlb_base + REG_MLBC0);
+
+	hctl_val = __raw_readl(mlb_base + REG_HCTL);
+	hctl_val &= ~HCTL_EN;
+	__raw_writel(hctl_val, mlb_base + REG_HCTL);
+
+	__raw_writel(0x0, mlb_base + REG_HCMR0);
+	__raw_writel(0x0, mlb_base + REG_HCMR1);
+
+	mlb150_dev_enable_dma_irq(0);
+	mlb150_dev_enable_ir_mlb(0);
+}
+
+static void mlb150_dev_init(void)
+{
+	u32 c0_val;
+	u32 ch_rx_mask = (1 << SYNC_RX_CL_AHB0) | (1 << CTRL_RX_CL_AHB0)
+			| (1 << ASYNC_RX_CL_AHB0) | (1 << ISOC_RX_CL_AHB0)
+			| (1 << SYNC_TX_CL_AHB0) | (1 << CTRL_TX_CL_AHB0)
+			| (1 << ASYNC_TX_CL_AHB0) | (1 << ISOC_TX_CL_AHB0);
+	u32 ch_tx_mask = (1 << (SYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_RX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (SYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (CTRL_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ASYNC_TX_CL_AHB1 - INT_AHB1_CH_START)) |
+			(1 << (ISOC_TX_CL_AHB1 - INT_AHB1_CH_START));
+
+	/* Disable EN bits */
+	mlb150_dev_exit();
+
+	/* Step 1. Initialize CTR and registers
+	 * a. Set all bit of the CTR (CAT, CDT, and ADT) to 0. */
+	mlb150_dev_reset_whole_ctr();
+
+	/* a. Set all bit of the CTR (CAT, CDT, and ADT) to 0. */
+	mlb150_dev_reset_all_regs();
+
+	/* Step 2, Configure the MediaLB interface */
+	/* Select pin mode and clock, 3-pin and 256fs */
+	c0_val = __raw_readl(mlb_base + REG_MLBC0);
+	c0_val &= ~(MLBC0_MLBPEN | MLBC0_MLBCLK_MASK);
+	__raw_writel(c0_val, mlb_base + REG_MLBC0);
+
+	c0_val |= MLBC0_MLBEN;
+	__raw_writel(c0_val, mlb_base + REG_MLBC0);
+
+	/* Step 3, Configure the HBI interface */
+	__raw_writel(ch_rx_mask, mlb_base + REG_HCMR0);
+	__raw_writel(ch_tx_mask, mlb_base + REG_HCMR1);
+	__raw_writel(HCTL_EN, mlb_base + REG_HCTL);
+
+	mlb150_dev_init_ir_amba_ahb();
+
+	mlb150_dev_enable_ir_mlb(1);
+}
+
+static s32 mlb150_dev_unmute_syn_ch(u32 rx_ch, u32 rx_cl, u32 tx_ch, u32 tx_cl)
 {
 	u32 timeout = 10000;
 
 	/* Check that MediaLB clock is running (MLBC1.CLKM = 0)
 	 * If MLBC1.CLKM = 1, clear the register bit, wait one
 	 * APB or I/O clock cycle and repeat the check */
-	while ((__raw_readl(mlb_base + MLB150_REG_MLBC1) & MLB150_MLBC1_CLKM)
+	while ((__raw_readl(mlb_base + REG_MLBC1) & MLBC1_CLKM)
 			|| timeout--)
-		__raw_writel(~MLB150_MLBC1_CLKM, mlb_base + MLB150_REG_MLBC1);
+		__raw_writel(~MLBC1_CLKM, mlb_base + REG_MLBC1);
 
-	if (unlikely(0 == timeout))
+	if (0 == timeout)
 		return -ETIME;
 
 	timeout = 10000;
 	/* Poll for MLB lock (MLBC0.MLBLK = 1) */
-	while (!(__raw_readl(mlb_base + MLB150_REG_MLBC0) & MLB150_MLBC0_MLBLK)
+	while (!(__raw_readl(mlb_base + REG_MLBC0) & MLBC0_MLBLK)
 			|| timeout--)
 		;
 
-	if (unlikely(0 == timeout))
+	if (0 == timeout)
 		return -ETIME;
 
 	/* Unmute synchronous channel(s) */
-	mlb150_dev_cat_mlb_write(rx_ch, CAT_CE | rx_ch);
+	mlb150_dev_cat_mlb_write(rx_ch, CAT_CE | rx_cl);
 	mlb150_dev_cat_mlb_write(tx_ch,
-			CAT_CE | tx_ch | CAT_RNW);
-	mlb150_dev_cat_hbi_write(rx_ch,
-			CAT_CE | rx_ch | CAT_RNW);
-	mlb150_dev_cat_hbi_write(tx_ch, CAT_CE | tx_ch);
+			CAT_CE | tx_cl | CAT_RNW);
+	mlb150_dev_cat_hbi_write(rx_cl,
+			CAT_CE | rx_cl | CAT_RNW);
+	mlb150_dev_cat_hbi_write(tx_cl, CAT_CE | tx_cl);
 
 	return 0;
 }
 
-static void mlb150_dev_exit(void)
+/* In case the user calls channel shutdown, but rx or tx is not completed yet */
+static s32 mlb150_trans_complete_check(struct mlb_dev_info *pdevinfo)
 {
-	mlb150_dev_enable_dma_irq(0);
-	mlb150_dev_enable_ir_mlb(0);
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	s32 timeout = 1024;
+
+	while (timeout--) {
+		read_lock(&tx_rbuf->rb_lock);
+		if (!CIRC_CNT(tx_rbuf->head, tx_rbuf->tail, TRANS_RING_NODES)) {
+			read_unlock(&tx_rbuf->rb_lock);
+			break;
+		} else
+			read_unlock(&tx_rbuf->rb_lock);
+	}
 
-	__raw_writel(0, mlb_base + MLB150_REG_HCTL);
-	__raw_writel(0, mlb_base + MLB150_REG_MLBC0);
-}
+	if (timeout <= 0) {
+		pr_debug("TX complete check timeout!\n");
+		return -ETIME;
+	}
 
-/*!
- * MLB receive start function
- *
- * load phy_head to next buf register to start next rx
- * here use single-packet buffer, set start=end
- */
-static inline void mlb_start_rx(u32 ch, s32 ctype, u32 dne_sts, u32 buf_addr)
-{
-	/*  Set ADT for RX */
-	mlb150_dev_set_ch_amba_ahb(ch, ctype, dne_sts, buf_addr);
-}
+	timeout = 1024;
+	while (timeout--) {
+		read_lock(&rx_rbuf->rb_lock);
+		if (!CIRC_CNT(rx_rbuf->head, rx_rbuf->tail, TRANS_RING_NODES)) {
+			read_unlock(&rx_rbuf->rb_lock);
+			break;
+		} else
+			read_unlock(&rx_rbuf->rb_lock);
+	}
 
-/*!
- * MLB transmit start function
- * make sure aquiring the rw buf_lock, when calling this
- */
-static inline void mlb_start_tx(u32 ch, s32 ctype, u32 dne_sts, u32 buf_addr)
-{
-	/*  Set ADT for TX */
-	mlb150_dev_set_ch_amba_ahb(ch, ctype, dne_sts, buf_addr);
+	if (timeout <= 0) {
+		pr_debug("RX complete check timeout!\n");
+		return -ETIME;
+	}
+
+	/* Interrupt from TX can only inform that the data is sent
+	 * to AHB bus, not mean that it is sent to MITB. Thus we add
+	 * a delay here for data to be completed sent. */
+	udelay(1000);
+
+	return 0;
 }
 
 /*!
  * Enable the MLB channel
  */
-static void mlb_channel_enable(int chan_dev_id, int on)
+static void mlb_channel_enable(struct mlb_data *drvdata,
+				int chan_dev_id, int on)
 {
-	struct mlb_dev_info *pdevinfo = &mlb_devinfo[chan_dev_id];
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_channel_info *tx_chinfo = &pdevinfo->channels[TX_CHANNEL];
+	struct mlb_channel_info *rx_chinfo = &pdevinfo->channels[RX_CHANNEL];
+	u32 tx_ch = tx_chinfo->address;
+	u32 rx_ch = rx_chinfo->address;
+	u32 tx_cl = tx_chinfo->cl;
+	u32 rx_cl = rx_chinfo->cl;
+
 	/*!
 	 * setup the direction, enable, channel type,
 	 * mode select, channel address and mask buf start
 	 */
 	if (on) {
 		u32 ctype = pdevinfo->channel_type;
-		struct mlb_channel_info *tx_chinfo = &_get_txchan(chan_dev_id);
-		struct mlb_channel_info *rx_chinfo = &_get_rxchan(chan_dev_id);
-		u32 tx_ch = tx_chinfo->address;
-		u32 rx_ch = rx_chinfo->address;
 
 		mlb150_dev_enable_ctr_write(0xffffffff, 0xffffffff,
 				0xffffffff, 0xffffffff);
-		mlb150_dev_init_rfb(rx_ch, tx_ch, ctype);
+		mlb150_dev_init_rfb(pdevinfo, rx_ch, tx_ch, ctype);
 
-		mlb150_dev_init_amba_ahb(rx_chinfo, tx_chinfo, ctype);
+		mlb150_dev_init_amba_ahb(pdevinfo, ctype);
 
+#ifdef DEBUG
+		mlb150_dev_dump_ctr_tbl(0, tx_chinfo->cl + 1);
+#endif
 		/* Synchronize and unmute synchrouous channel */
 		if (MLB_CTYPE_SYNC == ctype)
-			mlb150_dev_unmute_syn_ch(rx_ch, tx_ch);
+			mlb150_dev_unmute_syn_ch(rx_ch, rx_cl, tx_ch, tx_cl);
 
 		mlb150_dev_enable_ctr_write(0x0, ADT_RDY1 | ADT_DNE1 |
 				ADT_ERR1 | ADT_PS1 |
-				ADT_MEP1 | ADT_RDY2 | ADT_DNE2 | ADT_ERR2 |
-				ADT_PS2 | ADT_MEP2,
+				ADT_RDY2 | ADT_DNE2 | ADT_ERR2 | ADT_PS2,
 				0xffffffff, 0xffffffff);
 
-		if (pdevinfo->fps >= MLB150_CLK_2048FS)
-			mlb150_enable_pll();
+		if (pdevinfo->fps >= CLK_2048FS)
+			mlb150_enable_pll(drvdata);
 
 		atomic_set(&pdevinfo->on, 1);
 
 #ifdef DEBUG
 		mlb150_dev_dump_reg();
-		mlb150_dev_dump_ctr_tbl(0, tx_chinfo->address + 1);
+		mlb150_dev_dump_ctr_tbl(0, tx_chinfo->cl + 1);
 #endif
-		mlb_start_rx(rx_ch, ctype, ADT_DNE2,
-				pdevinfo->rx_bufs.phy_addrs[0]);
+		/* Init RX ADT */
+		mlb150_dev_pipo_start(&pdevinfo->rx_rbuf, rx_cl,
+					pdevinfo->rx_rbuf.phy_addrs[0]);
 	} else {
+		mlb150_dev_pipo_stop(&pdevinfo->rx_rbuf, rx_cl);
+
 		mlb150_dev_enable_dma_irq(0);
 		mlb150_dev_enable_ir_mlb(0);
 
 		mlb150_dev_reset_cat();
 
-		atomic_set(&mlb_devinfo[chan_dev_id].on, 0);
+		atomic_set(&pdevinfo->on, 0);
 
-		if (mlb_devinfo[chan_dev_id].fps >= MLB150_CLK_2048FS)
-			mlb150_disable_pll();
+		if (pdevinfo->fps >= CLK_2048FS)
+			mlb150_disable_pll(drvdata);
 	}
 }
 
 /*!
  * MLB interrupt handler
  */
-static void mlb_tx_isr(int minor)
+static void mlb_rx_isr(s32 ctype, u32 ahb_ch, struct mlb_dev_info *pdevinfo)
 {
-	struct mlb_dev_info *pdevinfo = &mlb_devinfo[minor];
-
-	pdevinfo->tx_busy = 0;
-
-	wake_up_interruptible(&pdevinfo->wt_wq);
-}
-
-static void mlb_rx_isr(int minor)
-{
-	struct mlb_dev_info *pdevinfo = &mlb_devinfo[minor];
-	struct mlb_channel_info *pchinfo = &_get_rxchan(minor);
-	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_bufs;
-	s32 wpos, rpos, adt_sts;
-	u32 rx_ring_buf = 0;
-	s32 ctype = pdevinfo->channel_type;
-	u32 ch_addr = pchinfo->address;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	s32 head, tail, adt_sts;
+	unsigned long flags;
+	u32 rx_buf_ptr;
 
 #ifdef DEBUG_RX
 	pr_debug("mxc_mlb150: mlb_rx_isr\n");
 #endif
 
-	rpos = rx_rbuf->rpos;
-	wpos = rx_rbuf->wpos;
+	write_lock_irqsave(&rx_rbuf->rb_lock, flags);
 
-#ifdef DEBUG_RX
-	pr_debug("adt_buf_ptr: 0x%08x\n", (u32)adt_buf_ptr);
-#endif
+	head = (rx_rbuf->head + 1) & (TRANS_RING_NODES - 1);
+	tail = ACCESS_ONCE(rx_rbuf->tail);
 
-	/*!
-	 * Copy packet from IRAM buf to ring buf.
-	 * if the wpos++ == rpos, drop this packet
-	 */
-	if (((wpos + 1) % TRANS_RING_NODES) != rpos) {
-		rx_ring_buf = rx_rbuf->phy_addrs[(wpos + 1) % TRANS_RING_NODES];
-#ifdef DEBUG_RX
-		if (len > mlb150_ch_packet_buf_size[ctype])
-			pr_debug("mxc_mlb150: packet overflow, "
-				"packet type: %d\n", ctype);
-#endif
+	if (CIRC_SPACE(head, tail, TRANS_RING_NODES) >= 1) {
+		rx_buf_ptr = rx_rbuf->phy_addrs[head];
 
-		/* update the ring wpos */
-		rx_rbuf->wpos = (wpos + 1) % TRANS_RING_NODES;
+		/* commit the item before incrementing the head */
+		smp_wmb();
 
-		/* wake up the reader */
-		wake_up_interruptible(&pdevinfo->rd_wq);
+		rx_rbuf->head = head;
 
-#ifdef DEBUG_RX
-		pr_debug("recv package, len:%d, rx_rdpos: %d, rx_wtpos: %d\n",
-			 len, rpos, pdevinfo->rx_bufs.wpos);
-#endif
-	} else {
-		rx_ring_buf = pdevinfo->rx_bufs.phy_addrs[TRANS_RING_NODES];
+		write_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
 
-		pr_debug
-		    ("drop package, due to no space, (%d,%d)\n",
-		     rpos, pdevinfo->rx_bufs.wpos);
+		/* wake up the reader */
+		wake_up_interruptible(&pdevinfo->rx_wq);
+	} else {
+		rx_buf_ptr = rx_rbuf->phy_addrs[head];
+		write_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
+		pr_debug("drop RX package, due to no space, (%d,%d)\n",
+				head, tail);
 	}
 
-	adt_sts = mlb150_dev_get_adt_sts(ch_addr);
-	mlb_start_rx(ch_addr, ctype, adt_sts, rx_ring_buf);
+	adt_sts = mlb150_dev_get_adt_sts(ahb_ch);
+	/*  Set ADT for RX */
+	mlb150_dev_pipo_next(ahb_ch, ctype, adt_sts, rx_buf_ptr);
+}
+
+static void mlb_tx_isr(s32 ctype, u32 ahb_ch, struct mlb_dev_info *pdevinfo)
+{
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	s32 head, tail, adt_sts;
+	u32 tx_buf_ptr;
+	unsigned long flags;
+
+	write_lock_irqsave(&tx_rbuf->rb_lock, flags);
+
+	head = ACCESS_ONCE(tx_rbuf->head);
+	tail = (tx_rbuf->tail + 1) & (TRANS_RING_NODES - 1);
+	smp_mb();
+	tx_rbuf->tail = tail;
+
+	/* check the current tx buffer is available or not */
+	if (CIRC_CNT(head, tail, TRANS_RING_NODES) >= 1) {
+		/* read index before reading contents at that index */
+		smp_read_barrier_depends();
+
+		tx_buf_ptr = tx_rbuf->phy_addrs[tail];
+
+		write_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+		wake_up_interruptible(&pdevinfo->tx_wq);
+
+		adt_sts = mlb150_dev_get_adt_sts(ahb_ch);
+		/*  Set ADT for TX */
+		mlb150_dev_pipo_next(ahb_ch, ctype, adt_sts, tx_buf_ptr);
+	} else
+		write_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
 }
 
 static irqreturn_t mlb_ahb_isr(int irq, void *dev_id)
 {
-	u32 rx_int_sts, tx_int_sts, acsr0,
-		acsr1, rx_err, tx_err, hcer0, hcer1;
-	struct mlb_dev_info *pdev = NULL;
-	struct mlb_channel_info *ptxchinfo = NULL, *prxchinfo = NULL;
-	int minor;
+	u32 acsr0, hcer0;
+	u32 ch_mask = (1 << SYNC_RX_CL) | (1 << CTRL_RX_CL)
+			| (1 << ASYNC_RX_CL) | (1 << ISOC_RX_CL)
+			| (1 << SYNC_TX_CL) | (1 << CTRL_TX_CL)
+			| (1 << ASYNC_TX_CL) | (1 << ISOC_TX_CL);
 
 	/* Step 5, Read the ACSRn registers to determine which channel or
 	 * channels are causing the interrupt */
-	acsr0 = __raw_readl(mlb_base + MLB150_REG_ACSR0);
-	acsr1 = __raw_readl(mlb_base + MLB150_REG_ACSR1);
+	acsr0 = __raw_readl(mlb_base + REG_ACSR0);
 
-	hcer0 = __raw_readl(mlb_base + MLB150_REG_HCER0);
-	hcer1 = __raw_readl(mlb_base + MLB150_REG_HCER1);
+	hcer0 = __raw_readl(mlb_base + REG_HCER0);
 
 	/* Step 6, If ACTL.SCE = 1, write the result of step 5 back to ACSR0
 	 * and ACSR1 to clear the interrupt */
-	if (MLB150_ACTL_SCE & __raw_readl(mlb_base + MLB150_REG_ACTL)) {
-		__raw_writel(acsr0, mlb_base + MLB150_REG_ACSR0);
-		__raw_writel(acsr1, mlb_base + MLB150_REG_ACSR1);
-	}
+	/* We'll not set ACTL_SCE */
+	/*
+	if (ACTL_SCE & __raw_readl(mlb_base + REG_ACTL))
+		__raw_writel(acsr0, mlb_base + REG_ACSR0);
+	*/
 
-	for (minor = 0; minor < MLB_MINOR_DEVICES; minor++) {
-		pdev = &mlb_devinfo[minor];
-		prxchinfo = &_get_rxchan(minor);
-		ptxchinfo = &_get_txchan(minor);
-
-		rx_int_sts = (prxchinfo->address < 31) ? acsr0 : acsr1;
-		tx_int_sts = (ptxchinfo->address < 31) ? acsr0 : acsr1;
-		rx_err = (prxchinfo->address < 31) ? hcer0 : hcer1;
-		tx_err = (ptxchinfo->address < 31) ? hcer0 : hcer1;
-
-		/* get tx channel interrupt status */
-		if (tx_int_sts & (1 << (ptxchinfo->address % 32))) {
-			if (!(tx_err & (1 << (ptxchinfo->address % 32))))
-				mlb_tx_isr(minor);
-			else {
-				pr_debug("tx channel %d encountered an AHB error!\n",
-					ptxchinfo->address);
-			}
-		}
+	if (ch_mask & hcer0)
+		pr_err("CH encounters an AHB error: 0x%x\n", hcer0);
 
-		/* get rx channel interrupt status */
-		if (rx_int_sts & (1 << (prxchinfo->address % 32))) {
-			if (!(rx_err & (1 << (prxchinfo->address % 32))))
-				mlb_rx_isr(minor);
-			else {
-				pr_debug("rx channel %d encountered an AHB error!\n",
-					prxchinfo->address);
-			}
-		}
-	}
+	if ((1 << SYNC_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_SYNC, SYNC_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_SYNC]);
+
+	if ((1 << CTRL_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_CTRL, CTRL_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_CTRL]);
+
+	if ((1 << ASYNC_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_ASYNC, ASYNC_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_ASYNC]);
+
+	if ((1 << ISOC_RX_CL) & acsr0)
+		mlb_rx_isr(MLB_CTYPE_ISOC, ISOC_RX_CL,
+				&mlb_devinfo[MLB_CTYPE_ISOC]);
+
+	if ((1 << SYNC_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_SYNC, SYNC_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_SYNC]);
+
+	if ((1 << CTRL_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_CTRL, CTRL_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_CTRL]);
+
+	if ((1 << ASYNC_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_ASYNC, ASYNC_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_ASYNC]);
+
+	if ((1 << ISOC_TX_CL) & acsr0)
+		mlb_tx_isr(MLB_CTYPE_ASYNC, ISOC_TX_CL,
+				&mlb_devinfo[MLB_CTYPE_ISOC]);
 
 	return IRQ_HANDLED;
 }
@@ -1587,38 +1751,41 @@ static irqreturn_t mlb_isr(int irq, void *dev_id)
 {
 	u32 rx_int_sts, tx_int_sts, ms0,
 		ms1, tx_cis, rx_cis, ctype;
-	struct mlb_dev_info *pdev;
 	int minor;
 	u32 cdt_val[4] = { 0 };
 
 	/* Step 4, Read the MSn register to determine which channel(s)
 	 * are causing the interrupt */
-	ms0 = __raw_readl(mlb_base + MLB150_REG_MS0);
-	ms1 = __raw_readl(mlb_base + MLB150_REG_MS1);
+	ms0 = __raw_readl(mlb_base + REG_MS0);
+	ms1 = __raw_readl(mlb_base + REG_MS1);
 	pr_debug("mxc_mlb150: mlb interrupt:0x%08x 0x%08x\n",
 			(u32)ms0, (u32)ms1);
 
 	for (minor = 0; minor < MLB_MINOR_DEVICES; minor++) {
-		pdev = &mlb_devinfo[minor];
+		struct mlb_dev_info *pdevinfo = &mlb_devinfo[minor];
+		u32 rx_mlb_ch = pdevinfo->channels[RX_CHANNEL].address;
+		u32 tx_mlb_ch = pdevinfo->channels[TX_CHANNEL].address;
+		u32 rx_mlb_cl = pdevinfo->channels[RX_CHANNEL].cl;
+		u32 tx_mlb_cl = pdevinfo->channels[TX_CHANNEL].cl;
+
 		tx_cis = rx_cis = 0;
 
-		ctype = pdev->channel_type;
-		rx_int_sts = (_get_rxchan(minor).address < 31) ? ms0 : ms1;
-		tx_int_sts = (_get_txchan(minor).address < 31) ? ms0 : ms1;
+		ctype = pdevinfo->channel_type;
+		rx_int_sts = (rx_mlb_ch < 31) ? ms0 : ms1;
+		tx_int_sts = (tx_mlb_ch < 31) ? ms0 : ms1;
 
 		pr_debug("mxc_mlb150: channel interrupt: "
-				"tx: 0x%08x, rx: 0x%08x\n",
-			(u32)tx_int_sts, (u32)rx_int_sts);
+				"tx %d: 0x%08x, rx %d: 0x%08x\n",
+			tx_mlb_ch, (u32)tx_int_sts, rx_mlb_ch, (u32)rx_int_sts);
 
 		/* Get tx channel interrupt status */
-		if (tx_int_sts & (1 << (_get_txchan(minor).address % 32))) {
-			mlb150_dev_cdt_read(_get_txchan(minor).address,
-					cdt_val);
-			pr_debug("mxc_mlb150: cdt_val[3]: 0x%08x, "
+		if (tx_int_sts & (1 << (tx_mlb_ch % 32))) {
+			mlb150_dev_cdt_read(tx_mlb_cl, cdt_val);
+			pr_debug("mxc_mlb150: TX_CH: %d, cdt_val[3]: 0x%08x, "
 					"cdt_val[2]: 0x%08x, "
 					"cdt_val[1]: 0x%08x, "
 					"cdt_val[0]: 0x%08x\n",
-					cdt_val[3], cdt_val[2],
+					tx_mlb_ch, cdt_val[3], cdt_val[2],
 					cdt_val[1], cdt_val[0]);
 			switch (ctype) {
 			case MLB_CTYPE_SYNC:
@@ -1652,14 +1819,18 @@ static irqreturn_t mlb_isr(int irq, void *dev_id)
 			default:
 				break;
 			}
-			mlb150_dev_cdt_write(_get_txchan(minor).address,
-					cdt_val);
+			mlb150_dev_cdt_write(tx_mlb_ch, cdt_val);
 		}
 
 		/* Get rx channel interrupt status */
-		if (rx_int_sts & (1 << (_get_rxchan(minor).address % 32))) {
-			mlb150_dev_cdt_read(_get_rxchan(minor).address,
-					cdt_val);
+		if (rx_int_sts & (1 << (rx_mlb_ch % 32))) {
+			mlb150_dev_cdt_read(rx_mlb_cl, cdt_val);
+			pr_debug("mxc_mlb150: RX_CH: %d, cdt_val[3]: 0x%08x, "
+					"cdt_val[2]: 0x%08x, "
+					"cdt_val[1]: 0x%08x, "
+					"cdt_val[0]: 0x%08x\n",
+					rx_mlb_ch, cdt_val[3], cdt_val[2],
+					cdt_val[1], cdt_val[0]);
 			switch (ctype) {
 			case MLB_CTYPE_SYNC:
 				tx_cis = (cdt_val[2] & ~CDT_SYNC_RSTS_MASK)
@@ -1685,17 +1856,16 @@ static irqreturn_t mlb_isr(int irq, void *dev_id)
 			default:
 				break;
 			}
-			mlb150_dev_cdt_write(_get_rxchan(minor).address,
-					cdt_val);
+			mlb150_dev_cdt_write(rx_mlb_ch, cdt_val);
 		}
 
 		if (!tx_cis && !rx_cis)
 			continue;
 
 		/* fill exception event */
-		spin_lock(&pdev->event_lock);
-		pdev->ex_event |= (rx_cis << 16) | tx_cis;
-		spin_unlock(&pdev->event_lock);
+		spin_lock(&pdevinfo->event_lock);
+		pdevinfo->ex_event |= (rx_cis << 16) | tx_cis;
+		spin_unlock(&pdevinfo->event_lock);
 	}
 
 	return IRQ_HANDLED;
@@ -1705,64 +1875,73 @@ static int mxc_mlb150_open(struct inode *inode, struct file *filp)
 {
 	int minor, ring_buf_size, buf_size, j, ret;
 	void __iomem *buf_addr;
-	ulong phyaddr;
-	struct mxc_mlb_platform_data *plat_data;
+	ulong phy_addr;
 	struct mlb_dev_info *pdevinfo = NULL;
 	struct mlb_channel_info *pchinfo = NULL;
-
-	plat_data = container_of(inode->i_cdev, struct mxc_mlb_platform_data,
-				cdev);
-	filp->private_data = plat_data;
+	struct mlb_data *drvdata;
 
 	minor = MINOR(inode->i_rdev);
 
-	if (unlikely(minor < 0 || minor >= MLB_MINOR_DEVICES))
+	if (minor < 0 || minor >= MLB_MINOR_DEVICES) {
+		pr_err("no device\n");
 		return -ENODEV;
+	}
 
 	/* open for each channel device */
-	if (unlikely(atomic_cmpxchg(&mlb_devinfo[minor].opencnt, 0, 1) != 0))
+	if (atomic_cmpxchg(&mlb_devinfo[minor].opencnt, 0, 1) != 0) {
+		pr_err("busy\n");
 		return -EBUSY;
+	}
+
+	/* initial MLB module */
+	mlb150_dev_init();
 
 	pdevinfo = &mlb_devinfo[minor];
-	pchinfo = &_get_txchan(minor);
+	pchinfo = &pdevinfo->channels[TX_CHANNEL];
 
-	ring_buf_size = mlb150_ch_packet_buf_size[minor];
-	buf_size = ring_buf_size * (TRANS_RING_NODES + 1) + PING_BUF_MAX_SIZE;
-	buf_addr = iram_alloc(buf_size, &phyaddr);
-	memset(buf_addr, 0, buf_size);
-	if (unlikely(buf_addr == NULL)) {
+	ring_buf_size = pdevinfo->buf_size;
+	buf_size = ring_buf_size * (TRANS_RING_NODES * 2);
+	buf_addr = iram_alloc(buf_size, &phy_addr);
+	if (buf_addr == NULL) {
 		ret = -ENOMEM;
-		dev_err(plat_data->dev, "can not alloc rx buffers\n");
+		pr_err("can not alloc rx/tx buffers: %d\n", buf_size);
 		return ret;
 	}
+	pr_debug("IRAM Range: Virt 0x%p - 0x%p, Phys 0x%x - 0x%x, size: 0x%x\n",
+			buf_addr, (buf_addr + buf_size - 1), (u32)phy_addr,
+			(u32)(phy_addr + buf_size - 1), buf_size);
+	pdevinfo->rbuf_base_virt = buf_addr;
+	pdevinfo->rbuf_base_phy = phy_addr;
+	memset(buf_addr, 0, buf_size);
 
-	dev_dbg(plat_data->dev, "ch_type: %d, RX ring buf virt base: 0x%08x "
-			"phy base: 0x%08x\n",
-			pdevinfo->channel_type, (u32)buf_addr, (u32)phyaddr);
-
-	for (j = 0; j < TRANS_RING_NODES + 1;
-		++j, buf_addr += ring_buf_size, phyaddr += ring_buf_size) {
-		pdevinfo->rx_bufs.virt_bufs[j] = buf_addr;
-		pdevinfo->rx_bufs.phy_addrs[j] = phyaddr;
-		pdevinfo->rx_bufs.size = pchinfo->buf_size;
+	for (j = 0; j < (TRANS_RING_NODES);
+		++j, buf_addr += ring_buf_size, phy_addr += ring_buf_size) {
+		pdevinfo->rx_rbuf.virt_bufs[j] = buf_addr;
+		pdevinfo->rx_rbuf.phy_addrs[j] = phy_addr;
+		pr_debug("RX Ringbuf[%d]: 0x%p 0x%x\n", j, buf_addr, (u32)phy_addr);
+	}
+	pdevinfo->rx_rbuf.unit_size = ring_buf_size;
+	pdevinfo->rx_rbuf.total_size = buf_size;
+
+	for (j = 0; j < (TRANS_RING_NODES);
+		++j, buf_addr += ring_buf_size, phy_addr += ring_buf_size) {
+		pdevinfo->tx_rbuf.virt_bufs[j] = buf_addr;
+		pdevinfo->tx_rbuf.phy_addrs[j] = phy_addr;
+		pr_debug("TX Ringbuf[%d]: 0x%p 0x%x\n", j, buf_addr, (u32)phy_addr);
 	}
 
-	/* set the virtual and physical buf head address */
-	pchinfo->ping_buf_head = pchinfo->pong_buf_head = (u32)buf_addr;
-	pchinfo->ping_phy_head = pchinfo->pong_phy_head = phyaddr;
-
-	pchinfo->buf_ptr = (u32)buf_addr;
-	pchinfo->buf_phy_addr = phyaddr;
-
-	dev_dbg(plat_data->dev, "ctype: %d, tx phy_head: 0x%08x, "
-		"buf_head: 0x%08x\n",
-		pchinfo->address,
-		(u32)pchinfo->buf_phy_addr,
-		(u32)pchinfo->buf_ptr);
+	pdevinfo->tx_rbuf.unit_size = ring_buf_size;
+	pdevinfo->tx_rbuf.total_size = buf_size;
 
 	/* reset the buffer read/write ptr */
-	pdevinfo->rx_bufs.rpos = pdevinfo->rx_bufs.wpos = 0;
+	pdevinfo->rx_rbuf.head = pdevinfo->rx_rbuf.tail = 0;
+	pdevinfo->tx_rbuf.head = pdevinfo->tx_rbuf.tail = 0;
 	pdevinfo->ex_event = 0;
+	pdevinfo->tx_ok = 0;
+
+	drvdata = container_of(inode->i_cdev, struct mlb_data, cdev);
+	drvdata->devinfo = pdevinfo;
+	filp->private_data = drvdata;
 
 	return 0;
 }
@@ -1770,26 +1949,24 @@ static int mxc_mlb150_open(struct inode *inode, struct file *filp)
 static int mxc_mlb150_release(struct inode *inode, struct file *filp)
 {
 	int minor;
-	u32 buf_size;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
 
 	minor = MINOR(inode->i_rdev);
 
 #ifdef DEBUG
 	mlb150_dev_dump_reg();
-	mlb150_dev_dump_ctr_tbl(0, _get_txchan(minor).address + 1);
-	mlb150_dev_dump_hex((const u8 *)mlb_devinfo[minor].rx_bufs.virt_bufs[0],
-			mlb_devinfo[minor].rx_bufs.size);
+	mlb150_dev_dump_ctr_tbl(0, pdevinfo->channels[TX_CHANNEL].cl + 1);
 #endif
 
 	/* clear channel settings and info */
-	mlb_channel_enable(minor, 0);
+	mlb_channel_enable(drvdata, minor, 0);
 
-	buf_size = mlb150_ch_packet_buf_size[minor] *
-			(TRANS_RING_NODES + 1) + PING_BUF_MAX_SIZE;
-	iram_free(mlb_devinfo[minor].rx_bufs.phy_addrs[0], buf_size);
+	iram_free(pdevinfo->rbuf_base_phy, rx_rbuf->total_size);
 
 	/* decrease the open count */
-	atomic_set(&mlb_devinfo[minor].opencnt, 0);
+	atomic_set(&pdevinfo->opencnt, 0);
 
 	return 0;
 }
@@ -1798,10 +1975,11 @@ static long mxc_mlb150_ioctl(struct file *filp,
 			 unsigned int cmd, unsigned long arg)
 {
 	struct inode *inode = filp->f_dentry->d_inode;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
 	void __user *argp = (void __user *)arg;
 	unsigned long flags, event;
 	int minor;
-	struct mxc_mlb_platform_data *plat_data = filp->private_data;
 
 	minor = MINOR(inode->i_rdev);
 
@@ -1814,46 +1992,75 @@ static long mxc_mlb150_ioctl(struct file *filp,
 				pr_err("mxc_mlb150: copy from user failed\n");
 				return -EFAULT;
 			}
-			_get_txchan(minor).address = (caddr >> 16) & 0xFFFF;
-			_get_rxchan(minor).address = caddr & 0xFFFF;
+			pdevinfo->channels[TX_CHANNEL].address =
+							(caddr >> 16) & 0xFFFF;
+			pdevinfo->channels[RX_CHANNEL].address = caddr & 0xFFFF;
 			pr_debug("mxc_mlb150: set ch addr, tx: %d, rx: %d\n",
-					_get_txchan(minor).address,
-					_get_rxchan(minor).address);
+					pdevinfo->channels[TX_CHANNEL].address,
+					pdevinfo->channels[RX_CHANNEL].address);
 			break;
 		}
 
 	case MLB_CHAN_STARTUP:
-		if (unlikely(atomic_read(&mlb_devinfo[minor].on))) {
-			pr_debug("mxc_mlb150: channel areadly startup\n");
+		if (atomic_read(&pdevinfo->on)) {
+			pr_debug("mxc_mlb150: channel alreadly startup\n");
 			break;
 		}
-		pr_debug("mxc_mlb150: start channel\n");
-		mlb_channel_enable(minor, 1);
+		mlb_channel_enable(drvdata, minor, 1);
 		break;
 	case MLB_CHAN_SHUTDOWN:
-		if (unlikely(atomic_read(&mlb_devinfo[minor].on) == 0)) {
+		if (atomic_read(&pdevinfo->on) == 0) {
 			pr_debug("mxc_mlb150: channel areadly shutdown\n");
 			break;
 		}
-		pr_debug("mxc_mlb150: shutdown channel\n");
-		mlb_channel_enable(minor, 0);
+		mlb150_trans_complete_check(pdevinfo);
+		mlb_channel_enable(drvdata, minor, 0);
 		break;
 	case MLB_CHAN_GETEVENT:
 		/* get and clear the ex_event */
-		spin_lock_irqsave(&mlb_devinfo[minor].event_lock, flags);
-		event = mlb_devinfo[minor].ex_event;
-		mlb_devinfo[minor].ex_event = 0;
-		spin_unlock_irqrestore(&mlb_devinfo[minor].event_lock, flags);
+		spin_lock_irqsave(&pdevinfo->event_lock, flags);
+		event = pdevinfo->ex_event;
+		pdevinfo->ex_event = 0;
+		spin_unlock_irqrestore(&pdevinfo->event_lock, flags);
 
-		pr_debug("mxc_mlb150: get event\n");
 		if (event) {
 			if (copy_to_user(argp, &event, sizeof(event))) {
 				pr_err("mxc_mlb150: copy to user failed\n");
 				return -EFAULT;
 			}
-		} else {
-			pr_debug("mxc_mlb150: no exception event now\n");
+		} else
 			return -EAGAIN;
+		break;
+	case MLB_SET_ISOC_BLKSIZE_188:
+		pdevinfo->isoc_blksz = 188;
+		pdevinfo->cdt_buf_dep = pdevinfo->adt_buf_dep =
+					pdevinfo->isoc_blksz * CH_ISOC_BLK_NUM;
+		break;
+	case MLB_SET_ISOC_BLKSIZE_196:
+		pdevinfo->isoc_blksz = 196;
+		pdevinfo->cdt_buf_dep = pdevinfo->adt_buf_dep =
+					pdevinfo->isoc_blksz * CH_ISOC_BLK_NUM;
+		break;
+	case MLB_SET_SYNC_QUAD:
+		{
+			u32 quad;
+
+			if (copy_from_user(&quad, argp, sizeof(quad))) {
+				pr_err("mxc_mlb150: get quad number "
+						"from user failed\n");
+				return -EFAULT;
+			}
+			if (quad <= 0 || quad > 3) {
+				pr_err("mxc_mlb150: Invalid Quadlets!"
+					"Quadlets in Sync mode can "
+					"only be 1, 2, 3\n");
+				return -EINVAL;
+			}
+			pdevinfo->sync_quad = quad;
+			/* Each quadlets is 4 bytes */
+			pdevinfo->cdt_buf_dep = quad * 4 * 4;
+			pdevinfo->adt_buf_dep =
+				pdevinfo->cdt_buf_dep * CH_SYNC_ADT_BUF_MULTI;
 		}
 		break;
 	case MLB_SET_FPS:
@@ -1861,43 +2068,47 @@ static long mxc_mlb150_ioctl(struct file *filp,
 			u32 fps, c0_val;
 
 			/* get fps from user space */
-			if (unlikely(copy_from_user(&fps, argp, sizeof(fps)))) {
+			if (copy_from_user(&fps, argp, sizeof(fps))) {
 				pr_err("mxc_mlb150: copy from user failed\n");
 				return -EFAULT;
 			}
 
-			if (plat_data->fps_sel)
-				plat_data->fps_sel(fps);
-
-			c0_val = __raw_readl(mlb_base + MLB150_REG_MLBC0);
-			c0_val &= ~MLB150_MLBC0_MLBCLK_MASK;
+			c0_val = __raw_readl(mlb_base + REG_MLBC0);
+			c0_val &= ~MLBC0_MLBCLK_MASK;
 
 			/* check fps value */
 			switch (fps) {
 			case 256:
 			case 512:
 			case 1024:
-				mlb_devinfo[minor].fps = fps >> 9;
-				c0_val &= ~MLB150_MLBC0_MLBPEN;
+				pdevinfo->fps = fps >> 9;
+				c0_val &= ~MLBC0_MLBPEN;
 				c0_val |= (fps >> 9)
-					<< MLB150_MLBC0_MLBCLK_SHIFT;
+					<< MLBC0_MLBCLK_SHIFT;
+
+				if (1024 == fps) {
+					/* Invert output clock phase
+					 * in 1024 fps */
+					__raw_writel(0x1,
+						mlb_base + REG_MLBPC2);
+				}
 				break;
 			case 2048:
 			case 3072:
 			case 4096:
-				mlb_devinfo[minor].fps = (fps >> 10) + 1;
+				pdevinfo->fps = (fps >> 10) + 1;
 				c0_val |= ((fps >> 10) + 1)
-					<< MLB150_MLBC0_MLBCLK_SHIFT;
+					<< MLBC0_MLBCLK_SHIFT;
 				break;
 			case 6144:
-				mlb_devinfo[minor].fps = fps >> 10;
+				pdevinfo->fps = fps >> 10;
 				c0_val |= ((fps >> 10) + 1)
-					<< MLB150_MLBC0_MLBCLK_SHIFT;
+					<< MLBC0_MLBCLK_SHIFT;
 				break;
 			case 8192:
-				mlb_devinfo[minor].fps = (fps >> 10) - 1;
+				pdevinfo->fps = (fps >> 10) - 1;
 				c0_val |= ((fps >> 10) - 1)
-						<< MLB150_MLBC0_MLBCLK_SHIFT;
+						<< MLBC0_MLBCLK_SHIFT;
 				break;
 			default:
 				pr_debug("mxc_mlb150: invalid fps argument: %d\n",
@@ -1905,11 +2116,11 @@ static long mxc_mlb150_ioctl(struct file *filp,
 				return -EINVAL;
 			}
 
-			__raw_writel(c0_val, mlb_base + MLB150_REG_MLBC0);
+			__raw_writel(c0_val, mlb_base + REG_MLBC0);
 
 			pr_debug("mxc_mlb150: set fps to %d, MLBC0: 0x%08x\n",
 				fps,
-				(u32)__raw_readl(mlb_base + MLB150_REG_MLBC0));
+				(u32)__raw_readl(mlb_base + REG_MLBC0));
 
 			break;
 		}
@@ -1937,19 +2148,19 @@ static long mxc_mlb150_ioctl(struct file *filp,
 			u8 devaddr;
 
 			/* get MLB device address from user space */
-			if (unlikely(copy_from_user
-				(&devaddr, argp, sizeof(unsigned char)))) {
+			if (copy_from_user
+				(&devaddr, argp, sizeof(unsigned char))) {
 				pr_err("mxc_mlb150: copy from user failed\n");
 				return -EFAULT;
 			}
 
-			c1_val = __raw_readl(mlb_base + MLB150_REG_MLBC1);
-			c1_val &= ~MLB150_MLBC1_NDA_MASK;
-			c1_val |= devaddr << MLB150_MLBC1_NDA_SHIFT;
-			__raw_writel(c1_val, mlb_base + MLB150_REG_MLBC1);
+			c1_val = __raw_readl(mlb_base + REG_MLBC1);
+			c1_val &= ~MLBC1_NDA_MASK;
+			c1_val |= devaddr << MLBC1_NDA_SHIFT;
+			__raw_writel(c1_val, mlb_base + REG_MLBC1);
 			pr_debug("mxc_mlb150: set dev addr, dev addr: %d, "
 				"MLBC1: 0x%08x\n", devaddr,
-				(u32)__raw_readl(mlb_base + MLB150_REG_MLBC1));
+				(u32)__raw_readl(mlb_base + REG_MLBC1));
 
 			break;
 		}
@@ -1970,35 +2181,59 @@ static long mxc_mlb150_ioctl(struct file *filp,
 static ssize_t mxc_mlb150_read(struct file *filp, char __user *buf,
 			    size_t count, loff_t *f_pos)
 {
-	int minor, ret;
-	int size, rdpos;
-	struct mlb_ringbuf *rx_rbuf = NULL;
-	struct mlb_dev_info *pdevinfo = NULL;
-
-#ifdef DEBUG_RX
-	pr_debug("mxc_mlb150: mxc_mlb150_read\n");
-#endif
-
-	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+	int size;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	int head, tail;
+	unsigned long flags;
 
-	pdevinfo = &mlb_devinfo[minor];
+	read_lock_irqsave(&rx_rbuf->rb_lock, flags);
 
-	rdpos = pdevinfo->rx_bufs.rpos;
-	rx_rbuf = &pdevinfo->rx_bufs;
+	head = ACCESS_ONCE(rx_rbuf->head);
+	tail = rx_rbuf->tail;
 
 	/* check the current rx buffer is available or not */
-	if (rdpos == rx_rbuf->wpos) {
+	if (0 == CIRC_CNT(head, tail, TRANS_RING_NODES)) {
+		read_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
+
 		if (filp->f_flags & O_NONBLOCK)
 			return -EAGAIN;
-		/* if !O_NONBLOCK, we wait for recv packet */
-		ret = wait_event_interruptible(pdevinfo->rd_wq,
-						(rx_rbuf->wpos != rdpos));
-		if (ret < 0)
-			return ret;
+
+		do {
+			DEFINE_WAIT(__wait);
+
+			for (;;) {
+				prepare_to_wait(&pdevinfo->rx_wq,
+						&__wait, TASK_INTERRUPTIBLE);
+
+				read_lock_irqsave(&rx_rbuf->rb_lock, flags);
+				if (CIRC_CNT(rx_rbuf->head, rx_rbuf->tail,
+						TRANS_RING_NODES) > 0) {
+					read_unlock_irqrestore(&rx_rbuf->rb_lock,
+								flags);
+					break;
+				}
+				read_unlock_irqrestore(&rx_rbuf->rb_lock,
+							flags);
+
+				if (!signal_pending(current)) {
+					schedule();
+					continue;
+				}
+				return -ERESTARTSYS;
+			}
+			finish_wait(&pdevinfo->rx_wq, &__wait);
+		} while (0);
+		read_lock_irqsave(&rx_rbuf->rb_lock, flags);
 	}
+	read_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
 
-	size = mlb150_ch_packet_buf_size[minor];
-	if (unlikely(size > count)) {
+	/* read index before reading contents at that index */
+	smp_read_barrier_depends();
+
+	size = pdevinfo->adt_buf_dep;
+	if (size > count) {
 		/* the user buffer is too small */
 		pr_warning
 			("mxc_mlb150: received data size is bigger than "
@@ -2006,14 +2241,18 @@ static ssize_t mxc_mlb150_read(struct file *filp, char __user *buf,
 		return -EINVAL;
 	}
 
-	/* copy rx buffer data to user buffer */
-	if (likely(copy_to_user(buf, rx_rbuf->virt_bufs[rdpos], size))) {
+	/* extract one item from the buffer */
+	if (copy_to_user(buf, rx_rbuf->virt_bufs[tail], size)) {
 		pr_err("mxc_mlb150: copy from user failed\n");
 		return -EFAULT;
 	}
 
-	/* update the read ptr */
-	rx_rbuf->rpos = (rdpos + 1) % TRANS_RING_NODES;
+	/* finish reading descriptor before incrementing tail */
+	smp_mb();
+
+	write_lock_irqsave(&rx_rbuf->rb_lock, flags);
+	rx_rbuf->tail = (tail + 1) & (TRANS_RING_NODES - 1);
+	write_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
 
 	*f_pos = 0;
 
@@ -2029,16 +2268,20 @@ static ssize_t mxc_mlb150_read(struct file *filp, char __user *buf,
 static ssize_t mxc_mlb150_write(struct file *filp, const char __user *buf,
 			     size_t count, loff_t *f_pos)
 {
-	s32 minor = 0, ret = 0;
+	s32 ret = 0;
 	struct mlb_channel_info *pchinfo = NULL;
-	struct mlb_dev_info *pdevinfo = NULL;
-	u32 adt_sts = 0;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	int head, tail;
+	unsigned long flags;
 
+	/*
 	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
-	pchinfo = &_get_txchan(minor);
-	pdevinfo = &mlb_devinfo[minor];
+	*/
+	pchinfo = &pdevinfo->channels[TX_CHANNEL];
 
-	if (unlikely(count > pchinfo->buf_size)) {
+	if (count > pdevinfo->buf_size) {
 		/* too many data to write */
 		pr_warning("mxc_mlb150: overflow write data\n");
 		return -EFBIG;
@@ -2046,31 +2289,76 @@ static ssize_t mxc_mlb150_write(struct file *filp, const char __user *buf,
 
 	*f_pos = 0;
 
-	/* check the current tx buffer is used or not */
-	if (1 == pdevinfo->tx_busy) {
-		if (filp->f_flags & O_NONBLOCK)
-			return -EAGAIN;
+	read_lock_irqsave(&tx_rbuf->rb_lock, flags);
 
-		ret = wait_event_interruptible(pdevinfo->wt_wq,
-				0 == pdevinfo->tx_busy);
+	head = tx_rbuf->head;
+	tail = ACCESS_ONCE(tx_rbuf->tail);
 
-		if (ret < 0)
-			goto out;
+	if (0 == CIRC_SPACE(head, tail, TRANS_RING_NODES)) {
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		do {
+			DEFINE_WAIT(__wait);
+
+			for (;;) {
+				prepare_to_wait(&pdevinfo->tx_wq,
+						&__wait, TASK_INTERRUPTIBLE);
+
+				read_lock_irqsave(&tx_rbuf->rb_lock, flags);
+				if (CIRC_SPACE(tx_rbuf->head, tx_rbuf->tail,
+							TRANS_RING_NODES) > 0) {
+					read_unlock_irqrestore(&tx_rbuf->rb_lock,
+							flags);
+					break;
+				}
+				read_unlock_irqrestore(&tx_rbuf->rb_lock,
+								flags);
+
+				if (!signal_pending(current)) {
+					schedule();
+					continue;
+				}
+				return -ERESTARTSYS;
+			}
+			finish_wait(&pdevinfo->tx_wq, &__wait);
+		} while (0);
 	}
 
-	if (copy_from_user((void *)pchinfo->buf_ptr, buf, count)) {
+	if (copy_from_user((void *)tx_rbuf->virt_bufs[head], buf, count)) {
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
 		pr_err("mxc_mlb: copy from user failed\n");
 		ret = -EFAULT;
 		goto out;
 	}
 
-	adt_sts = mlb150_dev_get_adt_sts(pchinfo->address);
-	pdevinfo->tx_busy = 1;
-	mlb_start_tx(pchinfo->address, pdevinfo->channel_type,
-			adt_sts, pchinfo->buf_phy_addr);
+	read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+	write_lock_irqsave(&tx_rbuf->rb_lock, flags);
+	smp_wmb();
+	tx_rbuf->head = (head + 1) & (TRANS_RING_NODES - 1);
+	write_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
 
-	ret = count;
+	read_lock_irqsave(&tx_rbuf->rb_lock, flags);
+	if (0 == CIRC_CNT(head, tail, TRANS_RING_NODES)) {
+		u32 tx_buf_ptr, ahb_ch;
+		s32 adt_sts;
+		u32 ctype = pdevinfo->channel_type;
+
+		/* read index before reading contents at that index */
+		smp_read_barrier_depends();
+
+		tx_buf_ptr = tx_rbuf->phy_addrs[tail];
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+		ahb_ch = pdevinfo->channels[TX_CHANNEL].cl;
+		adt_sts = mlb150_dev_get_adt_sts(ahb_ch);
 
+		/*  Set ADT for TX */
+		mlb150_dev_pipo_next(ahb_ch, ctype, adt_sts, tx_buf_ptr);
+	} else
+		read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+	ret = count;
 out:
 	return ret;
 }
@@ -2080,23 +2368,41 @@ static unsigned int mxc_mlb150_poll(struct file *filp,
 {
 	int minor;
 	unsigned int ret = 0;
-	struct mlb_dev_info *pdevinfo = NULL;
+	struct mlb_data *drvdata = filp->private_data;
+	struct mlb_dev_info *pdevinfo = drvdata->devinfo;
+	struct mlb_ringbuf *tx_rbuf = &pdevinfo->tx_rbuf;
+	struct mlb_ringbuf *rx_rbuf = &pdevinfo->rx_rbuf;
+	int head, tail;
+	unsigned long flags;
+
 
 	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
 
-	pdevinfo = &mlb_devinfo[minor];
+	poll_wait(filp, &pdevinfo->rx_wq, wait);
+	poll_wait(filp, &pdevinfo->tx_wq, wait);
 
-	poll_wait(filp, &pdevinfo->rd_wq, wait);
-	poll_wait(filp, &pdevinfo->wt_wq, wait);
+	read_lock_irqsave(&tx_rbuf->rb_lock, flags);
+
+	head = tx_rbuf->head;
+	tail = tx_rbuf->tail;
 
 	/* check the tx buffer is avaiable or not */
-	if (0 == pdevinfo->tx_busy)
+	if (CIRC_SPACE(head, tail, TRANS_RING_NODES) >= 1)
 		ret |= POLLOUT | POLLWRNORM;
 
+	read_unlock_irqrestore(&tx_rbuf->rb_lock, flags);
+
+	read_lock_irqsave(&rx_rbuf->rb_lock, flags);
+
+	head = rx_rbuf->head;
+	tail = rx_rbuf->tail;
+
 	/* check the rx buffer filled or not */
-	if (pdevinfo->rx_bufs.rpos != pdevinfo->rx_bufs.wpos)
+	if (CIRC_CNT(head, tail, TRANS_RING_NODES) >= 1)
 		ret |= POLLIN | POLLRDNORM;
 
+	read_unlock_irqrestore(&rx_rbuf->rb_lock, flags);
+
 	/* check the exception event */
 	if (pdevinfo->ex_event)
 		ret |= POLLIN | POLLRDNORM;
@@ -2124,175 +2430,180 @@ static const struct file_operations mxc_mlb150_fops = {
 static int __devinit mxc_mlb150_probe(struct platform_device *pdev)
 {
 	int ret, mlb_major, i;
-	struct mxc_mlb_platform_data *plat_data;
+	struct mlb_data *drvdata;
 	struct resource *res;
-	void __iomem *base;
+	struct mxc_mlb_platform_data *plat_data;
+
 
 	plat_data =
 		(struct mxc_mlb_platform_data *)pdev->dev.platform_data;
 	plat_data->dev = &pdev->dev;
+	drvdata = kzalloc(sizeof(struct mlb_data), GFP_KERNEL);
+	if (!drvdata) {
+		dev_err(&pdev->dev, "can't allocate enough memory\n");
+		return -ENOMEM;
+	}
 
 	/**
 	 * Register MLB lld as four character devices
 	 */
-	ret = alloc_chrdev_region(&dev, 0, MLB_MINOR_DEVICES, "mxc_mlb150");
-	mlb_major = MAJOR(dev);
-	dev_dbg(plat_data->dev, "MLB device major: %d\n", mlb_major);
-
-	if (unlikely(ret < 0)) {
-		dev_err(plat_data->dev, "can't get major %d\n", mlb_major);
-		goto err2;
+	ret = alloc_chrdev_region(&drvdata->firstdev, 0,
+			MLB_MINOR_DEVICES, "mxc_mlb150");
+	mlb_major = MAJOR(drvdata->firstdev);
+	dev_dbg(&pdev->dev, "MLB device major: %d\n", mlb_major);
+
+	if (ret < 0) {
+		dev_err(&pdev->dev, "can't get major %d\n", mlb_major);
+		goto err_reg;
 	}
 
-	cdev_init(&plat_data->cdev, &mxc_mlb150_fops);
-	plat_data->cdev.owner = THIS_MODULE;
+	cdev_init(&drvdata->cdev, &mxc_mlb150_fops);
+	drvdata->cdev.owner = THIS_MODULE;
 
-	ret = cdev_add(&plat_data->cdev, dev, MLB_MINOR_DEVICES);
-	if (unlikely(ret)) {
-		dev_err(plat_data->dev, "can't add cdev\n");
-		goto err2;
+	ret = cdev_add(&drvdata->cdev, drvdata->firstdev, MLB_MINOR_DEVICES);
+	if (ret) {
+		dev_err(&pdev->dev, "can't add cdev\n");
+		goto err_reg;
 	}
 
 	/* create class and device for udev information */
-	mlb_class = class_create(THIS_MODULE, "mlb150");
-	if (unlikely(IS_ERR(mlb_class))) {
-		dev_err(plat_data->dev, "failed to create mlb150 class\n");
+	drvdata->class = class_create(THIS_MODULE, "mlb150");
+	if (IS_ERR(drvdata->class)) {
+		dev_err(&pdev->dev, "failed to create device class\n");
 		ret = -ENOMEM;
-		goto err2;
+		goto err_reg;
 	}
 
 	for (i = 0; i < MLB_MINOR_DEVICES; i++) {
-		class_dev = device_create(mlb_class, NULL, MKDEV(mlb_major, i),
-					  NULL, mlb_devinfo[i].dev_name);
-		if (unlikely(IS_ERR(class_dev))) {
-			dev_err(plat_data->dev, "failed to create mlb150 %s"
+		struct device *class_dev;
+
+		class_dev = device_create(drvdata->class, NULL,
+				MKDEV(mlb_major, i),
+				NULL, mlb_devinfo[i].dev_name);
+		if (IS_ERR(class_dev)) {
+			dev_err(&pdev->dev, "failed to create mlb150 %s"
 				" class device\n", mlb_devinfo[i].dev_name);
 			ret = -ENOMEM;
-			goto err1;
+			goto err_dev;
 		}
 	}
 
-	/* get irq line */
-	/* AHB0 IRQ */
+	/* get irq */
+	/* ahb0 irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
 	if (unlikely(res == NULL)) {
-		dev_err(plat_data->dev, "No mlb150 ahb0 irq line provided\n");
-		goto err0;
+		dev_err(&pdev->dev, "No ahb0 irq line provided\n");
+		goto err_irq;
 	}
-
-	ahb0_irq = res->start;
-	dev_dbg(plat_data->dev, "ahb0_irq: %d\n", ahb0_irq);
-	if (request_irq(ahb0_irq, mlb_ahb_isr, 0, "mlb_ahb0", NULL)) {
-		dev_err(plat_data->dev, "failed to request irq\n");
-		ret = -EBUSY;
-		goto err0;
+	drvdata->irq_ahb0 = res->start;
+	dev_dbg(&pdev->dev, "ahb0_irq: %d\n", drvdata->irq_ahb0);
+	if (request_irq(drvdata->irq_ahb0, mlb_ahb_isr, 0, "mlb_ahb0", NULL)) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", drvdata->irq_ahb0);
+		goto err_irq;
 	}
 
-	/* AHB1 IRQ */
+	/* ahb1 irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 2);
 	if (unlikely(res == NULL)) {
-		dev_err(plat_data->dev, "No mlb150 ahb0 irq line provided\n");
-		goto err0;
+		dev_err(&pdev->dev, "No ahb1 irq line provided\n");
+		goto err_irq;
 	}
-
-	ahb1_irq = res->start;
-	dev_dbg(plat_data->dev, "ahb1_irq: %d\n", ahb1_irq);
-	if (request_irq(ahb1_irq, mlb_ahb_isr, 0, "mlb_ahb1", NULL)) {
-		dev_err(plat_data->dev, "failed to request irq\n");
-		ret = -EBUSY;
-		goto err0;
+	drvdata->irq_ahb1 = res->start;
+	dev_dbg(&pdev->dev, "ahb1_irq: %d\n", drvdata->irq_ahb1);
+	if (request_irq(drvdata->irq_ahb1, mlb_ahb_isr, 0, "mlb_ahb1", NULL)) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", drvdata->irq_ahb1);
+		goto err_irq;
 	}
 
-	/* MLB IRQ */
+	/* mlb irq */
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (res == NULL) {
-		dev_err(plat_data->dev, "No mlb150 irq line provided\n");
-		goto err0;
+	if (unlikely(res == NULL)) {
+		dev_err(&pdev->dev, "No mlb irq line provided\n");
+		goto err_irq;
 	}
-
-	mlb_irq = res->start;
-	dev_dbg(plat_data->dev, "mlb_irq: %d\n", mlb_irq);
-	if (request_irq(mlb_irq, mlb_isr, 0, "mlb", NULL)) {
-		dev_err(plat_data->dev, "failed to request irq\n");
-		ret = -EBUSY;
-		goto err0;
+	drvdata->irq_mlb  = res->start;
+	dev_dbg(&pdev->dev, "mlb_irq: %d\n", drvdata->irq_mlb);
+	if (request_irq(drvdata->irq_mlb, mlb_isr, 0, "mlb", NULL)) {
+		dev_err(&pdev->dev, "can't claim irq %d\n", drvdata->irq_mlb);
+		goto err_irq;
 	}
 
 	/* ioremap from phy mlb to kernel space */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (unlikely(res == NULL)) {
-		dev_err(plat_data->dev, "No mlb150 base address provided\n");
-		goto err0;
+	if (!res) {
+		dev_err(&pdev->dev, "can't get device resources\n");
+		ret = -ENOENT;
+		goto err_unmap;
 	}
-
-	base = ioremap(res->start, res->end - res->start);
-	dev_dbg(plat_data->dev, "mapped mlb150 base address: 0x%08x\n",
-		(u32)base);
-
-	if (unlikely(base == NULL)) {
-		dev_err(plat_data->dev,
-				"failed to do ioremap with mlb150 base\n");
-		goto err0;
+	mlb_base = (u32)ioremap(res->start, res->end - res->start);
+	dev_dbg(&pdev->dev, "mapped base address: 0x%08x\n", (u32)mlb_base);
+	if (!mlb_base) {
+		dev_err(&pdev->dev,
+			"failed to get ioremap base\n");
+		goto err_irq;
 	}
-	mlb_base = (u32)base;
-
-	dev_dbg(plat_data->dev, "mlb reg base: 0x%08x\n", mlb_base);
+	drvdata->membase = mlb_base;
 
+#ifdef CONFIG_REGULATOR
 	if (plat_data->reg_nvcc) {
 		/* power on MLB */
-		reg_nvcc = regulator_get(plat_data->dev, plat_data->reg_nvcc);
-		if (unlikely(!IS_ERR(reg_nvcc))) {
+		drvdata->nvcc = regulator_get(&pdev->dev, plat_data->reg_nvcc);
+		if (!IS_ERR(drvdata->nvcc)) {
 			/* set MAX LDO6 for NVCC to 2.5V */
-			regulator_set_voltage(reg_nvcc, 2500000, 2500000);
-			regulator_enable(reg_nvcc);
+			regulator_set_voltage(drvdata->nvcc, 2500000, 2500000);
+			regulator_enable(drvdata->nvcc);
 		}
 	}
+#endif
 
 	/* enable clock */
-	if (likely(plat_data->mlb_clk)) {
-		mlb_clk = clk_get(plat_data->dev, plat_data->mlb_clk);
-		if (unlikely(IS_ERR(mlb_clk))) {
+	if (plat_data->mlb_clk) {
+		drvdata->clk_mlb3p = clk_get(&pdev->dev, plat_data->mlb_clk);
+		if (IS_ERR(drvdata->clk_mlb3p)) {
 			dev_err(&pdev->dev, "unable to get mlb clock\n");
-			ret = PTR_ERR(mlb_clk);
-			goto err0;
+			ret = PTR_ERR(drvdata->clk_mlb3p);
+			goto err_clk;
 		}
-		clk_enable(mlb_clk);
+		clk_enable(drvdata->clk_mlb3p);
 	}
 
-	if (likely(plat_data->mlb_pll_clk)) {
-		mlb_pll_clk = clk_get(plat_data->dev, plat_data->mlb_pll_clk);
-		if (unlikely(IS_ERR(mlb_pll_clk))) {
+	if (plat_data->mlb_pll_clk) {
+		drvdata->clk_mlb6p = clk_get(&pdev->dev,
+				plat_data->mlb_pll_clk);
+		if (IS_ERR(drvdata->clk_mlb6p)) {
 			dev_err(&pdev->dev, "unable to get mlb pll clock\n");
-			ret = PTR_ERR(mlb_pll_clk);
-			goto err0;
+			ret = PTR_ERR(drvdata->clk_mlb6p);
+			goto err_clk;
 		}
 	}
 
-	/* initial MLB module */
-	mlb150_dev_init();
+	platform_set_drvdata(pdev, drvdata);
 
 	return 0;
 
-err0:
-	if (likely(ahb0_irq)) {
-		free_irq(ahb0_irq, NULL);
-		ahb0_irq = 0;
-	}
-	if (likely(ahb1_irq)) {
-		free_irq(ahb1_irq, NULL);
-		ahb1_irq = 0;
-	}
-	if (likely(mlb_irq)) {
-		free_irq(mlb_irq, NULL);
-		mlb_irq = 0;
-	}
-err1:
+err_clk:
+	if (plat_data->mlb_clk)
+		clk_disable(drvdata->clk_mlb3p);
+	if (plat_data->mlb_pll_clk)
+		clk_disable(drvdata->clk_mlb6p);
+err_irq:
+	if (drvdata->irq_ahb0)
+		free_irq(drvdata->irq_ahb0, NULL);
+	if (drvdata->irq_ahb1)
+		free_irq(drvdata->irq_ahb1, NULL);
+	if (drvdata->irq_mlb)
+		free_irq(drvdata->irq_mlb, NULL);
+err_dev:
 	for (--i; i >= 0; i--)
-		device_destroy(mlb_class, MKDEV(mlb_major, i));
+		device_destroy(drvdata->class, MKDEV(mlb_major, i));
+
+	class_destroy(drvdata->class);
+err_reg:
+	unregister_chrdev_region(drvdata->firstdev, MLB_MINOR_DEVICES);
+err_unmap:
+	iounmap((void __iomem *)drvdata->membase);
 
-	class_destroy(mlb_class);
-err2:
-	unregister_chrdev_region(dev, MLB_MINOR_DEVICES);
+	kfree(drvdata);
 
 	return ret;
 }
@@ -2301,6 +2612,7 @@ static int __devexit mxc_mlb150_remove(struct platform_device *pdev)
 {
 	int i;
 	struct mxc_mlb_platform_data *plat_data;
+	struct mlb_data *drvdata = platform_get_drvdata(pdev);
 
 	plat_data = (struct mxc_mlb_platform_data *)pdev->dev.platform_data;
 
@@ -2308,43 +2620,43 @@ static int __devexit mxc_mlb150_remove(struct platform_device *pdev)
 
 	/* disable mlb clock */
 	if (plat_data->mlb_clk) {
-		clk_disable(mlb_clk);
-		clk_put(mlb_clk);
+		clk_disable(drvdata->clk_mlb3p);
+		clk_put(drvdata->clk_mlb3p);
 	}
-
 	if (plat_data->mlb_pll_clk)
-		clk_put(mlb_pll_clk);
+		clk_put(drvdata->clk_mlb6p);
 
 	/* disable mlb power */
-	if (plat_data->reg_nvcc) {
-		regulator_disable(reg_nvcc);
-		regulator_put(reg_nvcc);
+#ifdef CONFIG_REGULATOR
+	if (drvdata->nvcc) {
+		regulator_disable(drvdata->nvcc);
+		regulator_put(drvdata->nvcc);
 	}
+#endif
 
 	/* inactive GPIO */
 	gpio_mlb_inactive();
 
 	/* iounmap */
-	if (mlb_base) {
-		iounmap((void *)mlb_base);
-		mlb_base = 0;
-	}
+	iounmap((void __iomem *)drvdata->membase);
 
-	if (ahb0_irq)
-		free_irq(ahb0_irq, NULL);
-	if (ahb1_irq)
-		free_irq(ahb1_irq, NULL);
-	if (mlb_irq)
-		free_irq(mlb_irq, NULL);
-	ahb0_irq = ahb1_irq = mlb_irq = 0;
+	if (drvdata->irq_ahb0)
+		free_irq(drvdata->irq_ahb0, NULL);
+	if (drvdata->irq_ahb1)
+		free_irq(drvdata->irq_ahb1, NULL);
+	if (drvdata->irq_mlb)
+		free_irq(drvdata->irq_mlb,  NULL);
 
 	/* destroy mlb device class */
 	for (i = MLB_MINOR_DEVICES - 1; i >= 0; i--)
-		device_destroy(mlb_class, MKDEV(MAJOR(dev), i));
-	class_destroy(mlb_class);
+		device_destroy(drvdata->class,
+				MKDEV(MAJOR(drvdata->firstdev), i));
+	class_destroy(drvdata->class);
 
 	/* Unregister the two MLB devices */
-	unregister_chrdev_region(dev, MLB_MINOR_DEVICES);
+	unregister_chrdev_region(drvdata->firstdev, MLB_MINOR_DEVICES);
+
+	kfree(drvdata);
 
 	return 0;
 }
@@ -2352,11 +2664,23 @@ static int __devexit mxc_mlb150_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int mxc_mlb150_suspend(struct platform_device *pdev, pm_message_t state)
 {
+	struct mlb_data *drvdata = platform_get_drvdata(pdev);
+
+	mlb150_dev_exit();
+
+	clk_disable(drvdata->clk_mlb3p);
+
 	return 0;
 }
 
 static int mxc_mlb150_resume(struct platform_device *pdev)
 {
+	struct mlb_data *drvdata = platform_get_drvdata(pdev);
+
+	clk_enable(drvdata->clk_mlb6p);
+
+	mlb150_dev_init();
+
 	return 0;
 }
 #else
diff --git a/drivers/mxc/thermal/cooling.c b/drivers/mxc/thermal/cooling.c
index 7019d99..605c1c4 100644
--- a/drivers/mxc/thermal/cooling.c
+++ b/drivers/mxc/thermal/cooling.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -57,7 +57,8 @@ cpufreq, it minor 1, and when we promote cpufreq, it add 1, so
 if it is 0, mean we didn't change the cpufreq */
 static int cpufreq_change_count;
 
-extern int thermal_hot;
+extern atomic_t thermal_on;
+extern int thermal_notifier_call_chain(unsigned long val);
 int anatop_thermal_get_cpufreq_cur(void)
 {
 	int ret = -EINVAL;
@@ -238,7 +239,8 @@ imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
 	secondary CPUs that detached by thermal driver */
 	if (cooling_cpuhotplug) {
 		if (!state) {
-			thermal_hot = 0;
+			if (atomic_read(&thermal_on))
+				thermal_notifier_call_chain(0);
 			for (i = 1; i < 4; i++) {
 				if (cpu_mask && (0x1 << i)) {
 					anatop_thermal_cpu_hotplug(true);
@@ -249,7 +251,8 @@ imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
 		}
 	} else {
 		if (!state) {
-			thermal_hot = 0;
+			if (atomic_read(&thermal_on))
+				thermal_notifier_call_chain(0);
 			if (cpufreq_change_count < 0)
 				anatop_thermal_cpufreq_up();
 			else if (cpufreq_change_count > 0)
diff --git a/drivers/mxc/thermal/thermal.c b/drivers/mxc/thermal/thermal.c
index 21ff18f..cbe771d 100644
--- a/drivers/mxc/thermal/thermal.c
+++ b/drivers/mxc/thermal/thermal.c
@@ -43,7 +43,6 @@
 #include <linux/cpufreq.h>
 #include <linux/clk.h>
 #include "anatop_driver.h"
-#include <mach/hardware.h>
 
 /* register define of anatop */
 #define HW_ANADIG_ANA_MISC0	(0x00000150)
@@ -157,8 +156,7 @@ static const struct anatop_device_id thermal_device_ids[] = {
 	{ANATOP_THERMAL_HID},
 	{""},
 };
-int thermal_hot;
-EXPORT_SYMBOL(thermal_hot);
+atomic_t thermal_on = ATOMIC_INIT(1);
 
 enum {
 	DEBUG_USER_STATE = 1U << 0,
@@ -278,6 +276,7 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 	struct anatop_thermal *tz = thermal->devdata;
 	unsigned int tmp;
 	unsigned int reg;
+	unsigned int val;
 
 	if (!tz)
 		return -EINVAL;
@@ -312,11 +311,16 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 		anatop_base + HW_ANADIG_TEMPSENSE0_SET);
 
 	tmp = 0;
+	val = jiffies;
 	/* read temperature values */
 	while ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0)
-		& BM_ANADIG_TEMPSENSE0_FINISHED) == 0)
+		& BM_ANADIG_TEMPSENSE0_FINISHED) == 0) {
+		if (time_after(jiffies, (unsigned long)(val + HZ / 2))) {
+			pr_info("Thermal sensor timeout, retry!\n");
+			return 0;
+		}
 		msleep(10);
-
+	}
 	reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0);
 	tmp = (reg & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
 		>> BP_ANADIG_TEMPSENSE0_TEMP_VALUE;
@@ -340,6 +344,11 @@ static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
 	*temp = (cooling_device_disable && tz->temperature >= KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET)) ?
 			KELVIN_TO_CEL(TEMP_CRITICAL - 1, KELVIN_OFFSET) : tz->temperature;
 
+	/* Set alarm threshold if necessary */
+	if ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0) &
+		BM_ANADIG_TEMPSENSE0_ALARM_VALUE) == 0)
+		anatop_update_alarm(raw_critical);
+
 	return 0;
 }
 
@@ -573,6 +582,27 @@ static int anatop_thermal_get_crit_temp(struct thermal_zone_device *thermal,
 		return -EINVAL;
 }
 
+static BLOCKING_NOTIFIER_HEAD(thermal_chain_head);
+
+int register_thermal_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&thermal_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(register_thermal_notifier);
+
+int unregister_thermal_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&thermal_chain_head, nb);
+}
+EXPORT_SYMBOL_GPL(unregister_thermal_notifier);
+
+int thermal_notifier_call_chain(unsigned long val)
+{
+	return (blocking_notifier_call_chain(&thermal_chain_head, val, NULL)
+		== NOTIFY_BAD) ? -EINVAL : 0;
+}
+EXPORT_SYMBOL_GPL(thermal_notifier_call_chain);
+
 static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 			   enum thermal_trip_type trip_type)
 {
@@ -590,7 +620,8 @@ static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 		printk(KERN_WARNING "thermal_notify: trip_critical reached!\n");
 		arch_reset(mode, cmd);
 	} else if (trip_type == THERMAL_TRIP_HOT) {
-		thermal_hot = 1;
+		if (atomic_read(&thermal_on))
+			thermal_notifier_call_chain(1);
 		printk(KERN_DEBUG "thermal_notify: trip_hot reached!\n");
 		type = ANATOP_THERMAL_NOTIFY_HOT;
 		/* if temperature increase, continue to detach secondary CPUs*/
@@ -605,7 +636,8 @@ static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
 			printk(KERN_INFO "No secondary CPUs detached!\n");
 		full_run = false;
 	} else {
-		thermal_hot = 0;
+		if (atomic_read(&thermal_on))
+			thermal_notifier_call_chain(0);
 		if (!full_run) {
 			temperature_cooling = 0;
 			if (cooling_cpuhotplug)
@@ -861,13 +893,13 @@ static int anatop_thermal_counting_ratio(unsigned int fuse_data)
 	raw_hot = (fuse_data & 0xfff00) >> 8;
 	hot_temp = fuse_data & 0xff;
 
-	if (!calibration_valid && cpu_is_mx6q())
+	if (!calibration_valid)
 		/*
 		 * The universal equation for thermal sensor
 		 * is slope = 0.4297157 - (0.0015976 * 25C fuse),
 		 * here we convert them to integer to make them
 		 * easy for counting, FACTOR1 is 15976,
-		 * FACTORs is 4297157. Our ratio = -100 * slope.
+		 * FACTOR2 is 4297157. Our ratio = -100 * slope.
 		 */
 		ratio = ((FACTOR1 * raw_25c - FACTOR2) + 50000) / 100000;
 	else
@@ -879,7 +911,6 @@ static int anatop_thermal_counting_ratio(unsigned int fuse_data)
 	/* Init default critical temp to set alarm */
 	raw_critical = raw_25c - ratio * (KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET) - 25) / 100;
 	clk_enable(pll3_clk);
-	anatop_update_alarm(raw_critical);
 
 	return ret;
 }
@@ -898,6 +929,35 @@ static irqreturn_t anatop_thermal_alarm_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static ssize_t anatop_thermal_flag_show(struct device *dev,
+		struct device_attribute *attr, char *buf) {
+	return sprintf(buf, "read thermal_hot_flag:%d\n",
+			atomic_read(&thermal_on));
+}
+
+static ssize_t anatop_thermal_flag_store(struct device *dev,
+		struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	int ret;
+	unsigned long data;
+	ret = strict_strtoul(buf, 10, &data);
+	if (data == 0)
+		atomic_set(&thermal_on, 0);
+	else
+		atomic_set(&thermal_on, 1);
+	return count;
+}
+
+static struct device_attribute anatop_thermal_flag_dev_attr = {
+	.attr = {
+		.name = "thermal_hot_flag",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.show = anatop_thermal_flag_show,
+	.store = anatop_thermal_flag_store,
+};
+
 static int anatop_thermal_probe(struct platform_device *pdev)
 {
 	int retval = 0;
@@ -962,6 +1022,9 @@ static int anatop_thermal_probe(struct platform_device *pdev)
 
 	anatop_thermal_add(device);
 	anatop_thermal_cpufreq_init();
+	retval = device_create_file(&pdev->dev, &anatop_thermal_flag_dev_attr);
+	if (retval)
+		dev_err(&pdev->dev, "create device file failed!\n");
 	pr_info("%s: default cooling device is cpufreq!\n", __func__);
 
 	goto success;
diff --git a/drivers/mxc/vpu/mxc_vpu.c b/drivers/mxc/vpu/mxc_vpu.c
index 3652e54..8a219db 100644
--- a/drivers/mxc/vpu/mxc_vpu.c
+++ b/drivers/mxc/vpu/mxc_vpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -251,8 +251,17 @@ static int vpu_open(struct inode *inode, struct file *filp)
 
 	mutex_lock(&vpu_data.lock);
 
-	if (open_count++ == 0 && !IS_ERR(vpu_regulator))
-		regulator_enable(vpu_regulator);
+	if (open_count++ == 0) {
+		if (!IS_ERR(vpu_regulator))
+			regulator_enable(vpu_regulator);
+
+#ifdef CONFIG_SOC_IMX6Q
+		clk_enable(vpu_clk);
+		if (READ_REG(BIT_CUR_PC))
+			pr_debug("Not power off before vpu open!\n");
+		clk_disable(vpu_clk);
+#endif
+	}
 
 	filp->private_data = (void *)(&vpu_data);
 	mutex_unlock(&vpu_data.lock);
@@ -519,6 +528,20 @@ static long vpu_ioctl(struct file *filp, u_int cmd,
 		}
 		break;
 	}
+	case VPU_IOC_LOCK_DEV:
+		{
+			u32 lock_en;
+
+			if (get_user(lock_en, (u32 __user *) arg))
+				return -EFAULT;
+
+			if (lock_en)
+				mutex_lock(&vpu_data.lock);
+			else
+				mutex_unlock(&vpu_data.lock);
+
+			break;
+		}
 	default:
 		{
 			printk(KERN_ERR "No such IOCTL, cmd is %d\n", cmd);
@@ -535,11 +558,69 @@ static long vpu_ioctl(struct file *filp, u_int cmd,
  */
 static int vpu_release(struct inode *inode, struct file *filp)
 {
+	int i;
+	unsigned long timeout;
 
 	mutex_lock(&vpu_data.lock);
+
 	if (open_count > 0 && !(--open_count)) {
-		if (!IS_ERR(vpu_regulator))
-			regulator_disable(vpu_regulator);
+
+		/* Wait for vpu go to idle state */
+		clk_enable(vpu_clk);
+		if (READ_REG(BIT_CUR_PC)) {
+
+			timeout = jiffies + HZ;
+			while (READ_REG(BIT_BUSY_FLAG)) {
+				msleep(1);
+				if (time_after(jiffies, timeout)) {
+					printk(KERN_WARNING "VPU timeout during release\n");
+					break;
+				}
+			}
+			clk_disable(vpu_clk);
+
+			/* Clean up interrupt */
+			cancel_work_sync(&vpu_data.work);
+			flush_workqueue(vpu_data.workqueue);
+			irq_status = 0;
+
+			clk_enable(vpu_clk);
+			if (READ_REG(BIT_BUSY_FLAG)) {
+
+				if (cpu_is_mx51() || cpu_is_mx53()) {
+					printk(KERN_ERR
+						"fatal error: can't gate/power off when VPU is busy\n");
+					clk_disable(vpu_clk);
+					mutex_unlock(&vpu_data.lock);
+					return -EFAULT;
+				}
+
+#ifdef CONFIG_SOC_IMX6Q
+				if (cpu_is_mx6dl() || cpu_is_mx6q()) {
+					WRITE_REG(0x11, 0x10F0);
+					timeout = jiffies + HZ;
+					while (READ_REG(0x10F4) != 0x77) {
+						msleep(1);
+						if (time_after(jiffies, timeout))
+							break;
+					}
+
+					if (READ_REG(0x10F4) != 0x77) {
+						printk(KERN_ERR
+							"fatal error: can't gate/power off when VPU is busy\n");
+						WRITE_REG(0x0, 0x10F0);
+						clk_disable(vpu_clk);
+						mutex_unlock(&vpu_data.lock);
+						return -EFAULT;
+					} else {
+						if (vpu_plat->reset)
+							vpu_plat->reset();
+					}
+				}
+#endif
+			}
+		}
+		clk_disable(vpu_clk);
 
 		vpu_free_buffers();
 
@@ -548,6 +629,14 @@ static int vpu_release(struct inode *inode, struct file *filp)
 		share_mem.cpu_addr = 0;
 		vfree((void *)vshare_mem.cpu_addr);
 		vshare_mem.cpu_addr = 0;
+
+		vpu_clk_usercount = clk_get_usecount(vpu_clk);
+		for (i = 0; i < vpu_clk_usercount; i++)
+			clk_disable(vpu_clk);
+
+		if (!IS_ERR(vpu_regulator))
+			regulator_disable(vpu_regulator);
+
 	}
 	mutex_unlock(&vpu_data.lock);
 
@@ -891,7 +980,9 @@ static int vpu_resume(struct platform_device *pdev)
 			WRITE_REG(0x0, BIT_RESET_CTRL);
 			WRITE_REG(0x0, BIT_CODE_RUN);
 			/* MX6 RTL has a bug not to init MBC_SET_SUBBLK_EN on reset */
+#ifdef CONFIG_SOC_IMX6Q
 			WRITE_REG(0x0, MBC_SET_SUBBLK_EN);
+#endif
 
 			/*
 			 * Re-load boot code, from the codebuffer in external RAM.
@@ -978,6 +1069,16 @@ static void __exit vpu_exit(void)
 	vpu_free_dma_buffer(&pic_para_mem);
 	vpu_free_dma_buffer(&user_data_mem);
 
+	/* reset VPU state */
+	if (!IS_ERR(vpu_regulator))
+		regulator_enable(vpu_regulator);
+	clk_enable(vpu_clk);
+	if (vpu_plat->reset)
+		vpu_plat->reset();
+	clk_disable(vpu_clk);
+	if (!IS_ERR(vpu_regulator))
+		regulator_disable(vpu_regulator);
+
 	clk_put(vpu_clk);
 
 	platform_driver_unregister(&mxcvpu_driver);
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index d0f8c7e..f0123ef 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -315,16 +315,24 @@ EXPORT_SYMBOL_GPL(can_put_echo_skb);
  * is handled in the device driver. The driver must protect
  * access to priv->echo_skb, if necessary.
  */
-void can_get_echo_skb(struct net_device *dev, unsigned int idx)
+unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx)
 {
 	struct can_priv *priv = netdev_priv(dev);
 
 	BUG_ON(idx >= priv->echo_skb_max);
 
 	if (priv->echo_skb[idx]) {
+		struct sk_buff *skb = priv->echo_skb[idx];
+		struct can_frame *cf = (struct can_frame *)skb->data;
+		u8 dlc = cf->can_dlc;
+
 		netif_rx(priv->echo_skb[idx]);
 		priv->echo_skb[idx] = NULL;
+
+		return dlc;
 	}
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(can_get_echo_skb);
 
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 920b8a0..d3b1342 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -126,7 +126,8 @@
 	(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)
 
 /* FLEXCAN interrupt flag register (IFLAG) bits */
-#define FLEXCAN_TX_BUF_ID		8
+#define FLEXCAN_RESERVED_BUF_ID		8
+#define FLEXCAN_TX_BUF_ID		13
 #define FLEXCAN_IFLAG_BUF(x)		BIT(x)
 #define FLEXCAN_IFLAG_RX_FIFO_OVERFLOW	BIT(7)
 #define FLEXCAN_IFLAG_RX_FIFO_WARN	BIT(6)
@@ -284,7 +285,6 @@ static int flexcan_get_berr_counter(const struct net_device *dev,
 static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	const struct flexcan_priv *priv = netdev_priv(dev);
-	struct net_device_stats *stats = &dev->stats;
 	struct flexcan_regs __iomem *regs = priv->base;
 	struct can_frame *cf = (struct can_frame *)skb->data;
 	u32 can_id;
@@ -314,13 +314,15 @@ static int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		writel(data, &regs->cantxfg[FLEXCAN_TX_BUF_ID].data[1]);
 	}
 
+	can_put_echo_skb(skb, dev, 0);
+
 	writel(can_id, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_id);
 	writel(ctrl, &regs->cantxfg[FLEXCAN_TX_BUF_ID].can_ctrl);
 
-	kfree_skb(skb);
-
-	/* tx_packets is incremented in flexcan_irq */
-	stats->tx_bytes += cf->can_dlc;
+	if (priv->version == FLEXCAN_VER_10_0_12) {
+		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
+		writel(0x0, &regs->cantxfg[FLEXCAN_RESERVED_BUF_ID].can_ctrl);
+	}
 
 	return NETDEV_TX_OK;
 }
@@ -633,7 +635,7 @@ static irqreturn_t flexcan_irq(int irq, void *dev_id)
 
 	/* transmission complete interrupt */
 	if (reg_iflag1 & (1 << FLEXCAN_TX_BUF_ID)) {
-		/* tx_bytes is incremented in flexcan_start_xmit */
+		stats->tx_bytes += can_get_echo_skb(dev, 0);
 		stats->tx_packets++;
 		writel((1 << FLEXCAN_TX_BUF_ID), &regs->iflag1);
 		netif_wake_queue(dev);
@@ -722,13 +724,14 @@ static int flexcan_chip_start(struct net_device *dev)
 	 * enable warning int
 	 * choose format C
 	 * enable self wakeup
+	 * disable local echo
 	 *
 	 */
 	reg_mcr = readl(&regs->mcr);
 	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |
 		FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |
 		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_WAK_MSK |
-		FLEXCAN_MCR_SLF_WAK;
+		FLEXCAN_MCR_SLF_WAK | FLEXCAN_MCR_SRX_DIS;
 	dev_dbg(dev->dev.parent, "%s: writing mcr=0x%08x", __func__, reg_mcr);
 	writel(reg_mcr, &regs->mcr);
 
@@ -1008,7 +1011,7 @@ static int __devinit flexcan_probe(struct platform_device *pdev)
 		goto failed_map;
 	}
 
-	dev = alloc_candev(sizeof(struct flexcan_priv), 0);
+	dev = alloc_candev(sizeof(struct flexcan_priv), 1);
 	if (!dev) {
 		err = -ENOMEM;
 		goto failed_alloc;
@@ -1016,7 +1019,7 @@ static int __devinit flexcan_probe(struct platform_device *pdev)
 
 	dev->netdev_ops = &flexcan_netdev_ops;
 	dev->irq = irq;
-	dev->flags |= IFF_ECHO; /* we support local echo in hardware */
+	dev->flags |= IFF_ECHO;
 
 	priv = netdev_priv(dev);
 	priv->can.clock.freq = clk_get_rate(clk);
diff --git a/drivers/net/fec.c b/drivers/net/fec.c
index 4b5818e..71e0abc 100755
--- a/drivers/net/fec.c
+++ b/drivers/net/fec.c
@@ -19,7 +19,7 @@
  * Copyright (c) 2004-2006 Macq Electronique SA.
  *
  * Support for FEC IEEE 1588.
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  */
 
 #include <linux/module.h>
@@ -27,6 +27,7 @@
 #include <linux/string.h>
 #include <linux/ptrace.h>
 #include <linux/errno.h>
+#include <linux/gpio.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -69,11 +70,13 @@
 #define FEC_QUIRK_ENET_MAC		(1 << 0)
 /* Controller needs driver to swap frame */
 #define FEC_QUIRK_SWAP_FRAME		(1 << 1)
+/* ENET IP errata ticket TKT168103 */
+#define FEC_QUIRK_BUG_TKT168103		(1 << 2)
 
 static struct platform_device_id fec_devtype[] = {
 	{
 		.name = "enet",
-		.driver_data = FEC_QUIRK_ENET_MAC,
+		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_BUG_TKT168103,
 	},
 	{
 		.name = "fec",
@@ -81,7 +84,8 @@ static struct platform_device_id fec_devtype[] = {
 	},
 	{
 		.name = "imx28-fec",
-		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_SWAP_FRAME,
+		.driver_data = FEC_QUIRK_ENET_MAC | FEC_QUIRK_SWAP_FRAME |
+				FEC_QUIRK_BUG_TKT168103,
 	},
 	{ }
 };
@@ -192,6 +196,7 @@ struct fec_enet_private {
 	struct net_device *netdev;
 
 	struct clk *clk;
+	struct clk *mdc_clk;
 
 	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
 	unsigned char *tx_bounce[TX_RING_SIZE];
@@ -228,6 +233,7 @@ struct fec_enet_private {
 	int	link;
 	int	full_duplex;
 	struct	completion mdio_done;
+	struct delayed_work fixup_trigger_tx;
 
 	struct  fec_ptp_private *ptp_priv;
 	uint    ptimer_present;
@@ -277,13 +283,44 @@ static void *swap_buffer(void *bufaddr, int len)
 	return bufaddr;
 }
 
+static inline
+void *fec_enet_get_pre_txbd(struct net_device *ndev)
+{
+	struct fec_enet_private *fep = netdev_priv(ndev);
+	struct bufdesc *bdp = fep->cur_tx;
+
+	if (bdp == fep->tx_bd_base)
+		return bdp + TX_RING_SIZE;
+	else
+		return bdp - 1;
+
+}
+
+/* MTIP enet IP have one IC issue recorded at PDM ticket:TKT168103
+ * The TDAR bit after being set by software is not acted upon by the
+ * ENET module due to the timing of when the ENET state machine
+ * clearing the TDAR bit occurring coincident or momentarily after
+ * the software sets the bit.
+ * This forces ENET module to check the Transmit buffer descriptor
+ * and take action if the “ready” flag is set. Otherwise the ENET
+ * returns to idle mode.
+ */
+static void fixup_trigger_tx_func(struct work_struct *work)
+{
+	struct fec_enet_private *fep =
+			container_of(work, struct fec_enet_private,
+					fixup_trigger_tx.work);
+
+	writel(0, fep->hwp + FEC_X_DES_ACTIVE);
+}
+
 static netdev_tx_t
 fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	const struct platform_device_id *id_entry =
 				platform_get_device_id(fep->pdev);
-	struct bufdesc *bdp;
+	struct bufdesc *bdp, *bdp_pre;
 	void *bufaddr;
 	unsigned short	status;
 	unsigned long   estatus;
@@ -299,7 +336,6 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	/* Fill in a Tx ring entry */
 	bdp = fep->cur_tx;
-
 	status = bdp->cbd_sc;
 
 	if (status & BD_ENET_TX_READY) {
@@ -372,6 +408,12 @@ fec_enet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	/* Trigger transmission start */
 	writel(0, fep->hwp + FEC_X_DES_ACTIVE);
 
+	bdp_pre = fec_enet_get_pre_txbd(ndev);
+	if ((id_entry->driver_data & FEC_QUIRK_BUG_TKT168103) &&
+		!(bdp_pre->cbd_sc & BD_ENET_TX_READY))
+		schedule_delayed_work(&fep->fixup_trigger_tx,
+					 msecs_to_jiffies(1));
+
 	/* If this was the last BD in the ring, start at the beginning again. */
 	if (status & BD_ENET_TX_WRAP)
 		bdp = fep->tx_bd_base;
@@ -594,7 +636,7 @@ static int fec_rx_poll(struct napi_struct *napi, int budget)
 		data = (__u8 *)__va(bdp->cbd_bufaddr);
 
 		if (bdp->cbd_bufaddr)
-			dma_unmap_single(&ndev->dev, bdp->cbd_bufaddr,
+			dma_unmap_single(&fep->pdev->dev, bdp->cbd_bufaddr,
 				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
 
 		if (id_entry->driver_data & FEC_QUIRK_SWAP_FRAME)
@@ -622,7 +664,7 @@ static int fec_rx_poll(struct napi_struct *napi, int budget)
 			netif_receive_skb(skb);
 		}
 
-		bdp->cbd_bufaddr = dma_map_single(&ndev->dev, data,
+		bdp->cbd_bufaddr = dma_map_single(&fep->pdev->dev, data,
 				FEC_ENET_RX_FRSIZE, DMA_FROM_DEVICE);
 rx_processing_done:
 		/* Clear the status flags for this buffer */
@@ -1098,9 +1140,8 @@ static int fec_enet_mii_init(struct platform_device *pdev)
 	/*
 	 * Set MII speed to 2.5 MHz (= clk_get_rate() / 2 * phy_speed)
 	 */
-	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk),
+	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->mdc_clk),
 					(FEC_ENET_MII_CLK << 2)) << 1;
-
 	/* set hold time to 2 internal clock cycle */
 	if (cpu_is_mx6q() || cpu_is_mx6dl())
 		fep->phy_speed |= FEC_ENET_HOLD_TIME;
@@ -1826,18 +1867,31 @@ fec_probe(struct platform_device *pdev)
 	if (pdata)
 		fep->phy_interface = pdata->phy;
 
-	/* This device has up to three irqs on some platforms */
-	for (i = 0; i < 3; i++) {
-		irq = platform_get_irq(pdev, i);
-		if (i && irq < 0)
-			break;
-		ret = request_irq(irq, fec_enet_interrupt, IRQF_DISABLED, pdev->name, ndev);
-		if (ret) {
-			while (--i >= 0) {
-				irq = platform_get_irq(pdev, i);
-				free_irq(irq, ndev);
-			}
+	if (pdata->gpio_irq > 0) {
+		gpio_request(pdata->gpio_irq, "gpio_enet_irq");
+		gpio_direction_input(pdata->gpio_irq);
+
+		irq = gpio_to_irq(pdata->gpio_irq);
+		ret = request_irq(irq, fec_enet_interrupt,
+				IRQF_TRIGGER_RISING,
+				 pdev->name, ndev);
+		if (ret)
 			goto failed_irq;
+	} else {
+		/* This device has up to three irqs on some platforms */
+		for (i = 0; i < 3; i++) {
+			irq = platform_get_irq(pdev, i);
+			if (i && irq < 0)
+				break;
+			ret = request_irq(irq, fec_enet_interrupt,
+					IRQF_DISABLED, pdev->name, ndev);
+			if (ret) {
+				while (--i >= 0) {
+					irq = platform_get_irq(pdev, i);
+					free_irq(irq, ndev);
+				}
+				goto failed_irq;
+			}
 		}
 	}
 
@@ -1846,6 +1900,11 @@ fec_probe(struct platform_device *pdev)
 		ret = PTR_ERR(fep->clk);
 		goto failed_clk;
 	}
+	fep->mdc_clk = clk_get(&pdev->dev, "fec_mdc_clk");
+	if (IS_ERR(fep->mdc_clk)) {
+		ret = PTR_ERR(fep->mdc_clk);
+		goto failed_clk;
+	}
 	clk_enable(fep->clk);
 
 	ret = fec_enet_init(ndev);
@@ -1872,6 +1931,8 @@ fec_probe(struct platform_device *pdev)
 	netif_carrier_off(ndev);
 	clk_disable(fep->clk);
 
+	INIT_DELAYED_WORK(&fep->fixup_trigger_tx, fixup_trigger_tx_func);
+
 	ret = register_netdev(ndev);
 	if (ret)
 		goto failed_register;
@@ -1887,11 +1948,16 @@ failed_mii_init:
 failed_init:
 	clk_disable(fep->clk);
 	clk_put(fep->clk);
+	clk_put(fep->mdc_clk);
 failed_clk:
-	for (i = 0; i < 3; i++) {
-		irq = platform_get_irq(pdev, i);
-		if (irq > 0)
-			free_irq(irq, ndev);
+	if (pdata->gpio_irq < 0)
+		free_irq(irq, ndev);
+	else {
+		for (i = 0; i < 3; i++) {
+			irq = platform_get_irq(pdev, i);
+			if (irq > 0)
+				free_irq(irq, ndev);
+		}
 	}
 failed_irq:
 	iounmap(fep->hwp);
@@ -1910,10 +1976,12 @@ fec_drv_remove(struct platform_device *pdev)
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	struct resource *r;
 
+	cancel_delayed_work_sync(&fep->fixup_trigger_tx);
 	fec_stop(ndev);
 	fec_enet_mii_remove(fep);
 	clk_disable(fep->clk);
 	clk_put(fep->clk);
+	clk_put(fep->mdc_clk);
 	iounmap((void __iomem *)ndev->base_addr);
 	if (fep->ptimer_present)
 		fec_ptp_cleanup(fep->ptp_priv);
diff --git a/drivers/power/sabresd_battery.c b/drivers/power/sabresd_battery.c
index 6489221..b84f0d4 100755
--- a/drivers/power/sabresd_battery.c
+++ b/drivers/power/sabresd_battery.c
@@ -2,7 +2,7 @@
  * sabresd_battery.c - Maxim 8903 USB/Adapter Charger Driver
  *
  * Copyright (C) 2011 Samsung Electronics
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  * Based on max8903_charger.c
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -300,12 +300,8 @@ static void max8903_battery_update_status(struct max8903_data *data)
 			temp_last = temp;
 		}
 		if (data->charger_online == 0 && temp_last != 0) {
-			if (temp < temp_last) {
-				temp_last = temp;
-				data->voltage_uV = temp;
-			} else {
-			data->voltage_uV = temp_last;
-			}
+			temp_last = temp;
+			data->voltage_uV = temp;
 		}
 		if (data->charger_online == 1 || data->usb_charger_online == 1) {
 			data->voltage_uV = temp;
diff --git a/drivers/regulator/pfuze100-regulator.c b/drivers/regulator/pfuze100-regulator.c
index 8ab80b7..bd356c4 100644
--- a/drivers/regulator/pfuze100-regulator.c
+++ b/drivers/regulator/pfuze100-regulator.c
@@ -631,9 +631,9 @@ static int pfuze100_regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 	 * 02: 8us,
 	 * 03: 16us,
 	 */
-	step_delay >>= 5;
+	step_delay >>= 6;
 	step_delay &= 0x3;
-	step_delay <<= 1;
+	step_delay = 2  <<  step_delay;
 
 	if (pfuze100_regulators[id].voltages[old_sel] <
 		pfuze100_regulators[id].voltages[new_sel])
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index f147c62..3eaea9d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1319,6 +1319,7 @@ int usb_suspend(struct device *dev, pm_message_t msg)
 	choose_wakeup(udev, msg);
 	return usb_suspend_both(udev, msg);
 }
+EXPORT_SYMBOL(usb_suspend);
 
 /* The device lock is held by the PM core */
 int usb_resume(struct device *dev, pm_message_t msg)
@@ -1353,6 +1354,7 @@ int usb_resume(struct device *dev, pm_message_t msg)
 		status = 0;
 	return status;
 }
+EXPORT_SYMBOL(usb_resume);
 
 #endif /* CONFIG_PM */
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 55a63e4..90241fa 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -156,7 +156,50 @@ EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+static u8 usb_device_white_list[] = {
+	USB_CLASS_HID,
+	USB_CLASS_HUB,
+	USB_CLASS_MASS_STORAGE
+};
+
+static inline int in_white_list(u8 interfaceclass)
+{
+	int i;
+	for (i = 0; i < sizeof(usb_device_white_list); i++)	{
+		if (interfaceclass == usb_device_white_list[i])
+			return 1;
+	}
+	return 0;
+}
+
+static inline int device_in_white_list(struct usb_device *udev)
+{
+	int i;
+	int num_configs;
+	struct usb_host_config *c;
+
+	/* for test fixture, we always return 1 */
+	if (udev->descriptor.idVendor == 0x1A0A)
+		return 1;
+
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c->desc.bNumInterfaces > 0)
+			desc = &c->intf_cache[0]->altsetting->desc;
 
+		if (desc && !in_white_list((u8)desc->bInterfaceClass))
+			continue;
+
+		return 1;
+	}
+	return 0;
+}
+#endif
 static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
@@ -1903,6 +1946,14 @@ int usb_new_device(struct usb_device *udev)
 	udev->dev.devt = MKDEV(USB_DEVICE_MAJOR,
 			(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+	if (!device_in_white_list(udev)) {
+		printk(KERN_ERR "unsupported device: not in white list\n");
+		goto fail;
+	} else {
+		printk(KERN_DEBUG "supported device\n");
+	}
+#endif
 	/* Tell the world! */
 	announce_device(udev);
 
@@ -3309,6 +3360,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_set_device_state(udev, USB_STATE_POWERED);
  		udev->bus_mA = hub->mA_per_port;
 		udev->level = hdev->level + 1;
+#ifdef CONFIG_FSL_USB_TEST_MODE
+		printk(KERN_INFO "+++ %s:udev->level :%d", __func__,
+						udev->level);
+#endif
 		udev->wusb = hub_is_wusb(hub);
 
 		/* Only USB 3.0 devices are connected to SuperSpeed hubs. */
@@ -3527,6 +3582,10 @@ static void hub_events(void)
 			if (ret < 0)
 				continue;
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+			if (portstatus & USB_PORT_STAT_TEST)
+				continue;
+#endif
 			if (portchange & USB_PORT_STAT_C_CONNECTION) {
 				clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_CONNECTION);
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 32d3adc..1b5eaa0 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -80,9 +80,6 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Logitech Quickcam Pro 9000 */
 	{ USB_DEVICE(0x046d, 0x0990), .driver_info = USB_QUIRK_RESET_RESUME },
 
-	/* Logitech Quickcam E3500 */
-	{ USB_DEVICE(0x046d, 0x09a4), .driver_info = USB_QUIRK_RESET_RESUME },
-
 	/* Logitech Quickcam Vision Pro */
 	{ USB_DEVICE(0x046d, 0x09a6), .driver_info = USB_QUIRK_RESET_RESUME },
 
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 04824da..087350a 100755
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -70,7 +70,6 @@
 #endif
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 DEFINE_MUTEX(udc_resume_mutex);
-extern void usb_debounce_id_vbus(void);
 static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
@@ -562,6 +561,8 @@ static void dr_controller_stop(struct fsl_udc *udc)
 	tmp &= ~USB_CMD_RUN_STOP;
 	fsl_writel(tmp, &dr_regs->usbcmd);
 
+	/* disable pulldown dp and dm */
+	dr_discharge_line(udc->pdata, true);
 	return;
 }
 
@@ -958,11 +959,8 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 			(unsigned)EP_MAX_LENGTH_TRANSFER);
 	if (NEED_IRAM(req->ep))
 		*length = min(*length, g_iram_size);
-#ifdef CONFIG_FSL_UTP
+
 	dtd = dma_pool_alloc_nonbufferable(udc_controller->td_pool, GFP_ATOMIC, dma);
-#else
-	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_ATOMIC, dma);
-#endif
 	if (dtd == NULL)
 		return dtd;
 
@@ -2519,6 +2517,7 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 
 	dr_phy_low_power_mode(udc_controller, true);
 
+	dr_clk_gate(false);
 	printk(KERN_INFO "unregistered gadget driver '%s'\r\n",
 	       driver->driver.name);
 	return 0;
@@ -3075,6 +3074,7 @@ static int __devinit fsl_udc_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto err2a;
 	}
+	pdata->lowpower = false;
 
 	spin_lock_init(&pdata->lock);
 
@@ -3230,6 +3230,7 @@ err4:
 err3:
 	free_irq(udc_controller->irq, udc_controller);
 err2:
+	dr_phy_low_power_mode(udc_controller, true);
 	if (pdata->exit)
 		pdata->exit(pdata->pdev);
 err2a:
@@ -3265,6 +3266,8 @@ static int  fsl_udc_remove(struct platform_device *pdev)
 	dr_wake_up_enable(udc_controller, false);
 
 	dr_discharge_line(pdata, true);
+
+	dr_clk_gate(false);
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
 
@@ -3296,13 +3299,12 @@ static int  fsl_udc_remove(struct platform_device *pdev)
 	release_mem_region(res->start, resource_size(res));
 }
 #endif
-	dr_clk_gate(false);
 	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
+
 	/*
-	 * do platform specific un-initialization:
-	 * release iomux pins, etc.
+	 * do platform specific un-initialization
 	 */
 	if (pdata->exit)
 		pdata->exit(pdata->pdev);
@@ -3446,7 +3448,6 @@ static int fsl_udc_resume(struct platform_device *pdev)
 		u32 temp;
 		if (udc_controller->stopped)
 			dr_clk_gate(true);
-		usb_debounce_id_vbus();
 		if (fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID) {
 			temp = fsl_readl(&dr_regs->otgsc);
 			/* if b_session_irq_en is cleared by otg */
@@ -3493,7 +3494,6 @@ static int fsl_udc_resume(struct platform_device *pdev)
 			dr_clk_gate(true);
 		dr_wake_up_enable(udc_controller, false);
 		dr_phy_low_power_mode(udc_controller, false);
-		usb_debounce_id_vbus();
 		/* if in host mode, we need to do nothing */
 		if ((fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID) == 0) {
 			dr_phy_low_power_mode(udc_controller, true);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 9e99765..c9f9a65 100755
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -59,6 +59,13 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config FSL_USB_TEST_MODE
+	bool "FSL High-speed Electrical Test Mode Support"
+	depends on USB_EHCI_ARC
+	default n
+	---help---
+	    enable freescale test mode
+
 config USB_EHCI_ARC
 	bool "Support for Freescale controller"
 	depends on USB_EHCI_HCD && (ARCH_MXC || ARCH_STMP3XXX || ARCH_MXS)
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 624a362..0bcc665 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -35,3 +35,4 @@ obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
+obj-$(CONFIG_FSL_USB_TEST_MODE)	+= arc_hset.o
diff --git a/drivers/usb/host/arc_hset.c b/drivers/usb/host/arc_hset.c
new file mode 100644
index 0000000..2ec9055
--- /dev/null
+++ b/drivers/usb/host/arc_hset.c
@@ -0,0 +1,468 @@
+/*
+ * HS USB Host-mode HSET driver for ARC USB controller
+ * Copyright 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Zhang Yan <jasper.zhang@freescale.com>
+ * Peter Chen <peter.chen@freescale.com>  */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define EHCI_IAA_MSECS		10		/* arbitrary */
+#include <linux/usb/hcd.h>
+#include "../core/usb.h"
+#include "ehci-fsl.h"
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <mach/arc_otg.h>
+#include "ehci.h"
+
+#define rh_level 1
+#define SINGLE_STEP_SLEEP_COUNT  15000
+#define USB_HIGH_SPEED		0x01
+#define USB_FULL_SPEED		0x02
+#define USB_LOW_SPEED		0x03
+
+/* ARC port test mode */
+#define PORTSC_PTC_TEST_MODE_DISABLE	0x00
+#define PORTSC_PTC_TEST_J		0x01
+#define PORTSC_PTC_TEST_K		0x02
+#define PORTSC_PTC_SE0_NAK		0x03
+#define PORTSC_PTC_TEST_PACKET		0x04
+#define PORTSC_PTC_FORCE_ENABLE_HS	0x05
+#define PORTSC_PTC_FORCE_ENABLE_FS	0x06
+#define PORTSC_PTC_FORCE_ENABLE_LS	0x07
+
+/* Other test */
+#define HSET_TEST_SUSPEND_RESUME	0x08
+#define HSET_TEST_GET_DEV_DESC		0x09
+#define HSET_TEST_GET_DEV_DESC_DATA	0x0A
+
+
+#define TEST_DEVICE_VID	 0x1A0A
+static struct usb_device_id archset_table[] = {
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0101) },	/* Test_SE0_NAK */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0102) },	/* Test_J */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0103) },	/* Test_K */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0104) },	/* Test_Packet */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0105) },	/* Force enable */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0106) },	/* HS_HOST_PORT_SUSPEND_RESUME */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0107) },	/* SINGLE_STEP_GET_DEV_DESC */
+	{ USB_DEVICE(TEST_DEVICE_VID, 0x0108) },	/* SINGLE_STEP_GET_DEV_DESC_DATA */
+	{ }	/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, archset_table);
+
+/* Private data */
+struct usb_archset {
+	struct usb_device    *udev;	/* the usb device for this device */
+	struct usb_interface *interface;	/* the interface for this device */
+	struct kref           kref;
+	struct ehci_hcd       *ehci;	/* the usb controller */
+	char                  ptcname[24];
+};
+
+ void set_single_step_desc_data_on(void);
+ void clear_single_step_desc_data_on(void);
+
+static void arc_kill_per_sched(struct ehci_hcd *ehci)
+{
+	u32 command = 0;
+	command = ehci_readl(ehci, &ehci->regs->command);
+	command &= ~(CMD_PSE);
+	ehci_writel(ehci, command, &ehci->regs->command);
+	printk(KERN_INFO "+++ %s: Periodic Schedule Stopped", __func__);
+}
+
+static void arc_hset_test(struct ehci_hcd *ehci, int mode)
+{
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc &= ~(0xf << 16);
+	portsc |= (mode << 16);
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+static inline void hub_set_testmode(struct usb_device *udev, u8
+			test_mode)
+{
+	struct usb_device *hub_dev;
+	int i;
+	int max_port;
+	int status;
+	u8 level = udev->level;
+
+	if (level == 0)
+		return;
+	else {
+		printk(KERN_INFO "run %s at tie %d hub\n", __func__, level);
+		/* get the port number of parent */
+		if (udev->parent != NULL) {
+			hub_dev = udev->parent;
+			max_port = hub_dev->maxchild;
+		} else {
+			printk(KERN_INFO "device don't have parent hub\n");
+			return;
+		}
+
+		for (i = 0; i < max_port; i++) {
+			status = usb_control_msg(hub_dev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RT_PORT,
+				USB_PORT_FEAT_SUSPEND, i+1,
+				NULL, 0, 1000);
+			if (status >= 0)
+				printk(KERN_INFO "send port_suspend to port %d\n", i+1);
+			else {
+				printk(KERN_INFO "send port_suspend error %d to port %d\n",
+					status, i+1);
+				continue;
+			}
+		}
+		msleep(1000);
+		status = usb_control_msg(hub_dev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE/*USB_REQ_CLEAR_FEATURE*/, USB_RT_PORT,
+				USB_PORT_FEAT_TEST, (__u16) ((test_mode << 8) | udev->portnum),
+				NULL, 0, 1000);
+		if (status >= 0)
+			printk(KERN_INFO "send cmd %d to port %d\n", test_mode, udev->portnum);
+		else
+			printk(KERN_INFO "send cmd %d error %d to port %d\n", test_mode, status, udev->portnum);
+	}
+}
+
+static inline void test_j(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	if (level == rh_level) {
+		printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_J);
+	} else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_J);
+}
+
+static inline void test_k(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_K);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_K);
+}
+
+static inline void test_se0_nak(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_SE0_NAK);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_SE0_NAK);
+}
+
+static inline void test_packet(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == rh_level)
+		arc_hset_test(hset->ehci, PORTSC_PTC_TEST_PACKET);
+	else
+		hub_set_testmode(udev, PORTSC_PTC_TEST_PACKET);
+}
+
+static inline void test_force_enable(struct usb_archset *hset, int
+			forcemode)
+{
+	struct usb_device *udev = hset->udev;
+	u8 level = udev->level;
+	int ptc_fmode = 0;
+	printk(KERN_INFO "%s at tie %d hub\n", __func__, level);
+	if (level == 0) {
+		switch (forcemode) {
+		case USB_HIGH_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_HS;
+			break;
+		case USB_FULL_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_FS;
+			break;
+		case USB_LOW_SPEED:
+			ptc_fmode = PORTSC_PTC_FORCE_ENABLE_LS;
+			break;
+		default:
+			printk(KERN_ERR "unknown speed mode %d\n", forcemode);
+			return;
+		}
+		arc_hset_test(hset->ehci, ptc_fmode);
+	} else
+		hub_set_testmode(udev, PORTSC_PTC_FORCE_ENABLE_HS);
+}
+
+static void suspend(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc |= PORT_SUSPEND;	/* Set suspend */
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+
+static void resume(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	u32 portsc = 0;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc |= PORT_RESUME;
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+}
+
+static void test_suspend_resume(struct usb_archset *hset)
+{
+	printk(KERN_INFO "%s\n", __func__);
+
+	suspend(hset);
+	msleep(15000);	/* Wait for 15s */
+	resume(hset);
+}
+
+static void test_single_step_get_dev_desc(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	struct usb_bus *bus = hcd_to_bus(ehci_to_hcd(ehci));
+	struct usb_device *udev = hset->udev;
+	int    result;
+
+	if (!ehci || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+
+	if (!udev) {
+		printk(KERN_ERR "No device connected.\n");
+		return;
+	}
+
+	/* Stop Periodic schedule to prevent polling of hubs */
+	arc_kill_per_sched(hset->ehci);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);	/* SOF for 15s */
+
+	result = usb_get_device_descriptor(udev, sizeof(struct usb_device_descriptor));
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "usb_get_device_descriptor failed %d\n", result);
+	else
+		printk(KERN_INFO "usb_get_device_descriptor passed\n");
+}
+static void test_single_step_get_dev_desc_data(struct usb_archset *hset)
+{
+	struct usb_device *udev = hset->udev;
+	struct usb_device_descriptor *desc;
+	int    result;
+	unsigned int size = sizeof(struct usb_device_descriptor);
+	printk(KERN_INFO "%s size = %d\n", __func__, size);
+	desc = kmalloc(sizeof(*desc), GFP_NOIO);
+	if (!desc) {
+		printk(KERN_ERR "alloc desc failed\n");
+		return ;
+	}
+
+	set_single_step_desc_data_on();
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size, USB_CTRL_GET_TIMEOUT);
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the setup transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the setup transaction passed\n");
+
+
+	/* Stop Periodic schedule to prevent polling of hubs */
+	arc_kill_per_sched(hset->ehci);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size,	USB_CTRL_GET_TIMEOUT);
+	if (result <= 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the data transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the data transaction passed\n");
+
+	result = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+					(0x01 << 8) + 0, 0, desc, size, USB_CTRL_GET_TIMEOUT);
+	if (result < 0 && result != -ETIMEDOUT)
+		printk(KERN_ERR "the status transaction failed %d\n", result);
+	else
+		printk(KERN_INFO "the status transaction passed\n");
+
+	clear_single_step_desc_data_on();
+
+	kfree(desc);
+
+	msleep(SINGLE_STEP_SLEEP_COUNT);	/* SOF for 15s */
+	printk(KERN_INFO "test_single_step_get_dev_desc_data finished\n");
+}
+
+
+void test_single_step_set_feature(struct usb_archset *hset)
+{
+	struct ehci_hcd *ehci = hset->ehci;
+	struct usb_bus *bus = hcd_to_bus(ehci_to_hcd(ehci));
+	struct usb_device *udev;
+
+	if (!ehci || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_ERR "No device connected.\n");
+		return;
+	}
+	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, 0, 0, 0,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+static struct usb_archset *the_hset[4];
+static struct usb_archset *init_hset_dev(void *controller)
+{
+	struct ehci_hcd *ehci = (struct ehci_hcd *)controller;
+	struct usb_archset *hset = NULL;
+	int ctrid = 0;
+
+	ctrid = ehci_to_hcd(ehci)->self.busnum-1;
+	if (the_hset[ctrid]) {
+		kref_get(&the_hset[ctrid]->kref);
+		return the_hset[ctrid];
+	}
+
+	hset = kzalloc(sizeof(struct usb_archset), GFP_KERNEL);
+	if (hset == NULL) {
+		printk(KERN_ERR "Out of memory!\n");
+		return NULL;
+	}
+	hset->ehci = (struct ehci_hcd *)controller;
+	kref_init(&hset->kref);
+	the_hset[ctrid] = hset;
+
+	return hset;
+}
+
+
+static void hset_delete(struct kref *kref)
+{
+	struct usb_archset *hset = container_of(kref, struct usb_archset,
+								kref);
+
+	kfree(hset);
+}
+
+static int archset_probe(struct usb_interface *iface,
+		const struct usb_device_id *id)
+{
+	struct usb_archset *hset;
+	struct usb_device *udev;
+	struct usb_hcd *hcd;
+
+	udev = usb_get_dev(interface_to_usbdev(iface));
+	hcd = bus_to_hcd(udev->bus);
+	hset = init_hset_dev((void *)hcd_to_ehci(hcd));
+	if (hset == NULL)
+		return -ENOMEM;
+
+	hset->udev = udev;
+	usb_set_intfdata(iface, hset);
+	switch (id->idProduct) {
+	case 0x0101:
+		test_se0_nak(hset);
+		break;
+	case 0x0102:
+		test_j(hset);
+		break;
+	case 0x0103:
+		test_k(hset);
+		break;
+	case 0x0104:
+		test_packet(hset);
+		break;
+	case 0x0105:
+		printk(KERN_INFO "Force FS/FS/LS ?\n");
+		test_force_enable(hset, USB_HIGH_SPEED);
+		break;
+	case 0x0106:
+		test_suspend_resume(hset);
+		break;
+	case 0x0107:
+		printk(KERN_INFO "Begin SINGLE_STEP_GET_DEVICE_DESCRIPTOR\n");
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 0x0108:
+		printk(KERN_INFO "Begin SINGLE_STEP_GET_DEVICE_DESCRIPTOR_DATA\n");
+		test_single_step_get_dev_desc_data(hset);
+		break;
+	}
+
+	return 0;
+}
+
+static void archset_disconnect(struct usb_interface *iface)
+{
+	struct usb_archset *hset;
+
+	hset = usb_get_intfdata(iface);
+	usb_set_intfdata(iface, NULL);
+
+	usb_put_dev(hset->udev);
+	kref_put(&hset->kref, hset_delete);
+}
+
+
+static struct usb_driver archset_driver = {
+	.name = "arc hset",
+	.probe = archset_probe,
+	.disconnect = archset_disconnect,
+	.id_table = archset_table,
+};
+
+static int __init usb_hset_init(void)
+{
+	int ret = 0;
+	printk(KERN_ERR "usb register error with %d\n", ret);
+	/* register driver to usb subsystem */
+	ret = usb_register(&archset_driver);
+    if (ret)
+		printk(KERN_ERR "usb register error with %d\n", ret);
+	else
+		printk(KERN_INFO "usb hset init succeed\n");
+
+	return ret;
+}
+
+static void __exit usb_hset_exit(void)
+{
+	usb_deregister(&archset_driver);
+}
+
+module_init(usb_hset_init);
+module_exit(usb_hset_exit);
+MODULE_DESCRIPTION("Freescale USB Host Test Mode Driver");
+MODULE_AUTHOR("Jasper Zhang");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/usb/host/ehci-arc.c b/drivers/usb/host/ehci-arc.c
index 8c703b9..dde47dd 100755
--- a/drivers/usb/host/ehci-arc.c
+++ b/drivers/usb/host/ehci-arc.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2005 MontaVista Software
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -249,6 +249,7 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		retval = -ENODEV;
 		goto err4;
 	}
+	pdata->lowpower = false;
 
 	spin_lock_init(&pdata->lock);
 
@@ -314,7 +315,10 @@ err2:
 	usb_put_hcd(hcd);
 err1:
 	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
-	if (pdata->exit)
+	fsl_usb_lowpower_mode(pdata, true);
+	if (pdata->usb_clock_for_pm)
+		pdata->usb_clock_for_pm(false);
+	if (pdata->exit && pdata->pdev)
 		pdata->exit(pdata->pdev);
 	return retval;
 }
@@ -332,7 +336,6 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
-	u32 tmp;
 
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
 		/* Need open clock for register access */
@@ -342,16 +345,20 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 		/*disable the wakeup to avoid an abnormal wakeup interrupt*/
 		usb_host_set_wakeup(hcd->self.controller, false);
 
-		tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
-		if (tmp & PORT_PTS_PHCD) {
-			tmp &= ~PORT_PTS_PHCD;
-			ehci_writel(ehci, tmp, &ehci->regs->port_status[0]);
-			msleep(100);
-		}
+		/* Put the PHY out of low power mode */
+		fsl_usb_lowpower_mode(pdata, false);
 	}
 
-	/* DDD shouldn't we turn off the power here? */
-	fsl_platform_set_vbus_power(pdata, 0);
+	/* disable the host wakeup */
+	usb_host_set_wakeup(hcd->self.controller, false);
+	/*free the ehci_fsl_pre_irq  */
+	free_irq(hcd->irq, (void *)pdev);
+
+	usb_remove_hcd(hcd);
+
+	ehci_port_power(ehci, 0);
+
+	iounmap(hcd->regs);
 
 	if (ehci->transceiver) {
 		(void)otg_set_host(ehci->transceiver, 0);
@@ -359,22 +366,23 @@ static void usb_hcd_fsl_remove(struct usb_hcd *hcd,
 	} else {
 		release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	}
-	/*disable the host wakeup and put phy to low power mode */
-	usb_host_set_wakeup(hcd->self.controller, false);
-	fsl_usb_lowpower_mode(pdata, true);
-	/*free the ehci_fsl_pre_irq  */
-	free_irq(hcd->irq, (void *)pdev);
-	usb_remove_hcd(hcd);
+
 	usb_put_hcd(hcd);
 
+	fsl_usb_lowpower_mode(pdata, true);
+
+	/* Close the VBUS */
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, pdata, 0);
+
+	if (pdata->usb_clock_for_pm)
+		pdata->usb_clock_for_pm(false);
+
 	/*
-	 * do platform specific un-initialization:
-	 * release iomux pins clocks, etc.
+	 * do platform specific un-initialization
 	 */
-	if (pdata->exit)
+	if (pdata->exit && pdata->pdev)
 		pdata->exit(pdata->pdev);
-
-	iounmap(hcd->regs);
 }
 
 static void fsl_setup_phy(struct ehci_hcd *ehci,
@@ -408,11 +416,23 @@ static void fsl_setup_phy(struct ehci_hcd *ehci,
 	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
 }
 
+static void ehci_fsl_stream_disable(struct ehci_hcd *ehci)
+{
+	u32 __iomem	*reg_ptr;
+	u32		tmp;
+
+	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
+	tmp = ehci_readl(ehci, reg_ptr);
+	tmp |= CI_USBMODE_SDIS;
+	ehci_writel(ehci, tmp, reg_ptr);
+}
+
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_fsl_reinit(struct ehci_hcd *ehci)
 {
 	fsl_platform_usb_setup(ehci);
 	ehci_port_power(ehci, 0);
+	ehci_fsl_stream_disable(ehci);
 
 	return 0;
 }
@@ -662,17 +682,32 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	/* Only handles OTG mode switch event, system suspend event will be done in bus suspend */
 	if (pdata->pmflags == 0) {
 		printk(KERN_DEBUG "%s, pm event \n", __func__);
+		disable_irq(hcd->irq);
 		if (!host_can_wakeup_system(pdev)) {
 			/* Need open clock for register access */
 			fsl_usb_clk_gate(hcd->self.controller->platform_data, true);
+			/*
+			 * Disable wakeup interrupt, since there is wakeup
+			 * when phcd from 1->0 if wakeup interrupt is enabled
+			 */
+			usb_host_set_wakeup(hcd->self.controller, false);
+
+			/*
+			 * Open PHY's clock, then the wakeup settings
+			 * can be wroten correctly
+			 */
+			fsl_usb_lowpower_mode(pdata, false);
 
 			usb_host_set_wakeup(hcd->self.controller, false);
 
+			fsl_usb_lowpower_mode(pdata, true);
+
 			fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
 		} else {
 			if (pdata->platform_phy_power_on)
 				pdata->platform_phy_power_on();
 		}
+		enable_irq(hcd->irq);
 
 		printk(KERN_DEBUG "host suspend ends\n");
 		return 0;
@@ -744,13 +779,18 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	return 0;
 }
 
+#define OTGSC_OFFSET 		0x64
+#define OTGSC_ID_VALUE		(1 << 8)
+#define OTGSC_ID_INT_STS	(1 << 16)
 static int ehci_fsl_drv_resume(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	struct usb_device *roothub = hcd->self.root_hub;
 	unsigned long flags;
-	u32 tmp;
+	u32 tmp, otgsc;
+	bool id_changed;
+	int id_value;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 	struct fsl_usb2_wakeup_platform_data *wake_up_pdata = pdata->wakeup_pdata;
 	/* Only handles OTG mode switch event */
@@ -758,29 +798,36 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	if (pdata->pmflags == 0) {
 		printk(KERN_DEBUG "%s,pm event, wait for wakeup irq if needed\n", __func__);
 		wait_event_interruptible(wake_up_pdata->wq, !wake_up_pdata->usb_wakeup_is_pending);
+		disable_irq(hcd->irq);
 		if (!host_can_wakeup_system(pdev)) {
 			/* Need open clock for register access */
 			fsl_usb_clk_gate(hcd->self.controller->platform_data, true);
+			fsl_usb_lowpower_mode(pdata, false);
 
-			usb_host_set_wakeup(hcd->self.controller, true);
-
-#ifndef NO_FIX_DISCONNECT_ISSUE
-			/*Unplug&plug device during suspend without remote wakeup enabled
-			For Low and full speed device, we should power on and power off
-			the USB port to make sure USB internal state machine work well.
-			*/
 			tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
-			if ((tmp & PORT_CONNECT) && !(tmp & PORT_SUSPEND) &&
-				((tmp & (0x3<<26)) != (0x2<<26))) {
-					printk(KERN_DEBUG "%s will do power off and power on port.\n", pdata->name);
-					ehci_writel(ehci, tmp & ~(PORT_RWC_BITS | PORT_POWER),
-						&ehci->regs->port_status[0]);
-					ehci_writel(ehci, tmp | PORT_POWER,
-						&ehci->regs->port_status[0]);
+			if (pdata->operating_mode == FSL_USB2_DR_OTG) {
+				otgsc = ehci_readl(ehci, (u32 __iomem *)ehci->regs + OTGSC_OFFSET / 4);
+				id_changed = !!(otgsc & OTGSC_ID_INT_STS);
+				id_value = !!(otgsc & OTGSC_ID_VALUE);
+				if (((tmp & PORT_CONNECT) && !id_value) || id_changed) {
+					set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+				} else if (!(tmp & PORT_CONNECT)) {
+					usb_host_set_wakeup(hcd->self.controller, true);
+					fsl_usb_lowpower_mode(pdata, true);
+					fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
+				}
+			} else {
+				if (tmp & PORT_CONNECT) {
+					set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+				} else {
+					usb_host_set_wakeup(hcd->self.controller, true);
+					fsl_usb_lowpower_mode(pdata, true);
+					fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
+				}
+
 			}
-#endif
-			fsl_usb_clk_gate(hcd->self.controller->platform_data, false);
 		}
+		enable_irq(hcd->irq);
 		return 0;
 	}
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
@@ -805,6 +852,7 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	ehci_writel(ehci, pdata->pm_configured_flag,
 		    &ehci->regs->configured_flag);
 
+	ehci_fsl_stream_disable(ehci);
 
 	tmp = ehci_readl(ehci, &ehci->regs->command);
 	tmp |= CMD_RUN;
diff --git a/drivers/usb/host/ehci-fsl.h b/drivers/usb/host/ehci-fsl.h
index 137c505..b0b0d17 100755
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2005-2011 Freescale Semiconductor, Inc.
+/* Copyright (C) 2005-2013 Freescale Semiconductor, Inc.
  * Copyright (c) 2005 MontaVista Software
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -36,6 +36,7 @@
 #define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
 #define USBMODE_CM_HOST		(3 << 0)	/* controller mode: host */
 #define USBMODE_ES		(1 << 2)	/* (Big) Endian Select */
+#define CI_USBMODE_SDIS		(1 << 4)	/* Chipidea Stream Disable bit */
 
 #define FSL_SOC_USB_USBGENCTRL	0x200
 #define USBGENCTRL_PPP		(1 << 3)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 58f4472..2bea9581 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -48,6 +48,21 @@
 #include <asm/system.h>
 #include <asm/unaligned.h>
 
+
+#ifdef CONFIG_FSL_USB_TEST_MODE
+static u32 single_step_desc_data_on;
+void set_single_step_desc_data_on(void)
+{
+	single_step_desc_data_on = 1;
+}
+EXPORT_SYMBOL_GPL(set_single_step_desc_data_on);
+
+void clear_single_step_desc_data_on(void)
+{
+	single_step_desc_data_on = 0;
+}
+EXPORT_SYMBOL_GPL(clear_single_step_desc_data_on);
+#endif
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -964,8 +979,22 @@ static int ehci_urb_enqueue (
 		/* FALLTHROUGH */
 	/* case PIPE_BULK: */
 	default:
-		if (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))
+#ifdef CONFIG_FSL_USB_TEST_MODE
+		if (!single_step_desc_data_on) {
+			printk(KERN_DEBUG "in test mode, but single step NOT on\n");
+			if (!qh_urb_transaction(ehci, urb, &qtd_list,
+						mem_flags))
+				return -ENOMEM;
+		} else {
+			printk(KERN_DEBUG "in test mode, single step on\n");
+			if (!single_step_qh_urb_transaction(ehci, urb,
+				&qtd_list, mem_flags))
+				return -ENOMEM;
+		}
+#else
+		if (!qh_urb_transaction(ehci, urb, &qtd_list, mem_flags))
 			return -ENOMEM;
+#endif
 		return submit_async(ehci, urb, &qtd_list, mem_flags);
 
 	case PIPE_INTERRUPT:
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e4dd26a..361dd5d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -592,6 +592,187 @@ static void qtd_list_free (
 	}
 }
 
+#ifdef CONFIG_FSL_USB_TEST_MODE
+/*
+ * create a list of filled qtds for this URB; won't link into qh.
+ */
+static struct list_head *
+single_step_qh_urb_transaction(
+	struct ehci_hcd		*ehci,
+	struct urb		*urb,
+	struct list_head	*head,
+	gfp_t			flags
+) {
+	struct ehci_qtd		*qtd, *qtd_prev;
+	dma_addr_t		buf;
+	int			len, this_sg_len, maxpacket;
+	int			is_input;
+	u32			token;
+	int			i;
+	struct scatterlist	*sg;
+#define SINGLE_STEP_PHASE_SETUP  0
+#define SINGLE_STEP_PHASE_DATA   1
+#define SINGLE_STEP_PHASE_STATUS 2
+#define SINGLE_STEP_PHASE_NONE   0xFF
+	static u32  phase_state = SINGLE_STEP_PHASE_NONE;
+
+	/*
+	 * URBs map to sequences of QTDs:  one logical transaction
+	 */
+	qtd = ehci_qtd_alloc(ehci, flags);
+	if (unlikely(!qtd))
+		return NULL;
+	list_add_tail(&qtd->qtd_list, head);
+	qtd->urb = urb;
+
+	token = QTD_STS_ACTIVE;
+	token |= (EHCI_TUNE_CERR << 10);
+	/* for split transactions, SplitXState initialized to zero */
+	len = urb->transfer_buffer_length;
+	is_input = usb_pipein(urb->pipe);
+	if (!is_input) {
+		printk(KERN_INFO "single step can only send IN\n");
+		return NULL;
+	}
+
+	if (!usb_pipecontrol(urb->pipe)) {
+		printk(KERN_INFO "single step can only send control pipe\n");
+		return NULL;
+	}
+
+	if (phase_state == SINGLE_STEP_PHASE_NONE) {
+		/*
+		 * SETUP pid
+		 * we use transfer_buffer_length to identfiy whether it
+		 * is in setup phase or data phase
+		 */
+		qtd_fill(ehci, qtd, urb->setup_dma,
+				sizeof(struct usb_ctrlrequest),
+				token | (2 /* "setup" */ << 8), 8);
+
+		/* ... and always at least one more pid */
+		qtd->urb = urb;
+		phase_state = SINGLE_STEP_PHASE_SETUP;
+	}
+	/*
+	 * data transfer stage:  buffer setup
+	 */
+	else
+		if (phase_state == SINGLE_STEP_PHASE_SETUP &&
+		len != 0) {
+		i = urb->num_sgs;
+		if (len > 0 && i > 0) {
+			sg = urb->sg;
+			buf = sg_dma_address(sg);
+
+			/* urb->transfer_buffer_length may be smaller than the
+			* size of the scatterlist (or vice versa)
+			*/
+			this_sg_len = min_t(int, sg_dma_len(sg), len);
+		} else {
+			sg = NULL;
+			buf = urb->transfer_dma;
+			this_sg_len = len;
+		}
+
+		if (is_input)
+			token |= (1 /* "in" */ << 8);
+		/* else it's already initted to "out" pid (0 << 8) */
+		maxpacket = max_packet(usb_maxpacket(urb->dev,
+						urb->pipe, !is_input));
+		/* for the first data qtd, the toggle should be 1 */
+		token ^= QTD_TOGGLE;
+
+		/*
+		 * buffer gets wrapped in one or more qtds;
+		 * last one may be "short" (including zero len)
+		 * and may serve as a control status ack
+		 */
+		for (;;) {
+			int this_qtd_len;
+
+			this_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len,
+							token, maxpacket);
+			this_sg_len -= this_qtd_len;
+			len -= this_qtd_len;
+			buf += this_qtd_len;
+
+			/*
+			* short reads advance to a "magic" dummy instead of
+			* the next qtd ... that forces the queue to stop, for
+			* manual cleanup. (will usually be overridden later.)
+			*/
+			if (is_input)
+				qtd->hw_alt_next = ehci->async->hw->hw_alt_next;
+
+			/* qh makes control packets use qtd toggle; switch it*/
+			if ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)
+				token ^= QTD_TOGGLE;
+
+			if (likely(this_sg_len <= 0)) {
+				if (--i <= 0 || len <= 0)
+					break;
+				sg = sg_next(sg);
+				buf = sg_dma_address(sg);
+				this_sg_len = min_t(int, sg_dma_len(sg), len);
+			}
+
+			qtd_prev = qtd;
+			qtd = ehci_qtd_alloc(ehci, flags);
+			if (unlikely(!qtd))
+				goto cleanup;
+			qtd->urb = urb;
+			qtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);
+			list_add_tail(&qtd->qtd_list, head);
+		}
+
+		phase_state = SINGLE_STEP_PHASE_DATA;
+
+		/*
+		 * unless the caller requires manual cleanup after short reads,
+		 * have the alt_next mechanism keep the queue running after the
+		 * last data qtd (the only one, for control and other cases).
+		 */
+		if (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0
+					|| usb_pipecontrol(urb->pipe)))
+			qtd->hw_alt_next = EHCI_LIST_END(ehci);
+	}
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	else
+		if (phase_state == SINGLE_STEP_PHASE_DATA) {
+		int	one_more = 0;
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			/* for single step, it always be out here */
+			token &= ~(3 << 8);
+			token |= QTD_TOGGLE;	/* force DATA1 */
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length % maxpacket)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			/* never any data in such packets */
+			qtd_fill(ehci, qtd, 0, 0, token, 0);
+		}
+	}
+
+	/* by default, enable interrupt on urb completion */
+	if (likely(!(urb->transfer_flags & URB_NO_INTERRUPT)))
+		qtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);
+	return head;
+
+cleanup:
+	qtd_list_free(ehci, urb, head);
+	phase_state = SINGLE_STEP_PHASE_NONE;
+	return NULL;
+}
+#endif
+
 /*
  * create a list of filled qtds for this URB; won't link into qh.
  */
diff --git a/drivers/usb/otg/fsl_otg.c b/drivers/usb/otg/fsl_otg.c
index 292c2e9..abf11b8 100755
--- a/drivers/usb/otg/fsl_otg.c
+++ b/drivers/usb/otg/fsl_otg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Author: Li Yang <LeoLi@freescale.com>
  *         Jerry Huang <Chang-Ming.Huang@freescale.com>
@@ -551,13 +551,9 @@ int fsl_otg_start_host(struct otg_fsm *fsm, int on)
 			goto end;
 		else {
 			VDBG("host off......\n");
-			if (host_pdrv->suspend) {
+			if (host_pdrv->suspend)
 				retval = host_pdrv->suspend(host_pdev,
 							otg_suspend_state);
-				if (fsm->id)
-					/* default-b */
-					fsl_otg_drv_vbus(dev->platform_data, 0);
-			}
 			otg_dev->host_working = 0;
 		}
 	}
@@ -631,6 +627,11 @@ static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
 
 		if (otg_dev->fsm.id) {
 			otg_dev->host_first_call = true;
+			/* The discharge will be false when the controller
+			 * is ready to use.
+			 */
+			if (pdata->dr_discharge_line)
+				pdata->dr_discharge_line(true);
 			schedule_otg_work(&otg_dev->otg_event, 100);
 		}
 		else {
@@ -665,8 +666,6 @@ static int fsl_otg_set_host(struct otg_transceiver *otg_p, struct usb_bus *host)
 
 	otg_dev->host_working = 0;
 
-	otg_statemachine(&otg_dev->fsm);
-
 	return 0;
 }
 
@@ -685,13 +684,19 @@ static int fsl_otg_set_peripheral(struct otg_transceiver *otg_p,
 		return -ENODEV;
 
 	if (!gadget) {
-		if (!otg_dev->otg.default_a)
+		/*
+		 * At i.mx platform, we still not implement fully
+		 * OTG.
+		 */
+		/*
+		if (!otg_dev->otg.default_a) {
 			otg_p->gadget->ops->vbus_draw(otg_p->gadget, 0);
-		usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+			usb_gadget_vbus_disconnect(otg_dev->otg.gadget);
+		}
+		*/
 		otg_dev->otg.gadget = 0;
 		otg_dev->fsm.b_bus_req = 0;
 		pdata->port_enables = 0;
-		otg_statemachine(&otg_dev->fsm);
 		return 0;
 	}
 	pdata->port_enables = 1;
diff --git a/drivers/usb/otg/otg_fsm.c b/drivers/usb/otg/otg_fsm.c
index 9e16afe..85b7148 100755
--- a/drivers/usb/otg/otg_fsm.c
+++ b/drivers/usb/otg/otg_fsm.c
@@ -1,6 +1,6 @@
 /* OTG Finite State Machine from OTG spec
  *
- * Copyright (C) 2006-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2006-2013 Freescale Semiconductor, Inc.
  *
  * Author: 	Li Yang <LeoLi@freescale.com>
  * 		Jerry Huang <Chang-Ming.Huang@freescale.com>
@@ -254,6 +254,8 @@ int otg_statemachine(struct otg_fsm *fsm)
 	enum usb_otg_state state;
 	unsigned long flags;
 
+	return 0;
+
 	spin_lock_irqsave(&fsm->lock, flags);
 
 	state = fsm->transceiver->state;
diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
index 695ff33..19de5c5 100644
--- a/drivers/video/mxc/ldb.c
+++ b/drivers/video/mxc/ldb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -238,6 +238,8 @@ static int ldb_disp_setup(struct mxc_dispdrv_handle *disp, struct fb_info *fbi)
 	val = readl(ldb->control_reg);
 	val |= ldb->setting[setting_idx].ch_val;
 	writel(val, ldb->control_reg);
+	dev_dbg(&ldb->pdev->dev, "LDB setup, control reg:0x%x\n",
+			readl(ldb->control_reg));
 
 	/* vsync setup */
 	reg = readl(ldb->control_reg);
@@ -321,6 +323,9 @@ int ldb_fb_event(struct notifier_block *nb, unsigned long val, void *v)
 				data = readl(ldb->control_reg);
 				data &= ~ldb->setting[index].ch_mask;
 				writel(data, ldb->control_reg);
+				dev_dbg(&ldb->pdev->dev,
+					"LDB blank, control reg:0x%x\n",
+						readl(ldb->control_reg));
 			}
 		}
 		break;
@@ -411,6 +416,7 @@ static int ldb_disp_init(struct mxc_dispdrv_handle *disp,
 	uint32_t base_addr;
 	uint32_t reg, setting_idx;
 	uint32_t ch_mask = 0, ch_val = 0;
+	uint32_t ipu_id, disp_id;
 
 	/* if input format not valid, make RGB666 as default*/
 	if (!valid_mode(setting->if_fmt)) {
@@ -479,6 +485,28 @@ static int ldb_disp_init(struct mxc_dispdrv_handle *disp,
 					plat_data->disp_id, ret, ret);
 				plat_data->disp_id = ret;
 			}
+		} else if (((ldb->mode == LDB_SEP0) || (ldb->mode == LDB_SEP1))
+				&& (cpu_is_mx6q() || cpu_is_mx6dl())) {
+			if (plat_data->disp_id == plat_data->sec_disp_id) {
+				dev_err(&ldb->pdev->dev,
+					"For LVDS separate mode,"
+					"two DIs should be different!\n");
+				return -EINVAL;
+			}
+
+			if (((!plat_data->disp_id) && (ldb->mode == LDB_SEP1))
+				|| ((plat_data->disp_id) &&
+					(ldb->mode == LDB_SEP0))) {
+				dev_dbg(&ldb->pdev->dev,
+					"LVDS separate mode:"
+					"swap DI configuration!\n");
+				ipu_id = plat_data->ipu_id;
+				disp_id = plat_data->disp_id;
+				plat_data->ipu_id = plat_data->sec_ipu_id;
+				plat_data->disp_id = plat_data->sec_disp_id;
+				plat_data->sec_ipu_id = ipu_id;
+				plat_data->sec_disp_id = disp_id;
+			}
 		}
 
 		if (ldb->mode == LDB_SPL_DI0) {
@@ -679,19 +707,8 @@ static int ldb_disp_init(struct mxc_dispdrv_handle *disp,
 	ldb->setting[setting_idx].ch_mask = ch_mask;
 	ldb->setting[setting_idx].ch_val = ch_val;
 
-	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
-		if ((ldb->mode == LDB_SEP0) || (ldb->mode == LDB_SEP1)) {
-			reg = readl(ldb->control_reg);
-			reg &= ~(LDB_CH0_MODE_MASK | LDB_CH1_MODE_MASK);
-			reg |= LDB_CH0_MODE_EN_TO_DI0 | LDB_CH1_MODE_EN_TO_DI1;
-			writel(reg, ldb->control_reg);
-			ldb->setting[setting_idx].ch_mask = setting->disp_id ?
-					LDB_CH1_MODE_MASK : LDB_CH0_MODE_MASK;
-			ldb->setting[setting_idx].ch_val = setting->disp_id ?
-				LDB_CH1_MODE_EN_TO_DI1 : LDB_CH0_MODE_EN_TO_DI0;
-		}
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
 		ldb_ipu_ldb_route(setting->dev_id, setting->disp_id, ldb);
-	}
 
 	/*
 	 * ldb_di0_clk -> ipux_di0_clk
diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
index 6f36bd4..721ff88 100644
--- a/drivers/video/mxc/mxc_edid.c
+++ b/drivers/video/mxc/mxc_edid.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -78,12 +78,22 @@ const struct fb_videomode mxc_cea_mode[64] = {
 	},
 	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
 	[8] = {
-		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
 	},
 	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
 	[9] = {
-		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #14: 1440x480p@59.94/60Hz 4:3 */
+	[14] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #15: 1440x480p@59.94/60Hz 16:9 */
+	[15] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
 	/* #16: 1920x1080p@60Hz 16:9 */
@@ -114,6 +124,26 @@ const struct fb_videomode mxc_cea_mode[64] = {
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
+	/* #23: 720(1440)x288pH@50Hz 4:3 */
+	[23] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #24: 720(1440)x288pH@50Hz 16:9 */
+	[24] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #29: 720(1440)x576pH@50Hz 4:3 */
+	[29] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #30: 720(1440)x576pH@50Hz 16:9 */
+	[30] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
 	/* #31: 1920x1080p@50Hz */
 	[31] = {
 		NULL, 50, 1920, 1080, 6734, 148, 528, 36, 4, 44, 5,
@@ -126,10 +156,29 @@ const struct fb_videomode mxc_cea_mode[64] = {
 		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
 		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
 	},
-	/* #35: (2880)x480p4x@59.94/60Hz */
-	[35] = {
-		NULL, 60, 2880, 480, 9250, 240, 64, 30, 9, 248, 6, 0,
-		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	/* #33: 1920x1080p@25Hz */
+	[33] = {
+		NULL, 25, 1920, 1080, 13468, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #34: 1920x1080p@30Hz */
+	[34] = {
+		NULL, 30, 1920, 1080, 13468, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #41: 1280x720p@100Hz 16:9 */
+	[41] = {
+		NULL, 100, 1280, 720, 6734, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #47: 1280x720p@119.88/120Hz 16:9 */
+	[47] = {
+		NULL, 120, 1280, 720, 6734, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
 	},
 };
 
@@ -158,6 +207,9 @@ int mxc_edid_fb_mode_is_equal(bool use_aspect,
 		mode1->upper_margin == mode2->upper_margin &&
 		mode1->lower_margin == mode2->lower_margin &&
 		mode1->sync         == mode2->sync &&
+		/* refresh check, 59.94Hz and 60Hz have the same parameter
+		 * in struct of mxc_cea_mode */
+		abs(mode1->refresh - mode2->refresh) <= 1 &&
 		(mode1->vmode & mask) == (mode2->vmode & mask));
 }
 
diff --git a/drivers/video/mxc/mxc_elcdif_fb.c b/drivers/video/mxc/mxc_elcdif_fb.c
index 6624fd0..023d594 100644
--- a/drivers/video/mxc/mxc_elcdif_fb.c
+++ b/drivers/video/mxc/mxc_elcdif_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -940,14 +940,14 @@ static int mxc_elcdif_fb_set_par(struct fb_info *fbi)
 
 	setup_dotclk_panel((PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
 			   fbi->var.vsync_len,
-			   fbi->var.upper_margin +
-			   fbi->var.yres + fbi->var.lower_margin,
-			   fbi->var.upper_margin,
+			   fbi->var.upper_margin + fbi->var.yres +
+			   fbi->var.lower_margin + fbi->var.vsync_len,
+			   fbi->var.upper_margin + fbi->var.vsync_len,
 			   fbi->var.yres,
 			   fbi->var.hsync_len,
-			   fbi->var.left_margin +
-			   fbi->var.xres + fbi->var.right_margin,
-			   fbi->var.left_margin,
+			   fbi->var.left_margin + fbi->var.xres +
+			   fbi->var.right_margin + fbi->var.hsync_len,
+			   fbi->var.left_margin + fbi->var.hsync_len,
 			   fbi->var.xres,
 			   bpp_to_pixfmt(fbi),
 			   data->output_pix_fmt,
diff --git a/drivers/video/mxc/mxc_epdc_fb.c b/drivers/video/mxc/mxc_epdc_fb.c
index 6787b1e..4103498 100644
--- a/drivers/video/mxc/mxc_epdc_fb.c
+++ b/drivers/video/mxc/mxc_epdc_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -2253,7 +2253,7 @@ static int epdc_submit_merge(struct update_desc_list *upd_desc_list,
 	/* Merged update should take on the earliest order */
 	upd_desc_list->update_order =
 		(upd_desc_list->update_order > update_to_merge->update_order) ?
-		update_to_merge->update_order : upd_desc_list->update_order;
+		upd_desc_list->update_order : update_to_merge->update_order;
 
 	return MERGE_OK;
 }
@@ -5025,9 +5025,36 @@ static int mxc_epdc_fb_resume(struct platform_device *pdev)
 
 	return 0;
 }
+
+static void mxc_epdc_fb_shutdown(struct platform_device *pdev)
+{
+	struct mxc_epdc_fb_data *fb_data = platform_get_drvdata(pdev);
+
+	/* Disable power to the EPD panel */
+	if (regulator_is_enabled(fb_data->vcom_regulator))
+		regulator_disable(fb_data->vcom_regulator);
+	if (regulator_is_enabled(fb_data->display_regulator))
+		regulator_disable(fb_data->display_regulator);
+
+	/* Disable clocks to EPDC */
+	clk_enable(fb_data->epdc_clk_axi);
+	clk_enable(fb_data->epdc_clk_pix);
+	__raw_writel(EPDC_CTRL_CLKGATE, EPDC_CTRL_SET);
+	clk_disable(fb_data->epdc_clk_pix);
+	clk_disable(fb_data->epdc_clk_axi);
+
+	/* Disable pins used by EPDC (to prevent leakage current) */
+	if (fb_data->pdata->disable_pins)
+		fb_data->pdata->disable_pins();
+
+	/* turn off the V3p3 */
+	if (regulator_is_enabled(fb_data->v3p3_regulator))
+		regulator_disable(fb_data->v3p3_regulator);
+}
 #else
 #define mxc_epdc_fb_suspend	NULL
 #define mxc_epdc_fb_resume	NULL
+#define mxc_epdc_fb_shutdown	NULL
 #endif
 
 static struct platform_driver mxc_epdc_fb_driver = {
@@ -5035,6 +5062,7 @@ static struct platform_driver mxc_epdc_fb_driver = {
 	.remove = mxc_epdc_fb_remove,
 	.suspend = mxc_epdc_fb_suspend,
 	.resume = mxc_epdc_fb_resume,
+	.shutdown = mxc_epdc_fb_shutdown,
 	.driver = {
 		   .name = "imx_epdc_fb",
 		   .owner = THIS_MODULE,
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index 8038f3d..4c98d51 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -481,6 +481,14 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	ipu_disable_irq(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
 	ipu_disable_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, true);
 	ipu_uninit_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch);
+
+	/*
+	 * Disable IPU hsp clock if it is enabled for an
+	 * additional time in ipu common driver.
+	 */
+	if (mxc_fbi->first_set_par && mxc_fbi->late_init)
+		ipu_disable_hsp_clk(mxc_fbi->ipu);
+
 	mxcfb_set_fix(fbi);
 
 	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
@@ -1312,6 +1320,20 @@ static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
 
 			break;
 		}
+	case MXCFB_CSC_UPDATE:
+		{
+			struct mxcfb_csc_matrix csc;
+
+			if (copy_from_user(&csc, (void *) arg, sizeof(csc)))
+				return -EFAULT;
+
+			if ((mxc_fbi->ipu_ch != MEM_FG_SYNC) &&
+				(mxc_fbi->ipu_ch != MEM_BG_SYNC) &&
+				(mxc_fbi->ipu_ch != MEM_BG_ASYNC0))
+				return -EFAULT;
+			ipu_set_csc_coefficients(mxc_fbi->ipu, mxc_fbi->ipu_ch,
+						csc.param);
+		}
 	default:
 		retval = -EINVAL;
 	}
@@ -2018,6 +2040,31 @@ static int mxcfb_register(struct fb_info *fbi)
 	fb_var_to_videomode(&m, &fbi->var);
 	fb_add_videomode(&m, &fbi->modelist);
 
+	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
+		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering EOF irq handler.\n");
+		ret = -EBUSY;
+		goto err0;
+	}
+	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
+	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
+		mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering NFACK irq handler.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
+
+	if (mxcfbi->ipu_alp_ch_irq != -1)
+		if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
+				mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
+					MXCFB_NAME, fbi) != 0) {
+			dev_err(fbi->device, "Error registering alpha irq "
+					"handler.\n");
+			ret = -EBUSY;
+			goto err2;
+		}
+
 	if (!mxcfbi->late_init) {
 		fbi->var.activate |= FB_ACTIVATE_FORCE;
 		console_lock();
@@ -2025,25 +2072,26 @@ static int mxcfb_register(struct fb_info *fbi)
 		ret = fb_set_var(fbi, &fbi->var);
 		fbi->flags &= ~FBINFO_MISC_USEREVENT;
 		console_unlock();
+		if (ret < 0) {
+			dev_err(fbi->device, "Error fb_set_var ret:%d\n", ret);
+			goto err3;
+		}
 
 		if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
 			console_lock();
-			fb_blank(fbi, FB_BLANK_UNBLANK);
+			ret = fb_blank(fbi, FB_BLANK_UNBLANK);
 			console_unlock();
+			if (ret < 0) {
+				dev_err(fbi->device,
+					"Error fb_blank ret:%d\n", ret);
+				goto err4;
+			}
 		}
 	} else {
 		/*
 		 * Setup the channel again though bootloader
 		 * has done this, then set_par() can stop the
-		 * channel and re-initialize it. Moreover,
-		 * ipu_init_channel() enables ipu hsp clock,
-		 * so we may keep the clock on until user
-		 * space triggers set_par(), i.e., any ipu
-		 * interface which enables/disables ipu hsp
-		 * clock with pair(called in IPUv3 fb driver
-		 * or mxc v4l2 driver<probed after fb driver>)
-		 * cannot eventually disables the clock to
-		 * damage the channel.
+		 * channel neatly and re-initialize it .
 		 */
 		if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
 			console_lock();
@@ -2053,44 +2101,13 @@ static int mxcfb_register(struct fb_info *fbi)
 		}
 	}
 
-	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
-		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
-		dev_err(fbi->device, "Error registering EOF irq handler.\n");
-		ret = -EBUSY;
-		goto err0;
-	}
-	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
-	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
-		mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
-		dev_err(fbi->device, "Error registering NFACK irq handler.\n");
-		ret = -EBUSY;
-		goto err1;
-	}
-	ipu_disable_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
-
-	if (mxcfbi->ipu_alp_ch_irq != -1)
-		if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
-				mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
-					MXCFB_NAME, fbi) != 0) {
-			dev_err(fbi->device, "Error registering alpha irq "
-					"handler.\n");
-			ret = -EBUSY;
-			goto err2;
-		}
 
 	ret = register_framebuffer(fbi);
 	if (ret < 0)
-		goto err3;
+		goto err5;
 
 	return ret;
-err3:
-	if (mxcfbi->ipu_alp_ch_irq != -1)
-		ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq, fbi);
-err2:
-	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq, fbi);
-err1:
-	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq, fbi);
-err0:
+err5:
 	if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
 		console_lock();
 		if (!mxcfbi->late_init)
@@ -2102,6 +2119,15 @@ err0:
 		}
 		console_unlock();
 	}
+err4:
+err3:
+	if (mxcfbi->ipu_alp_ch_irq != -1)
+		ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq, fbi);
+err2:
+	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq, fbi);
+err1:
+	ipu_free_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq, fbi);
+err0:
 	return ret;
 }
 
diff --git a/drivers/video/mxc/mxcfb_sii902x_elcdif.c b/drivers/video/mxc/mxcfb_sii902x_elcdif.c
index ceab3e6..ecba5b8 100644
--- a/drivers/video/mxc/mxcfb_sii902x_elcdif.c
+++ b/drivers/video/mxc/mxcfb_sii902x_elcdif.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -238,11 +238,6 @@ static void det_worker(struct work_struct *work)
 			dev_dbg(&sii902x.pdev->dev, "EVENT=plugin\n");
 			sprintf(event_string, "EVENT=plugin");
 
-			/* make sure fb is powerdown */
-			console_lock();
-			fb_blank(sii902x.fbi, FB_BLANK_POWERDOWN);
-			console_unlock();
-
 			if (sii902x_read_edid(sii902x.fbi) < 0)
 				dev_err(&sii902x.client->dev,
 					"Sii902x: read edid fail\n");
@@ -286,18 +281,15 @@ static void det_worker(struct work_struct *work)
 					sii902x.fbi->flags &= ~FBINFO_MISC_USEREVENT;
 					console_unlock();
 				}
-
-				console_lock();
-				fb_blank(sii902x.fbi, FB_BLANK_UNBLANK);
-				console_unlock();
+				/* Power on sii902x */
+				sii902x_poweron();
 			}
 		} else {
 			sii902x.cable_plugin = 0;
 			dev_dbg(&sii902x.pdev->dev, "EVENT=plugout\n");
 			sprintf(event_string, "EVENT=plugout");
-			console_lock();
-			fb_blank(sii902x.fbi, FB_BLANK_POWERDOWN);
-			console_unlock();
+			/* Power off sii902x */
+			sii902x_poweroff();
 		}
 		kobject_uevent_env(&sii902x.pdev->dev.kobj, KOBJ_CHANGE, envp);
 	}
@@ -461,18 +453,6 @@ static int __devexit sii902x_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int sii902x_suspend(struct i2c_client *client, pm_message_t message)
-{
-	/*TODO*/
-	return 0;
-}
-
-static int sii902x_resume(struct i2c_client *client)
-{
-	/*TODO*/
-	return 0;
-}
-
 static void sii902x_poweron(void)
 {
 	struct fsl_mxc_lcd_platform_data *plat = sii902x.client->dev.platform_data;
@@ -522,8 +502,6 @@ static struct i2c_driver sii902x_i2c_driver = {
 		   },
 	.probe = sii902x_probe,
 	.remove = sii902x_remove,
-	.suspend = sii902x_suspend,
-	.resume = sii902x_resume,
 	.id_table = sii902x_id,
 };
 
diff --git a/drivers/video/mxc_hdmi.c b/drivers/video/mxc_hdmi.c
index 92822f8..c5069aa 100644
--- a/drivers/video/mxc_hdmi.c
+++ b/drivers/video/mxc_hdmi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -53,6 +53,7 @@
 #include <linux/console.h>
 #include <linux/types.h>
 
+#include "edid.h"
 #include <mach/mxc_edid.h>
 #include "mxc/mxc_dispdrv.h"
 
@@ -94,7 +95,7 @@
 static const struct fb_videomode vga_mode = {
 	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
 	NULL, 60, 640, 480, 39721, 48, 16, 33, 10, 96, 2, 0,
-	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, FB_MODE_IS_VESA,
 };
 
 static const struct fb_videomode xga_mode = {
@@ -148,9 +149,16 @@ struct hdmi_data_info {
 	unsigned int colorimetry;
 	unsigned int pix_repet_factor;
 	unsigned int hdcp_enable;
+	unsigned int rgb_out_enable;
 	struct hdmi_vmode video_mode;
 };
 
+struct hdmi_phy_reg_config {
+	/* HDMI PHY register config for pass HCT */
+	u16 reg_vlev;
+	u16 reg_cksymtx;
+};
+
 struct mxc_hdmi {
 	struct platform_device *pdev;
 	struct platform_device *core_pdev;
@@ -159,6 +167,7 @@ struct mxc_hdmi {
 	struct clk *hdmi_isfr_clk;
 	struct clk *hdmi_iahb_clk;
 	struct delayed_work hotplug_work;
+	struct delayed_work hdcp_hdp_work;
 	struct notifier_block nb;
 
 	struct hdmi_data_info hdmi_data;
@@ -178,14 +187,24 @@ struct mxc_hdmi {
 	struct fb_videomode previous_mode;
 	struct fb_videomode previous_non_vga_mode;
 	bool requesting_vga_for_initialization;
+
+	struct hdmi_phy_reg_config phy_config;
 };
 
+static int hdmi_major;
+static struct class *hdmi_class;
 struct i2c_client *hdmi_i2c;
+struct mxc_hdmi *g_hdmi;
 
 static bool hdmi_inited;
 
 extern const struct fb_videomode mxc_cea_mode[64];
 extern void mxc_hdmi_cec_handle(u16 cec_stat);
+
+static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event);
+static void mxc_hdmi_enable_pins(struct mxc_hdmi *hdmi);
+static void mxc_hdmi_disable_pins(struct mxc_hdmi *hdmi);
+
 #ifdef DEBUG
 static void dump_fb_videomode(struct fb_videomode *m)
 {
@@ -245,6 +264,88 @@ static ssize_t mxc_hdmi_show_edid(struct device *dev,
 
 static DEVICE_ATTR(edid, S_IRUGO, mxc_hdmi_show_edid, NULL);
 
+static ssize_t mxc_hdmi_show_rgb_out_enable(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi->hdmi_data.rgb_out_enable == true)
+		strcpy(buf, "RGB out\n");
+	else
+		strcpy(buf, "YCbCr out\n");
+
+	return strlen(buf);
+}
+
+static ssize_t mxc_hdmi_store_rgb_out_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	hdmi->hdmi_data.rgb_out_enable = value;
+
+	/* Reconfig HDMI for output color space change */
+	mxc_hdmi_setup(hdmi, 0);
+
+	return count;
+}
+
+static DEVICE_ATTR(rgb_out_enable, S_IRUGO | S_IWUSR,
+				mxc_hdmi_show_rgb_out_enable,
+				mxc_hdmi_store_rgb_out_enable);
+
+static ssize_t mxc_hdmi_show_hdcp_enable(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi->hdmi_data.hdcp_enable == false)
+		strcpy(buf, "hdcp disable\n");
+	else
+		strcpy(buf, "hdcp enable\n");
+
+	return strlen(buf);
+}
+
+static ssize_t mxc_hdmi_store_hdcp_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	char event_string[32];
+	char *envp[] = { event_string, NULL };
+	unsigned long value;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	hdmi->hdmi_data.hdcp_enable = value;
+
+	/* Reconfig HDMI for HDCP */
+	mxc_hdmi_setup(hdmi, 0);
+
+	if (hdmi->hdmi_data.hdcp_enable == false) {
+		sprintf(event_string, "EVENT=hdcpdisable");
+		kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+	} else {
+		sprintf(event_string, "EVENT=hdcpenable");
+		kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+	}
+
+	return count;
+
+}
+
+static DEVICE_ATTR(hdcp_enable, S_IRUGO | S_IWUSR,
+			mxc_hdmi_show_hdcp_enable, mxc_hdmi_store_hdcp_enable);
+
 /*!
  * this submodule is responsible for the video data synchronization.
  * for example, for RGB 4:4:4 input, the data map is defined as
@@ -778,6 +879,45 @@ static int hdmi_phy_i2c_write_verify(struct mxc_hdmi *hdmi, unsigned short data,
 }
 #endif
 
+static bool  hdmi_edid_wait_i2c_done(struct mxc_hdmi *hdmi, int msec)
+{
+    unsigned char val = 0;
+    val = hdmi_readb(HDMI_IH_I2CM_STAT0) & 0x2;
+    while (val == 0) {
+		udelay(1000);
+		if (msec-- == 0) {
+			dev_dbg(&hdmi->pdev->dev,
+					"HDMI EDID i2c operation time out!!\n");
+			return false;
+		}
+		val = hdmi_readb(HDMI_IH_I2CM_STAT0) & 0x2;
+	}
+	return true;
+}
+
+static u8 hdmi_edid_i2c_read(struct mxc_hdmi *hdmi,
+					u8 addr, u8 blockno)
+{
+	u8 spointer = blockno / 2;
+	u8 edidaddress = ((blockno % 2) * 0x80) + addr;
+	u8 data;
+
+	hdmi_writeb(0xFF, HDMI_IH_I2CM_STAT0);
+	hdmi_writeb(edidaddress, HDMI_I2CM_ADDRESS);
+	hdmi_writeb(spointer, HDMI_I2CM_SEGADDR);
+	if (spointer == 0)
+		hdmi_writeb(HDMI_I2CM_OPERATION_READ,
+			HDMI_I2CM_OPERATION);
+	else
+		hdmi_writeb(HDMI_I2CM_OPERATION_READ_EXT,
+			HDMI_I2CM_OPERATION);
+
+	hdmi_edid_wait_i2c_done(hdmi, 1000);
+	data = hdmi_readb(HDMI_I2CM_DATAI);
+	hdmi_writeb(0xFF, HDMI_IH_I2CM_STAT0);
+	return data;
+}
+
 /* "Power-down enable (active low)"
  * That mean that power up == 1! */
 static void mxc_hdmi_phy_enable_power(u8 enable)
@@ -1046,6 +1186,14 @@ static int hdmi_phy_configure(struct mxc_hdmi *hdmi, unsigned char pRep,
 	hdmi_phy_i2c_write(hdmi, 0x800d, 0x09);  /* CKSYMTXCTRL */
 	/* TX/CK LVL 10 */
 	hdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);  /* VLEVCTRL */
+
+	/* Board specific setting for PHY register 0x09, 0x0e to pass HCT */
+	if (hdmi->phy_config.reg_cksymtx != 0)
+		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_cksymtx, 0x09);
+
+	if (hdmi->phy_config.reg_vlev != 0)
+		hdmi_phy_i2c_write(hdmi, hdmi->phy_config.reg_vlev, 0x0E);
+
 	/* REMOVE CLK TERM */
 	hdmi_phy_i2c_write(hdmi, 0x8000, 0x05);  /* CKCALCTRL */
 
@@ -1114,28 +1262,13 @@ static void mxc_hdmi_phy_init(struct mxc_hdmi *hdmi)
 
 static void hdmi_tx_hdcp_config(struct mxc_hdmi *hdmi)
 {
-	u8 de, val;
-
-	if (hdmi->hdmi_data.video_mode.mDataEnablePolarity)
-		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;
-	else
-		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW;
-
-	/* disable rx detect */
-	val = hdmi_readb(HDMI_A_HDCPCFG0);
-	val &= HDMI_A_HDCPCFG0_RXDETECT_MASK;
-	val |= HDMI_A_HDCPCFG0_RXDETECT_DISABLE;
-	hdmi_writeb(val, HDMI_A_HDCPCFG0);
-
-	val = hdmi_readb(HDMI_A_VIDPOLCFG);
-	val &= HDMI_A_VIDPOLCFG_DATAENPOL_MASK;
-	val |= de;
-	hdmi_writeb(val, HDMI_A_VIDPOLCFG);
-
-	val = hdmi_readb(HDMI_A_HDCPCFG1);
-	val &= HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK;
-	val |= HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE;
-	hdmi_writeb(val, HDMI_A_HDCPCFG1);
+	if (hdmi->hdmi_data.hdcp_enable) {
+		/* Enable HDMI DDC pin */
+		mxc_hdmi_enable_pins(hdmi);
+	} else {
+		/* Disable HDMI DDC pin */
+		mxc_hdmi_disable_pins(hdmi);
+	}
 }
 
 static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
@@ -1362,19 +1495,131 @@ static void hdmi_av_composer(struct mxc_hdmi *hdmi)
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 }
 
+static int mxc_edid_read_internal(struct mxc_hdmi *hdmi, unsigned char *edid,
+			struct mxc_edid_cfg *cfg, struct fb_info *fbi)
+{
+	int extblknum;
+	int i, j, ret;
+	unsigned char *ediddata = edid;
+	unsigned char tmpedid[EDID_LENGTH];
+
+	dev_info(&hdmi->pdev->dev, "%s\n", __func__);
+
+	if (!edid || !cfg || !fbi)
+		return -EINVAL;
+
+	/* init HDMI I2CM for read edid*/
+	hdmi_writeb(0x0, HDMI_I2CM_DIV);
+	hdmi_writeb(0x00, HDMI_I2CM_SS_SCL_HCNT_1_ADDR);
+	hdmi_writeb(0x79, HDMI_I2CM_SS_SCL_HCNT_0_ADDR);
+	hdmi_writeb(0x00, HDMI_I2CM_SS_SCL_LCNT_1_ADDR);
+	hdmi_writeb(0x91, HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
+
+	hdmi_writeb(0x00, HDMI_I2CM_FS_SCL_HCNT_1_ADDR);
+	hdmi_writeb(0x0F, HDMI_I2CM_FS_SCL_HCNT_0_ADDR);
+	hdmi_writeb(0x00, HDMI_I2CM_FS_SCL_LCNT_1_ADDR);
+	hdmi_writeb(0x21, HDMI_I2CM_FS_SCL_LCNT_0_ADDR);
+
+	hdmi_writeb(0x50, HDMI_I2CM_SLAVE);
+	hdmi_writeb(0x30, HDMI_I2CM_SEGADDR);
+
+	/* Umask edid interrupt */
+	hdmi_writeb(HDMI_I2CM_INT_DONE_POL,
+		    HDMI_I2CM_INT);
+
+	hdmi_writeb(HDMI_I2CM_CTLINT_NAC_POL |
+		    HDMI_I2CM_CTLINT_ARBITRATION_POL,
+		    HDMI_I2CM_CTLINT);
+
+	/* reset edid data zero */
+	memset(edid, 0, EDID_LENGTH*4);
+	memset(cfg, 0, sizeof(struct mxc_edid_cfg));
+
+	/* Check first three byte of EDID head */
+	if (!(hdmi_edid_i2c_read(hdmi, 0, 0) == 0x00) ||
+		!(hdmi_edid_i2c_read(hdmi, 1, 0) == 0xFF) ||
+		!(hdmi_edid_i2c_read(hdmi, 2, 0) == 0xFF)) {
+		dev_info(&hdmi->pdev->dev, "EDID head check failed!");
+		return -ENOENT;
+	}
+
+	for (i = 0; i < 128; i++) {
+		*ediddata = hdmi_edid_i2c_read(hdmi, i, 0);
+		ediddata++;
+	}
+
+	extblknum = edid[0x7E];
+	if (extblknum < 0)
+		return extblknum;
+
+	if (extblknum) {
+		ediddata = edid + EDID_LENGTH;
+		for (i = 0; i < 128; i++) {
+			*ediddata = hdmi_edid_i2c_read(hdmi, i, 1);
+			ediddata++;
+		}
+	}
+
+	/* edid first block parsing */
+	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
+	fb_edid_to_monspecs(edid, &fbi->monspecs);
+
+	ret = mxc_edid_parse_ext_blk(edid + EDID_LENGTH,
+			cfg, &fbi->monspecs);
+	if (ret < 0)
+		return -ENOENT;
+
+	/* need read segment block? */
+	if (extblknum > 1) {
+		for (j = 1; j <= extblknum; j++) {
+			for (i = 0; i < 128; i++)
+				*(tmpedid + 1) = hdmi_edid_i2c_read(hdmi, i, j);
+
+			/* edid ext block parsing */
+			ret = mxc_edid_parse_ext_blk(tmpedid + EDID_LENGTH,
+					cfg, &fbi->monspecs);
+			if (ret < 0)
+				return -ENOENT;
+		}
+	}
+
+	return 0;
+}
+
 static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 {
 	int ret;
 	u8 edid_old[HDMI_EDID_LEN];
+	u8 clkdis;
 
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
 	/* save old edid */
 	memcpy(edid_old, hdmi->edid, HDMI_EDID_LEN);
 
-	ret = mxc_edid_read(hdmi_i2c->adapter, hdmi_i2c->addr, hdmi->edid,
-			    &hdmi->edid_cfg, hdmi->fbi);
+	if (!hdmi->hdmi_data.hdcp_enable)
+		ret = mxc_edid_read(hdmi_i2c->adapter, hdmi_i2c->addr,
+				hdmi->edid, &hdmi->edid_cfg, hdmi->fbi);
+	else {
+
+		/* Disable HDCP clk */
+		if (hdmi->hdmi_data.hdcp_enable) {
+			clkdis = hdmi_readb(HDMI_MC_CLKDIS);
+			clkdis |= HDMI_MC_CLKDIS_HDCPCLK_DISABLE;
+			hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+		}
+
+		ret = mxc_edid_read_internal(hdmi, hdmi->edid,
+				&hdmi->edid_cfg, hdmi->fbi);
+
+		/* Enable HDCP clk */
+		if (hdmi->hdmi_data.hdcp_enable) {
+			clkdis = hdmi_readb(HDMI_MC_CLKDIS);
+			clkdis &= ~HDMI_MC_CLKDIS_HDCPCLK_DISABLE;
+			hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+		}
 
+	}
 	if (ret < 0)
 		return HDMI_EDID_FAIL;
 
@@ -1394,6 +1639,28 @@ static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
 	return HDMI_EDID_SUCCESS;
 }
 
+static void mxc_hdmi_enable_pins(struct mxc_hdmi *hdmi)
+{
+	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Enable pins to HDMI */
+	if (plat->enable_pins)
+		plat->enable_pins();
+}
+
+static void mxc_hdmi_disable_pins(struct mxc_hdmi *hdmi)
+{
+	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Disable pins to HDMI */
+	if (plat->disable_pins)
+		plat->disable_pins();
+}
+
 static void mxc_hdmi_phy_disable(struct mxc_hdmi *hdmi)
 {
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
@@ -1557,6 +1824,12 @@ static void mxc_hdmi_edid_rebuild_modelist(struct mxc_hdmi *hdmi)
 	console_unlock();
 }
 
+static void  mxc_hdmi_default_edid_cfg(struct mxc_hdmi *hdmi)
+{
+	/* Default setting HDMI working in HDMI mode */
+	hdmi->edid_cfg.hdmi_cap = true;
+}
+
 static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 {
 	u32 i;
@@ -1572,6 +1845,11 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 
 	fb_destroy_modelist(&hdmi->fbi->modelist);
 
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&vga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
+
 	/*Add all no interlaced CEA mode to default modelist */
 	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
 		mode = &mxc_cea_mode[i];
@@ -1579,10 +1857,6 @@ static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
 			fb_add_videomode(mode, &hdmi->fbi->modelist);
 	}
 
-	/*Add XGA and SXGA to default modelist */
-	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
-	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
-
 	console_unlock();
 }
 
@@ -1629,17 +1903,17 @@ static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi)
 		return;
 	}
 
-	/* If video mode same as previous, init HDMI PHY and return */
+	/* If video mode same as previous, init HDMI again */
 	if (fb_mode_is_equal(&hdmi->previous_non_vga_mode, mode)) {
 		dev_dbg(&hdmi->pdev->dev,
 				"%s: Video mode same as previous\n", __func__);
 		/* update fbi mode in case modelist is updated */
 		hdmi->fbi->mode = (struct fb_videomode *)mode;
-		mxc_hdmi_phy_init(hdmi);
+		/* update hdmi setting in case EDID data updated  */
+		mxc_hdmi_setup(hdmi, 0);
 	} else {
 		dev_dbg(&hdmi->pdev->dev, "%s: New video mode\n", __func__);
 		mxc_hdmi_set_mode_to_vga_dvi(hdmi);
-
 		fb_videomode_to_var(&hdmi->fbi->var, mode);
 		dump_fb_videomode((struct fb_videomode *)mode);
 		mxc_hdmi_notify_fb(hdmi);
@@ -1675,8 +1949,10 @@ static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
 	case HDMI_EDID_SAME:
 		break;
 
-	case HDMI_EDID_NO_MODES:
 	case HDMI_EDID_FAIL:
+		mxc_hdmi_default_edid_cfg(hdmi);
+		/* No break here  */
+	case HDMI_EDID_NO_MODES:
 	default:
 		mxc_hdmi_default_modelist(hdmi);
 		break;
@@ -1705,10 +1981,13 @@ static void mxc_hdmi_cable_disconnected(struct mxc_hdmi *hdmi)
 {
 	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
 
-	hdmi_disable_overflow_interrupts();
+	/* Disable All HDMI clock */
+	hdmi_writeb(0xff, HDMI_MC_CLKDIS);
 
 	mxc_hdmi_phy_disable(hdmi);
 
+	hdmi_disable_overflow_interrupts();
+
 	hdmi->cable_plugin = false;
 }
 
@@ -1720,7 +1999,7 @@ static void hotplug_worker(struct work_struct *work)
 	u32 phy_int_stat, phy_int_pol, phy_int_mask;
 	u8 val;
 	unsigned long flags;
-	char event_string[16];
+	char event_string[32];
 	char *envp[] = { event_string, NULL };
 
 	phy_int_stat = hdmi->latest_intr_stat;
@@ -1789,6 +2068,21 @@ static void hotplug_worker(struct work_struct *work)
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 }
 
+static void hdcp_hdp_worker(struct work_struct *work)
+{
+	struct delayed_work *delay_work = to_delayed_work(work);
+	struct mxc_hdmi *hdmi =
+		container_of(delay_work, struct mxc_hdmi, hdcp_hdp_work);
+	char event_string[32];
+	char *envp[] = { event_string, NULL };
+
+	/* HDCP interrupt */
+	sprintf(event_string, "EVENT=hdcpint");
+	kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+
+	/* Unmute interrupts in HDCP application*/
+}
+
 static irqreturn_t mxc_hdmi_hotplug(int irq, void *data)
 {
 	struct mxc_hdmi *hdmi = data;
@@ -1837,6 +2131,17 @@ static irqreturn_t mxc_hdmi_hotplug(int irq, void *data)
 		schedule_delayed_work(&(hdmi->hotplug_work), msecs_to_jiffies(20));
 	}
 
+	/* Check HDCP  interrupt state */
+	if (hdmi->hdmi_data.hdcp_enable) {
+		val = hdmi_readb(HDMI_A_APIINTSTAT);
+		if (val != 0) {
+			/* Mute interrupts until interrupt handled */
+			val = 0xFF;
+			hdmi_writeb(val, HDMI_A_APIINTMSK);
+			schedule_delayed_work(&(hdmi->hdcp_hdp_work), msecs_to_jiffies(50));
+		}
+	}
+
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 	return IRQ_HANDLED;
 }
@@ -1851,15 +2156,6 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	fb_var_to_videomode(&m, &hdmi->fbi->var);
 	dump_fb_videomode(&m);
 
-	/* Exit the setup if we get mode change and are already set to
-	 * this video mode */
-	if ((event == FB_EVENT_MODE_CHANGE) &&
-		fb_mode_is_equal(&hdmi->previous_mode, &m)) {
-		dev_dbg(&hdmi->pdev->dev,
-			"%s video mode did not change.\n", __func__);
-		mxc_hdmi_phy_init(hdmi);
-		return;
-	}
 	dev_dbg(&hdmi->pdev->dev, "%s - video mode changed\n", __func__);
 
 	/* Save mode as 'previous_mode' so that we can know if mode changed. */
@@ -1881,17 +2177,12 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 
 	hdmi_disable_overflow_interrupts();
 
-	if (hdmi->vic == 0) {
-		dev_dbg(&hdmi->pdev->dev, "Non-CEA mode used in HDMI\n");
+	dev_dbg(&hdmi->pdev->dev, "CEA mode used vic=%d\n", hdmi->vic);
+	if (hdmi->edid_cfg.hdmi_cap)
+		hdmi->hdmi_data.video_mode.mDVI = false;
+	else {
+		dev_dbg(&hdmi->pdev->dev, "CEA mode vic=%d work in DVI\n", hdmi->vic);
 		hdmi->hdmi_data.video_mode.mDVI = true;
-	} else {
-		dev_dbg(&hdmi->pdev->dev, "CEA mode used vic=%d\n", hdmi->vic);
-		if (hdmi->edid_cfg.hdmi_cap)
-			hdmi->hdmi_data.video_mode.mDVI = false;
-		else {
-			dev_dbg(&hdmi->pdev->dev, "CEA mode vic=%d work in DVI\n", hdmi->vic);
-			hdmi->hdmi_data.video_mode.mDVI = true;
-		}
 	}
 
 	if ((hdmi->vic == 6) || (hdmi->vic == 7) ||
@@ -1920,8 +2211,10 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	hdmi->hdmi_data.enc_in_format = RGB;
 
 	hdmi->hdmi_data.enc_out_format = RGB;
-	/*DVI mode not support non-RGB */
-	if (!hdmi->hdmi_data.video_mode.mDVI) {
+
+	/* YCbCr only enabled in HDMI mode */
+	if (!hdmi->hdmi_data.video_mode.mDVI &&
+		!hdmi->hdmi_data.rgb_out_enable) {
 		if (hdmi->edid_cfg.cea_ycbcr444)
 			hdmi->hdmi_data.enc_out_format = YCBCR444;
 		else if (hdmi->edid_cfg.cea_ycbcr422)
@@ -1931,7 +2224,6 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 	/* IPU not support depth color output */
 	hdmi->hdmi_data.enc_color_depth = 8;
 	hdmi->hdmi_data.pix_repet_factor = 0;
-	hdmi->hdmi_data.hdcp_enable = 0;
 	hdmi->hdmi_data.video_mode.mDataEnablePolarity = true;
 
 	/* HDMI Initialization Step B.1 */
@@ -2136,6 +2428,10 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	if (plat->init)
 		plat->init(mxc_hdmi_ipu_id, mxc_hdmi_disp_id);
 
+	/* Specific phy config */
+	hdmi->phy_config.reg_cksymtx = plat->phy_reg_cksymtx;
+	hdmi->phy_config.reg_vlev = plat->phy_reg_vlev;
+
 	hdmi->hdmi_isfr_clk = clk_get(&hdmi->pdev->dev, "hdmi_isfr_clk");
 	if (IS_ERR(hdmi->hdmi_isfr_clk)) {
 		ret = PTR_ERR(hdmi->hdmi_isfr_clk);
@@ -2213,7 +2509,7 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
 	if (!mode) {
 		pr_err("%s: could not find mode in modelist\n", __func__);
-		return;
+		return -1;
 	}
 
 	fb_videomode_to_var(&hdmi->fbi->var, mode);
@@ -2222,6 +2518,7 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 	hdmi->edid_cfg.hdmi_cap = true;
 
 	INIT_DELAYED_WORK(&hdmi->hotplug_work, hotplug_worker);
+	INIT_DELAYED_WORK(&hdmi->hdcp_hdp_work, hdcp_hdp_worker);
 
 	/* Configure registers related to HDMI interrupt
 	 * generation before registering IRQ. */
@@ -2237,6 +2534,9 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 
 	memset(&hdmi->hdmi_data, 0, sizeof(struct hdmi_data_info));
 
+	/* Default HDMI working in RGB mode */
+	hdmi->hdmi_data.rgb_out_enable = true;
+
 	ret = request_irq(irq, mxc_hdmi_hotplug, IRQF_SHARED,
 			  dev_name(&hdmi->pdev->dev), hdmi);
 	if (ret < 0) {
@@ -2258,6 +2558,16 @@ static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
 		dev_warn(&hdmi->pdev->dev,
 			"cound not create sys node for edid\n");
 
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_rgb_out_enable);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for rgb out enable\n");
+
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_hdcp_enable);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for hdcp enable\n");
+
 	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
 
 	hdmi_inited = true;
@@ -2315,9 +2625,50 @@ static struct mxc_dispdrv_driver mxc_hdmi_drv = {
 	.disable = mxc_hdmi_power_off,
 };
 
+
+static int mxc_hdmi_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long mxc_hdmi_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int __user *argp = (void __user *)arg;
+	int ret = 0;
+
+	switch (cmd) {
+	case HDMI_IOC_GET_RESOURCE:
+		ret = copy_to_user(argp, &g_hdmi->hdmi_data,
+				sizeof(g_hdmi->hdmi_data)) ? -EFAULT : 0;
+		break;
+	case HDMI_IOC_GET_CPU_TYPE:
+		*argp = mxc_cpu_type;
+		break;
+	default:
+		pr_debug("Unsupport cmd %d\n", cmd);
+		break;
+     }
+     return ret;
+}
+
+static int mxc_hdmi_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations mxc_hdmi_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_hdmi_open,
+	.release = mxc_hdmi_release,
+	.unlocked_ioctl = mxc_hdmi_ioctl,
+};
+
+
 static int __devinit mxc_hdmi_probe(struct platform_device *pdev)
 {
 	struct mxc_hdmi *hdmi;
+	struct device *temp_class;
 	int ret = 0;
 
 	/* Check that I2C driver is loaded and available */
@@ -2330,6 +2681,28 @@ static int __devinit mxc_hdmi_probe(struct platform_device *pdev)
 		ret = -ENOMEM;
 		goto ealloc;
 	}
+	g_hdmi = hdmi;
+
+	hdmi_major = register_chrdev(hdmi_major, "mxc_hdmi", &mxc_hdmi_fops);
+	if (hdmi_major < 0) {
+		printk(KERN_ERR "HDMI: unable to get a major for HDMI\n");
+		ret = -EBUSY;
+		goto ealloc;
+	}
+
+	hdmi_class = class_create(THIS_MODULE, "mxc_hdmi");
+	if (IS_ERR(hdmi_class)) {
+		ret = PTR_ERR(hdmi_class);
+		goto err_out_chrdev;
+	}
+
+	temp_class = device_create(hdmi_class, NULL, MKDEV(hdmi_major, 0),
+				   NULL, "mxc_hdmi");
+	if (IS_ERR(temp_class)) {
+		ret = PTR_ERR(temp_class);
+		goto err_out_class;
+	}
+
 
 	hdmi->pdev = pdev;
 
@@ -2359,6 +2732,11 @@ edispdrv:
 	platform_device_put(hdmi->core_pdev);
 ecore:
 	kfree(hdmi);
+err_out_class:
+	device_destroy(hdmi_class, MKDEV(hdmi_major, 0));
+	class_destroy(hdmi_class);
+err_out_chrdev:
+	unregister_chrdev(hdmi_major, "mxc_hdmi");
 ealloc:
 	return ret;
 }
@@ -2375,6 +2753,7 @@ static int mxc_hdmi_remove(struct platform_device *pdev)
 	/* No new work will be scheduled, wait for running ISR */
 	free_irq(irq, hdmi);
 	kfree(hdmi);
+	g_hdmi = NULL;
 
 	return 0;
 }
@@ -2396,6 +2775,13 @@ module_init(mxc_hdmi_init);
 
 static void __exit mxc_hdmi_exit(void)
 {
+	if (hdmi_major > 0) {
+		device_destroy(hdmi_class, MKDEV(hdmi_major, 0));
+		class_destroy(hdmi_class);
+		unregister_chrdev(hdmi_major, "mxc_hdmi");
+		hdmi_major = 0;
+	}
+
 	platform_driver_unregister(&mxc_hdmi_driver);
 }
 module_exit(mxc_hdmi_exit);
diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index cc0bb49..129dbee 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -93,7 +93,7 @@ void can_bus_off(struct net_device *dev);
 
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 		      unsigned int idx);
-void can_get_echo_skb(struct net_device *dev, unsigned int idx);
+unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
 struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);
diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index d6733e2..acc1435 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -151,6 +151,12 @@ clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 				      freq, minsec);
 }
 
+#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)
+extern int tick_check_broadcast_pending(void);
+#else
+static inline int tick_check_broadcast_pending(void) { return 0; }
+#endif
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else
diff --git a/include/linux/dmapool.h b/include/linux/dmapool.h
index 4509501..c3c41ef 100644
--- a/include/linux/dmapool.h
+++ b/include/linux/dmapool.h
@@ -22,10 +22,8 @@ void dma_pool_destroy(struct dma_pool *pool);
 void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
 		     dma_addr_t *handle);
 
-#ifdef CONFIG_FSL_UTP
 void *dma_pool_alloc_nonbufferable(struct dma_pool *pool, gfp_t mem_flags,
 		     dma_addr_t *handle);
-#endif
 
 void dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t addr);
 
diff --git a/include/linux/fec.h b/include/linux/fec.h
index 8f69cb5..7d4e73d 100644
--- a/include/linux/fec.h
+++ b/include/linux/fec.h
@@ -3,7 +3,7 @@
  * Copyright (c) 2009 Orex Computed Radiography
  *   Baruch Siach <baruch@tkos.co.il>
  *
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
  *
  * Header file for the FEC platform data
  *
@@ -21,6 +21,7 @@ struct fec_platform_data {
 	int (*power_hibernate) (struct phy_device *);
 	phy_interface_t phy;
 	unsigned char mac[ETH_ALEN];
+	int gpio_irq;
 };
 
 #endif
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 78a50ac..ac56f18 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -6,7 +6,7 @@
  *
  * Maintainer: Kumar Gala <galak@kernel.crashing.org>
  *
- * Copyright 2004-2012 Freescale Semiconductor, Inc.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -284,6 +284,9 @@ struct fsl_mxc_hdmi_platform_data {
 	void (*put_pins) (void);
 	void (*enable_pins) (void);
 	void (*disable_pins) (void);
+	/* HDMI PHY register config for pass HCT */
+	u16 phy_reg_vlev;
+	u16 phy_reg_cksymtx;
 };
 
 struct fsl_mxc_hdmi_core_platform_data {
diff --git a/include/linux/ipu.h b/include/linux/ipu.h
index f8178f1..358d315 100644
--- a/include/linux/ipu.h
+++ b/include/linux/ipu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2012 Freescale Semiconductor, Inc.
+ * Copyright 2005-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -94,6 +94,7 @@ typedef enum {
 /*! @{ */
 #define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
 #define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_16 fourcc('I', 'P', 'U', '2')	/*!< IPU Generic Data */
 #define IPU_PIX_FMT_LVDS666 fourcc('L', 'V', 'D', '6')	/*!< IPU Generic Data */
 #define IPU_PIX_FMT_LVDS888 fourcc('L', 'V', 'D', '8')	/*!< IPU Generic Data */
 /*! @} */
@@ -168,6 +169,14 @@ struct ipu_deinterlace {
 	u8	motion; /*see ipu_motion_sel*/
 #define IPU_DEINTERLACE_FIELD_TOP	0
 #define IPU_DEINTERLACE_FIELD_BOTTOM	1
+#define IPU_DEINTERLACE_FIELD_MASK	\
+		(IPU_DEINTERLACE_FIELD_TOP | IPU_DEINTERLACE_FIELD_BOTTOM)
+	/* deinterlace frame rate double flags */
+#define IPU_DEINTERLACE_RATE_EN		0x80
+#define IPU_DEINTERLACE_RATE_FRAME1	0x40
+#define IPU_DEINTERLACE_RATE_MASK	\
+		(IPU_DEINTERLACE_RATE_EN | IPU_DEINTERLACE_RATE_FRAME1)
+#define IPU_DEINTERLACE_MAX_FRAME	2
 	u8	field_fmt;
 };
 
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index a9e6ba4..418fd87 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -432,7 +432,7 @@ static inline void inline_map_copy_from(struct map_info *map, void *to, unsigned
 	if (map->cached)
 		memcpy(to, (char *)map->cached + from, len);
 	else
-		memcpy_fromio(to, map->virt + from, len);
+		memcpy(to, map->virt + from, len);
 }
 
 static inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
diff --git a/include/linux/mxc_asrc.h b/include/linux/mxc_asrc.h
index 37c64b7..8de07b9 100644
--- a/include/linux/mxc_asrc.h
+++ b/include/linux/mxc_asrc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,21 +34,27 @@
 #define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 7, enum asrc_pair_index)
 
 enum asrc_pair_index {
+	ASRC_UNVALID_PAIR = -1,
 	ASRC_PAIR_A,
 	ASRC_PAIR_B,
 	ASRC_PAIR_C
 };
 
+#define ASRC_PAIR_MAX_NUM	(ASRC_PAIR_C + 1)
+
 enum asrc_inclk {
 	INCLK_NONE = 0x03,
 	INCLK_ESAI_RX = 0x00,
 	INCLK_SSI1_RX = 0x01,
 	INCLK_SSI2_RX = 0x02,
+	INCLK_SSI3_RX = 0x07,
 	INCLK_SPDIF_RX = 0x04,
 	INCLK_MLB_CLK = 0x05,
+	INCLK_PAD = 0x06,
 	INCLK_ESAI_TX = 0x08,
 	INCLK_SSI1_TX = 0x09,
 	INCLK_SSI2_TX = 0x0a,
+	INCLK_SSI3_TX = 0x0b,
 	INCLK_SPDIF_TX = 0x0c,
 	INCLK_ASRCK1_CLK = 0x0f,
 };
@@ -58,11 +64,14 @@ enum asrc_outclk {
 	OUTCLK_ESAI_TX = 0x00,
 	OUTCLK_SSI1_TX = 0x01,
 	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SSI3_TX = 0x07,
 	OUTCLK_SPDIF_TX = 0x04,
 	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_PAD = 0x06,
 	OUTCLK_ESAI_RX = 0x08,
 	OUTCLK_SSI1_RX = 0x09,
 	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SSI3_RX = 0x0b,
 	OUTCLK_SPDIF_RX = 0x0c,
 	OUTCLK_ASRCK1_CLK = 0x0f,
 };
diff --git a/include/linux/mxc_mlb.h b/include/linux/mxc_mlb.h
index 7ac953c..3a63647 100644
--- a/include/linux/mxc_mlb.h
+++ b/include/linux/mxc_mlb.h
@@ -1,7 +1,7 @@
 /*
  * mxc_mlb.h
  *
- * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,6 +21,7 @@
 #define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
 #define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
 #define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+
 /*!
  * set channel address for each logical channel
  * the MSB 16bits is for tx channel, the left LSB is for rx channel
@@ -30,6 +31,10 @@
 #define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
 #define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
 
+#define MLB_SET_ISOC_BLKSIZE_188 _IO('S', 0x17)
+#define MLB_SET_ISOC_BLKSIZE_196 _IO('S', 0x18)
+#define MLB_SET_SYNC_QUAD	_IOW('S', 0x19, unsigned int)
+
 /*!
  * MLB event define
  */
diff --git a/include/linux/mxcfb.h b/include/linux/mxcfb.h
index be391e0..d96d1b7 100644
--- a/include/linux/mxcfb.h
+++ b/include/linux/mxcfb.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -110,7 +110,7 @@ struct mxcfb_update_data {
 	__u32 update_mode;
 	__u32 update_marker;
 	int temp;
-	uint flags;
+	unsigned int flags;
 	struct mxcfb_alt_buffer_data alt_buffer_data;
 };
 
@@ -132,6 +132,14 @@ struct mxcfb_waveform_modes {
 	int mode_gc32;
 };
 
+/*
+ * Structure used to define a 5*3 matrix of parameters for
+ * setting IPU DP CSC module related to this framebuffer.
+ */
+struct mxcfb_csc_matrix {
+	int param[5][3];
+};
+
 #define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
 #define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
 #define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
@@ -144,6 +152,7 @@ struct mxcfb_waveform_modes {
 #define MXCFB_GET_DIFMT	       _IOR('F', 0x2A, u_int32_t)
 #define MXCFB_GET_FB_BLANK     _IOR('F', 0x2B, u_int32_t)
 #define MXCFB_SET_DIFMT		_IOW('F', 0x2C, u_int32_t)
+#define MXCFB_CSC_UPDATE	_IOW('F', 0x2D, struct mxcfb_csc_matrix)
 
 /* IOCTLs for E-ink panel updates */
 #define MXCFB_SET_WAVEFORM_MODES	_IOW('F', 0x2B, struct mxcfb_waveform_modes)
diff --git a/kernel/power/main.c b/kernel/power/main.c
index b7d0e30..0fae580 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -16,6 +16,7 @@
 #include "power.h"
 
 DEFINE_MUTEX(pm_mutex);
+EXPORT_SYMBOL(pm_mutex);
 
 #ifdef CONFIG_PM_SLEEP
 
diff --git a/kernel/time/tick-broadcast.c b/kernel/time/tick-broadcast.c
index 7a90d02..56f7043 100644
--- a/kernel/time/tick-broadcast.c
+++ b/kernel/time/tick-broadcast.c
@@ -360,6 +360,8 @@ int tick_resume_broadcast(void)
 
 /* FIXME: use cpumask_var_t. */
 static DECLARE_BITMAP(tick_broadcast_oneshot_mask, NR_CPUS);
+static DECLARE_BITMAP(tick_broadcast_pending, NR_CPUS);
+static DECLARE_BITMAP(tick_force_broadcast_mask, NR_CPUS);
 
 /*
  * Exposed for debugging: see timer_list.c
@@ -376,6 +378,15 @@ static int tick_broadcast_set_event(ktime_t expires, int force)
 	return tick_dev_program_event(bc, expires, force);
 }
 
+/*
+ * Called before going idle with interrupts disabled. Checks whether a
+ * broadcast event from the other core is about to happen.
+ */
+int tick_check_broadcast_pending(void)
+{
+	return test_bit(smp_processor_id(), tick_force_broadcast_mask);
+}
+
 int tick_resume_broadcast_oneshot(struct clock_event_device *bc)
 {
 	clockevents_set_mode(bc, CLOCK_EVT_MODE_ONESHOT);
@@ -413,12 +424,24 @@ again:
 	/* Find all expired events */
 	for_each_cpu(cpu, tick_get_broadcast_oneshot_mask()) {
 		td = &per_cpu(tick_cpu_device, cpu);
-		if (td->evtdev->next_event.tv64 <= now.tv64)
+		if (td->evtdev->next_event.tv64 <= now.tv64) {
 			cpumask_set_cpu(cpu, to_cpumask(tmpmask));
-		else if (td->evtdev->next_event.tv64 < next_event.tv64)
+			/*
+			 * Mark the remote cpu in the pending mask, so
+			 * it can avoid reprogramming the cpu local
+			 * timer in tick_broadcast_oneshot_control().
+			 */
+			set_bit(cpu, tick_broadcast_pending);
+		} else if (td->evtdev->next_event.tv64 < next_event.tv64)
 			next_event.tv64 = td->evtdev->next_event.tv64;
 	}
 
+	/* Take care of enforced broadcast requests */
+	for_each_cpu(cpu, to_cpumask(tick_force_broadcast_mask)) {
+		set_bit(cpu, tmpmask);
+		clear_bit(cpu, tick_force_broadcast_mask);
+	}
+
 	/*
 	 * Wakeup the cpus which have an expired event.
 	 */
@@ -454,6 +477,7 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 	struct clock_event_device *bc, *dev;
 	struct tick_device *td;
 	unsigned long flags;
+	ktime_t now;
 	int cpu;
 
 	/*
@@ -478,6 +502,8 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 
 	raw_spin_lock_irqsave(&tick_broadcast_lock, flags);
 	if (reason == CLOCK_EVT_NOTIFY_BROADCAST_ENTER) {
+		WARN_ON_ONCE(test_bit(cpu, tick_broadcast_pending));
+		WARN_ON_ONCE(test_bit(cpu, tick_force_broadcast_mask));
 		if (!cpumask_test_cpu(cpu, tick_get_broadcast_oneshot_mask())) {
 			cpumask_set_cpu(cpu, tick_get_broadcast_oneshot_mask());
 			clockevents_set_mode(dev, CLOCK_EVT_MODE_SHUTDOWN);
@@ -489,10 +515,61 @@ void tick_broadcast_oneshot_control(unsigned long reason)
 			cpumask_clear_cpu(cpu,
 					  tick_get_broadcast_oneshot_mask());
 			clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);
-			if (dev->next_event.tv64 != KTIME_MAX)
-				tick_program_event(dev->next_event, 1);
+			if (dev->next_event.tv64 == KTIME_MAX)
+				goto out;
+			/*
+			 * The cpu handling the broadcast timer marked
+			 * this cpu in the broadcast pending mask and
+			 * fired the broadcast IPI. So we are going to
+			 * handle the expired event anyway via the
+			 * broadcast IPI handler. No need to reprogram
+			 * the timer with an already expired event.
+			 */
+			if (test_and_clear_bit(cpu, tick_broadcast_pending))
+				goto out;
+			/*
+			 * If the pending bit is not set, then we are
+			 * either the CPU handling the broadcast
+			 * interrupt or we got woken by something else.
+			 *
+			 * We are not longer in the broadcast mask, so
+			 * if the cpu local expiry time is already
+			 * reached, we would reprogram the cpu local
+			 * timer with an already expired event.
+			 *
+			 * This can lead to a ping-pong when we return
+			 * to idle and therefor rearm the broadcast
+			 * timer before the cpu local timer was able
+			 * to fire. This happens because the forced
+			 * reprogramming makes sure that the event
+			 * will happen in the future and depending on
+			 * the min_delta setting this might be far
+			 * enough out that the ping-pong starts.
+			 *
+			 * If the cpu local next_event has expired
+			 * then we know that the broadcast timer
+			 * next_event has expired as well and
+			 * broadcast is about to be handled. So we
+			 * avoid reprogramming and enforce that the
+			 * broadcast handler, which did not run yet,
+			 * will invoke the cpu local handler.
+			 *
+			 * We cannot call the handler directly from
+			 * here, because we might be in a NOHZ phase
+			 * and we did not go through the irq_enter()
+			 * nohz fixups.
+			 */
+			now = ktime_get();
+			if (dev->next_event.tv64 <= now.tv64)
+				set_bit(cpu, tick_force_broadcast_mask);
+			/*
+			 * We got woken by something else. Reprogram
+			 * the cpu local timer device.
+			 */
+			tick_program_event(dev->next_event, 1);
 		}
 	}
+out:
 	raw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);
 }
 
diff --git a/mm/compaction.c b/mm/compaction.c
index c4bc5ac..bf6bc32 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -715,14 +715,12 @@ static int compact_node(int nid)
 }
 
 /* Compact all nodes in the system */
-static int compact_nodes(void)
+static void compact_nodes(void)
 {
 	int nid;
 
 	for_each_online_node(nid)
 		compact_node(nid);
-
-	return COMPACT_COMPLETE;
 }
 
 /* The written value is actually unused, all memory is compacted */
@@ -733,7 +731,7 @@ int sysctl_compaction_handler(struct ctl_table *table, int write,
 			void __user *buffer, size_t *length, loff_t *ppos)
 {
 	if (write)
-		return compact_nodes();
+		compact_nodes();
 
 	return 0;
 }
diff --git a/mm/dmapool.c b/mm/dmapool.c
index 98798f41..0d19926 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -212,7 +212,6 @@ static void pool_initialise_page(struct dma_pool *pool, struct dma_page *page)
 	} while (offset < pool->allocation);
 }
 
-#ifdef CONFIG_FSL_UTP
 static struct dma_page *pool_alloc_page_nonbufferable(struct dma_pool *pool, gfp_t mem_flags)
 {
 	struct dma_page *page;
@@ -236,7 +235,6 @@ static struct dma_page *pool_alloc_page_nonbufferable(struct dma_pool *pool, gfp
 	}
 	return page;
 }
-#endif
 
 static struct dma_page *pool_alloc_page(struct dma_pool *pool, gfp_t mem_flags)
 {
@@ -379,7 +377,6 @@ void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
 }
 EXPORT_SYMBOL(dma_pool_alloc);
 
-#ifdef CONFIG_FSL_UTP
 /**
  * dma_pool_alloc_nonbufferable - get a block of consistent memory
  * @pool: dma pool that will produce the block
@@ -439,7 +436,6 @@ void *dma_pool_alloc_nonbufferable(struct dma_pool *pool, gfp_t mem_flags,
 	return retval;
 }
 EXPORT_SYMBOL(dma_pool_alloc_nonbufferable);
-#endif
 
 static struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)
 {
diff --git a/sound/soc/codecs/cs42888.c b/sound/soc/codecs/cs42888.c
index 698ff4b..03f160b 100644
--- a/sound/soc/codecs/cs42888.c
+++ b/sound/soc/codecs/cs42888.c
@@ -1,6 +1,6 @@
 /*
  * cs42888.c  -- CS42888 ALSA SoC Audio Driver
- * Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 /*
  * The code contained herein is licensed under the GNU General Public
@@ -129,6 +129,11 @@ static const char *cs42888_supply_names[CS42888_NUM_SUPPLIES] = {
 #define CS42888_TRANS_ADC_SNGVOL_MASK	(1 << CS42888_TRANS_ADC_SNGVOL_OFFSET)
 #define CS42888_TRANS_ADC_SZC_MASK	(3 << CS42888_TRANS_ADC_SZC_OFFSET)
 
+#define CS42888_TRANS_DAC_SZC_IC     (0 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_ZC     (1 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_SR     (2 << CS42888_TRANS_DAC_SZC_OFFSET)
+#define CS42888_TRANS_DAC_SZC_SRZC   (3 << CS42888_TRANS_DAC_SZC_OFFSET)
+
 #define CS42888_MUTE_AOUT8	(0x1 << 7)
 #define CS42888_MUTE_AOUT7	(0x1 << 6)
 #define CS42888_MUTE_AOUT6	(0x1 << 5)
@@ -717,7 +722,6 @@ static int cs42888_hw_params(struct snd_pcm_substream *substream,
 		pr_err("i2c write failed\n");
 		return ret;
 	}
-	 msleep(400);
 
 	ret = cs42888_fill_cache(codec);
 	if (ret < 0) {
@@ -884,6 +888,8 @@ static int cs42888_probe(struct snd_soc_codec *codec)
 	/* Disable auto-mute */
 	val = snd_soc_read(codec, CS42888_TRANS);
 	val &= ~CS42888_TRANS_AMUTE_MASK;
+	val &= ~CS42888_TRANS_DAC_SZC_MASK;
+	val |=  CS42888_TRANS_DAC_SZC_SR;
 	ret = snd_soc_write(codec, CS42888_TRANS, val);
 	if (ret < 0) {
 		pr_err("i2c write failed\n");
diff --git a/sound/soc/codecs/mxc_spdif.c b/sound/soc/codecs/mxc_spdif.c
index 33b2337..b358f71 100644
--- a/sound/soc/codecs/mxc_spdif.c
+++ b/sound/soc/codecs/mxc_spdif.c
@@ -1,7 +1,7 @@
 /*
  * MXC SPDIF ALSA Soc Codec Driver
  *
- * Copyright (C) 2007-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007-2013 Freescale Semiconductor, Inc.
  */
 
 /*
@@ -881,10 +881,17 @@ static int mxc_spdif_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int cstatus;
 
-	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW))
+	clk_enable(plat_data->spdif_clk);
+
+	if (!(__raw_readl(spdif_base_addr + SPDIF_REG_SIS) & INT_CNEW)) {
+		clk_disable(plat_data->spdif_clk);
 		return -EAGAIN;
+	}
 
 	cstatus = __raw_readl(spdif_base_addr + SPDIF_REG_SRCSLH);
 	ucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;
@@ -898,6 +905,8 @@ static int mxc_spdif_capture_get(struct snd_kcontrol *kcontrol,
 	/* clear intr */
 	__raw_writel(INT_CNEW, spdif_base_addr + SPDIF_REG_SIC);
 
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -980,12 +989,19 @@ static int mxc_spdif_vbit_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_vbit_get(struct snd_kcontrol *kcontrol,
 			      struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int int_val;
 
+	clk_enable(plat_data->spdif_clk);
+
 	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SIS);
 	ucontrol->value.integer.value[0] = (int_val & INT_VAL_NOGOOD) != 0;
 	__raw_writel(INT_VAL_NOGOOD, spdif_base_addr + SPDIF_REG_SIC);
 
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1016,9 +1032,11 @@ static int mxc_spdif_rxrate_get(struct snd_kcontrol *kcontrol,
 	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 
 	if (atomic_read(&spdif_priv->dpll_locked)) {
+		clk_enable(plat_data->spdif_clk);
 		ucontrol->value.integer.value[0] =
 		    spdif_get_rxclk_rate(plat_data->spdif_clk,
 					 SPDIF_DEFAULT_GAINSEL);
+		clk_disable(plat_data->spdif_clk);
 	} else {
 		ucontrol->value.integer.value[0] = 0;
 	}
@@ -1046,9 +1064,18 @@ static int mxc_spdif_usync_info(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int int_val;
+
+	clk_enable(plat_data->spdif_clk);
+
 	int_val = __raw_readl(spdif_base_addr + SPDIF_REG_SRCD);
 	ucontrol->value.integer.value[0] = (int_val & SRCD_CD_USER) != 0;
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
@@ -1060,10 +1087,18 @@ static int mxc_spdif_usync_get(struct snd_kcontrol *kcontrol,
 static int mxc_spdif_usync_put(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mxc_spdif_priv *spdif_priv = snd_soc_codec_get_drvdata(codec);
+	struct mxc_spdif_platform_data *plat_data = spdif_priv->plat_data;
 	unsigned int int_val;
 
+	clk_enable(plat_data->spdif_clk);
+
 	int_val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;
 	__raw_writel(int_val, spdif_base_addr + SPDIF_REG_SRCD);
+
+	clk_disable(plat_data->spdif_clk);
+
 	return 0;
 }
 
diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c
index 784b595..b54ddb7 100644
--- a/sound/soc/codecs/wm8962.c
+++ b/sound/soc/codecs/wm8962.c
@@ -5,7 +5,7 @@
  *
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  *
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -2218,6 +2218,8 @@ SOC_ENUM("Capture LHPF Mode", cap_lhpf_mode),
 SOC_DOUBLE_R_TLV("Sidetone Volume", WM8962_DAC_DSP_MIXING_1,
 		 WM8962_DAC_DSP_MIXING_2, 4, 12, 0, st_tlv),
 
+SOC_DOUBLE_R_TLV("Digital Playback Volume", WM8962_LEFT_DAC_VOLUME,
+		 WM8962_RIGHT_DAC_VOLUME, 1, 127, 0, digital_tlv),
 SOC_SINGLE("DAC High Performance Switch", WM8962_ADC_DAC_CONTROL_2, 0, 1, 0),
 
 SOC_SINGLE("ADC High Performance Switch", WM8962_ADDITIONAL_CONTROL_1,
@@ -2377,9 +2379,9 @@ static int sysclk_event(struct snd_soc_dapm_widget *w,
 		break;
 
 	case SND_SOC_DAPM_POST_PMD:
-		if (fll)
-			snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
-					    WM8962_FLL_ENA, 0);
+		/* After Power-down, close FLL if FLL-enabled */
+		snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,
+				WM8962_FLL_ENA, 0);
 		break;
 
 	default:
@@ -3459,6 +3461,9 @@ static int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,
 	if (fll_div.theta || fll_div.lambda)
 		fll1 |= WM8962_FLL_FRAC;
 
+	/* Stop the FLL while we reconfigure */
+	snd_soc_update_bits(codec, WM8962_FLL_CONTROL_1, WM8962_FLL_ENA, 0);
+
 	snd_soc_update_bits(codec, WM8962_FLL_CONTROL_2,
 			    WM8962_FLL_OUTDIV_MASK |
 			    WM8962_FLL_REFCLK_DIV_MASK,
@@ -4099,10 +4104,6 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 			    WM8962_SPKOUTL_VOL_MASK, 0x72);
 	snd_soc_update_bits(codec, WM8962_SPKOUTR_VOLUME,
 			    WM8962_SPKOUTR_VOL_MASK, 0x72);
-	snd_soc_update_bits(codec, WM8962_LEFT_DAC_VOLUME,
-			    WM8962_DACL_VOL_MASK, 0xd8);
-	snd_soc_update_bits(codec, WM8962_RIGHT_DAC_VOLUME,
-			    WM8962_DACR_VOL_MASK, 0xd8);
 
 	snd_soc_update_bits(codec, WM8962_LEFT_INPUT_VOLUME,
 			    WM8962_INL_VOL_MASK, 0x3f);
@@ -4110,7 +4111,7 @@ static int wm8962_probe(struct snd_soc_codec *codec)
 			    WM8962_INR_VOL_MASK, 0x3f);
 	snd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,
 			    WM8962_ADCL_VOL_MASK, 0xd8);
-	snd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,
+	snd_soc_update_bits(codec, WM8962_RIGHT_ADC_VOLUME,
 			    WM8962_ADCR_VOL_MASK, 0xd8);
 	snd_soc_update_bits(codec, WM8962_RIGHT_INPUT_MIXER_VOLUME,
 			    WM8962_IN3R_MIXINR_VOL_MASK, 0x7);
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index 72d8550..e30ebbe 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -124,4 +124,10 @@ config SND_SOC_IMX_HDMI
 	help
 	  Say Y if you want to add support for SoC audio through IMX HDMI.
 
+config SND_MXC_SOC_IRAM
+	bool "Locate SSI Audio DMA playback buffers in IRAM"
+	depends on MACH_MX6SL_EVK && MACH_MX6SL_ARM2
+	help
+	  Say Y if you don't want Audio playback buffers in external ram
+
 endif	# SND_IMX_SOC
diff --git a/sound/soc/imx/imx-hdmi-dai.c b/sound/soc/imx/imx-hdmi-dai.c
index 0a1686b..06805f3 100644
--- a/sound/soc/imx/imx-hdmi-dai.c
+++ b/sound/soc/imx/imx-hdmi-dai.c
@@ -1,7 +1,7 @@
 /*
  * ALSA SoC HDMI Audio Layer for MXS
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * Based on stmp3xxx_spdif_dai.c
  * Vladimir Barinov <vbarinov@embeddedalley.com>
@@ -42,8 +42,10 @@ static int imx_hdmi_dai_probe(struct platform_device *pdev)
 	struct imx_hdmi *hdmi_data;
 	int ret = 0;
 
-	if (!hdmi_get_registered())
-		return -ENOMEM;
+	if (!hdmi_get_registered()) {
+		dev_err(&pdev->dev, "Failed: Load HDMI-video first.\n");
+		return -ENODEV;
+	}
 
 	hdmi_data = kzalloc(sizeof(*hdmi_data), GFP_KERNEL);
 	if (!hdmi_data)
diff --git a/sound/soc/imx/imx-hdmi.c b/sound/soc/imx/imx-hdmi.c
index a30d478..f214cff 100644
--- a/sound/soc/imx/imx-hdmi.c
+++ b/sound/soc/imx/imx-hdmi.c
@@ -1,7 +1,7 @@
 /*
  * ASoC HDMI Transmitter driver for IMX development boards
  *
- * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  *
  * based on stmp3780_devb_spdif.c
  *
@@ -57,8 +57,10 @@ static int __init imx_hdmi_init(void)
 {
 	int ret = 0;
 
-	if (!hdmi_get_registered())
-		return -ENOMEM;
+	if (!hdmi_get_registered()) {
+		pr_err("Initialize HDMI-audio failed. Load HDMI-video first!\n");
+		return -ENODEV;
+	}
 
 	imx_hdmi_snd_device = platform_device_alloc("soc-audio", 4);
 	if (!imx_hdmi_snd_device) {
diff --git a/sound/soc/imx/imx-si4763.c b/sound/soc/imx/imx-si4763.c
index 1dd50e7..7b2458e 100644
--- a/sound/soc/imx/imx-si4763.c
+++ b/sound/soc/imx/imx-si4763.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -131,7 +131,7 @@ static struct snd_soc_card snd_soc_card_imx_3stack = {
 	.num_links = 1,
 };
 
-static int __init imx_3stack_si4763_probe(struct platform_device *pdev)
+static int __devinit imx_3stack_si4763_probe(struct platform_device *pdev)
 {
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
 
diff --git a/sound/soc/imx/imx-ssi.c b/sound/soc/imx/imx-ssi.c
index 060d093..d398307 100644
--- a/sound/soc/imx/imx-ssi.c
+++ b/sound/soc/imx/imx-ssi.c
@@ -1,7 +1,7 @@
 /*
  * imx-ssi.c  --  ALSA Soc Audio Layer
  *
- * Copyright 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
  *
@@ -53,6 +53,7 @@
 #include <sound/soc.h>
 
 #include <mach/ssi.h>
+#include <mach/iram.h>
 #include <mach/hardware.h>
 
 #include "imx-ssi.h"
@@ -62,6 +63,9 @@
 #define IMX_SSI_FORMATS \
 	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
 	SNDRV_PCM_FMTBIT_S24_LE)
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+static int UseIRAM;
+#endif
 
 /*
  * SSI Network Mode or TDM slots configuration.
@@ -419,15 +423,61 @@ static struct snd_soc_dai_ops imx_ssi_pcm_dai_ops = {
 	.shutdown	= imx_ssi_shutdown,
 };
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+
+static struct vm_operations_struct snd_mxc_audio_playback_vm_ops = {
+	.open = snd_pcm_mmap_data_open,
+	.close = snd_pcm_mmap_data_close,
+};
+
+/*
+	enable user space access to iram buffer
+*/
+static int imx_iram_audio_playback_mmap(struct snd_pcm_substream *substream,
+					struct vm_area_struct *area)
+{
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	unsigned long off;
+	unsigned long phys;
+	unsigned long size;
+	int ret = 0;
+
+	area->vm_ops = &snd_mxc_audio_playback_vm_ops;
+	area->vm_private_data = substream;
+
+	off = area->vm_pgoff << PAGE_SHIFT;
+	phys = buf->addr + off;
+	size = area->vm_end - area->vm_start;
+
+	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+	area->vm_flags |= VM_IO;
+	ret =
+	    remap_pfn_range(area, area->vm_start, phys >> PAGE_SHIFT,
+			    size, area->vm_page_prot);
+
+	return ret;
+}
+#endif
+
 int snd_imx_pcm_mmap(struct snd_pcm_substream *substream,
 		struct vm_area_struct *vma)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int ret;
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if ((!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+			&& (UseIRAM & (1<<substream->stream)))
+		ret = imx_iram_audio_playback_mmap(substream, vma);
+	else
+		ret = dma_mmap_coherent(NULL, vma, runtime->dma_area,
+			runtime->dma_addr, runtime->dma_bytes);
+#else
 	ret = dma_mmap_coherent(NULL, vma, runtime->dma_area,
 			runtime->dma_addr, runtime->dma_bytes);
-
+#endif
 	pr_debug("%s: ret: %d %p 0x%08x 0x%08x\n", __func__, ret,
 			runtime->dma_area,
 			runtime->dma_addr,
@@ -442,6 +492,9 @@ static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	size_t size;
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	unsigned long buf_paddr;
+#endif
 
 	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
 		size = IMX_SSI_DMABUF_SIZE;
@@ -455,11 +508,34 @@ static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
+	buf->bytes = size;
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	if (!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi"))) {
+		buf->area = iram_alloc(size, &buf_paddr);
+		if (!buf->area) {
+			buf->area =
+			    dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+			if (!buf->area)
+				return -ENOMEM;
+		} else {
+			buf->addr = buf_paddr;
+			UseIRAM |= 1<<substream->stream;
+		}
+	} else {
+		buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+		if (!buf->area)
+			return -ENOMEM;
+
+	}
+#else
 	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
 					   &buf->addr, GFP_KERNEL);
 	if (!buf->area)
 		return -ENOMEM;
-	buf->bytes = size;
+#endif
 
 	return 0;
 }
@@ -500,6 +576,9 @@ void imx_pcm_free(struct snd_pcm *pcm)
 	struct snd_pcm_substream *substream;
 	struct snd_dma_buffer *buf;
 	int stream;
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+#endif
 
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
@@ -510,8 +589,19 @@ void imx_pcm_free(struct snd_pcm *pcm)
 		if (!buf->area)
 			continue;
 
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+		if ((!strncmp(rtd->cpu_dai->name, "imx-ssi", strlen("imx-ssi")))
+			&& (UseIRAM & (1<<substream->stream))) {
+			iram_free(buf->addr, IMX_SSI_DMABUF_SIZE);
+			UseIRAM &= ~(1<<substream->stream);
+		} else {
+			dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		}
+#else
 		dma_free_writecombine(pcm->card->dev, buf->bytes,
 				      buf->area, buf->addr);
+#endif
 		buf->area = NULL;
 	}
 }
diff --git a/sound/soc/imx/imx-wm8962.c b/sound/soc/imx/imx-wm8962.c
index 9abc4a7..d6ab88d 100644
--- a/sound/soc/imx/imx-wm8962.c
+++ b/sound/soc/imx/imx-wm8962.c
@@ -1,7 +1,7 @@
 /*
  * imx-wm8962.c
  *
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2013 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -53,15 +53,41 @@ struct imx_priv {
 	int amic_irq;
 	int amic_status;
 	struct platform_device *pdev;
+	struct snd_pcm_substream *first_stream;
+	struct snd_pcm_substream *second_stream;
 };
 unsigned int sample_format = SNDRV_PCM_FMTBIT_S16_LE;
 static struct imx_priv card_priv;
 static struct snd_soc_card snd_soc_card_imx;
 static struct snd_soc_codec *gcodec;
-static int suspend_hp_flag;
-static int suspend_mic_flag;
-static int hp_irq;
-static int mic_irq;
+
+static struct snd_soc_jack imx_hp_jack;
+static struct snd_soc_jack_pin imx_hp_jack_pins[] = {
+	{
+		.pin = "Ext Spk",
+		.mask = SND_JACK_HEADPHONE,
+	},
+};
+static struct snd_soc_jack_gpio imx_hp_jack_gpio = {
+	.name = "headphone detect",
+	.report = SND_JACK_HEADPHONE,
+	.debounce_time = 150,
+	.invert = 0,
+};
+
+static struct snd_soc_jack imx_mic_jack;
+static struct snd_soc_jack_pin imx_mic_jack_pins[] = {
+	{
+		.pin = "DMIC",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+static struct snd_soc_jack_gpio imx_mic_jack_gpio = {
+	.name = "micphone detect",
+	.report = SND_JACK_MICROPHONE,
+	.debounce_time = 150,
+	.invert = 0,
+};
 
 static int imx_hifi_startup(struct snd_pcm_substream *substream)
 {
@@ -89,6 +115,56 @@ static void imx_hifi_shutdown(struct snd_pcm_substream *substream)
 	return;
 }
 
+static int check_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct imx_priv *priv = &card_priv;
+	unsigned int channels = params_channels(params);
+	unsigned int sample_rate = params_rate(params);
+	snd_pcm_format_t sample_format = params_format(params);
+
+	substream->runtime->sample_bits =
+		snd_pcm_format_physical_width(sample_format);
+	substream->runtime->rate = sample_rate;
+	substream->runtime->format = sample_format;
+	substream->runtime->channels = channels;
+
+	if (!priv->first_stream) {
+		priv->first_stream = substream;
+	} else {
+		priv->second_stream = substream;
+
+		/* Check two sample rates of two streams */
+		if (priv->first_stream->runtime->rate !=
+				priv->second_stream->runtime->rate) {
+			pr_err("\n!KEEP THE SAME SAMPLE RATE: %d!\n",
+					priv->first_stream->runtime->rate);
+			return -EINVAL;
+		}
+
+		/* Check two sample bits of two streams */
+		if (priv->first_stream->runtime->sample_bits !=
+				priv->second_stream->runtime->sample_bits) {
+			snd_pcm_format_t first_format =
+				priv->first_stream->runtime->format;
+
+			pr_err("\n!KEEP THE SAME FORMAT: %s!\n",
+					snd_pcm_format_name(first_format));
+			return -EINVAL;
+		}
+
+		/* Check two channel numbers of two streams */
+		if (priv->first_stream->runtime->channels !=
+				priv->second_stream->runtime->channels) {
+			pr_err("\n!KEEP THE SAME CHANNEL NUMBER: %d!\n",
+					priv->first_stream->runtime->channels);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 				     struct snd_pcm_hw_params *params)
 {
@@ -102,6 +178,18 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 	u32 dai_format;
 	unsigned int pll_out;
 
+	/*
+	 * WM8962 doesn't support two substreams in different parameters
+	 * (i.e. different sample rates, audio formats, channel numbers)
+	 * So we here check the three parameters above of two substreams
+	 * if they are running in the same time.
+	 */
+	ret = check_hw_params(substream, params);
+	if (ret < 0) {
+		pr_err("Failed to match hw params: %d\n", ret);
+		return ret;
+	}
+
 	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
 		SND_SOC_DAIFMT_CBM_CFM;
 
@@ -132,8 +220,8 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 	else
 		pll_out = sample_rate * 256;
 
-	ret = snd_soc_dai_set_pll(codec_dai, WM8962_FLL_OSC,
-				  WM8962_FLL_OSC, priv->sysclk,
+	ret = snd_soc_dai_set_pll(codec_dai, WM8962_FLL_MCLK,
+				  WM8962_FLL_MCLK, priv->sysclk,
 				  pll_out);
 	if (ret < 0)
 		pr_err("Failed to start FLL: %d\n", ret);
@@ -150,114 +238,120 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream,
 	return 0;
 }
 
-static const struct snd_kcontrol_new controls[] = {
-	SOC_DAPM_PIN_SWITCH("Ext Spk"),
-};
-
-/* imx card dapm widgets */
-static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
-	SND_SOC_DAPM_HP("Headphone Jack", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
-	SND_SOC_DAPM_MIC("AMIC", NULL),
-	SND_SOC_DAPM_MIC("DMIC", NULL),
-};
-
-/* imx machine connections to the codec pins */
-static const struct snd_soc_dapm_route audio_map[] = {
-	{ "Headphone Jack", NULL, "HPOUTL" },
-	{ "Headphone Jack", NULL, "HPOUTR" },
-
-	{ "Ext Spk", NULL, "SPKOUTL" },
-	{ "Ext Spk", NULL, "SPKOUTR" },
 
-	{ "MICBIAS", NULL, "AMIC" },
-	{ "IN3R", NULL, "MICBIAS" },
+static int imx_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct imx_priv *priv = &card_priv;
+	int ret;
 
-	{ "DMIC", NULL, "MICBIAS" },
-	{ "DMICDAT", NULL, "DMIC" },
+	if (priv->first_stream == substream)
+		priv->first_stream = priv->second_stream;
+	priv->second_stream = NULL;
+
+	if (!priv->first_stream) {
+		/*
+		 * wm8962 doesn't allow us to continuously setting FLL,
+		 * So we set MCLK as sysclk once, which'd remove the limitation.
+		 */
+		ret = snd_soc_dai_set_sysclk(codec_dai, WM8962_SYSCLK_MCLK,
+				0, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to set SYSCLK: %d\n", ret);
+			return ret;
+		}
 
-};
+		/*
+		 * Continuously setting FLL would cause playback distortion.
+		 * We can fix it just by mute codec after playback.
+		 */
+		ret = snd_soc_dai_digital_mute(codec_dai, 1);
+		if (ret < 0) {
+			pr_err("Failed to set MUTE: %d\n", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
 
-static void headphone_detect_handler(struct work_struct *wor)
+static void imx_resume_event(struct work_struct *wor)
 {
 	struct imx_priv *priv = &card_priv;
 	struct platform_device *pdev = priv->pdev;
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
-	char *envp[3];
-	char *buf;
+	struct snd_soc_jack *jack;
+	int enable;
+	int report;
 
-	/*sysfs_notify(&pdev->dev.kobj, NULL, "headphone");*/
-	priv->hp_status = gpio_get_value(plat->hp_gpio);
+	if (plat->hp_gpio != -1) {
+		jack = imx_hp_jack_gpio.jack;
 
-	/* if headphone is inserted, disable speaker */
-	if (priv->hp_status != plat->hp_active_low)
-		snd_soc_dapm_nc_pin(&gcodec->dapm, "Ext Spk");
-	else
-		snd_soc_dapm_enable_pin(&gcodec->dapm, "Ext Spk");
+		enable = gpio_get_value_cansleep(imx_hp_jack_gpio.gpio);
+		if (imx_hp_jack_gpio.invert)
+			enable = !enable;
 
-	snd_soc_dapm_sync(&gcodec->dapm);
+		if (enable)
+			report = imx_hp_jack_gpio.report;
+		else
+			report = 0;
 
-	/* setup a message for userspace headphone in */
-	buf = kmalloc(32, GFP_ATOMIC);
-	if (!buf) {
-		pr_err("%s kmalloc failed\n", __func__);
-		return;
+		snd_soc_jack_report(jack, report, imx_hp_jack_gpio.report);
 	}
 
-	if (priv->hp_status != plat->hp_active_low)
-		snprintf(buf, 32, "STATE=%d", 2);
-	else
-		snprintf(buf, 32, "STATE=%d", 0);
+	if (plat->mic_gpio != -1) {
+		jack = imx_mic_jack_gpio.jack;
+
+		enable = gpio_get_value_cansleep(imx_mic_jack_gpio.gpio);
+		if (imx_mic_jack_gpio.invert)
+			enable = !enable;
 
-	envp[0] = "NAME=headphone";
-	envp[1] = buf;
-	envp[2] = NULL;
-	kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
-	kfree(buf);
+		if (enable)
+			report = imx_mic_jack_gpio.report;
+		else
+			report = 0;
 
-	if ((suspend_hp_flag == 1) && (hp_irq == 0)) {
-		suspend_hp_flag = 0;
-		return;
+		snd_soc_jack_report(jack, report, imx_mic_jack_gpio.report);
 	}
-	hp_irq = 0;
-	enable_irq(priv->hp_irq);
 
 	return;
 }
 
-static DECLARE_DELAYED_WORK(hp_event, headphone_detect_handler);
-
-static irqreturn_t imx_headphone_detect_handler(int irq, void *data)
-{
-	if (suspend_hp_flag == 1)
-		return IRQ_HANDLED;
-
-	hp_irq = 1;
-	disable_irq_nosync(irq);
-	schedule_delayed_work(&hp_event, msecs_to_jiffies(200));
-	return IRQ_HANDLED;
-}
-
-static ssize_t show_headphone(struct device_driver *dev, char *buf)
+static int imx_event_hp(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
 {
 	struct imx_priv *priv = &card_priv;
 	struct platform_device *pdev = priv->pdev;
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	char *envp[3];
+	char *buf;
 
-	/* determine whether hp is plugged in */
-	priv->hp_status = gpio_get_value(plat->hp_gpio);
+	if (plat->hp_gpio != -1) {
+		priv->hp_status = gpio_get_value(plat->hp_gpio);
 
-	if (priv->hp_status != plat->hp_active_low)
-		strcpy(buf, "headphone\n");
-	else
-		strcpy(buf, "speaker\n");
+		buf = kmalloc(32, GFP_ATOMIC);
+		if (!buf) {
+			pr_err("%s kmalloc failed\n", __func__);
+			return -ENOMEM;
+		}
 
-	return strlen(buf);
-}
+		if (priv->hp_status != plat->hp_active_low)
+			snprintf(buf, 32, "STATE=%d", 2);
+		else
+			snprintf(buf, 32, "STATE=%d", 0);
 
-static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+		envp[0] = "NAME=headphone";
+		envp[1] = buf;
+		envp[2] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+		kfree(buf);
+	}
 
-static void amic_detect_handler(struct work_struct *work)
+	return 0;
+}
+
+static int imx_event_mic(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
 {
 	struct imx_priv *priv = &card_priv;
 	struct platform_device *pdev = priv->pdev;
@@ -265,56 +359,78 @@ static void amic_detect_handler(struct work_struct *work)
 	char *envp[3];
 	char *buf;
 
-	/* sysfs_notify(&pdev->dev.kobj, NULL, "amic"); */
-	priv->amic_status = gpio_get_value(plat->mic_gpio);
+	if (plat->mic_gpio != -1) {
+		priv->amic_status = gpio_get_value(plat->mic_gpio);
 
-	/* if amic is inserted, disable dmic */
-	if (priv->amic_status != plat->mic_active_low)
-		snd_soc_dapm_nc_pin(&gcodec->dapm, "DMIC");
-	else
-		snd_soc_dapm_enable_pin(&gcodec->dapm, "DMIC");
+		buf = kmalloc(32, GFP_ATOMIC);
+		if (!buf) {
+			pr_err("%s kmalloc failed\n", __func__);
+			return -ENOMEM;
+		}
 
-	snd_soc_dapm_sync(&gcodec->dapm);
+		if (priv->amic_status == 0)
+			snprintf(buf, 32, "STATE=%d", 2);
+		else
+			snprintf(buf, 32, "STATE=%d", 0);
 
-	/* setup a message for userspace headphone in */
-	buf = kmalloc(32, GFP_ATOMIC);
-	if (!buf) {
-		pr_err("%s kmalloc failed\n", __func__);
-		return;
+		envp[0] = "NAME=amic";
+		envp[1] = buf;
+		envp[2] = NULL;
+		kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
+		kfree(buf);
 	}
 
-	if (priv->amic_status == 0)
-		snprintf(buf, 32, "STATE=%d", 2);
-	else
-		snprintf(buf, 32, "STATE=%d", 0);
+	return 0;
+}
 
-	envp[0] = "NAME=amic";
-	envp[1] = buf;
-	envp[2] = NULL;
-	kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, envp);
-	kfree(buf);
 
-	if ((suspend_mic_flag == 1) && (mic_irq == 0)) {
-		suspend_mic_flag = 0;
-		return;
-	}
-	mic_irq = 0;
-	enable_irq(priv->amic_irq);
-}
+static const struct snd_kcontrol_new controls[] = {
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+/* imx card dapm widgets */
+static const struct snd_soc_dapm_widget imx_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", imx_event_hp),
+	SND_SOC_DAPM_MIC("AMIC", NULL),
+	SND_SOC_DAPM_MIC("DMIC", imx_event_mic),
+};
+
+/* imx machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "Headphone Jack", NULL, "HPOUTL" },
+	{ "Headphone Jack", NULL, "HPOUTR" },
 
-static DECLARE_DELAYED_WORK(amic_event, amic_detect_handler);
+	{ "Ext Spk", NULL, "SPKOUTL" },
+	{ "Ext Spk", NULL, "SPKOUTR" },
 
-static irqreturn_t imx_amic_detect_handler(int irq, void *data)
+	{ "MICBIAS", NULL, "AMIC" },
+	{ "IN3R", NULL, "MICBIAS" },
+
+	{ "DMIC", NULL, "MICBIAS" },
+	{ "DMICDAT", NULL, "DMIC" },
+
+};
+
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
 {
-	if (suspend_mic_flag == 1)
-		return IRQ_HANDLED;
+	struct imx_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	/* determine whether hp is plugged in */
+	priv->hp_status = gpio_get_value(plat->hp_gpio);
+
+	if (priv->hp_status != plat->hp_active_low)
+		strcpy(buf, "headphone\n");
+	else
+		strcpy(buf, "speaker\n");
 
-	mic_irq = 1;
-	disable_irq_nosync(irq);
-	schedule_delayed_work(&amic_event, msecs_to_jiffies(200));
-	return IRQ_HANDLED;
+	return strlen(buf);
 }
 
+static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
 static ssize_t show_amic(struct device_driver *dev, char *buf)
 {
 	struct imx_priv *priv = &card_priv;
@@ -334,9 +450,7 @@ static ssize_t show_amic(struct device_driver *dev, char *buf)
 
 static DRIVER_ATTR(amic, S_IRUGO | S_IWUSR, show_amic, NULL);
 
-static DECLARE_DELAYED_WORK(resume_hp_event, headphone_detect_handler);
-static DECLARE_DELAYED_WORK(resume_mic_event, amic_detect_handler);
-
+static DECLARE_DELAYED_WORK(resume_hp_event, imx_resume_event);
 
 int imx_hifi_trigger(struct snd_pcm_substream *substream, int cmd)
 {
@@ -344,17 +458,10 @@ int imx_hifi_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct platform_device *pdev = priv->pdev;
 	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
 
-	if (SNDRV_PCM_TRIGGER_SUSPEND == cmd) {
-		suspend_hp_flag = 1;
-		suspend_mic_flag = 1;
-	}
 	if (SNDRV_PCM_TRIGGER_RESUME == cmd) {
-		if (plat->hp_gpio != -1)
+		if ((plat->hp_gpio != -1) || (plat->mic_gpio != -1))
 			schedule_delayed_work(&resume_hp_event,
-							msecs_to_jiffies(200));
-		if (plat->mic_gpio != -1)
-			schedule_delayed_work(&resume_mic_event,
-							msecs_to_jiffies(200));
+				msecs_to_jiffies(200));
 	}
 
 	return 0;
@@ -381,60 +488,42 @@ static int imx_wm8962_init(struct snd_soc_pcm_runtime *rtd)
 	snd_soc_dapm_enable_pin(&codec->dapm, "AMIC");
 
 	if (plat->hp_gpio != -1) {
-		priv->hp_irq = gpio_to_irq(plat->hp_gpio);
-
-		ret = request_irq(priv->hp_irq,
-					imx_headphone_detect_handler,
-					IRQ_TYPE_EDGE_BOTH, pdev->name, priv);
-
-		if (ret < 0) {
-			ret = -EINVAL;
-			return ret;
-		}
+		imx_hp_jack_gpio.gpio = plat->hp_gpio;
+		snd_soc_jack_new(codec, "Ext Spk", SND_JACK_LINEOUT,
+				&imx_hp_jack);
+		snd_soc_jack_add_pins(&imx_hp_jack,
+					ARRAY_SIZE(imx_hp_jack_pins),
+					imx_hp_jack_pins);
+		snd_soc_jack_add_gpios(&imx_hp_jack,
+					1, &imx_hp_jack_gpio);
 
 		ret = driver_create_file(pdev->dev.driver,
-						&driver_attr_headphone);
+							&driver_attr_headphone);
 		if (ret < 0) {
 			ret = -EINVAL;
 			return ret;
 		}
-
-		priv->hp_status = gpio_get_value(plat->hp_gpio);
-
-		/* if headphone is inserted, disable speaker */
-		if (priv->hp_status != plat->hp_active_low)
-			snd_soc_dapm_nc_pin(&codec->dapm, "Ext Spk");
-		else
-			snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
 	}
 
 	if (plat->mic_gpio != -1) {
-		priv->amic_irq = gpio_to_irq(plat->mic_gpio);
-
-		ret = request_irq(priv->amic_irq,
-					imx_amic_detect_handler,
-					IRQ_TYPE_EDGE_BOTH, pdev->name, priv);
-
-		if (ret < 0) {
-			ret = -EINVAL;
-			return ret;
-		}
+		imx_mic_jack_gpio.gpio = plat->mic_gpio;
+		snd_soc_jack_new(codec, "DMIC", SND_JACK_MICROPHONE,
+				&imx_mic_jack);
+		snd_soc_jack_add_pins(&imx_mic_jack,
+					ARRAY_SIZE(imx_mic_jack_pins),
+					imx_mic_jack_pins);
+		snd_soc_jack_add_gpios(&imx_mic_jack,
+					1, &imx_mic_jack_gpio);
 
-		ret = driver_create_file(pdev->dev.driver, &driver_attr_amic);
+		ret = driver_create_file(pdev->dev.driver,
+							&driver_attr_amic);
 		if (ret < 0) {
 			ret = -EINVAL;
 			return ret;
 		}
-
-		priv->amic_status = gpio_get_value(plat->mic_gpio);
-
-		/* if amic is inserted, disable DMIC */
-		if (priv->amic_status != plat->mic_active_low)
-			snd_soc_dapm_nc_pin(&codec->dapm, "DMIC");
-		else
-			snd_soc_dapm_enable_pin(&codec->dapm, "DMIC");
-	} else if (!snd_soc_dapm_get_pin_status(&codec->dapm, "DMICDAT"))
+	} else {
 		snd_soc_dapm_nc_pin(&codec->dapm, "DMIC");
+	}
 
 	snd_soc_dapm_sync(&codec->dapm);
 
@@ -445,6 +534,7 @@ static struct snd_soc_ops imx_hifi_ops = {
 	.startup = imx_hifi_startup,
 	.shutdown = imx_hifi_shutdown,
 	.hw_params = imx_hifi_hw_params,
+	.hw_free = imx_hifi_hw_free,
 	.trigger = imx_hifi_trigger,
 };
 
@@ -509,6 +599,9 @@ static int __devinit imx_wm8962_probe(struct platform_device *pdev)
 
 	priv->sysclk = plat->sysclk;
 
+	priv->first_stream = NULL;
+	priv->second_stream = NULL;
+
 	return ret;
 }
 
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index e62ad5f..b3ab124 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -748,6 +748,9 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	codec_dai->active--;
 	codec->active--;
 
+	if (!cpu_dai->active && !codec_dai->active)
+		rtd->rate = 0;
+
 	/* Muting the DAC suppresses artifacts caused during digital
 	 * shutdown, for example from stopping clocks.
 	 */
diff --git a/tools/perf/builtin-sched.c b/tools/perf/builtin-sched.c
index 3632c2f..dcfe887 100644
--- a/tools/perf/builtin-sched.c
+++ b/tools/perf/builtin-sched.c
@@ -14,7 +14,6 @@
 #include "util/debug.h"
 
 #include <sys/prctl.h>
-#include <sys/resource.h>
 
 #include <semaphore.h>
 #include <pthread.h>
-- 
2.0.0

